{
    "docs": [
        {
            "location": "/",
            "text": "Che cos'\u00e8 Yii?\n\n\nYii \u00e8 un framework PHP utilizzato per sviluppare rapidamente applicazioni web moderne. Il nome \"Yii\" significa \"semplice ed evolutivo\" in cinese. Pu\u00f2 essere considerato anche come acronimo di \"Yes It is!\"\n\n\nPerch\u00e8 confrontare Yii con gli altri Framework?\n\n\nSe hai gi\u00e0 familiarit\u00e0 con altri Framework, potresti apprezzare di sapere le caratteristiche di Yii:\n\n\n- Come la maggior parte dei framework PHP, Yii implementa il modello \n  architetturale MVC (model - view - controller) e promuove l'organizzazione \n  dei codici in base a quel modello.\n- Yii usa come filosiga la seguente caratteristica; il codice deve essere scritto in modo semplice ma \n  elegante. Yii non cercher\u00e0 mai di sovrascrivere le cose. Principalmente ha lo\n  scopo di seguire un modello di progettazione ben definito e curato.\n- Yii \u00e8 un framework full-stack che fornisce molte funzionalit\u00e0 pronte \n  all'uso, come i costruttori di query, l'Active Record per i database \n  relazionali e NoSQL. Offre anche un massimo supporto per lo sviluppo di API.\n- Yii \u00e8 estremamente estensibile. E' possibile personalizzare o sostituire \n  quasi ogni pezzo di codice. E' inoltre possibile sfruttare l'architettura \n  solida di Yii per sviluppare estensioni ridistribuibili.\n- Obbiettivo primario di Yii \u00e8 quello di poter offrire alte prestazioni.\n\n\n\nVersioni di Yii\n\n\nAttualmente Yii dispone di due versioni principali: 1.1 e 2.0. La nuova versione 2.0 \u00e8 una riscrittura completa di Yii, adottando le pi\u00f9 recenti tecnologie e protocolli, tra cui Composer, PSR, namespaces e cos\u00ec via. Questa guida riguarder\u00e0 principalmente la versione 2.0.\n\n\nRequisiti e Prerequisiti\n\n\nYii 2.0 richiede PHP 5.4.0 o superiore e funziona meglio con l'ultima versione di PHP 7. E' possibile trovare i requisiti pi\u00f9 dettagliati per le singole funzionalit\u00e0, eseguendo il checker di requisiti incluso in ogni versione di Yii.\n\n\nL'utilizzo di Yii richiede la conoscenza base della programmazione orientata agli oggetti (OOP), in quanto Yii \u00e8 un framework puro basato su OOP. Yii 2.0 utilizza anche funzionalit\u00e0 del PHP, come i namespaces e i traits.",
            "title": "Homepage"
        },
        {
            "location": "/#che-cose-yii",
            "text": "Yii \u00e8 un framework PHP utilizzato per sviluppare rapidamente applicazioni web moderne. Il nome \"Yii\" significa \"semplice ed evolutivo\" in cinese. Pu\u00f2 essere considerato anche come acronimo di \"Yes It is!\"",
            "title": "Che cos'\u00e8 Yii?"
        },
        {
            "location": "/#perche-confrontare-yii-con-gli-altri-framework",
            "text": "Se hai gi\u00e0 familiarit\u00e0 con altri Framework, potresti apprezzare di sapere le caratteristiche di Yii:  - Come la maggior parte dei framework PHP, Yii implementa il modello \n  architetturale MVC (model - view - controller) e promuove l'organizzazione \n  dei codici in base a quel modello.\n- Yii usa come filosiga la seguente caratteristica; il codice deve essere scritto in modo semplice ma \n  elegante. Yii non cercher\u00e0 mai di sovrascrivere le cose. Principalmente ha lo\n  scopo di seguire un modello di progettazione ben definito e curato.\n- Yii \u00e8 un framework full-stack che fornisce molte funzionalit\u00e0 pronte \n  all'uso, come i costruttori di query, l'Active Record per i database \n  relazionali e NoSQL. Offre anche un massimo supporto per lo sviluppo di API.\n- Yii \u00e8 estremamente estensibile. E' possibile personalizzare o sostituire \n  quasi ogni pezzo di codice. E' inoltre possibile sfruttare l'architettura \n  solida di Yii per sviluppare estensioni ridistribuibili.\n- Obbiettivo primario di Yii \u00e8 quello di poter offrire alte prestazioni.",
            "title": "Perch\u00e8 confrontare Yii con gli altri Framework?"
        },
        {
            "location": "/#versioni-di-yii",
            "text": "Attualmente Yii dispone di due versioni principali: 1.1 e 2.0. La nuova versione 2.0 \u00e8 una riscrittura completa di Yii, adottando le pi\u00f9 recenti tecnologie e protocolli, tra cui Composer, PSR, namespaces e cos\u00ec via. Questa guida riguarder\u00e0 principalmente la versione 2.0.",
            "title": "Versioni di Yii"
        },
        {
            "location": "/#requisiti-e-prerequisiti",
            "text": "Yii 2.0 richiede PHP 5.4.0 o superiore e funziona meglio con l'ultima versione di PHP 7. E' possibile trovare i requisiti pi\u00f9 dettagliati per le singole funzionalit\u00e0, eseguendo il checker di requisiti incluso in ogni versione di Yii.  L'utilizzo di Yii richiede la conoscenza base della programmazione orientata agli oggetti (OOP), in quanto Yii \u00e8 un framework puro basato su OOP. Yii 2.0 utilizza anche funzionalit\u00e0 del PHP, come i namespaces e i traits.",
            "title": "Requisiti e Prerequisiti"
        },
        {
            "location": "/getting-started/sub-installing-Yii/",
            "text": "Installazione di Yii\n\n\nE\u2019 possibile installare Yii in due modi. Installarlo tramite Composer oppure installarlo da un file di archivio. Il primo \u00e8 il metodo migliore, in quanto consente di installare nuove estensioni oppure di aggiornare Yii in modo semplice.\nIn questa, e nelle prossime sezioni, descriveremo come installare Yii e di come implementare tutte le sue funzionalit\u00e0 e i suoi utilizzi. Esistono due versioni di Yii: la versione base (basic) e la versione avanzata (advanced). La basic \u00e8 diversa dall\u2019advanced principalmente per l\u2019organizzazione del codice. Nel primo avremo una struttura MVC, mentre nell\u2019advanced avremmo due strutture MVC separate. La parte \u201cbackend\u201d e la parte \u201cfrontend\u201d.\n\n\n\n\nInfo\n\n\nIl modello della versione basic \u00e8 adatto allo sviluppo del 90% delle applicazioni Web. Se sei nuovo a Yii, ti consigliamo di attenersi al modello della versione basic per la sua semplicit\u00e0 e le sue funzionalit\u00e0.\n\n\n\n\nInstallazione tramite Composer\n\n\nSe \u00e8 la prima volta che installi il Composer, puoi seguire le istruzioni di \nhttps://getcomposer.org/download/\n . Su Linux e Max OS X, eseguire i seguenti comandi:\n\n\ncurl -sS https://getcomposer.org/installer | php \nmv composer.phar /usr/local/bin/composer\n\n\n\nIn questa guida tutti i comandi che sono relativi al \"composer\" presuppongono che sia installato a livello globale, in modo che sia disponibile come comando\ncomposer\n. \n\n\nSe hai gi\u00e0 installato il Composer, assicuratevi di utilizzare una versione aggiornata. E' possibile aggiornare il proprio Composer con il comando \ncomposer self-update\n.\n\n\nInstallazione di Yii\n\n\nCon il Composer installato, \u00e8 possibile installare Yii eseguendo i seguenti comandi in una cartella accessibile a Web.\n\n\ncomposer global require \"fxp/composer-asset-plugin:^1.3.1\"\ncomposer create-project --prefer-dist yiisoft/yii2-app-basic basic\n\n\n\nIl primo comando installa il plugin asset del Composer. Esso consente di gestire le dipendenze del pacchetto. Basta eseguirlo solo una volta. Il secondo comando installa l'ultima versione stabile di Yii in una directory denominata \nbasic\n. Se si desidera, \u00e8 possibile scegliere un nome diverso per la directory di destinazione.\n\n\n\n\nNote\n\n\nSe si desidera installare l'ultima versione di sviluppo di Yii, \u00e8 possibile utilizzare il seguente comando che permette di aggiungere un'opzione di stabilit\u00e0\n\n\ncomposer create-project --prefer-dist --stability=dev yiisoft/yii2-app-basic basic\n\n\n\n\n\nInstallazione da un file di archivio\n\n\nL'installazione di Yii da un file di archivio prevede 3 passaggi:\n\n\n\n\nScaricare il file dall'archivio da http://www.yiiframework.com/download/.\n\n\nScompattare il file scaricato in una cartella accessibile a web.\n\n\nModificare il file \nconfig/web.php\n immettendo una chiave segreta per la \ncookieValidationKey\n (voce di configurazione). Questo avviene automaticamente se si installa Yii tramite Composer.\n// !!! insert a secret key in the following (if it is empty) - this is required \n       by cookie validation\n\n'cookieValidationKey' =\n 'enter your secret key here',\n\n\n\n\n\n\n\nVerifica dell'installazione\n\n\nUna volta completata l'installazione, dobbiamo configurare il server Web (vedere le sezione successiva). E' possibile utilizzare il server Web incorporato PHP eseguendo il seguente comando da console, nella directory \nweb\n del progetto.\n\n\nphp yii serve\n\n\n\n\n\nNote\n\n\nPer impostazione predefinita, il server HTTP ascolter\u00e0 la porta 8080. Tuttavia, se la porta \u00e8 gi\u00e0 in uso o si desidera utilizzare pi\u00f9 applicazioni in questo modo, \u00e8 possibile specificare quale porta deve essere utilizzata. Basta aggiungere l'argomento -port\n\n\nphp yii serve --port=8888\n\n\n\n\nE' possibile usare il browser per accedere all'applicazione Yii installata con il seguente URL:\n\n\nhttp://localhost:8080/\n\n\n\n     \n\n\nDovresti avere una schermata uguale a quella sopra. Se ci\u00f2 non si vede, controlla se l'installazione PHP soddisfa i requisiti di Yii. E' possibile verificare se i requisiti minimi sono soddisfatti utilizzando uno dei sequenti approcci:\n\n\n\n\nCopia \n\\requirements.php\n di \n/web/requirements.php\n e quindi utilizzare un browser per accedervi attraverso il seguene link \nhttp://localhost/requirements.php\n\n\nEseguire i seguenti comandi\ncd basic\nphp requirements.php\n\n\n\n\n\n\n\nE' necessario configurare l'installazione PHP in modo che i requisiti minimi di Yii siano accettati.\n\n\nConfigurazione del server Web\n\n\n\n\nNote\n\n\nE' possibile saltare questa sezione per ora, se si sta seguendo la guida di Yii senza alcuna intenzione di distribuirla a un server di produzione.\n\n\n\n\nSu un server di produzione, \u00e8 possibile configurare il server Web in modo che l'applicazione sia accessibile tramite l'URL \nhttp://www.example.com/index.php\n anzich\u00e8 \nhttp://www.example.com/basic/web/index.php\n. Tale configurazione richiede di indicare la radice del documento del server Web nella cartella\nbasic/web\n.\nSi potrebbe anche desiderare di nascondere nell'URL \nindex.php\n.",
            "title": "Installazione di Yii"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#installazione-di-yii",
            "text": "E\u2019 possibile installare Yii in due modi. Installarlo tramite Composer oppure installarlo da un file di archivio. Il primo \u00e8 il metodo migliore, in quanto consente di installare nuove estensioni oppure di aggiornare Yii in modo semplice.\nIn questa, e nelle prossime sezioni, descriveremo come installare Yii e di come implementare tutte le sue funzionalit\u00e0 e i suoi utilizzi. Esistono due versioni di Yii: la versione base (basic) e la versione avanzata (advanced). La basic \u00e8 diversa dall\u2019advanced principalmente per l\u2019organizzazione del codice. Nel primo avremo una struttura MVC, mentre nell\u2019advanced avremmo due strutture MVC separate. La parte \u201cbackend\u201d e la parte \u201cfrontend\u201d.   Info  Il modello della versione basic \u00e8 adatto allo sviluppo del 90% delle applicazioni Web. Se sei nuovo a Yii, ti consigliamo di attenersi al modello della versione basic per la sua semplicit\u00e0 e le sue funzionalit\u00e0.",
            "title": "Installazione di Yii"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#installazione-tramite-composer",
            "text": "Se \u00e8 la prima volta che installi il Composer, puoi seguire le istruzioni di  https://getcomposer.org/download/  . Su Linux e Max OS X, eseguire i seguenti comandi:  curl -sS https://getcomposer.org/installer | php \nmv composer.phar /usr/local/bin/composer  In questa guida tutti i comandi che sono relativi al \"composer\" presuppongono che sia installato a livello globale, in modo che sia disponibile come comando composer .   Se hai gi\u00e0 installato il Composer, assicuratevi di utilizzare una versione aggiornata. E' possibile aggiornare il proprio Composer con il comando  composer self-update .",
            "title": "Installazione tramite Composer"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#installazione-di-yii_1",
            "text": "Con il Composer installato, \u00e8 possibile installare Yii eseguendo i seguenti comandi in una cartella accessibile a Web.  composer global require \"fxp/composer-asset-plugin:^1.3.1\"\ncomposer create-project --prefer-dist yiisoft/yii2-app-basic basic  Il primo comando installa il plugin asset del Composer. Esso consente di gestire le dipendenze del pacchetto. Basta eseguirlo solo una volta. Il secondo comando installa l'ultima versione stabile di Yii in una directory denominata  basic . Se si desidera, \u00e8 possibile scegliere un nome diverso per la directory di destinazione.   Note  Se si desidera installare l'ultima versione di sviluppo di Yii, \u00e8 possibile utilizzare il seguente comando che permette di aggiungere un'opzione di stabilit\u00e0  composer create-project --prefer-dist --stability=dev yiisoft/yii2-app-basic basic",
            "title": "Installazione di Yii"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#installazione-da-un-file-di-archivio",
            "text": "L'installazione di Yii da un file di archivio prevede 3 passaggi:   Scaricare il file dall'archivio da http://www.yiiframework.com/download/.  Scompattare il file scaricato in una cartella accessibile a web.  Modificare il file  config/web.php  immettendo una chiave segreta per la  cookieValidationKey  (voce di configurazione). Questo avviene automaticamente se si installa Yii tramite Composer. // !!! insert a secret key in the following (if it is empty) - this is required \n       by cookie validation\n\n'cookieValidationKey' =  'enter your secret key here',",
            "title": "Installazione da un file di archivio"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#verifica-dellinstallazione",
            "text": "Una volta completata l'installazione, dobbiamo configurare il server Web (vedere le sezione successiva). E' possibile utilizzare il server Web incorporato PHP eseguendo il seguente comando da console, nella directory  web  del progetto.  php yii serve   Note  Per impostazione predefinita, il server HTTP ascolter\u00e0 la porta 8080. Tuttavia, se la porta \u00e8 gi\u00e0 in uso o si desidera utilizzare pi\u00f9 applicazioni in questo modo, \u00e8 possibile specificare quale porta deve essere utilizzata. Basta aggiungere l'argomento -port  php yii serve --port=8888   E' possibile usare il browser per accedere all'applicazione Yii installata con il seguente URL:  http://localhost:8080/         Dovresti avere una schermata uguale a quella sopra. Se ci\u00f2 non si vede, controlla se l'installazione PHP soddisfa i requisiti di Yii. E' possibile verificare se i requisiti minimi sono soddisfatti utilizzando uno dei sequenti approcci:   Copia  \\requirements.php  di  /web/requirements.php  e quindi utilizzare un browser per accedervi attraverso il seguene link  http://localhost/requirements.php  Eseguire i seguenti comandi cd basic\nphp requirements.php    E' necessario configurare l'installazione PHP in modo che i requisiti minimi di Yii siano accettati.",
            "title": "Verifica dell'installazione"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#configurazione-del-server-web",
            "text": "Note  E' possibile saltare questa sezione per ora, se si sta seguendo la guida di Yii senza alcuna intenzione di distribuirla a un server di produzione.   Su un server di produzione, \u00e8 possibile configurare il server Web in modo che l'applicazione sia accessibile tramite l'URL  http://www.example.com/index.php  anzich\u00e8  http://www.example.com/basic/web/index.php . Tale configurazione richiede di indicare la radice del documento del server Web nella cartella basic/web .\nSi potrebbe anche desiderare di nascondere nell'URL  index.php .",
            "title": "Configurazione del server Web"
        },
        {
            "location": "/getting-started/sub-saying-hello/",
            "text": "Iniziamo con un \"Ciao\"\n\n\nQuesta sezione descrive come creare una nuova pagina \"Ciao\" nella nostra applicazione. Per effettuare ci\u00f2, dovremmo creare un'azione e una vista.\n\n\n\n\nL'applicazione invier\u00e0 la richiesta di pagina all'azione\n\n\ne l'azione render\u00e0 a sua volta la visualizzazione della pagina all'utente finale con su scritta la parola \"Ciao\".\n\n\n\n\nCreazione di un'azione\n\n\nPer l'azione che dovr\u00e0 scrivere \"Ciao\", bisogna creare un'azione  \nsay\n che legge un messaggio (\nmessage\n) come parametro dalla richiesta, e visuallizza quel messaggio all'utente. Se la richiesta non fornisce un messaggio come parametro, l'azione visualizzer\u00e0 come predefinito la parola \"Ciao\".\n\n\nLe azioni devono essere dichiarate nella cartella \ncontrollers\n. Per semplicit\u00e0, puoi dichiarare l'azione \nsay\n nell'esistente \nSiteController\n. Questo controller \u00e8 definito nel file che si trova in \ncontrollers/SiteControlle.php\n. Ecco l'inizio della nostra azione:\n\n\n?php\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    // ...existing code...\n\n    public function actionSay($message = 'Hello'){\n\n        return $this-\nrender('say', ['message' =\n $message]);\n\n    }\n}\n\n\n\nNel codice precedente l'azione \nsay\n viene definita in un metodo chiamato \nactionSay\n nella classe \nSiteController\n. Yii utilizza il prefisso \naction\n per differenziare i metodi d'azione dai metodi non di azione in una classe di controller. Il nome dopo l'\naction\n mappa l'ID dell'azione da effettuare.\n\n\nQuando si tratta di denominare le azioni, \u00e8 necessario capire come Yii tratta gli ID relativi all'azione che richiamiamo. I nomi/numeri relativi all'azione sono sempre indicati in minuscolo. Se un ID di un'azione \u00e8 composto da pi\u00f9 parole, verranno concatenate con i trattini ( per esempio, \ncreate-comment\n). I nomi del metodo di un'azione vengono mappati rimuovendo i trattini dall'ID, capitalizzando la prima lettera di ogni parola con la parola \naction\n. Ad esempio, l'ID associato all'azione \ncreate-comment\n corrisponde al nome del metodo dell'azione, che sar\u00e0 \nactionCreateComment\n.\n\n\nCreazione di una vista\n\n\nLe viste (views) sono gli script che scrivi per generare una risposta ad una determinata azione e stampata a video. Per l'attivit\u00e0 \"Ciao\", verr\u00e0 creata una vista relativa al \nsay\n che avr\u00e0 il compito di stampare il valore contenuto in \n$message\n a video.\n\n\n?php\nuse yii\\helpers\\Html;\n?\n\n\n?= Html::encode($message) ?\n\n\n\n\nLa vista relativa al \nsay\n deve essere salvata nel file \nviews/site/say.php\n.  Quando il metodo \nrender()\n [inizializzato nel controller] verr\u00e0 chiamato in un'azione, cercher\u00e0 un file PHP denominato come segue:\n\n\nviews/ControllerID/ViewsName.php\n\n\nSi noti che nel codice soprastante il parametro \n$message\n \u00e8 codificato in HTML prima di essere stampato. Ci\u00f2 \u00e8 necessario poich\u00e8 il parametro viene da un utente finale, rendendolo vulnerabile agli attacchi di \nscripting cross-site(XSS) - [incorporando codice JavaScript dannoso all'interno del nostro parametro]\n.\n\n\nDopo aver creato l'azione e la vista, puoi accedere alla nuova pagina tramite il seguente URL:\n\n\nhttp://hostname/index.php?r=site%2Fsay\nmessage=Hello+World\n\n\n\n\n\nSe tutto \u00e8 andato bene, visualizzerete a video un messaggio con su scritto \"Ciao!\".  Questo perch\u00e8 \nmessage\n viene passato come parametro al metodo \nactionSay()\n nel Controller. Il layout della pagina  (intestazione e pi\u00e8 di pagina)resta il solito\u00ec, perch\u00e8 il metodo \nrender()\n incorpora automaticamente il risultato della vista del \nsay\n in un layout di default, che si trova in \nviews/layouts/main.php\n.\n\n\nIl parametro \nr\n nell'URL indicata sopra, richiede ulteriori spiegazioni. Si tratta del percordo di un ID univoco dell'applicazione che si riferisce ad un'azione. Il formato del percordo \u00e8 \nControllerID/ActionID\n. Quando l'azione riceve una richiesta, verifica questo parametro utlizzando la parte del \nControllerID\n per determinare quale classe del controller deve essere instanziata per gestire la richiesta. A questo punto, il controllore user\u00e0 la parte dell'\nActionID\n per determinare quale azione deve essere instanziata. Nel nostro esempio, il percordo \nsite/say\n verr\u00e0 controllato nel file \nSiteController\n usando l'ID dell'azione \nsay\n. Di conseguenza verr\u00e0 richiamato il metodo \nactionSay()\n.",
            "title": "Iniziamo con un \"Ciao\""
        },
        {
            "location": "/getting-started/sub-saying-hello/#iniziamo-con-un-ciao",
            "text": "Questa sezione descrive come creare una nuova pagina \"Ciao\" nella nostra applicazione. Per effettuare ci\u00f2, dovremmo creare un'azione e una vista.   L'applicazione invier\u00e0 la richiesta di pagina all'azione  e l'azione render\u00e0 a sua volta la visualizzazione della pagina all'utente finale con su scritta la parola \"Ciao\".",
            "title": "Iniziamo con un \"Ciao\""
        },
        {
            "location": "/getting-started/sub-saying-hello/#creazione-di-unazione",
            "text": "Per l'azione che dovr\u00e0 scrivere \"Ciao\", bisogna creare un'azione   say  che legge un messaggio ( message ) come parametro dalla richiesta, e visuallizza quel messaggio all'utente. Se la richiesta non fornisce un messaggio come parametro, l'azione visualizzer\u00e0 come predefinito la parola \"Ciao\".  Le azioni devono essere dichiarate nella cartella  controllers . Per semplicit\u00e0, puoi dichiarare l'azione  say  nell'esistente  SiteController . Questo controller \u00e8 definito nel file che si trova in  controllers/SiteControlle.php . Ecco l'inizio della nostra azione:  ?php\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    // ...existing code...\n\n    public function actionSay($message = 'Hello'){\n\n        return $this- render('say', ['message' =  $message]);\n\n    }\n}  Nel codice precedente l'azione  say  viene definita in un metodo chiamato  actionSay  nella classe  SiteController . Yii utilizza il prefisso  action  per differenziare i metodi d'azione dai metodi non di azione in una classe di controller. Il nome dopo l' action  mappa l'ID dell'azione da effettuare.  Quando si tratta di denominare le azioni, \u00e8 necessario capire come Yii tratta gli ID relativi all'azione che richiamiamo. I nomi/numeri relativi all'azione sono sempre indicati in minuscolo. Se un ID di un'azione \u00e8 composto da pi\u00f9 parole, verranno concatenate con i trattini ( per esempio,  create-comment ). I nomi del metodo di un'azione vengono mappati rimuovendo i trattini dall'ID, capitalizzando la prima lettera di ogni parola con la parola  action . Ad esempio, l'ID associato all'azione  create-comment  corrisponde al nome del metodo dell'azione, che sar\u00e0  actionCreateComment .",
            "title": "Creazione di un'azione"
        },
        {
            "location": "/getting-started/sub-saying-hello/#creazione-di-una-vista",
            "text": "Le viste (views) sono gli script che scrivi per generare una risposta ad una determinata azione e stampata a video. Per l'attivit\u00e0 \"Ciao\", verr\u00e0 creata una vista relativa al  say  che avr\u00e0 il compito di stampare il valore contenuto in  $message  a video.  ?php\nuse yii\\helpers\\Html;\n?  ?= Html::encode($message) ?   La vista relativa al  say  deve essere salvata nel file  views/site/say.php .  Quando il metodo  render()  [inizializzato nel controller] verr\u00e0 chiamato in un'azione, cercher\u00e0 un file PHP denominato come segue:  views/ControllerID/ViewsName.php  Si noti che nel codice soprastante il parametro  $message  \u00e8 codificato in HTML prima di essere stampato. Ci\u00f2 \u00e8 necessario poich\u00e8 il parametro viene da un utente finale, rendendolo vulnerabile agli attacchi di  scripting cross-site(XSS) - [incorporando codice JavaScript dannoso all'interno del nostro parametro] .  Dopo aver creato l'azione e la vista, puoi accedere alla nuova pagina tramite il seguente URL:  http://hostname/index.php?r=site%2Fsay message=Hello+World   Se tutto \u00e8 andato bene, visualizzerete a video un messaggio con su scritto \"Ciao!\".  Questo perch\u00e8  message  viene passato come parametro al metodo  actionSay()  nel Controller. Il layout della pagina  (intestazione e pi\u00e8 di pagina)resta il solito\u00ec, perch\u00e8 il metodo  render()  incorpora automaticamente il risultato della vista del  say  in un layout di default, che si trova in  views/layouts/main.php .  Il parametro  r  nell'URL indicata sopra, richiede ulteriori spiegazioni. Si tratta del percordo di un ID univoco dell'applicazione che si riferisce ad un'azione. Il formato del percordo \u00e8  ControllerID/ActionID . Quando l'azione riceve una richiesta, verifica questo parametro utlizzando la parte del  ControllerID  per determinare quale classe del controller deve essere instanziata per gestire la richiesta. A questo punto, il controllore user\u00e0 la parte dell' ActionID  per determinare quale azione deve essere instanziata. Nel nostro esempio, il percordo  site/say  verr\u00e0 controllato nel file  SiteController  usando l'ID dell'azione  say . Di conseguenza verr\u00e0 richiamato il metodo  actionSay() .",
            "title": "Creazione di una vista"
        },
        {
            "location": "/getting-started/sub-working-with-forms/",
            "text": "Lavorare con i moduli\n\n\nQuesta sezione descrive come creare una nuova pagina con un modulo, per ottenere dati/informazioni dall'utente. La pagina visualizzer\u00e0 una maschera con due campi di immmissione. Un campo per il nome e l'altra per l'e-mail. Dopo aver ricevuto i due valori dall'utente, la pagina ristamper\u00e0 i valori inseriti per conferma.\n\n\nAttraverso questo tutorial imparerai come:\n\n\n\n\ncreare un modello per rappresentare i dati inseriti da un utente attraverso un modulo.\n\n\ndichiarare regole per convalidare i dati inseriti.\n\n\ncostruire un modulo HTML in una views.\n\n\n\n\nCreazione di un modello\n\n\nI dati da richiedere all'utente finale verranno rappresentati da una classe \nEntryForm\n (come mostrata di seguito) e salvata nella seguente directory \nmodels/EntryForm.php\n.\n\n\nCodice EntryForm.php\n\n\n?php\n\nnamespace app\\models;\n\nuse Yii;\nuse yii\\base\\Model;\n\nclass EntryForm extends Model{\n\n    public $name;\n    public $email;\n\n    public function rules(){\n\n        return [\n            [['name', 'email'], 'required'],\n            ['email', 'email'],\n        ];\n    }\n}\n\n\n\nLa classe \nEntryForm\n contiene due valori pubblici: \nname\n e \nemail\n. Questi valori vengono utilizzati per memorizzare i dati immessi dall'utente. Inoltre contiene un metodo denominato \nrules()\n che restituisce un insieme di regole per la convalida dei dati. Le regole di convalida scritte in precedenza controllano:\n\n\n\n\nentrambe le variabili \nname\n e \nemail\n che non siano vuote e che siano stati inseriti dei valori;\n\n\nche il campo \nemail\n deve coincidere con un indirizzo e-mail valido.\n\n\n\n\nSe si dispone di un oggetto \nEntryForm\n popolato con i dati immessi dall'utente, \u00e8 possibile chiamare il metodo \nvalidate()\n per attivare la routine di convalida dei dati. Se avviene un errore di convalida dei dati, verr\u00e0 stabilito il valore \ntrue\n alla propriet\u00e0 \nhasErrors\n e possiamo anche conoscere quali errori di convalida si verificano.\n\n\n?php\n    $model = new EntryForm();\n    $model-\nname = 'Qiang';\n    $model-\nemail = 'bad';\n    if ($model-\nvalidate()) {\n        // Good!   \n    } else {\n        // Failure!\n        // Use $model-\ngetErrors()\n    }\n?\n\n\n\n\nCreazione di un'azione\n\n\nSuccessivamente \u00e8 necessario creare un'azione di inserimento \nentry\n all'interno del file controllore della nostra applicazione (\nSiteController\n).\n\n\n?php\n\nnamespace app\\controllers;\n\nuse Yii;\nuse yii\\web\\Controller;\nuse app\\models\\EntryForm;\n\nclass SiteController extends Controller{\n\n    // ...existing code...\n\n    public function actionEntry(){\n\n        $model = new EntryForm();\n\n        if ($model-\nload(Yii::$app-\nrequest-\npost()) \n $model-\nvalidate()) {\n            // valid data received in $model\n\n            // do something meaningful here about $model ...\n\n            return $this-\nrender('entry-confirm', ['model' =\n $model]);\n        } else {\n            // either the page is initially displayed or there is some validation error\n            return $this-\nrender('entry', ['model' =\n $model]);\n        }\n    }\n}\n\n\n\nPer prima cosa viene creato un oggetto di tipo \nEntryForm\n. A questo punto cercher\u00e0 di popolare il modello con i dati \n$_POST\n forniti da Yii. Se il modello \u00e8 stato popolato correttamente, l'azione richiamer\u00e0 il metodo \nvalidate()\n per assicurarsi che i valori immessi siano validi.\n\n\n\n\nNote\n\n\nL'espressione \nYii::$app\n rappresenta l'istanza di applicazione, che \u00e8 un singleton accessibile a livello globale. E' anche un servizio che fornisce componenti quali \nrequest\n , \nresponse\n , \ndb\n, ecc.. per supportare una specifica funzionalit\u00e0. Nel codice precedente il componente \nrequest\n viene utilizzato per accedere ai dati in \n$_POST\n.\n\n\n\n\nSe tutto va bene, l'azione render\u00e0 una vista denominata \nentry-confirm\n per confermare la presentazione dei dati in modo corretto all'utente. Se non vengono inviati i dati in modo corretto, oppure i dati contengono errori, avremmo la visualizzazione dell'\nentry\n, in cui verr\u00e0 mostrata la maschera HTML insieme a tutti i messaggi di errori ( o di convalida).\n\n\nCreazione di Viste\n\n\nInfine, dobbiamo creare due file view denominati \nentry-form\n e \nentry\n. All'interno del primo file avverr\u00e0 la visualizzazione del nome e dell'email inseriti dall'utente. Questi dati devono essere memorizzati nella seguente directory: \nviews/site/entry-confirm.php\n.\n\n\nENTRY-CONFIRM.php\n\n\n?php\nuse yii\\helpers\\Html;\n?\n\n\np\nYou have entered the following information:\n/p\n\n\n\nul\n\n    \nli\nlabel\nName\n/label\n: \n?= Html::encode($model-\nname) ?\n/li\n\n    \nli\nlabel\nEmail\n/label\n: \n?= Html::encode($model-\nemail) ?\n/li\n\n\n/ul\n\n\n\n\nAll'interno del file \nentry\n ci sar\u00e0 la visualizzazione del modulo in HTML dove l'utente dovr\u00e0 inserire i propri dati. Questo file deve essere memorizzato nella seguente directory: \nviews/site/entry.php\n.\n\n\nENTRY.php\n\n\n?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\ActiveForm;\n?\n\n\n?php $form = ActiveForm::begin(); ?\n\n\n    \n?= $form-\nfield($model, 'name') ?\n\n\n    \n?= $form-\nfield($model, 'email') ?\n\n\n    \ndiv class=\"form-group\"\n\n        \n?= Html::submitButton('Submit', ['class' =\n 'btn btn-primary']) ?\n\n    \n/div\n\n\n\n?php ActiveForm::end(); ?\n\n\n\n\nLa vista \nentry.php\n utilizza un potente widget denominato \nActiveForm\n per creare il modulo HTML. I metodi \nbegin()\n e \nend()\n vengono usati per tag di apertura e chiusura. Tra le due chiamate , i campi di input vengono creati dal metodo \nfield()\n. Il primo campo \u00e8 relativo al nome, mentre il secondo \u00e8 relativo all'email. Dopo i campi di input, il metodo \nsubmitButton\n viene chiamato per generare il pulsante di invio.\n\n\nPer controllare se tutto funziona, bisogna inserire il seguente URL nel browser\n\n\nhttp://hostname/index.php?r=site%2Fentry\n\n\n\n\n\nDopo aver inserito un nome e una e-mail validi e facendo sul pulsante \nSubmit\n, verr\u00e0 visualizzata una pagina che visualizzer\u00e0 i dati appena immessi.",
            "title": "Lavoriamo con i moduli"
        },
        {
            "location": "/getting-started/sub-working-with-forms/#lavorare-con-i-moduli",
            "text": "Questa sezione descrive come creare una nuova pagina con un modulo, per ottenere dati/informazioni dall'utente. La pagina visualizzer\u00e0 una maschera con due campi di immmissione. Un campo per il nome e l'altra per l'e-mail. Dopo aver ricevuto i due valori dall'utente, la pagina ristamper\u00e0 i valori inseriti per conferma.  Attraverso questo tutorial imparerai come:   creare un modello per rappresentare i dati inseriti da un utente attraverso un modulo.  dichiarare regole per convalidare i dati inseriti.  costruire un modulo HTML in una views.",
            "title": "Lavorare con i moduli"
        },
        {
            "location": "/getting-started/sub-working-with-forms/#creazione-di-un-modello",
            "text": "I dati da richiedere all'utente finale verranno rappresentati da una classe  EntryForm  (come mostrata di seguito) e salvata nella seguente directory  models/EntryForm.php .  Codice EntryForm.php  ?php\n\nnamespace app\\models;\n\nuse Yii;\nuse yii\\base\\Model;\n\nclass EntryForm extends Model{\n\n    public $name;\n    public $email;\n\n    public function rules(){\n\n        return [\n            [['name', 'email'], 'required'],\n            ['email', 'email'],\n        ];\n    }\n}  La classe  EntryForm  contiene due valori pubblici:  name  e  email . Questi valori vengono utilizzati per memorizzare i dati immessi dall'utente. Inoltre contiene un metodo denominato  rules()  che restituisce un insieme di regole per la convalida dei dati. Le regole di convalida scritte in precedenza controllano:   entrambe le variabili  name  e  email  che non siano vuote e che siano stati inseriti dei valori;  che il campo  email  deve coincidere con un indirizzo e-mail valido.   Se si dispone di un oggetto  EntryForm  popolato con i dati immessi dall'utente, \u00e8 possibile chiamare il metodo  validate()  per attivare la routine di convalida dei dati. Se avviene un errore di convalida dei dati, verr\u00e0 stabilito il valore  true  alla propriet\u00e0  hasErrors  e possiamo anche conoscere quali errori di convalida si verificano.  ?php\n    $model = new EntryForm();\n    $model- name = 'Qiang';\n    $model- email = 'bad';\n    if ($model- validate()) {\n        // Good!   \n    } else {\n        // Failure!\n        // Use $model- getErrors()\n    }\n?",
            "title": "Creazione di un modello"
        },
        {
            "location": "/getting-started/sub-working-with-forms/#creazione-di-unazione",
            "text": "Successivamente \u00e8 necessario creare un'azione di inserimento  entry  all'interno del file controllore della nostra applicazione ( SiteController ).  ?php\n\nnamespace app\\controllers;\n\nuse Yii;\nuse yii\\web\\Controller;\nuse app\\models\\EntryForm;\n\nclass SiteController extends Controller{\n\n    // ...existing code...\n\n    public function actionEntry(){\n\n        $model = new EntryForm();\n\n        if ($model- load(Yii::$app- request- post())   $model- validate()) {\n            // valid data received in $model\n\n            // do something meaningful here about $model ...\n\n            return $this- render('entry-confirm', ['model' =  $model]);\n        } else {\n            // either the page is initially displayed or there is some validation error\n            return $this- render('entry', ['model' =  $model]);\n        }\n    }\n}  Per prima cosa viene creato un oggetto di tipo  EntryForm . A questo punto cercher\u00e0 di popolare il modello con i dati  $_POST  forniti da Yii. Se il modello \u00e8 stato popolato correttamente, l'azione richiamer\u00e0 il metodo  validate()  per assicurarsi che i valori immessi siano validi.   Note  L'espressione  Yii::$app  rappresenta l'istanza di applicazione, che \u00e8 un singleton accessibile a livello globale. E' anche un servizio che fornisce componenti quali  request  ,  response  ,  db , ecc.. per supportare una specifica funzionalit\u00e0. Nel codice precedente il componente  request  viene utilizzato per accedere ai dati in  $_POST .   Se tutto va bene, l'azione render\u00e0 una vista denominata  entry-confirm  per confermare la presentazione dei dati in modo corretto all'utente. Se non vengono inviati i dati in modo corretto, oppure i dati contengono errori, avremmo la visualizzazione dell' entry , in cui verr\u00e0 mostrata la maschera HTML insieme a tutti i messaggi di errori ( o di convalida).",
            "title": "Creazione di un'azione"
        },
        {
            "location": "/getting-started/sub-working-with-forms/#creazione-di-viste",
            "text": "Infine, dobbiamo creare due file view denominati  entry-form  e  entry . All'interno del primo file avverr\u00e0 la visualizzazione del nome e dell'email inseriti dall'utente. Questi dati devono essere memorizzati nella seguente directory:  views/site/entry-confirm.php .  ENTRY-CONFIRM.php  ?php\nuse yii\\helpers\\Html;\n?  p You have entered the following information: /p  ul \n     li label Name /label :  ?= Html::encode($model- name) ? /li \n     li label Email /label :  ?= Html::encode($model- email) ? /li  /ul   All'interno del file  entry  ci sar\u00e0 la visualizzazione del modulo in HTML dove l'utente dovr\u00e0 inserire i propri dati. Questo file deve essere memorizzato nella seguente directory:  views/site/entry.php .  ENTRY.php  ?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\ActiveForm;\n?  ?php $form = ActiveForm::begin(); ? \n\n     ?= $form- field($model, 'name') ? \n\n     ?= $form- field($model, 'email') ? \n\n     div class=\"form-group\" \n         ?= Html::submitButton('Submit', ['class' =  'btn btn-primary']) ? \n     /div  ?php ActiveForm::end(); ?   La vista  entry.php  utilizza un potente widget denominato  ActiveForm  per creare il modulo HTML. I metodi  begin()  e  end()  vengono usati per tag di apertura e chiusura. Tra le due chiamate , i campi di input vengono creati dal metodo  field() . Il primo campo \u00e8 relativo al nome, mentre il secondo \u00e8 relativo all'email. Dopo i campi di input, il metodo  submitButton  viene chiamato per generare il pulsante di invio.  Per controllare se tutto funziona, bisogna inserire il seguente URL nel browser  http://hostname/index.php?r=site%2Fentry   Dopo aver inserito un nome e una e-mail validi e facendo sul pulsante  Submit , verr\u00e0 visualizzata una pagina che visualizzer\u00e0 i dati appena immessi.",
            "title": "Creazione di Viste"
        },
        {
            "location": "/getting-started/sub-working-with-database/",
            "text": "Lavorare con i database\n\n\nQuesta sezione descrive come creare una nuova pagina che visualizza i dati di una paese recuperati da una tabella di database denominata \ncountry\n. Per raggiungere questo obiettivo, sar\u00e0 possibile configurare una connessione di database, creare una classe \nActive Record\n, definire un'azione e creare una vista.\nAttraverso questo tutorial, imparerai come:\n\n\n\n\nconfigurare una connessione DB,\n\n\ndefinire una classe Active Record,\n\n\nscrivere una query utilizzando la classe Active Record,\n\n\nvisualizzare i dati in una vista in modo paginato.\n\n\n\n\nTieni presente che per terminare questa sezione, dovresti avere conoscenze e esperienze di base nell'utilizzo dei database. In particolare, si dovrebbe sapere come creare un database e come seguire le istruzioni SQL utilizzando uno strumento client del DB.\n\n\nPreparazione del Database\n\n\nPer iniziare, dobbiamo creare un database denominato \nyii2basic\n, da cui recupererai i dati nell'applicazione. E' possibile creare un database \nSQLite\n,\nMySQL\n,\nMSSQL\n,\nOracle\n, in quanto Yii ha un supporto integrato per molte applicazioni di database. Nella seguente descrizione, attueremo una descizione dei database \nMySQL\n.\n\n\nA questo punto, dobbiamo creare una tabella denominata \ncountry\n nel database e inserire alcuni dati di esempio. E' possibile eseguire le seguenti istruzioni SQL per effettuarlo:\n\n\nCREATE TABLE `country` (\n    `code` CHAR(2) NOT NULL PRIMARY KEY,\n    `name` CHAR(52) NOT NULL,\n    `population` INT(11) NOT NULL DEFAULT '0'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `country` VALUES ('AU','Australia',24016400);\nINSERT INTO `country` VALUES ('BR','Brazil',205722000);\nINSERT INTO `country` VALUES ('CA','Canada',35985751);\nINSERT INTO `country` VALUES ('CN','China',1375210000);\nINSERT INTO `country` VALUES ('DE','Germany',81459000);\nINSERT INTO `country` VALUES ('FR','France',64513242);\nINSERT INTO `country` VALUES ('GB','United Kingdom',65097000);\nINSERT INTO `country` VALUES ('IN','India',1285400000);\nINSERT INTO `country` VALUES ('RU','Russia',146519759);\nINSERT INTO `country` VALUES ('US','United States',322976000);\n\n\n\nA questo punto, hai un database denominato \nyii2basic\n e all'interno di esso, una tabella denominata \ncountry\n con tre colonne contenenti dieci righe di dati.\n\n\nConfigurazione di una connessione DB\n\n\nPrima di procedere, assicurarsi di aver installato sia l'estensione  del PDO di PHP che il driver PDO per il database che si sta utilizzando.\nCon quelli installati, aprire il file \nconfig/db.php\n e cambiare i parametri per far si che la connessione con il DB avvenga con successo. Per impostazione predefinita, il file \u00e8 composto come segue:\n\n\n?php\n\nreturn [\n    'class' =\n 'yii\\db\\Connection',\n    'dsn' =\n 'mysql:host=localhost;dbname=yii2basic',\n    'username' =\n 'root',\n    'password' =\n '',\n    'charset' =\n 'utf8',\n];\n\n\n\nIl file \nconfig/db.php\n \u00e8 uno strumento di configurazione tipico basato su file. Questo particolare file di configurazione specifica i parametri necessari per creare e inizializzare un'istanza del \nyii \\ db \\ Connection\n in cui \u00e8 possibile eseguire query SQL nei confronti del database sottostante.\n\n\n\n\nNote\n\n\nIl file \nconfig.db\n verr\u00e0 incluso nella configurazione principale dell'applicazione \nconfig/web.php\n, che specifica come inizializzare l'istanza della stessa.\n\n\n\n\nCreazione di un record attivo\n\n\nPer rappresentare e recuperare dati nella tabella \ncountry\n, dobbiamo creare una classe \nActive Record\n generata all'interno di un altra classe chiamata \nCountry\n e salvarla all'interno della directory \nmodels/Country.php\n.\n\n\n?php\n\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass Country extends ActiveRecord\n{\n}\n\n\n\nLa classe \nCountry\n estende la classe \nActive Record\n. Non c'\u00e8 bisogno di scrivere nessun codice all'interno di esso! Con il codice precedente, Yii indovina il nome della tabella associata al nome della classe.\n\n\n\n\nNote\n\n\nSe non \u00e8 possibile eseguire una corrispondenza diretta dal nome della classe al nome della tabella del DB, \u00e8  possibile utilizzare il metodo \ntableName()\n per specificare esplicitamente il nome della tabella associato.\n\n\n\n\nUtilizzando la classe \nCountry\n, \u00e8 possibile modificare facilmente i dati nella tabella \ncountry\n, come mostrato in questi frammenti:\n\n\nuse app\\models\\Country;\n\n// get all rows from the country table and order them by \"name\"\n$countries = Country::find()-\norderBy('name')-\nall();\n\n// get the row whose primary key is \"US\"\n$country = Country::findOne('US');\n\n// displays \"United States\"\necho $country-\nname;\n\n// modifies the country name to be \"U.S.A.\" and save it to database\n$country-\nname = 'U.S.A.';\n$country-\nsave();\n\n\n\n\n\nNote\n\n\nActive Record \u00e8 un metodo molto potente e utile per accedere e manipolare i dati del database in modo orientato agli oggetti. Potete trovare informazioni pi\u00f9 dettagliate nella sezione \nActive Record\n spiegata successivamente. In alternativa \u00e8 possibile interagire con un database utilizzando un metodo di accesso ai dati di livello inferiore denominato \nData Accesso Objects\n.\n\n\n\n\nCreazione di un'azione\n\n\nPer far si che i dati inseriti nel nostro database vengano visualizzati all'utente finale, \u00e8 necessario creare una nuova azione. Invece di inserire la nuova azione nel \nsite\n controller, come nelle sezioni precedenti, \u00e8 pi\u00f9 logico creare un nuovo controller specificamente per tutte le azioni relative ai dati del paese. Denominare questo nuovo controller \nCountryController\n e creare un'azione \nindex\n in esso, come mostrato in seguito.\n\n\n?php\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\nuse yii\\data\\Pagination;\nuse app\\models\\Country;\n\nclass CountryController extends Controller{\n\n    public function actionIndex(){\n\n        $query = Country::find();\n\n        $pagination = new Pagination([\n            'defaultPageSize' =\n 5,\n            'totalCount' =\n $query-\ncount(),\n        ]);\n\n        $countries = $query-\norderBy('name')\n            -\noffset($pagination-\noffset)\n            -\nlimit($pagination-\nlimit)\n            -\nall();\n\n        return $this-\nrender('index', [\n            'countries' =\n $countries,\n            'pagination' =\n $pagination,\n        ]);\n    }\n}\n\n\n\nSalvare il precedente codice nella seguente directory: \ncontroller/CountryController.php\n.\nL'azione \nindex\n chiama \nCountry::find()\n. Questo metodo \nActive Record\n crea una query DB e recupera tutti i dati dalla tabella \ncountry\n nel nostro DB.\nPer limitare il numero di paesi restituiti in ogni richiesta, la query viene  paginata con l'aiuto di un oggetto  \nyii \\ data \\ Pagination\n. L'oggetto \nPagination\n serve per due scopi:\n\n\n\n\nImposta le clausole di \noffset\n e di \nlimit\n per l'istruzione SQL rappresentato nella query in modo che restituisce solo una singola pagina di dati alla volta (max 5 righe in una pagina),\n\n\nviene utilizzato nella visualizzazione di un \npager\n costituito da un elenco di pulsanti di pagina, come verr\u00e0 spiegato nella sottosezione successiva.\n\n\n\n\nAlla fine, l'azione \nindex\n rende una vista denominata \nindex\n e passa i dati del paese cos\u00ec come le informazioni di paginazione.\n\n\nCreazione di una vista\n\n\nSotto la directory delle \nviews\n, dobbiamo creare una sotto-directory denominata \ncountry\n. Questa cartella verr\u00e0 utilizzata per contenere tutte le viste rese dal controllore \ncountry\n. All'interno della directory \nviews/country\n, creiamo un file denominato \nindex.php\n contenente quanto segue:\n\n\n?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\LinkPager;\n?\n\n\nh1\nCountries\n/h1\n\n\nul\n\n\n?php foreach ($countries as $country): ?\n\n    \nli\n\n        \n?= Html::encode(\"{$country-\nname} ({$country-\ncode})\") ?\n:\n        \n?= $country-\npopulation ?\n\n    \n/li\n\n\n?php endforeach; ?\n\n\n/ul\n\n\n\n?= LinkPager::widget(['pagination' =\n $pagination]) ?\n\n\n\n\nLa vista presenta due sezioni relative alla visualizzazione dei dati del paese. Nella prima parte, i dati che ci vengono forniti riguardante i paesi vengono attraversati e resi come un elenco HTML non ordinato. Nella seconda parte viene utilizzato un widget \nyii \\ widgets \\ LinkPager\n utlizzando le informazioni di paginazione passate dall'azione. Il widget \nLinkPager\n visualizza un elenco di pulsanti per la pagina. Facendo clic su uno di essi verranno aggiornati i dati del paese nella pagina corrispondente.\nPer vedere se e come funziona il codice precedente, dobbiamo incollare il seguente URL nel nostro browser\n\n\nhttp://hostname/index.php?r=country%2Findex\n\n\n\n\n\nIn un primo momento, vedrai una pagina che mostra 5 paesi. Sotto i paesi, vedrete un pager con 4 pulsanti. Se fai clic sul pulsante \n2\n, la pagina visualizzer\u00e0 altri cinque paesi che si troveranno nel nostro database. Con il seguente URL se lo copiate e lo incollate nel vostro browser, vedrete a video la seconda pagina dei paesi.\n\n\nhttp://hostname/index.php?r=country%2Findex\npage=2",
            "title": "Lavoriamo con i database"
        },
        {
            "location": "/getting-started/sub-working-with-database/#lavorare-con-i-database",
            "text": "Questa sezione descrive come creare una nuova pagina che visualizza i dati di una paese recuperati da una tabella di database denominata  country . Per raggiungere questo obiettivo, sar\u00e0 possibile configurare una connessione di database, creare una classe  Active Record , definire un'azione e creare una vista.\nAttraverso questo tutorial, imparerai come:   configurare una connessione DB,  definire una classe Active Record,  scrivere una query utilizzando la classe Active Record,  visualizzare i dati in una vista in modo paginato.   Tieni presente che per terminare questa sezione, dovresti avere conoscenze e esperienze di base nell'utilizzo dei database. In particolare, si dovrebbe sapere come creare un database e come seguire le istruzioni SQL utilizzando uno strumento client del DB.",
            "title": "Lavorare con i database"
        },
        {
            "location": "/getting-started/sub-working-with-database/#preparazione-del-database",
            "text": "Per iniziare, dobbiamo creare un database denominato  yii2basic , da cui recupererai i dati nell'applicazione. E' possibile creare un database  SQLite , MySQL , MSSQL , Oracle , in quanto Yii ha un supporto integrato per molte applicazioni di database. Nella seguente descrizione, attueremo una descizione dei database  MySQL .  A questo punto, dobbiamo creare una tabella denominata  country  nel database e inserire alcuni dati di esempio. E' possibile eseguire le seguenti istruzioni SQL per effettuarlo:  CREATE TABLE `country` (\n    `code` CHAR(2) NOT NULL PRIMARY KEY,\n    `name` CHAR(52) NOT NULL,\n    `population` INT(11) NOT NULL DEFAULT '0'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `country` VALUES ('AU','Australia',24016400);\nINSERT INTO `country` VALUES ('BR','Brazil',205722000);\nINSERT INTO `country` VALUES ('CA','Canada',35985751);\nINSERT INTO `country` VALUES ('CN','China',1375210000);\nINSERT INTO `country` VALUES ('DE','Germany',81459000);\nINSERT INTO `country` VALUES ('FR','France',64513242);\nINSERT INTO `country` VALUES ('GB','United Kingdom',65097000);\nINSERT INTO `country` VALUES ('IN','India',1285400000);\nINSERT INTO `country` VALUES ('RU','Russia',146519759);\nINSERT INTO `country` VALUES ('US','United States',322976000);  A questo punto, hai un database denominato  yii2basic  e all'interno di esso, una tabella denominata  country  con tre colonne contenenti dieci righe di dati.",
            "title": "Preparazione del Database"
        },
        {
            "location": "/getting-started/sub-working-with-database/#configurazione-di-una-connessione-db",
            "text": "Prima di procedere, assicurarsi di aver installato sia l'estensione  del PDO di PHP che il driver PDO per il database che si sta utilizzando.\nCon quelli installati, aprire il file  config/db.php  e cambiare i parametri per far si che la connessione con il DB avvenga con successo. Per impostazione predefinita, il file \u00e8 composto come segue:  ?php\n\nreturn [\n    'class' =  'yii\\db\\Connection',\n    'dsn' =  'mysql:host=localhost;dbname=yii2basic',\n    'username' =  'root',\n    'password' =  '',\n    'charset' =  'utf8',\n];  Il file  config/db.php  \u00e8 uno strumento di configurazione tipico basato su file. Questo particolare file di configurazione specifica i parametri necessari per creare e inizializzare un'istanza del  yii \\ db \\ Connection  in cui \u00e8 possibile eseguire query SQL nei confronti del database sottostante.   Note  Il file  config.db  verr\u00e0 incluso nella configurazione principale dell'applicazione  config/web.php , che specifica come inizializzare l'istanza della stessa.",
            "title": "Configurazione di una connessione DB"
        },
        {
            "location": "/getting-started/sub-working-with-database/#creazione-di-un-record-attivo",
            "text": "Per rappresentare e recuperare dati nella tabella  country , dobbiamo creare una classe  Active Record  generata all'interno di un altra classe chiamata  Country  e salvarla all'interno della directory  models/Country.php .  ?php\n\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass Country extends ActiveRecord\n{\n}  La classe  Country  estende la classe  Active Record . Non c'\u00e8 bisogno di scrivere nessun codice all'interno di esso! Con il codice precedente, Yii indovina il nome della tabella associata al nome della classe.   Note  Se non \u00e8 possibile eseguire una corrispondenza diretta dal nome della classe al nome della tabella del DB, \u00e8  possibile utilizzare il metodo  tableName()  per specificare esplicitamente il nome della tabella associato.   Utilizzando la classe  Country , \u00e8 possibile modificare facilmente i dati nella tabella  country , come mostrato in questi frammenti:  use app\\models\\Country;\n\n// get all rows from the country table and order them by \"name\"\n$countries = Country::find()- orderBy('name')- all();\n\n// get the row whose primary key is \"US\"\n$country = Country::findOne('US');\n\n// displays \"United States\"\necho $country- name;\n\n// modifies the country name to be \"U.S.A.\" and save it to database\n$country- name = 'U.S.A.';\n$country- save();   Note  Active Record \u00e8 un metodo molto potente e utile per accedere e manipolare i dati del database in modo orientato agli oggetti. Potete trovare informazioni pi\u00f9 dettagliate nella sezione  Active Record  spiegata successivamente. In alternativa \u00e8 possibile interagire con un database utilizzando un metodo di accesso ai dati di livello inferiore denominato  Data Accesso Objects .",
            "title": "Creazione di un record attivo"
        },
        {
            "location": "/getting-started/sub-working-with-database/#creazione-di-unazione",
            "text": "Per far si che i dati inseriti nel nostro database vengano visualizzati all'utente finale, \u00e8 necessario creare una nuova azione. Invece di inserire la nuova azione nel  site  controller, come nelle sezioni precedenti, \u00e8 pi\u00f9 logico creare un nuovo controller specificamente per tutte le azioni relative ai dati del paese. Denominare questo nuovo controller  CountryController  e creare un'azione  index  in esso, come mostrato in seguito.  ?php\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\nuse yii\\data\\Pagination;\nuse app\\models\\Country;\n\nclass CountryController extends Controller{\n\n    public function actionIndex(){\n\n        $query = Country::find();\n\n        $pagination = new Pagination([\n            'defaultPageSize' =  5,\n            'totalCount' =  $query- count(),\n        ]);\n\n        $countries = $query- orderBy('name')\n            - offset($pagination- offset)\n            - limit($pagination- limit)\n            - all();\n\n        return $this- render('index', [\n            'countries' =  $countries,\n            'pagination' =  $pagination,\n        ]);\n    }\n}  Salvare il precedente codice nella seguente directory:  controller/CountryController.php .\nL'azione  index  chiama  Country::find() . Questo metodo  Active Record  crea una query DB e recupera tutti i dati dalla tabella  country  nel nostro DB.\nPer limitare il numero di paesi restituiti in ogni richiesta, la query viene  paginata con l'aiuto di un oggetto   yii \\ data \\ Pagination . L'oggetto  Pagination  serve per due scopi:   Imposta le clausole di  offset  e di  limit  per l'istruzione SQL rappresentato nella query in modo che restituisce solo una singola pagina di dati alla volta (max 5 righe in una pagina),  viene utilizzato nella visualizzazione di un  pager  costituito da un elenco di pulsanti di pagina, come verr\u00e0 spiegato nella sottosezione successiva.   Alla fine, l'azione  index  rende una vista denominata  index  e passa i dati del paese cos\u00ec come le informazioni di paginazione.",
            "title": "Creazione di un'azione"
        },
        {
            "location": "/getting-started/sub-working-with-database/#creazione-di-una-vista",
            "text": "Sotto la directory delle  views , dobbiamo creare una sotto-directory denominata  country . Questa cartella verr\u00e0 utilizzata per contenere tutte le viste rese dal controllore  country . All'interno della directory  views/country , creiamo un file denominato  index.php  contenente quanto segue:  ?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\LinkPager;\n?  h1 Countries /h1  ul  ?php foreach ($countries as $country): ? \n     li \n         ?= Html::encode(\"{$country- name} ({$country- code})\") ? :\n         ?= $country- population ? \n     /li  ?php endforeach; ?  /ul  ?= LinkPager::widget(['pagination' =  $pagination]) ?   La vista presenta due sezioni relative alla visualizzazione dei dati del paese. Nella prima parte, i dati che ci vengono forniti riguardante i paesi vengono attraversati e resi come un elenco HTML non ordinato. Nella seconda parte viene utilizzato un widget  yii \\ widgets \\ LinkPager  utlizzando le informazioni di paginazione passate dall'azione. Il widget  LinkPager  visualizza un elenco di pulsanti per la pagina. Facendo clic su uno di essi verranno aggiornati i dati del paese nella pagina corrispondente.\nPer vedere se e come funziona il codice precedente, dobbiamo incollare il seguente URL nel nostro browser  http://hostname/index.php?r=country%2Findex   In un primo momento, vedrai una pagina che mostra 5 paesi. Sotto i paesi, vedrete un pager con 4 pulsanti. Se fai clic sul pulsante  2 , la pagina visualizzer\u00e0 altri cinque paesi che si troveranno nel nostro database. Con il seguente URL se lo copiate e lo incollate nel vostro browser, vedrete a video la seconda pagina dei paesi.  http://hostname/index.php?r=country%2Findex page=2",
            "title": "Creazione di una vista"
        },
        {
            "location": "/getting-started/sub-generate-code-gii/",
            "text": "Generare codice con \nGii\n\n\nQuesta sezione descrive come utilizzare \nGii\n per generare automaticamente il codice che implementa alcune funzioni comuni del sito Web. Utilizzare Gii per generare codice in automatico \u00e8 semplicemente una questione di immissione delle informazioni giuste per le istruzioni visualizzate nelle pagine Web Gii.\nAttraverso questo tutorial, imparerai come:\n\n\n\n\nabilitare Gii nella tua applicazione,\n\n\nutilizzare Gii per generare una classe Active Record,\n\n\nutilizzare Gii per generare il codice che implementa le operazioni CRUD per una tabella DB,\n\n\npersonalizzare il codice generato da Gii.\n\n\n\n\nPartiamo da Gii\n\n\nGii viene fornito da Yii come modulo. E' possibile abilitare Gii configurandolo nella propriet\u00e0 dei moduli nell'applicazione. A seconda del modo in cui \u00e8 stata creata l'applicazione, \u00e8 possibile che il codice riportato di seguito sia gi\u00e0 fornito nel file di configurazione \nconfig/web.php\n.\n\n\n$config = [ ... ];\n\nif (YII_ENV_DEV) {\n    $config['bootstrap'][] = 'gii';\n    $config['modules']['gii'] = [\n        'class' =\n 'yii\\gii\\Module',\n    ];\n}\n\n\n\nLa configurazione soprastante indica che l'applicazione deve includere un modulo denominato \ngii\n, che fa parte della classe \nyii \\ gii \\ Module\n.\nSe selezioniamo l'entry script della nostra applicazione ( \nweb/index.php\n), troverete la seguente riga, il che rende essenzialmente \nYII_ENV_DEV\n a \ntrue\n\n\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n\n\nGrazie a questa linea di codica, la nostra applicazione \u00e8 in modalit\u00e0 di sviluppo e sar\u00e0 gi\u00e0 abilitata a Gii per la configurazione precedentemente impostata da noi. Adesso \u00e8 possibile accedere a Gii attraverso il seguente URL\n\n\nhttp://hostname/index.php?r=gii\n\n\n\n\n\nWarning\n\n\nSe accediamo a Gii da una macchina diversa da localhsot, l'accesso verr\u00e0 negato come impostazione predefinita per scopi di protezione. E' possibile configurare Gii per aggiungere gli indirizzi IP consentiti, come segue:\n\n\n'gii' =\n [\n    'class' =\n 'yii\\gii\\Module',\n    'allowedIPs' =\n ['127.0.0.1', '::1', '192.168.0.*', '192.168.178.20'] // adjust this to your needs\n],\n\n\n\n\n\n\n\nGenerare una classe Active Record\n\n\nPer utilizzare Gii nella generazione di una classe Active Record, dovete selezionare \nModel Generator\n (facendo click sul pulsante \nStart\n). Quindi compilare il modulo come segue:\n\n\n\n\nNome della tabella: \ncountry\n\n\nClasse del modello: \nCountry\n\n\n\n\n\n\nPremendo il pulsante \nPreview\n vedrete il file \nmodels/Country.php\n che verr\u00e0 creato dall'Active Record. Puoi anche cliccare sul nome del file per visualizzare l'anteprima del suo contenuto.\nQuando si utilizza Gii, se si \u00e8 gi\u00e0 creato lo stesso file, lo sovrascriver\u00e0. Se premiamo il pulsante \ndiff\n accanto al nome del fil, potrete vedere le differenze tra il codice che verr\u00e0 generato e la versione esistente.\n\n\n\n\nQuando sovrascriverete un file esistente, selezionate la casella accanto a \noverwrite\n e quindi fate clic sul pulsante \nGenerate\n. Se invece si crea un nuovo file, \u00e8 sufficiente fare clic sul pulsante \nGenerate\n.\nSuccessivamente, verr\u00e0 visualizzata una pagina di conferma, per essere sicuri che il codice sia stato generato in modo corretto o meno. Se si avesse un file esistente, verr\u00e0 visualizzato anche un messaggio dove verr\u00e0 indicato che \u00e8 stato sovrascritto il codice appena generato.\n\n\nGenerazione codice di un CRUD\n\n\nCRUD sta per \nCreate - Read - Update - Delete\n. Rappresentano le 4 attivit\u00e0 comuni che si effettuano sui dati nella maggior parte dei siti Web. Per creare funzionalit\u00e0 CRUD usando Gii, dobbiamo selezione l'opzione \nCRUD Generator\n (nella pagina indice di Gii). Continuando con l'esempio dei \"paesi\", compiliamo il modulo come segue:\n\n\n\n\nModel Class: \napp\\models\\Country\n\n\nSearch Model Class: \napp\\models\\CountrySearch\n\n\nController Class: \napp\\controllers\\CountryController\n\n\n\n\n\n\nPremendo il pulsante \npreview\n, verr\u00e0 visualizzato un elenco di file da generare, come mostrato di seguito:\n\n\n\n\nSe in precedenza avete creato i file \ncontrollers/CountryController.php\n e \nviews/country/index.php\n nella sezione \nLavorare con i database\n, dovete controllare la casella \noverwrite\n per sostituirli.\n\n\nPer vedere se tutto quello che abbiamo fatto funziona, copiamo il seguente URL nel nostro browser\n\n\nhttp://hostname/index.php?r=country%2Findex\n\n\n\nA questo punto vedrai una griglia di dati che mostra i paesi inseriti in precedenza nel nostro database. Puoi ordinare la griglia, oppure filtrarla immettendo le condizioni di filtro nelle intestazioni di colonna.\nPer ogni paese visualizzato nella griglia, \u00e8 possibile scegliere di visualizzarli, modificarli o elimiarli. Puoi anche scegliere di aggiungere un nuovo paese sul pulsante \nCreate Country\n nella parte superiore della griglia.\n\n\n\n\nSchermata relativa alla modifica di un paese:\n\n\n\n\nDi seguito \u00e8 riportato l'elenco dei file generati da Gii, nel caso in cui si desidera esaminare, implementare (o personalizzare) le funzionalit\u00e0:\n\n\n\n\nController: \ncontrollers/CountryController.php\n\n\nModels: \nmodels/Country.php\n e \nmodels/CountrySearch.php\n\n\nViews: \nviews/country/*.php\n\n\n\n\n\n\nTip\n\n\nGii\n \u00e8 stato progettato per essere uno strumento di generazione di codici estremamente personalizzabile e estensibile. Se utilizziamo \nGii\n accelleriamo notevolmente la velocit\u00e0 nello sviluppo delle applicazioni.",
            "title": "Generare codice con Gii"
        },
        {
            "location": "/getting-started/sub-generate-code-gii/#generare-codice-con-gii",
            "text": "Questa sezione descrive come utilizzare  Gii  per generare automaticamente il codice che implementa alcune funzioni comuni del sito Web. Utilizzare Gii per generare codice in automatico \u00e8 semplicemente una questione di immissione delle informazioni giuste per le istruzioni visualizzate nelle pagine Web Gii.\nAttraverso questo tutorial, imparerai come:   abilitare Gii nella tua applicazione,  utilizzare Gii per generare una classe Active Record,  utilizzare Gii per generare il codice che implementa le operazioni CRUD per una tabella DB,  personalizzare il codice generato da Gii.",
            "title": "Generare codice con Gii"
        },
        {
            "location": "/getting-started/sub-generate-code-gii/#partiamo-da-gii",
            "text": "Gii viene fornito da Yii come modulo. E' possibile abilitare Gii configurandolo nella propriet\u00e0 dei moduli nell'applicazione. A seconda del modo in cui \u00e8 stata creata l'applicazione, \u00e8 possibile che il codice riportato di seguito sia gi\u00e0 fornito nel file di configurazione  config/web.php .  $config = [ ... ];\n\nif (YII_ENV_DEV) {\n    $config['bootstrap'][] = 'gii';\n    $config['modules']['gii'] = [\n        'class' =  'yii\\gii\\Module',\n    ];\n}  La configurazione soprastante indica che l'applicazione deve includere un modulo denominato  gii , che fa parte della classe  yii \\ gii \\ Module .\nSe selezioniamo l'entry script della nostra applicazione (  web/index.php ), troverete la seguente riga, il che rende essenzialmente  YII_ENV_DEV  a  true  defined('YII_ENV') or define('YII_ENV', 'dev');  Grazie a questa linea di codica, la nostra applicazione \u00e8 in modalit\u00e0 di sviluppo e sar\u00e0 gi\u00e0 abilitata a Gii per la configurazione precedentemente impostata da noi. Adesso \u00e8 possibile accedere a Gii attraverso il seguente URL  http://hostname/index.php?r=gii   Warning  Se accediamo a Gii da una macchina diversa da localhsot, l'accesso verr\u00e0 negato come impostazione predefinita per scopi di protezione. E' possibile configurare Gii per aggiungere gli indirizzi IP consentiti, come segue:  'gii' =  [\n    'class' =  'yii\\gii\\Module',\n    'allowedIPs' =  ['127.0.0.1', '::1', '192.168.0.*', '192.168.178.20'] // adjust this to your needs\n],",
            "title": "Partiamo da Gii"
        },
        {
            "location": "/getting-started/sub-generate-code-gii/#generare-una-classe-active-record",
            "text": "Per utilizzare Gii nella generazione di una classe Active Record, dovete selezionare  Model Generator  (facendo click sul pulsante  Start ). Quindi compilare il modulo come segue:   Nome della tabella:  country  Classe del modello:  Country    Premendo il pulsante  Preview  vedrete il file  models/Country.php  che verr\u00e0 creato dall'Active Record. Puoi anche cliccare sul nome del file per visualizzare l'anteprima del suo contenuto.\nQuando si utilizza Gii, se si \u00e8 gi\u00e0 creato lo stesso file, lo sovrascriver\u00e0. Se premiamo il pulsante  diff  accanto al nome del fil, potrete vedere le differenze tra il codice che verr\u00e0 generato e la versione esistente.   Quando sovrascriverete un file esistente, selezionate la casella accanto a  overwrite  e quindi fate clic sul pulsante  Generate . Se invece si crea un nuovo file, \u00e8 sufficiente fare clic sul pulsante  Generate .\nSuccessivamente, verr\u00e0 visualizzata una pagina di conferma, per essere sicuri che il codice sia stato generato in modo corretto o meno. Se si avesse un file esistente, verr\u00e0 visualizzato anche un messaggio dove verr\u00e0 indicato che \u00e8 stato sovrascritto il codice appena generato.",
            "title": "Generare una classe Active Record"
        },
        {
            "location": "/getting-started/sub-generate-code-gii/#generazione-codice-di-un-crud",
            "text": "CRUD sta per  Create - Read - Update - Delete . Rappresentano le 4 attivit\u00e0 comuni che si effettuano sui dati nella maggior parte dei siti Web. Per creare funzionalit\u00e0 CRUD usando Gii, dobbiamo selezione l'opzione  CRUD Generator  (nella pagina indice di Gii). Continuando con l'esempio dei \"paesi\", compiliamo il modulo come segue:   Model Class:  app\\models\\Country  Search Model Class:  app\\models\\CountrySearch  Controller Class:  app\\controllers\\CountryController    Premendo il pulsante  preview , verr\u00e0 visualizzato un elenco di file da generare, come mostrato di seguito:   Se in precedenza avete creato i file  controllers/CountryController.php  e  views/country/index.php  nella sezione  Lavorare con i database , dovete controllare la casella  overwrite  per sostituirli.  Per vedere se tutto quello che abbiamo fatto funziona, copiamo il seguente URL nel nostro browser  http://hostname/index.php?r=country%2Findex  A questo punto vedrai una griglia di dati che mostra i paesi inseriti in precedenza nel nostro database. Puoi ordinare la griglia, oppure filtrarla immettendo le condizioni di filtro nelle intestazioni di colonna.\nPer ogni paese visualizzato nella griglia, \u00e8 possibile scegliere di visualizzarli, modificarli o elimiarli. Puoi anche scegliere di aggiungere un nuovo paese sul pulsante  Create Country  nella parte superiore della griglia.   Schermata relativa alla modifica di un paese:   Di seguito \u00e8 riportato l'elenco dei file generati da Gii, nel caso in cui si desidera esaminare, implementare (o personalizzare) le funzionalit\u00e0:   Controller:  controllers/CountryController.php  Models:  models/Country.php  e  models/CountrySearch.php  Views:  views/country/*.php    Tip  Gii  \u00e8 stato progettato per essere uno strumento di generazione di codici estremamente personalizzabile e estensibile. Se utilizziamo  Gii  accelleriamo notevolmente la velocit\u00e0 nello sviluppo delle applicazioni.",
            "title": "Generazione codice di un CRUD"
        },
        {
            "location": "/getting-started/sub-looking-ahead/",
            "text": "Guadiamo avanti\n\n\nSe hai letto tutto il capitolo, sei riuscito a creare un'applicazione Yii completa. Nel corso del capitolo, hai imparato come implementare alcune funzionalit\u00e0 comunemente necessarie, come ottenere dati dagli utenti tramite un modulo HTML, recuperare dati da un database e visualizzare i dati in modo paginato. Hai anche imparato a utilizzare \nGii\n per generare automaticamente il codice. L'utilizzo di \nGii\n per la generazione di codici trasforma la maggior parte del tuo processo di sviluppo Web in un compito semplice come quello di riempire alcuni form.\nAdesso continuiamo a scoprire in modo pi\u00f9 approfondito il framework Yii e quello che pu\u00f2 offrire.",
            "title": "Guardiamo avanti"
        },
        {
            "location": "/getting-started/sub-looking-ahead/#guadiamo-avanti",
            "text": "Se hai letto tutto il capitolo, sei riuscito a creare un'applicazione Yii completa. Nel corso del capitolo, hai imparato come implementare alcune funzionalit\u00e0 comunemente necessarie, come ottenere dati dagli utenti tramite un modulo HTML, recuperare dati da un database e visualizzare i dati in modo paginato. Hai anche imparato a utilizzare  Gii  per generare automaticamente il codice. L'utilizzo di  Gii  per la generazione di codici trasforma la maggior parte del tuo processo di sviluppo Web in un compito semplice come quello di riempire alcuni form.\nAdesso continuiamo a scoprire in modo pi\u00f9 approfondito il framework Yii e quello che pu\u00f2 offrire.",
            "title": "Guadiamo avanti"
        },
        {
            "location": "/application-structure/sub-overview/",
            "text": "Panoramica\n\n\nLe applicazioni Yii sono organizzate in base al modello MVC ( model - view - controller ). I model (modelli) rappresentano i dati, la logica aziendale e le regole; le view (viste) rappresentano la rappresentazione dei modelli; e i controller (controllori) prendono l'input e lo trasformano in comandi per i model e le view.\n\n\nOltre al MVC, le applicazioni Yii hanno anche le seguenti entit\u00e0:\n\n\n\n\nEntry script\n: sono script PHP che sono direttamente accessibili dagli utenti finali. Sono responsabili dell'avvio di un ciclo che permette la gestione delle richieste da parte dell'utente.\n\n\nApplication\n: sono oggetti accessibili a livello globale che gestiscono i componenti dell'applicazione e le coordinano per soddisfare le richieste.\n\n\nApplication component\n: sono oggetti registrati con applicazioni e forniscono veri servizi per soddisfare le richieste.\n\n\nModule\n: sono pacchetti autonomi che contengono pattern MVC completi da soli. Un'applicazione pu\u00f2 essere organizzata in termini di moduli multipli.\n\n\nFiltri\n: rappresentano il codice che deve essere richiamato prima e dopo la gestione effettiva di ogni richiesta da parte dei controllori.\n\n\nWidget\n: sono oggetti che possono essere incorporati nelle view (viste).Possono contenere la logica dei controller e possono essere anche riutilizzati in viste diverse.\n\n\n\n\nIl seguente schema mostra la struttura statica di un'applicazione:",
            "title": "Panoramica"
        },
        {
            "location": "/application-structure/sub-overview/#panoramica",
            "text": "Le applicazioni Yii sono organizzate in base al modello MVC ( model - view - controller ). I model (modelli) rappresentano i dati, la logica aziendale e le regole; le view (viste) rappresentano la rappresentazione dei modelli; e i controller (controllori) prendono l'input e lo trasformano in comandi per i model e le view.  Oltre al MVC, le applicazioni Yii hanno anche le seguenti entit\u00e0:   Entry script : sono script PHP che sono direttamente accessibili dagli utenti finali. Sono responsabili dell'avvio di un ciclo che permette la gestione delle richieste da parte dell'utente.  Application : sono oggetti accessibili a livello globale che gestiscono i componenti dell'applicazione e le coordinano per soddisfare le richieste.  Application component : sono oggetti registrati con applicazioni e forniscono veri servizi per soddisfare le richieste.  Module : sono pacchetti autonomi che contengono pattern MVC completi da soli. Un'applicazione pu\u00f2 essere organizzata in termini di moduli multipli.  Filtri : rappresentano il codice che deve essere richiamato prima e dopo la gestione effettiva di ogni richiesta da parte dei controllori.  Widget : sono oggetti che possono essere incorporati nelle view (viste).Possono contenere la logica dei controller e possono essere anche riutilizzati in viste diverse.   Il seguente schema mostra la struttura statica di un'applicazione:",
            "title": "Panoramica"
        },
        {
            "location": "/application-structure/sub-entry-script/",
            "text": "Entry Script\n\n\nGli \nEntry Scipt\n ( oppure \"script di accesso\") sono il primo passo nel processo di avvio dell'applicazione. Questi script devono essere memorizzati nelle directory accessibili al Web, in modo tale che possano essere accessibili dagli utenti finali. Sono spesso chiamati \nindex.php\n, ma possono anche utilizzare altri nomi.\n\n\nGli script di accesso effettuano principalmente i seguenti lavori:\n\n\n\n\nDefinire costanti globali;\n\n\nRegistrare il \nComposer autoloader\n;\n\n\nIncludree il file della classe Yii;\n\n\nCarica la configurazione dell'applicazione;\n\n\nCrea e configura un'istanza dell'applicazione;\n\n\nChiama \nyii \\ base \\ Application ::run()\n per elaborare la richiesta di entrata.\n\n\n\n\nApplicazioni Web\n\n\nDi seguito \u00e8 riportato il codice dello script di accesso per il modello di progetto di un'applicazione Web:\n\n\n?php\n\ndefined('YII_DEBUG') or define('YII_DEBUG', true);\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n// register Composer autoloader\nrequire(__DIR__ . '/../vendor/autoload.php');\n\n// include Yii class file\nrequire(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/../config/web.php');\n\n// create, configure and run application\n(new yii\\web\\Application($config))-\nrun();\n\n\n\nApplicazioni tramite Console\n\n\nAnalogamente, il seguente codice \u00e8 lo script di accesso per il modello di progetto di un'applicazione console:\n\n\n#!/usr/bin/env php\n\n?php\n/**\n * Yii console bootstrap file.\n *\n * @link http://www.yiiframework.com/\n * @copyright Copyright (c) 2008 Yii Software LLC\n * @license http://www.yiiframework.com/license/\n */\n\ndefined('YII_DEBUG') or define('YII_DEBUG', true);\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n// register Composer autoloader\nrequire(__DIR__ . '/vendor/autoload.php');\n\n// include Yii class file\nrequire(__DIR__ . '/vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/config/console.php');\n\n$application = new yii\\console\\Application($config);\n$exitCode = $application-\nrun();\nexit($exitCode);\n\n\n\nDefinizione di costanti\n\n\nGli script di inserimento sono il luogo migliore per definire le costanti globali. Yii supporta le seguenti 3 costanti:\n\n\n\n\nYII_DEBUG\n: specifica se l'applicazione \u00e8 in esecuzione in modalit\u00e0 di debug. Quando la modalit\u00e0 debug sar\u00e0 attiva ( cio\u00e8 settata a \ntrue\n) manterr\u00f2 ulteriori informazioni sul registro e riveler\u00e0 gli stack di chiamata degli errori dettagliata se vengono prelevate eccezioni. Per questo, questa modalit\u00e0 andrebbe sempre attivata durante lo sviluppo. Il valore predefinito \u00e8 \nfalse\n.\n\n\nYII_ENV\n: specifica l'ambiente in cui \u00e8 in esecuzione l'applicazione. Il valore predefinito di \nYII_ENV\n \u00e8 \n'prod'\n, il che significa che l'applicazione \u00e8 in esecuzione in ambiente di produzione.\n\n\nYII_ENABLE_HERROR_HANDLER\n: specifica se abilitare il gestore di errori fornito da Yii. Il valore predefinito di questa costante \u00e8 \ntrue\n.\n\n\n\n\nQuando si definisce una costante, utilizziamo spesso il seguente codice:\n\n\ndefined('YII_DEBUG') or define('YII_DEBUG', true);\n\n\n\nLe definizioni di costanti dovrebbero essere eseguite nell'entry script in modo che possano avere effetto quando altri file PHP vengano inclusi.",
            "title": "Entry Script"
        },
        {
            "location": "/application-structure/sub-entry-script/#entry-script",
            "text": "Gli  Entry Scipt  ( oppure \"script di accesso\") sono il primo passo nel processo di avvio dell'applicazione. Questi script devono essere memorizzati nelle directory accessibili al Web, in modo tale che possano essere accessibili dagli utenti finali. Sono spesso chiamati  index.php , ma possono anche utilizzare altri nomi.  Gli script di accesso effettuano principalmente i seguenti lavori:   Definire costanti globali;  Registrare il  Composer autoloader ;  Includree il file della classe Yii;  Carica la configurazione dell'applicazione;  Crea e configura un'istanza dell'applicazione;  Chiama  yii \\ base \\ Application ::run()  per elaborare la richiesta di entrata.",
            "title": "Entry Script"
        },
        {
            "location": "/application-structure/sub-entry-script/#applicazioni-web",
            "text": "Di seguito \u00e8 riportato il codice dello script di accesso per il modello di progetto di un'applicazione Web:  ?php\n\ndefined('YII_DEBUG') or define('YII_DEBUG', true);\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n// register Composer autoloader\nrequire(__DIR__ . '/../vendor/autoload.php');\n\n// include Yii class file\nrequire(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/../config/web.php');\n\n// create, configure and run application\n(new yii\\web\\Application($config))- run();",
            "title": "Applicazioni Web"
        },
        {
            "location": "/application-structure/sub-entry-script/#applicazioni-tramite-console",
            "text": "Analogamente, il seguente codice \u00e8 lo script di accesso per il modello di progetto di un'applicazione console:  #!/usr/bin/env php ?php\n/**\n * Yii console bootstrap file.\n *\n * @link http://www.yiiframework.com/\n * @copyright Copyright (c) 2008 Yii Software LLC\n * @license http://www.yiiframework.com/license/\n */\n\ndefined('YII_DEBUG') or define('YII_DEBUG', true);\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n// register Composer autoloader\nrequire(__DIR__ . '/vendor/autoload.php');\n\n// include Yii class file\nrequire(__DIR__ . '/vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/config/console.php');\n\n$application = new yii\\console\\Application($config);\n$exitCode = $application- run();\nexit($exitCode);",
            "title": "Applicazioni tramite Console"
        },
        {
            "location": "/application-structure/sub-entry-script/#definizione-di-costanti",
            "text": "Gli script di inserimento sono il luogo migliore per definire le costanti globali. Yii supporta le seguenti 3 costanti:   YII_DEBUG : specifica se l'applicazione \u00e8 in esecuzione in modalit\u00e0 di debug. Quando la modalit\u00e0 debug sar\u00e0 attiva ( cio\u00e8 settata a  true ) manterr\u00f2 ulteriori informazioni sul registro e riveler\u00e0 gli stack di chiamata degli errori dettagliata se vengono prelevate eccezioni. Per questo, questa modalit\u00e0 andrebbe sempre attivata durante lo sviluppo. Il valore predefinito \u00e8  false .  YII_ENV : specifica l'ambiente in cui \u00e8 in esecuzione l'applicazione. Il valore predefinito di  YII_ENV  \u00e8  'prod' , il che significa che l'applicazione \u00e8 in esecuzione in ambiente di produzione.  YII_ENABLE_HERROR_HANDLER : specifica se abilitare il gestore di errori fornito da Yii. Il valore predefinito di questa costante \u00e8  true .   Quando si definisce una costante, utilizziamo spesso il seguente codice:  defined('YII_DEBUG') or define('YII_DEBUG', true);  Le definizioni di costanti dovrebbero essere eseguite nell'entry script in modo che possano avere effetto quando altri file PHP vengano inclusi.",
            "title": "Definizione di costanti"
        },
        {
            "location": "/application-structure/sub-applications/",
            "text": "Applicazioni\n\n\nLe applicazioni sono oggetti che regolano la struttura complessiva e il ciclo di vita dei sistemi applicativi di Yii. Ogni sistema applicativo Yii contiene un singolo oggetto di applicazione che viene creato nell'entry script ed \u00e8 globalmente accessibile tramite l'espressione \n\\Yii::$app\n.\n\n\n\n\nInfo\n\n\nA seconda del contesto, quando diciamo \nun'applicazione\n, pu\u00f2 significare o un oggetto dell'applicazione o un sistema applicativo.\n\n\n\n\nEsistono due tipi di applicazioni: \napplicazioni Web\n e \napplicazioni Console\n.  Come indicano i nomi, il primo gestisce principalmente le richieste Web, mentre quest'ultimo gestisce le richieste di comando della console.\n\n\nConfigurazione dell'applicazione\n\n\nQuando uno script di accesso crea un'applicazione, caricher\u00e0 una configurazione e la applica all'app, come segue:\n\n\nrequire(__DIR__ . '/../vendor/autoload.php');\nrequire(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/../config/web.php');\n\n// instantiate and configure the application\n(new yii\\web\\Application($config))-\nrun();\n\n\n\nLe configurazioni applicative specificano come inizializzare le propriet\u00e0 degli oggetti applicativi. Poich\u00e8 le configurazioni di applicazione sono complesse, vengono di solito conservate in file di configurazione come \nweb.php\n nell'esempio precedente.\n\n\nPropriet\u00e0 dell'applicazione\n\n\nCi sono molte propriet\u00e0 che pu\u00f2 avere un'applicazione e che dovremmo configurare nei file di configurazione. Queste propriet\u00e0 descrivono in genere l'ambiente in cui sono in esecuzione applicazioni. Ad esemppio, le applicazioni devono sapere come caricare i controller, dove memorizzare file temporanei, ecc.. Adesso andremo ad elencare queste propriet\u00e0.\n\n\nPropriet\u00e0 richieste\n\n\nIn qualsiasi applicazione, \u00e8 necessario almeno configurare le seguenti due propriet\u00e0:\n\n\nID\n\n\nLa propriet\u00e0 ID specifica un id univoco che differenzia un'applicazione da un'altra. Sebbene non sia un requisito, per una migliore interoperabilit\u00e0 \u00e8 consigliabile utilizzare solo caratteri alfanumerici quando si specifica un ID dell'applicazione.\n\n\nbasePath\n\n\nLa propriet\u00e0 \nbasePath\n specifica la directory principale di un'applicazione. E' la directory che contiene tutto il codice sorgente protetto di un sistema applicativo. In base a tale directory, normalmente ci saranno sotto-directory come \nmodels\n, \nviews\n e \ncontrollers\n che contengono il codice sorgente corrispondente al pattern MVC.\nE' possibile configurare la propriet\u00e0 \nbasePath\n utilizzando un percorso di directory o un alias di percorso. In entrambe le forme, la directory corrispondente deve esistere oppure verr\u00e0 lanciata un'eccezione. Il percorso viene normalizzato chiamando la funzione \nrealpath()\n.\n\n\nPropriet\u00e0 importanti\n\n\nLe propriet\u00e0 descritte in questa sottosezione spesso devono essere configurate perch\u00e8 differiscono da diverse applicazioni.\n\n\nAlias\n\n\nQuesta propriet\u00e0 consente di definire un insieme di alias in termini di array. Le chiavi dell'array sono nomi di alias e i valori dell'array sono le corrispondenti definizioni del percorso. Per esempio:\n\n\n[\n    'aliases' =\n [\n        '@name1' =\n 'path/to/path1',\n        '@name2' =\n 'path/to/path2',\n    ],\n]\n\n\n\nQuesta propriet\u00e0 viene utilizzata per richiamare un'applicazione che potrebbe avere un nome differente a quello indicato nell'ID.\n\n\nBootstrap\n\n\nQuesta \u00e8 una propriet\u00e0 molto utile. Consente di specificare una serie di componenti che devono essere eseguiti durante il processo di avvio dell'applicazione. Ad esempio, se si desidera che un modulo personalizza le regole URL, \u00e8 possibile elencare l'ID come elemento di questa propriet\u00e0.\nOgni componente elencato in questa propriet\u00e0 pu\u00f2 essere specificato in uno dei seguenti formati:\n\n\n\n\nun ID di un'applicazione specificato tramite componenti,\n\n\nun modulo ID specificato tramite moduli,\n\n\nun nome di una classe,\n\n\nun array di configurazione,\n\n\nuna funzione anonima che crea e restituisce un determinato componente.\n\n\n\n\nEsempio:\n\n\n[\n    'bootstrap' =\n [\n        // an application component ID or module ID\n        'demo',\n\n        // a class name\n        'app\\components\\Profiler',\n\n        // a configuration array\n        [\n            'class' =\n 'app\\components\\Profiler',\n            'level' =\n 3,\n        ],\n\n        // an anonymous function\n        function () {\n            return new app\\components\\Profiler();\n        }\n    ],\n]\n\n\n\n\n\nInfo\n\n\nse un ID di un modulo \u00e8 lo stesso ID di un componente dell'applicazione, il componente verr\u00e0 utilizzato durante il processo di avvio. Se si desidera usare il modulo invece del componente, \u00e8 possibile specificarlo utilizzando una funzione anonima come segue:\n\n\n[\n    function () {\n        return Yii::$app-\ngetModule('user');\n    },\n]\n\n\n\n\n\nDurante il processo di avvio, ogni componente viene instanziato. Se la classe dei componenti implementa \nyii /base / BootstrapInterface\n, verr\u00e0 anche chiamato il metodo \nbootstrap()\n. Questo metodo pu\u00f2 contenere ID di eventuali moduli che voglio caricare prima di alcuni ( per es. il modulo \u2018log\u2019 per tener traccia di eventuali errori nella fase di caricamento ).\n\n\nCatchAll\n\n\nQuesta propriet\u00e0 \u00e8 supportata solo dalle applicazioni Web. Specifica un'azione del controller che dovrebbe gestire tutte le richieste dell'utente. Questo viene utilizzato principalmente quando l'applicazione \u00e8 in modalit\u00e0 di debug e deve gestire tutte le richieste in entrata tramite un'unica azione.\nLa configurazione \u00e8 una matrice il cui primo elemento specifica il percorso dell'azione. Il resto degli elementi della matrice specifica i parametri da associare all'azione. \n\n\nEsempio:\n\n\n[\n    'catchAll' =\n [\n        'offline/notice',\n        'param1' =\n 'value1',\n        'param2' =\n 'value2',\n    ],\n]\n\n\n\n\n\nInfo\n\n\nIl pannello di debug sull'ambiente di sviluppo non funziona quando questa propriet\u00e0 \u00e8 abilitata.\n\n\n\n\nComponenti - (components)\n\n\nQuesta \u00e8 la propriet\u00e0 pi\u00f9 importante. Consente di registrare un elenco di componenti denominati \napplication component\n che \u00e8 possibile utilizzare in altri luoghi. \n\n\nEsempio:\n\n\n[\n    'components' =\n [\n        'cache' =\n [\n            'class' =\n 'yii\\caching\\FileCache',\n        ],\n        'user' =\n [\n            'identityClass' =\n 'app\\models\\User',\n            'enableAutoLogin' =\n true,\n        ],\n    ],  \n]\n\n\n\nOgni componente dell'applicazione viene specificata come array di chiave valore.\n\n\nEsempio 2:\n\n\n'components' =\n [\n        'user' =\n [\n            'identityClass' =\n 'common\\models\\User',\n            'enableAutoLogin' =\n true,\n        ],]\n\n\nNella parte di codice sopra stante, si vede la struttura chiave-valore applicata.\nLa prima chiave che troviamo \u00e8 \nUser\n cio\u00e8 l\u2019identificavo (ID) del modulo/componente, e il suo valore, \u00e8 composto a sua volta da un array chiave-valore, dove le chiavi questa volta sono identificativi o della classe principale del modulo \nidentityClass\n o di una sua configurazione \nenableAutoLogin\n.\n\n\nControllerMap\n\n\nQuesta propriet\u00e0 consente di mappare un controller ID in una classe arbitraria del controller. Per impostazione predefinitam Yii mapper\u00e0 gli ID alle classi di controller basate su una convenzione ( ad esempio l'ID \npost\n verr\u00e0 mappato \napp\\controller\\PostController\n). Configurando questa propriet\u00e0, \u00e8 possibile rompere la convenzione per specifici controller. Nell'esempio seguente, \naccount\n verr\u00e0 mappato \napp\\controllers\\UserController\n, mentre \narticle\n verr\u00e0 mappato su \napp\\controllers\\PostController\n.\n\n\n[\n    'controllerMap' =\n [\n        'account' =\n 'app\\controllers\\UserController',\n        'article' =\n [\n            'class' =\n 'app\\controllers\\PostController',\n            'enableCsrfValidation' =\n false,\n        ],\n    ],  \n]\n\n\n\nLe chiavi dell'array rappresentano gli ID del controller, mentre i valori dell'array rappresentano i nomi o le configurazioni dei nomi delle classi di controllo corrispondenti.\n\n\nControllerNamespace\n\n\nQuesta propriet\u00e0 specifica i namespace predefiniti in cui le classi controller devono essere posizionate. Come posizione di default li troveremo in \napp\\controllers\n. Se \u00e8 un ID del controller \npost\n, per convenzione, corrisponderebbe il nome della classe di controllo \nPostController\n e il nome della classe completamente qualificato \napp\\controllers\\PostController\n.\n\n\nLe classi del controller possono anche essere posizionate sotto le sotto-directory della directory corrispondente a questi namespace. Ad esempio, dato un ID controller \nadmin/post\n, la corrispondente classe del controller completamente qualificata sarebbe \napp\\controllers\\admin\\PostController\n.\n\n\nE' importante che le classi di controllo pienamente qualificate debbano essere \nautoloadable\n e i namespace delle classi di controller corrispondino al valore di questa propriet\u00e0. Altrimenti riceverai un errore \nPagina non trovata\n quando si accede alla nostra applicazione.\n\n\nLingua - (language)\n\n\nQuesta propriet\u00e0 specifica la lingua in cui l'applicazionedeve visualizzare il contenuto agli utenti finali. Il valore predefinito di questa propriet\u00e0 \u00e8 \nen\n ( inglese ). E' necessario configurare questa propriet\u00e0 se vogliamo che l'applicazione possa supportare pi\u00f9 lingue.\nIl valore di questa propriet\u00e0 determina diversi aspetti di internalizzazione, tra cui la traduzione dei messaggi, la formattazione della data, la formattazione del numero, ecc..\n\n\nModuli - (modules)\n\n\nQuesta propriet\u00e0 specifica i moduli che contiene l'applicazione. I moduli vengono visti come sotto-applicazioni della nostra applicazione padre.\n\n\nEsempio:\n\n\n[\n    'modules' =\n [\n        // a \"booking\" module specified with the module class\n        'booking' =\n 'app\\modules\\booking\\BookingModule',\n\n        // a \"comment\" module specified with a configuration array\n        'comment' =\n [\n            'class' =\n 'app\\modules\\comment\\CommentModule',\n            'db' =\n 'db',\n        ],\n    ],  \n]\n\n\n\nNome - (name)\n\n\nQuesta propriet\u00e0 specifica il nome dell'applicazione che pu\u00f2 essere visualizzato agli utenti finali. A differenza della propriet\u00e0 ID, che dovrebbe assumere un valore univoco, il valore di questa propriet\u00e0 \u00e8 usato principalmente per scopi di visualizzazione. Non deve essere univoco.\n\n\nParametri - (params)\n\n\nQuesta propriet\u00e0 specifica una serie di parametri applicativi accessibili a livello globale. Invece di utilizzare numerosi codici e stringhe dappertutto nel codice, \u00e8 una buona pratica definirli come parametri dell'app in un unico punto e utilizzare parametri in luoghi dove \u00e8 necessario. \n\n\nEsempio: possiamo utilizzare questa propriet\u00e0 per definire la dimensione dell'immagine in miniatura come parametro\n\n\n[\n    'params' =\n [\n        'thumbnail.size' =\n [128, 128],\n    ],\n]\n\n\n\nA questo punto nel codice in cui bisgona utilizzare il valore della dimensione, possiamo usare il seguente codice:\n\n\n$size = \\Yii::$app-\nparams['thumbnail.size'];\n$width = \\Yii::$app-\nparams['thumbnail.size'][0];\n\n\n\nIn seguito, se si decide di modificare le dimensioni delle miniature, \u00e8 necessario modificarlo solo nella configurazione dell'applicazione; non \u00e8 necessario toccare alcun codice dipendente.\n\n\nLinguaggio del codice - (sourceLanguage)\n\n\nQuesta propriet\u00e0 specifica la lingua in cui \u00e8 scritto il codice dell'applicazione. Il valore predefinito \u00e8 \nen-US\n, cio\u00e8 l'inglese (Stati Uniti). E' necessario configurare questo propriet\u00e0 se il contenuto del testo nel codice non \u00e8 in inglese.\n\n\nFuso orario - (timeZone)\n\n\nQuesta propriet\u00e0 viene fornita come modalit\u00e0 alternativa per impostare il fuso orario predefinito del runtime PHP. Configurando questa propriet\u00e0, si sta chiamando essenzialmente la funzione PHP \ndate_default_timezone_set()\n.\n\n\nEsempio:\n\n\n[\n    'timeZone' =\n 'America/Los_Angeles',\n]\n\n\n\nVersioni - (version)\n\n\nQuesta propriet\u00e0 specifica la versione dell'applicazione. E' predefinito \n1.0\n.\n\n\nPropriet\u00e0 Utili\n\n\nLe propriet\u00e0 descritte in questa sottosezione non sono comunemente configurate perch\u00e8 i loro valori predefiniti derivano da convenzioni comuni. Tuttavia, \u00e8 possibile configurarli nel caso in cui si desidera rompere le convenzioni.\n\n\nCharset\n\n\nQuesta propriet\u00e0 specifica il carattere che l'applicazione utilizza. Il valore predefinito \u00e8 quello \nUTF-8\n che dovrebbe essere mantenuto come per la maggior parte delle applicazioni a meno che non si tratti di un sistema legacy che utilizza un sacco di dati non Unicode.\n\n\nDefaultRoute\n\n\nQuesta propriet\u00e0 specifica il percorso che un'applicazione deve utilizzare quando una richiesta non lo specifica. Ad esempio, \nhelp\n,\npost/create\n o \nadmin/post/create\n. Se non viene dato un ID dell'azione, questa propriet\u00e0 prende il valore predefinito specificato in \nyii \\base \\ Controller :: $defaultAction\n.\n\n\nPer le applicazioni Web, il valore predefinito di questa propriet\u00e0 \u00e8 \nsite\n, il che significa che il \nSiteController\n e l'azione predefinita devono essere utilizzati. Di conseguenza se si accede all'applicazione senza specificare un percorso, verr\u00e0 visualizzato il risultato di \napp\\controllers\\SiteController::actionIndex()\n.\n\n\nPer le applicazioni tramite console, il valore predefinito \u00e8 \nhelp\n, il che significa che il comando principale  \nyii \\ console \\ controllers \\ HelpController::actionIndex()\n deve essere utilizzato. Di conseguenza, se su esegue il comando \nyii\n senza fornire argomenti, visualizzer\u00e0 le informazioni di aiuto (help).\n\n\nEstensioni - (extensions)\n\n\nQuesta propriet\u00e0 specifica l'elenco delle estensioni installate e utilizzate dall'applicazione. Per impostazione predefinita, l'array verr\u00e0 restituito dal file \n@vendor/yiisoft/extensions.php\n. Il file \nextensions.php\n viene generato e mantenuto automaticamente quando si utilizza il Composer per installare le estensioni. Quindi, la maggior parte dei casi, non \u00e8 necessario configurare questa propriet\u00e0.\nNel caso particolare quando si desidera mantenere manualmente le estensioni, \u00e8 possibile configurare questa propriet\u00e0 come segue:\n\n\n[\n    'extensions' =\n [\n        [\n            'name' =\n 'extension name',\n            'version' =\n 'version number',\n            'bootstrap' =\n 'BootstrapClassName',  // optional, may also be a configuration array\n            'alias' =\n [  // optional\n                '@alias1' =\n 'to/path1',\n                '@alias2' =\n 'to/path2',\n            ],\n        ],\n\n        // ... more extensions like the above ...\n\n    ],\n]\n\n\n\nCome potete vedere, la propriet\u00e0 prende una serie di specifiche di estensione. Ogni estensione \u00e8 specificata con una matrice composta da elementi \nname\n e \nversion\n.\n\n\nDisposizione - (layout)\n\n\nQuesta propriet\u00e0 specifica il nome del layout predefinito che dovrebbe essere utilizzato quando si effettua una visualizzazione. Il valore di defult \u00e8 \nmain\n, significa che il file di layout \nmain.php\n sotto il percorso di layout dovrebbe essere usato. Se entrambi i percorsi di layout e il percorso di visualizzazione stanno prendendo i valori predefiniti, il file di layout predefinito pu\u00f2 essere rappresentato come alias di percorso \n@app/views/layouts/main.php\n.\nE' possibile configurare questa propriet\u00e0 \nfalse\n se si desidera disattivare l'impostazione predefinita di layout.\n\n\nlayoutPath\n\n\nQuesta propriet\u00e0 specifica il percorso in cui dovrebbero essere caricati i file di layout. Il valore predefinito \u00e8 la sotto-directory \nlayouts\n sotto il percorso di visualizzazione. Se il percorso di visualizzazione sta prendendo il suo valore predefinito, il percorso di layout pu\u00f2 essere rappresentato come alias di percorso: \n@app/views/layouts\n.\n\n\nruntimepath\n\n\nQuesta propriet\u00e0 specifica il percorso in cui possono essere generati file temporanei, ad esempio file di log, file di cache.Il valore predefinito \u00e8 la directory rappresentata dall'alias \n@app/runtime\n.\n\n\nviewPath\n\n\nQuesta propriet\u00e0 specifica la directory principale in cui si trovano i file di visualizzazione. Il valore predefinito della directory \u00e8 rappresentata dall'alias \n@app/views\n.\n\n\nvendorPath\n\n\nQuesta propriet\u00e0 specifica la directory del fornitore gestita dal Composer. Contriene tutte le livrerie di terze parti utilizzate dall'applicazione, incluso il framework Yii. Il valore predefinito \u00e8 la directory rappresentata dall'alias \n@aap/vendor\n.\n\n\nenableCoreCommands\n\n\nQuesta propriet\u00e0 \u00e8 supportata solo dalle applicazioni tramite console. Specifica se i comandi base inclusi nella versione di Yii dovrebbero essere abilitati. Il valore predefinito \u00e8 \ntrue\n.\n\n\nEventi dell'applicazione\n\n\nUn'applicazione attiva diversi eventi durante il ciclo di vita di una richiesta. E' possibile associare i gestori di eventi nelle configurazioni dell'applicazione come segue:\n\n\n[\n    'on beforeRequest' =\n function ($event) {\n        // ...\n    },\n]\n\n\n\nIn alternativa \u00e8 possibile associare i gestori di eventi durante il processo di avvio dopo che viene creata l'istanza dell'applicazione.\n\n\nEsempio:\n\n\n\\Yii::$app-\non(\\yii\\base\\Application::EVENT_BEFORE_REQUEST, function ($event) {\n    // ...\n});\n\n\n\nEVENT_BEFORE_REQUEST\n\n\nQuesto evento viene attivato \nprima\n che un'applicazione gestisca una richiesta. Il nome effettivo dell'evento \u00e8 \nbeforeRequest\n.\n\n\nEVENT_AFTER_REQUEST\n\n\nQuesto evento viene attivato \ndopo\n che un'applicazione gestisca una richiesta, ma \nprima\n di inviare la risposta. Il nome effettivo dell'evento \u00e8 \nafterRequest\n.\nQuando questo evento viene attivato, la gestione delle richieste \u00e8 completata e si pu\u00f2 prendere questa possibilit\u00e0 per eseguire una successiva elaborazione della richiesta o personalizzare la risposta.\n\n\nEVENT_BEFORE_ACTION\n\n\nQuesto evento viene attivato \nprima\n di eseguire tutte le azioni del controller. Il nome effettivo dell'evento \u00e8 \nbeforeAction\n.\nIl parametro dell'evento \u00e8 un'istanza di \nyii \\ base \\ ActioneEvent\n. Un gestore di evento pu\u00f2 impostare la propriet\u00e0 dell'actionEvent [isValid()] ad essere \nfalse\n e smettere di eseguire l'azione. \n\n\nEsempio:\n\n\n[\n    'on beforeAction' =\n function ($event) {\n        if (some condition) {\n            $event-\nisValid = false;\n        } else {\n        }\n    },\n]\n\n\n\nSi noti che lo stesso evento \nbeforeAction\n viene attivato anche dai moduli e dai controller. Gli oggetti applicativi sono i primi che innescano questo evento, seguito da moduli (se esistono) e infire da controllori. Se settiamo l'evento a \nfalse\n tramite il metodo [isValid()] tutti gli eventi successivi non vettanno attivati.\n\n\nEVENT_AFTER_ACTION\n\n\nQuesto evento viene attivato \ndopo\n l'esecuzione di ogni azione del controller. Il nome effettivo dell'evento \u00e8 \nafterAction\n.\nIl parametro che andremo a settare all'evento \u00e8 un'istanza di \nyii \\ base \\ ActionEvent\n. Attraverso la propriet\u00e0 Yii dell'evento, un gestore di eventi pu\u00f2 accedere o modificare il risultato dell'azione.\n\n\nEsempio:\n\n\n[\n    'on afterAction' =\n function ($event) {\n        if (some condition) {\n            // modify $event-\nresult\n        } else {\n        }\n    },\n]\n\n\n\nSi noti che lo stesso evento \nafterAction\n viene attivato anche dai moduli e dai controller. Questi oggetti innescano questo evento nell'ordine inverso come per quello del \nbeforeAction\n. Cio\u00e8, i controller sono i primi oggetti che innescano questo evento, seguito dai moduli ( ovviamente se esistono )e infine dalle applicazioni.\n\n\nCiclo di vita dell'applicazione\n\n\n\n\nQuando viene eseguito uno script di inserimento (entry script) per gestire una richiesta, un'applicazione sar\u00e0 sottoposta al seguente ciclo di vita:\n\n\n\n\nLo script di inserimento carica la configurazione dell'applicazione come un array.\n\n\nLo script di inserimento crea una nuova istanza dell'applicazione:\n\n\nviene chiamato \npreInit()\n, che configura alcune propriet\u00e0 dell'applicazione al alta priorit\u00e0 ( come per esempio il \nbasePath\n);\n\n\nregistrare eventuali errori nel \ngestore di errori\n;\n\n\nconfigurare le propriet\u00e0 dell'applicazione;\n\n\nviene chiamato \ninit()\n che chiama ulteriormente \nbootstrap()\n per eseguire questi ultimi componenti.\n\n\n\n\n\n\nL'entry script chiama \nyii \\ base Application :: run()\n per eseguire l'applicazione:\n\n\nviene attivato l'evento \nEVENT_BEFORE_REQUEST\n;\n\n\nviene controllata la richiesta. Viene convertita la richiesta in un percorso con i relativi parametri, viene creato un modulo, i controller e gli oggetti di azione come specificato nel percorso e infine viene eseguita l'azione;\n\n\nviene attivato l'evento \nEVENT_AFTER_REQUEST\n;\n\n\ninfine viene inviata una risposta all'utente finale.\n\n\n\n\n\n\nL'entry script riceve lo stato di uscita dall'applicazione e completa l'elaborazione delle richieste.",
            "title": "Applicazioni"
        },
        {
            "location": "/application-structure/sub-applications/#applicazioni",
            "text": "Le applicazioni sono oggetti che regolano la struttura complessiva e il ciclo di vita dei sistemi applicativi di Yii. Ogni sistema applicativo Yii contiene un singolo oggetto di applicazione che viene creato nell'entry script ed \u00e8 globalmente accessibile tramite l'espressione  \\Yii::$app .   Info  A seconda del contesto, quando diciamo  un'applicazione , pu\u00f2 significare o un oggetto dell'applicazione o un sistema applicativo.   Esistono due tipi di applicazioni:  applicazioni Web  e  applicazioni Console .  Come indicano i nomi, il primo gestisce principalmente le richieste Web, mentre quest'ultimo gestisce le richieste di comando della console.",
            "title": "Applicazioni"
        },
        {
            "location": "/application-structure/sub-applications/#configurazione-dellapplicazione",
            "text": "Quando uno script di accesso crea un'applicazione, caricher\u00e0 una configurazione e la applica all'app, come segue:  require(__DIR__ . '/../vendor/autoload.php');\nrequire(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/../config/web.php');\n\n// instantiate and configure the application\n(new yii\\web\\Application($config))- run();  Le configurazioni applicative specificano come inizializzare le propriet\u00e0 degli oggetti applicativi. Poich\u00e8 le configurazioni di applicazione sono complesse, vengono di solito conservate in file di configurazione come  web.php  nell'esempio precedente.",
            "title": "Configurazione dell'applicazione"
        },
        {
            "location": "/application-structure/sub-applications/#proprieta-dellapplicazione",
            "text": "Ci sono molte propriet\u00e0 che pu\u00f2 avere un'applicazione e che dovremmo configurare nei file di configurazione. Queste propriet\u00e0 descrivono in genere l'ambiente in cui sono in esecuzione applicazioni. Ad esemppio, le applicazioni devono sapere come caricare i controller, dove memorizzare file temporanei, ecc.. Adesso andremo ad elencare queste propriet\u00e0.",
            "title": "Propriet\u00e0 dell'applicazione"
        },
        {
            "location": "/application-structure/sub-applications/#proprieta-richieste",
            "text": "In qualsiasi applicazione, \u00e8 necessario almeno configurare le seguenti due propriet\u00e0:  ID  La propriet\u00e0 ID specifica un id univoco che differenzia un'applicazione da un'altra. Sebbene non sia un requisito, per una migliore interoperabilit\u00e0 \u00e8 consigliabile utilizzare solo caratteri alfanumerici quando si specifica un ID dell'applicazione.  basePath  La propriet\u00e0  basePath  specifica la directory principale di un'applicazione. E' la directory che contiene tutto il codice sorgente protetto di un sistema applicativo. In base a tale directory, normalmente ci saranno sotto-directory come  models ,  views  e  controllers  che contengono il codice sorgente corrispondente al pattern MVC.\nE' possibile configurare la propriet\u00e0  basePath  utilizzando un percorso di directory o un alias di percorso. In entrambe le forme, la directory corrispondente deve esistere oppure verr\u00e0 lanciata un'eccezione. Il percorso viene normalizzato chiamando la funzione  realpath() .",
            "title": "Propriet\u00e0 richieste"
        },
        {
            "location": "/application-structure/sub-applications/#proprieta-importanti",
            "text": "Le propriet\u00e0 descritte in questa sottosezione spesso devono essere configurate perch\u00e8 differiscono da diverse applicazioni.  Alias  Questa propriet\u00e0 consente di definire un insieme di alias in termini di array. Le chiavi dell'array sono nomi di alias e i valori dell'array sono le corrispondenti definizioni del percorso. Per esempio:  [\n    'aliases' =  [\n        '@name1' =  'path/to/path1',\n        '@name2' =  'path/to/path2',\n    ],\n]  Questa propriet\u00e0 viene utilizzata per richiamare un'applicazione che potrebbe avere un nome differente a quello indicato nell'ID.  Bootstrap  Questa \u00e8 una propriet\u00e0 molto utile. Consente di specificare una serie di componenti che devono essere eseguiti durante il processo di avvio dell'applicazione. Ad esempio, se si desidera che un modulo personalizza le regole URL, \u00e8 possibile elencare l'ID come elemento di questa propriet\u00e0.\nOgni componente elencato in questa propriet\u00e0 pu\u00f2 essere specificato in uno dei seguenti formati:   un ID di un'applicazione specificato tramite componenti,  un modulo ID specificato tramite moduli,  un nome di una classe,  un array di configurazione,  una funzione anonima che crea e restituisce un determinato componente.   Esempio:  [\n    'bootstrap' =  [\n        // an application component ID or module ID\n        'demo',\n\n        // a class name\n        'app\\components\\Profiler',\n\n        // a configuration array\n        [\n            'class' =  'app\\components\\Profiler',\n            'level' =  3,\n        ],\n\n        // an anonymous function\n        function () {\n            return new app\\components\\Profiler();\n        }\n    ],\n]   Info  se un ID di un modulo \u00e8 lo stesso ID di un componente dell'applicazione, il componente verr\u00e0 utilizzato durante il processo di avvio. Se si desidera usare il modulo invece del componente, \u00e8 possibile specificarlo utilizzando una funzione anonima come segue:  [\n    function () {\n        return Yii::$app- getModule('user');\n    },\n]   Durante il processo di avvio, ogni componente viene instanziato. Se la classe dei componenti implementa  yii /base / BootstrapInterface , verr\u00e0 anche chiamato il metodo  bootstrap() . Questo metodo pu\u00f2 contenere ID di eventuali moduli che voglio caricare prima di alcuni ( per es. il modulo \u2018log\u2019 per tener traccia di eventuali errori nella fase di caricamento ).  CatchAll  Questa propriet\u00e0 \u00e8 supportata solo dalle applicazioni Web. Specifica un'azione del controller che dovrebbe gestire tutte le richieste dell'utente. Questo viene utilizzato principalmente quando l'applicazione \u00e8 in modalit\u00e0 di debug e deve gestire tutte le richieste in entrata tramite un'unica azione.\nLa configurazione \u00e8 una matrice il cui primo elemento specifica il percorso dell'azione. Il resto degli elementi della matrice specifica i parametri da associare all'azione.   Esempio:  [\n    'catchAll' =  [\n        'offline/notice',\n        'param1' =  'value1',\n        'param2' =  'value2',\n    ],\n]   Info  Il pannello di debug sull'ambiente di sviluppo non funziona quando questa propriet\u00e0 \u00e8 abilitata.   Componenti - (components)  Questa \u00e8 la propriet\u00e0 pi\u00f9 importante. Consente di registrare un elenco di componenti denominati  application component  che \u00e8 possibile utilizzare in altri luoghi.   Esempio:  [\n    'components' =  [\n        'cache' =  [\n            'class' =  'yii\\caching\\FileCache',\n        ],\n        'user' =  [\n            'identityClass' =  'app\\models\\User',\n            'enableAutoLogin' =  true,\n        ],\n    ],  \n]  Ogni componente dell'applicazione viene specificata come array di chiave valore.  Esempio 2:  'components' =  [\n        'user' =  [\n            'identityClass' =  'common\\models\\User',\n            'enableAutoLogin' =  true,\n        ],]  Nella parte di codice sopra stante, si vede la struttura chiave-valore applicata.\nLa prima chiave che troviamo \u00e8  User  cio\u00e8 l\u2019identificavo (ID) del modulo/componente, e il suo valore, \u00e8 composto a sua volta da un array chiave-valore, dove le chiavi questa volta sono identificativi o della classe principale del modulo  identityClass  o di una sua configurazione  enableAutoLogin .  ControllerMap  Questa propriet\u00e0 consente di mappare un controller ID in una classe arbitraria del controller. Per impostazione predefinitam Yii mapper\u00e0 gli ID alle classi di controller basate su una convenzione ( ad esempio l'ID  post  verr\u00e0 mappato  app\\controller\\PostController ). Configurando questa propriet\u00e0, \u00e8 possibile rompere la convenzione per specifici controller. Nell'esempio seguente,  account  verr\u00e0 mappato  app\\controllers\\UserController , mentre  article  verr\u00e0 mappato su  app\\controllers\\PostController .  [\n    'controllerMap' =  [\n        'account' =  'app\\controllers\\UserController',\n        'article' =  [\n            'class' =  'app\\controllers\\PostController',\n            'enableCsrfValidation' =  false,\n        ],\n    ],  \n]  Le chiavi dell'array rappresentano gli ID del controller, mentre i valori dell'array rappresentano i nomi o le configurazioni dei nomi delle classi di controllo corrispondenti.  ControllerNamespace  Questa propriet\u00e0 specifica i namespace predefiniti in cui le classi controller devono essere posizionate. Come posizione di default li troveremo in  app\\controllers . Se \u00e8 un ID del controller  post , per convenzione, corrisponderebbe il nome della classe di controllo  PostController  e il nome della classe completamente qualificato  app\\controllers\\PostController .  Le classi del controller possono anche essere posizionate sotto le sotto-directory della directory corrispondente a questi namespace. Ad esempio, dato un ID controller  admin/post , la corrispondente classe del controller completamente qualificata sarebbe  app\\controllers\\admin\\PostController .  E' importante che le classi di controllo pienamente qualificate debbano essere  autoloadable  e i namespace delle classi di controller corrispondino al valore di questa propriet\u00e0. Altrimenti riceverai un errore  Pagina non trovata  quando si accede alla nostra applicazione.  Lingua - (language)  Questa propriet\u00e0 specifica la lingua in cui l'applicazionedeve visualizzare il contenuto agli utenti finali. Il valore predefinito di questa propriet\u00e0 \u00e8  en  ( inglese ). E' necessario configurare questa propriet\u00e0 se vogliamo che l'applicazione possa supportare pi\u00f9 lingue.\nIl valore di questa propriet\u00e0 determina diversi aspetti di internalizzazione, tra cui la traduzione dei messaggi, la formattazione della data, la formattazione del numero, ecc..  Moduli - (modules)  Questa propriet\u00e0 specifica i moduli che contiene l'applicazione. I moduli vengono visti come sotto-applicazioni della nostra applicazione padre.  Esempio:  [\n    'modules' =  [\n        // a \"booking\" module specified with the module class\n        'booking' =  'app\\modules\\booking\\BookingModule',\n\n        // a \"comment\" module specified with a configuration array\n        'comment' =  [\n            'class' =  'app\\modules\\comment\\CommentModule',\n            'db' =  'db',\n        ],\n    ],  \n]  Nome - (name)  Questa propriet\u00e0 specifica il nome dell'applicazione che pu\u00f2 essere visualizzato agli utenti finali. A differenza della propriet\u00e0 ID, che dovrebbe assumere un valore univoco, il valore di questa propriet\u00e0 \u00e8 usato principalmente per scopi di visualizzazione. Non deve essere univoco.  Parametri - (params)  Questa propriet\u00e0 specifica una serie di parametri applicativi accessibili a livello globale. Invece di utilizzare numerosi codici e stringhe dappertutto nel codice, \u00e8 una buona pratica definirli come parametri dell'app in un unico punto e utilizzare parametri in luoghi dove \u00e8 necessario.   Esempio: possiamo utilizzare questa propriet\u00e0 per definire la dimensione dell'immagine in miniatura come parametro  [\n    'params' =  [\n        'thumbnail.size' =  [128, 128],\n    ],\n]  A questo punto nel codice in cui bisgona utilizzare il valore della dimensione, possiamo usare il seguente codice:  $size = \\Yii::$app- params['thumbnail.size'];\n$width = \\Yii::$app- params['thumbnail.size'][0];  In seguito, se si decide di modificare le dimensioni delle miniature, \u00e8 necessario modificarlo solo nella configurazione dell'applicazione; non \u00e8 necessario toccare alcun codice dipendente.  Linguaggio del codice - (sourceLanguage)  Questa propriet\u00e0 specifica la lingua in cui \u00e8 scritto il codice dell'applicazione. Il valore predefinito \u00e8  en-US , cio\u00e8 l'inglese (Stati Uniti). E' necessario configurare questo propriet\u00e0 se il contenuto del testo nel codice non \u00e8 in inglese.  Fuso orario - (timeZone)  Questa propriet\u00e0 viene fornita come modalit\u00e0 alternativa per impostare il fuso orario predefinito del runtime PHP. Configurando questa propriet\u00e0, si sta chiamando essenzialmente la funzione PHP  date_default_timezone_set() .  Esempio:  [\n    'timeZone' =  'America/Los_Angeles',\n]  Versioni - (version)  Questa propriet\u00e0 specifica la versione dell'applicazione. E' predefinito  1.0 .",
            "title": "Propriet\u00e0 importanti"
        },
        {
            "location": "/application-structure/sub-applications/#proprieta-utili",
            "text": "Le propriet\u00e0 descritte in questa sottosezione non sono comunemente configurate perch\u00e8 i loro valori predefiniti derivano da convenzioni comuni. Tuttavia, \u00e8 possibile configurarli nel caso in cui si desidera rompere le convenzioni.  Charset  Questa propriet\u00e0 specifica il carattere che l'applicazione utilizza. Il valore predefinito \u00e8 quello  UTF-8  che dovrebbe essere mantenuto come per la maggior parte delle applicazioni a meno che non si tratti di un sistema legacy che utilizza un sacco di dati non Unicode.  DefaultRoute  Questa propriet\u00e0 specifica il percorso che un'applicazione deve utilizzare quando una richiesta non lo specifica. Ad esempio,  help , post/create  o  admin/post/create . Se non viene dato un ID dell'azione, questa propriet\u00e0 prende il valore predefinito specificato in  yii \\base \\ Controller :: $defaultAction .  Per le applicazioni Web, il valore predefinito di questa propriet\u00e0 \u00e8  site , il che significa che il  SiteController  e l'azione predefinita devono essere utilizzati. Di conseguenza se si accede all'applicazione senza specificare un percorso, verr\u00e0 visualizzato il risultato di  app\\controllers\\SiteController::actionIndex() .  Per le applicazioni tramite console, il valore predefinito \u00e8  help , il che significa che il comando principale   yii \\ console \\ controllers \\ HelpController::actionIndex()  deve essere utilizzato. Di conseguenza, se su esegue il comando  yii  senza fornire argomenti, visualizzer\u00e0 le informazioni di aiuto (help).  Estensioni - (extensions)  Questa propriet\u00e0 specifica l'elenco delle estensioni installate e utilizzate dall'applicazione. Per impostazione predefinita, l'array verr\u00e0 restituito dal file  @vendor/yiisoft/extensions.php . Il file  extensions.php  viene generato e mantenuto automaticamente quando si utilizza il Composer per installare le estensioni. Quindi, la maggior parte dei casi, non \u00e8 necessario configurare questa propriet\u00e0.\nNel caso particolare quando si desidera mantenere manualmente le estensioni, \u00e8 possibile configurare questa propriet\u00e0 come segue:  [\n    'extensions' =  [\n        [\n            'name' =  'extension name',\n            'version' =  'version number',\n            'bootstrap' =  'BootstrapClassName',  // optional, may also be a configuration array\n            'alias' =  [  // optional\n                '@alias1' =  'to/path1',\n                '@alias2' =  'to/path2',\n            ],\n        ],\n\n        // ... more extensions like the above ...\n\n    ],\n]  Come potete vedere, la propriet\u00e0 prende una serie di specifiche di estensione. Ogni estensione \u00e8 specificata con una matrice composta da elementi  name  e  version .  Disposizione - (layout)  Questa propriet\u00e0 specifica il nome del layout predefinito che dovrebbe essere utilizzato quando si effettua una visualizzazione. Il valore di defult \u00e8  main , significa che il file di layout  main.php  sotto il percorso di layout dovrebbe essere usato. Se entrambi i percorsi di layout e il percorso di visualizzazione stanno prendendo i valori predefiniti, il file di layout predefinito pu\u00f2 essere rappresentato come alias di percorso  @app/views/layouts/main.php .\nE' possibile configurare questa propriet\u00e0  false  se si desidera disattivare l'impostazione predefinita di layout.  layoutPath  Questa propriet\u00e0 specifica il percorso in cui dovrebbero essere caricati i file di layout. Il valore predefinito \u00e8 la sotto-directory  layouts  sotto il percorso di visualizzazione. Se il percorso di visualizzazione sta prendendo il suo valore predefinito, il percorso di layout pu\u00f2 essere rappresentato come alias di percorso:  @app/views/layouts .  runtimepath  Questa propriet\u00e0 specifica il percorso in cui possono essere generati file temporanei, ad esempio file di log, file di cache.Il valore predefinito \u00e8 la directory rappresentata dall'alias  @app/runtime .  viewPath  Questa propriet\u00e0 specifica la directory principale in cui si trovano i file di visualizzazione. Il valore predefinito della directory \u00e8 rappresentata dall'alias  @app/views .  vendorPath  Questa propriet\u00e0 specifica la directory del fornitore gestita dal Composer. Contriene tutte le livrerie di terze parti utilizzate dall'applicazione, incluso il framework Yii. Il valore predefinito \u00e8 la directory rappresentata dall'alias  @aap/vendor .  enableCoreCommands  Questa propriet\u00e0 \u00e8 supportata solo dalle applicazioni tramite console. Specifica se i comandi base inclusi nella versione di Yii dovrebbero essere abilitati. Il valore predefinito \u00e8  true .",
            "title": "Propriet\u00e0 Utili"
        },
        {
            "location": "/application-structure/sub-applications/#eventi-dellapplicazione",
            "text": "Un'applicazione attiva diversi eventi durante il ciclo di vita di una richiesta. E' possibile associare i gestori di eventi nelle configurazioni dell'applicazione come segue:  [\n    'on beforeRequest' =  function ($event) {\n        // ...\n    },\n]  In alternativa \u00e8 possibile associare i gestori di eventi durante il processo di avvio dopo che viene creata l'istanza dell'applicazione.  Esempio:  \\Yii::$app- on(\\yii\\base\\Application::EVENT_BEFORE_REQUEST, function ($event) {\n    // ...\n});  EVENT_BEFORE_REQUEST  Questo evento viene attivato  prima  che un'applicazione gestisca una richiesta. Il nome effettivo dell'evento \u00e8  beforeRequest .  EVENT_AFTER_REQUEST  Questo evento viene attivato  dopo  che un'applicazione gestisca una richiesta, ma  prima  di inviare la risposta. Il nome effettivo dell'evento \u00e8  afterRequest .\nQuando questo evento viene attivato, la gestione delle richieste \u00e8 completata e si pu\u00f2 prendere questa possibilit\u00e0 per eseguire una successiva elaborazione della richiesta o personalizzare la risposta.  EVENT_BEFORE_ACTION  Questo evento viene attivato  prima  di eseguire tutte le azioni del controller. Il nome effettivo dell'evento \u00e8  beforeAction .\nIl parametro dell'evento \u00e8 un'istanza di  yii \\ base \\ ActioneEvent . Un gestore di evento pu\u00f2 impostare la propriet\u00e0 dell'actionEvent [isValid()] ad essere  false  e smettere di eseguire l'azione.   Esempio:  [\n    'on beforeAction' =  function ($event) {\n        if (some condition) {\n            $event- isValid = false;\n        } else {\n        }\n    },\n]  Si noti che lo stesso evento  beforeAction  viene attivato anche dai moduli e dai controller. Gli oggetti applicativi sono i primi che innescano questo evento, seguito da moduli (se esistono) e infire da controllori. Se settiamo l'evento a  false  tramite il metodo [isValid()] tutti gli eventi successivi non vettanno attivati.  EVENT_AFTER_ACTION  Questo evento viene attivato  dopo  l'esecuzione di ogni azione del controller. Il nome effettivo dell'evento \u00e8  afterAction .\nIl parametro che andremo a settare all'evento \u00e8 un'istanza di  yii \\ base \\ ActionEvent . Attraverso la propriet\u00e0 Yii dell'evento, un gestore di eventi pu\u00f2 accedere o modificare il risultato dell'azione.  Esempio:  [\n    'on afterAction' =  function ($event) {\n        if (some condition) {\n            // modify $event- result\n        } else {\n        }\n    },\n]  Si noti che lo stesso evento  afterAction  viene attivato anche dai moduli e dai controller. Questi oggetti innescano questo evento nell'ordine inverso come per quello del  beforeAction . Cio\u00e8, i controller sono i primi oggetti che innescano questo evento, seguito dai moduli ( ovviamente se esistono )e infine dalle applicazioni.",
            "title": "Eventi dell'applicazione"
        },
        {
            "location": "/application-structure/sub-applications/#ciclo-di-vita-dellapplicazione",
            "text": "Quando viene eseguito uno script di inserimento (entry script) per gestire una richiesta, un'applicazione sar\u00e0 sottoposta al seguente ciclo di vita:   Lo script di inserimento carica la configurazione dell'applicazione come un array.  Lo script di inserimento crea una nuova istanza dell'applicazione:  viene chiamato  preInit() , che configura alcune propriet\u00e0 dell'applicazione al alta priorit\u00e0 ( come per esempio il  basePath );  registrare eventuali errori nel  gestore di errori ;  configurare le propriet\u00e0 dell'applicazione;  viene chiamato  init()  che chiama ulteriormente  bootstrap()  per eseguire questi ultimi componenti.    L'entry script chiama  yii \\ base Application :: run()  per eseguire l'applicazione:  viene attivato l'evento  EVENT_BEFORE_REQUEST ;  viene controllata la richiesta. Viene convertita la richiesta in un percorso con i relativi parametri, viene creato un modulo, i controller e gli oggetti di azione come specificato nel percorso e infine viene eseguita l'azione;  viene attivato l'evento  EVENT_AFTER_REQUEST ;  infine viene inviata una risposta all'utente finale.    L'entry script riceve lo stato di uscita dall'applicazione e completa l'elaborazione delle richieste.",
            "title": "Ciclo di vita dell'applicazione"
        },
        {
            "location": "/application-structure/sub-application-components/",
            "text": "Componenti applicativi\n\n\nLe applicazioni sono localizzatori di servizi. Essi ospitano un insieme di componenti dell'applicazione che forniscono diversi servizi per le richieste di elaborazione. Ad esempio, il componente \nurlManager\n \u00e8 responsabile dell'instradamento delle richieste Web ai vai controller appropriati; il componente \ndb\n fornisce servizi correlati al DB, e cos\u00ec via.\nOgni componente di applicazione ha un ID che lo identifica in modo univoco tra gli altri componenti dell'applicazione. E' possibile accedere ad ogni componente applicativo tramite la seguente espressione:\n\n\n\\Yii::$app-\ncomponentID\n\n\n\nAd esempio, \u00e8 possibile utilizzare \n\\Yii::$app-\ndb\n per ottenere la connessione al DB e \n\\Yii::$app-\ncache\n per ottenere la cache primaria registrata con l'applicazione.\n\n\nUna componente di applicazione viene creata la prima volta che viene acceduto tramite l'espressione indicata in precedenza. Tutti gli altri accsessi restituiranno la stessa istanza di componente.\nI componenti dell'applicazione possono essere oggetti. E' possibile registrarli configurando la propriet\u00e0 \nyii \\ base \\ Application :: $\n nella parte in cui avviene la configurazione della nostra applicazione.\n\n\nEsempio:\n\n\n[\n    'components' =\n [\n        // register \"cache\" component using a class name\n        'cache' =\n 'yii\\caching\\ApcCache',\n\n        // register \"db\" component using a configuration array\n        'db' =\n [\n            'class' =\n 'yii\\db\\Connection',\n            'dsn' =\n 'mysql:host=localhost;dbname=demo',\n            'username' =\n 'root',\n            'password' =\n '',\n        ],\n\n        // register \"search\" component using an anonymous function\n        'search' =\n function () {\n            return new app\\components\\SolrService;\n        },\n    ],\n]\n\n\n\n\n\nInfo\n\n\nMentre \u00e8 possibile registrare quanti componenti voi vogliate, devi fare questo giudizio. I componenti dell'applicazione sono come variabili globali. L'utilizzo di troppi componenti dell'applicazione pu\u00f2 potenzialmente rendere il codice pi\u00f9 difficile da testare. In molti casi, \u00e8 possibile creare una componente locale e utilizzarlo quando necessario.\n\n\n\n\nComponenti di avvio\n\n\nCome accennato in precedenza, una componente dell'applicazione verr\u00e0 istanziata solo quando viene visualizzata la prima volta. Se non \u00e8 affatto accessibile durante una richiesta, non verr\u00e0 istanziata. A volte, per\u00f2 si pu\u00f2 desiderare di creare un'istanza di un componente applicativo per ogni richiesta, anche se non \u00e8 esplicitamente accessibile. A tal fine, \u00e8 possibile elencare l'ID nella propriet\u00e0 d'avvio dell'applicazione.\n\n\nAd esempio, la seguente configurazione dell'applicazione assicura che il componente di \nlog\n sia sempre caricato:\n\n\n[\n    'bootstrap' =\n [\n        'log',\n    ],\n    'components' =\n [\n        'log' =\n [\n            // configuration for \"log\" component\n        ],\n    ],\n]\n\n\n\nComponenti dell'applicazione di base\n\n\nYii definisce un insieme di componenti dell'applicazione \"principali\" con ID fisse e configurazioni predefinite. Ad esempio, la componente di \nrequest(richiesta)\n viene utilizzata per raccogliere informazioni su una richiesta di utente e risolverla in una \nroute(percorso)\n; il componente \ndb\n rappresenta una connessione di database tramite cui \u00e8 possibile eseguire query di database. Con l'aiuto di questi componenti principali, le applicazioni Yii sono in grado di gestire le richieste degli utenti.\nDi seguito viene riportato l'elenco dei componenti predefiniti dell'applicazione di base. Puoi configurarli e personalizzarli come fai con i componenti di applicazione normali. Quando si configura una componente dell'applicazione principale, se non si specifica la classe, verr\u00e0 utilizzato il valore predefinito.\n\n\n\n\nassetManager\n: gestisce i bundle di asset e asset per la pubblicazione di informazioni(publishing);\n\n\ndb\n: rappresenta una connessione di database tramite cui \u00e8 possibile eseguire query DB. Notare che quando si configura questo componente, \u00e8 necessario specificare la classe del componente e altre propriet\u00e0 richieste ( ad esempio ***yii \\ db \\ Connection :: $ dsn);\n\n\nyii \\ base \\ Application :: errorHandler\n: gestisce errori e eccezioni PHP;\n\n\nformatter\n: formatta i dati quando vengono visualizzati agli utenti finali. Ad esempio, una data pu\u00f2 essere formattata in formato long;\n\n\ni18n\n: supporta la traduzione e la formattazione dei messaggi;\n\n\nlog\n: gestisce gli obiettivi di log;\n\n\nmailer\n: supporta la composizione e l'invio di posta;\n\n\nyii \\ base \\ Application :: response\n: rappresenta la risposta inviata agli utenti finali;\n\n\nyii \\ base \\ Application :: request\n: rappresenta la richiesta ricevuta dagli utenti finali;\n\n\nsession(sessione)\n: rappresenta le informazioni sulla sessione. Questo componente \u00e8 disponibile solo nelle applicazioni Web;\n\n\nurlManager\n: supporta l'analisi e la creazione di URL;\n\n\nuser(utente)\n: rappresenta le informazioni di autenticazione utente. Questo componente \u00e8 disponibile solo nelle applicazioni Web;\n\n\nview(vista)\n: supporta la visualizzazione delle view.",
            "title": "Componenti applicativi"
        },
        {
            "location": "/application-structure/sub-application-components/#componenti-applicativi",
            "text": "Le applicazioni sono localizzatori di servizi. Essi ospitano un insieme di componenti dell'applicazione che forniscono diversi servizi per le richieste di elaborazione. Ad esempio, il componente  urlManager  \u00e8 responsabile dell'instradamento delle richieste Web ai vai controller appropriati; il componente  db  fornisce servizi correlati al DB, e cos\u00ec via.\nOgni componente di applicazione ha un ID che lo identifica in modo univoco tra gli altri componenti dell'applicazione. E' possibile accedere ad ogni componente applicativo tramite la seguente espressione:  \\Yii::$app- componentID  Ad esempio, \u00e8 possibile utilizzare  \\Yii::$app- db  per ottenere la connessione al DB e  \\Yii::$app- cache  per ottenere la cache primaria registrata con l'applicazione.  Una componente di applicazione viene creata la prima volta che viene acceduto tramite l'espressione indicata in precedenza. Tutti gli altri accsessi restituiranno la stessa istanza di componente.\nI componenti dell'applicazione possono essere oggetti. E' possibile registrarli configurando la propriet\u00e0  yii \\ base \\ Application :: $  nella parte in cui avviene la configurazione della nostra applicazione.  Esempio:  [\n    'components' =  [\n        // register \"cache\" component using a class name\n        'cache' =  'yii\\caching\\ApcCache',\n\n        // register \"db\" component using a configuration array\n        'db' =  [\n            'class' =  'yii\\db\\Connection',\n            'dsn' =  'mysql:host=localhost;dbname=demo',\n            'username' =  'root',\n            'password' =  '',\n        ],\n\n        // register \"search\" component using an anonymous function\n        'search' =  function () {\n            return new app\\components\\SolrService;\n        },\n    ],\n]   Info  Mentre \u00e8 possibile registrare quanti componenti voi vogliate, devi fare questo giudizio. I componenti dell'applicazione sono come variabili globali. L'utilizzo di troppi componenti dell'applicazione pu\u00f2 potenzialmente rendere il codice pi\u00f9 difficile da testare. In molti casi, \u00e8 possibile creare una componente locale e utilizzarlo quando necessario.",
            "title": "Componenti applicativi"
        },
        {
            "location": "/application-structure/sub-application-components/#componenti-di-avvio",
            "text": "Come accennato in precedenza, una componente dell'applicazione verr\u00e0 istanziata solo quando viene visualizzata la prima volta. Se non \u00e8 affatto accessibile durante una richiesta, non verr\u00e0 istanziata. A volte, per\u00f2 si pu\u00f2 desiderare di creare un'istanza di un componente applicativo per ogni richiesta, anche se non \u00e8 esplicitamente accessibile. A tal fine, \u00e8 possibile elencare l'ID nella propriet\u00e0 d'avvio dell'applicazione.  Ad esempio, la seguente configurazione dell'applicazione assicura che il componente di  log  sia sempre caricato:  [\n    'bootstrap' =  [\n        'log',\n    ],\n    'components' =  [\n        'log' =  [\n            // configuration for \"log\" component\n        ],\n    ],\n]",
            "title": "Componenti di avvio"
        },
        {
            "location": "/application-structure/sub-application-components/#componenti-dellapplicazione-di-base",
            "text": "Yii definisce un insieme di componenti dell'applicazione \"principali\" con ID fisse e configurazioni predefinite. Ad esempio, la componente di  request(richiesta)  viene utilizzata per raccogliere informazioni su una richiesta di utente e risolverla in una  route(percorso) ; il componente  db  rappresenta una connessione di database tramite cui \u00e8 possibile eseguire query di database. Con l'aiuto di questi componenti principali, le applicazioni Yii sono in grado di gestire le richieste degli utenti.\nDi seguito viene riportato l'elenco dei componenti predefiniti dell'applicazione di base. Puoi configurarli e personalizzarli come fai con i componenti di applicazione normali. Quando si configura una componente dell'applicazione principale, se non si specifica la classe, verr\u00e0 utilizzato il valore predefinito.   assetManager : gestisce i bundle di asset e asset per la pubblicazione di informazioni(publishing);  db : rappresenta una connessione di database tramite cui \u00e8 possibile eseguire query DB. Notare che quando si configura questo componente, \u00e8 necessario specificare la classe del componente e altre propriet\u00e0 richieste ( ad esempio ***yii \\ db \\ Connection :: $ dsn);  yii \\ base \\ Application :: errorHandler : gestisce errori e eccezioni PHP;  formatter : formatta i dati quando vengono visualizzati agli utenti finali. Ad esempio, una data pu\u00f2 essere formattata in formato long;  i18n : supporta la traduzione e la formattazione dei messaggi;  log : gestisce gli obiettivi di log;  mailer : supporta la composizione e l'invio di posta;  yii \\ base \\ Application :: response : rappresenta la risposta inviata agli utenti finali;  yii \\ base \\ Application :: request : rappresenta la richiesta ricevuta dagli utenti finali;  session(sessione) : rappresenta le informazioni sulla sessione. Questo componente \u00e8 disponibile solo nelle applicazioni Web;  urlManager : supporta l'analisi e la creazione di URL;  user(utente) : rappresenta le informazioni di autenticazione utente. Questo componente \u00e8 disponibile solo nelle applicazioni Web;  view(vista) : supporta la visualizzazione delle view.",
            "title": "Componenti dell'applicazione di base"
        },
        {
            "location": "/application-structure/sub-controllers/",
            "text": "Controllori  (Controllers)\n\n\nI controllori(controller) sono parte dell'architettura MVC. Sono oggetti di classi che si estendono da \nyii \\ base \\ Controller\n e sono responsabili delle richieste di elaborazione e della generazione di risposte. In particolare, dopo aver assunto il controllo delle applicazioni, i controller analizzeranno i dati ricevuti dalla richieste in entrata, li passano ai modelli, iniettano i risultati dei modelli nelle viste(view) e, infine, generano risposte in uscita.\n\n\nAzioni\n\n\nI controller sono composti da azioni che sono le unit\u00e0 pi\u00f9 semplici che gli utenti finali possono richiederne l'esecuzione. Un controller pu\u00f2 avere una o pi\u00f9 azioni.\nL'esempio seguente mostra un controller \npost\n con due azioni: azione di vista ( \nview\n) e azione di creazione ( \ncreate\n):\n\n\nnamespace app\\controllers;\n\nuse Yii;\nuse app\\models\\Post;\nuse yii\\web\\Controller;\nuse yii\\web\\NotFoundHttpException;\n\nclass PostController extends Controller{\n    public function actionView($id){\n        $model = Post::findOne($id);\n        if ($model === null) {\n            throw new NotFoundHttpException;\n        }\n\n        return $this-\nrender('view', [\n            'model' =\n $model,\n        ]);\n    }\n\n    public function actionCreate(){\n        $model = new Post;\n\n        if ($model-\nload(Yii::$app-\nrequest-\npost()) \n $model-\nsave()) {\n            return $this-\nredirect(['view', 'id' =\n $model-\nid]);\n        } else {\n            return $this-\nrender('create', [\n                'model' =\n $model,\n            ]);\n        }\n    }\n}\n\n\n\nNell'azione di vista( definita dal metodo \nactionView()\n),carica il modello secondo l'ID del modello richiesto. Se il modello viene caricato correttamente, lo visualizzer\u00e0 utilizzando un vista denominata \nview\n. Altrimenti verr\u00e0 lanciata un'eccezione.\n\n\nNell'azione di creazione( definita dal metodo \nactionCreate()\n), carica il modello secondo l'ID del modello richiesto. In primo luogo cerca di popolare una nuova istanza del modello utilizzando i dati di richiesta e salvarli all'interno del modello. Se entrambe le azioni avvengono con successo, reindirizzer\u00e0 il browser all'azione \nview\n con l'ID del modello appena creato. Altrimenti verr\u00e0 visualizzata la vista di creazione (\ncreate\n) attraverso la quale gli utenti possono fornire l'input necessario.\n\n\nItinerari\n\n\nGli utenti finali gestiscono le azioni attraverso i percorsi. Un percorso \u00e8 una stringa che consiste nelle seguenti parti:\n\n\n\n\nun modulo ID: questo esiste solo se il controller appartiene a un modulo non applicativo;\n\n\nun controller ID: una stringa che identifica in modo univoco il controller tra tutti i controller della stessa applicazione;\n\n\nun ID d'azione: una stringa che identifica in modo univoco l'azione tra tutte le azioni all'interno dello stesso controller.\n\n\n\n\nI percorsi hanno il seguente formato:\n\n\nControllerID/ActionID\n\n\n\noppure il seguente formato se il controller appartiene a un modulo:\n\n\nModuleID/ControllerID/ActionID\n\n\n\nQuindi, se un utente possa richiedere il seguente URL (http://hostname/index.php?r=site/index), verr\u00e0 eseguita l'azione di \nindex\n nel controller del \nsite\n.\n\n\nCreazione di un controller\n\n\nNelle applicazioni Web, i controller devono estendere \nyii \\ web \\ Controller\n. Analogamente nelle applicazioni console,i controller devono estendersi da \nyii \\ web \\ Controller\n. Il seguente codice definisce un controller \nsite\n.\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n}\n\n\n\nDi solito, un controllore \u00e8 progettato per gestire le richieste relative a un particolare tipo di risorsa. Per questo motivo, gli ID controller sono spesso nomi che si riferiscono ai tipi delle risorse che gestiscono. Ad esempio, \u00e8 possibile utilizzare \narticle\n come ID di un controller che gestisce i dati dell'articolo.\n\n\nPer impostazione predefinita, gli ID controller devono contenere solo questi caratteri: lettere minuscole, cifre, sottolineature, trattini e barre in avanti. Ad esempio, \narticle\n e \npost-comment\n sono entrambi ID controller validi, mentre \narticle?\n,\nPostComment\n,\nadmin\\post\n non lo sono.\n\n\nUn ID controller pu\u00f2 anche contenere un prefisso della sotto-directory. Ad esempio, \nadmin/article\n sta per un controller \narticle\n nella sotto-directory \nadmin\n sotto lo spazio dei nomi del controller. I caratteri validi per i prefissi della sotto-directory includono: lettere maiuscole o minuscole, cifre, sottolineature, trattini, ect.\n\n\nNome del codice dei controller\n\n\nI nomi delle classi di controller possono essere derivati da un ID controller secondo la seguente procedura:\n\n\n\n\nruotare la prima lettera in ogni parola separata da trattini in maiuscolo. Notare che se l'ID del controller contiene barre di scorrimento, questa regola si applica solo alla parte dopo l'ultima barra dell'ID;\n\n\nrimuovere i trattini e sostituire gli \"slash\" con i \"backslash\".\n\n\naggiungi il suffisso \nController\n.\n\n\nprendere il namespace del controller.\n\n\n\n\nDi seguito sono riportati alcuni esempi, supponendo che i namespace dei controller prendano il valore predefinito \napp\\controllers\n:\n\n\n\n\narticle\n diventa \napp\\controllers\\ArticleController\n;\n\n\npost-comment\n diventa \napp\\controllers\\PostCommentController\n;\n\n\nadmin/post-comment\n diventa \napp\\controllers\\admin\\PostCommentController\n;\n\n\nadminPanels/post-comment\n diventa \napp\\controllers\\adminPanels\\PostCommentController\n.\n\n\n\n\nLe classi del controllore devono essere \nautoloadable\n. Per questo motivo, negli esempi precedenti, la classe controller \narticle\n dovrebbe essere salvata dove lo pseudonimo \u00e8 \n@app/controllers/ArticleController.php\n; mentre il controller \nadmin/post-comment\n dovrebbero essere in \n@app/controllers/admin/PostCommentController.php\n.\n\n\n\n\nInfo\n\n\nL'ultimo esempio \nadmin/post-comment\n mostra come \u00e8 possibile inserire un controller sotto una sotto-directory del namespace del controller. Questo \u00e8 utile quando si desidera organizzare i controller in pi\u00f9 categorie e non si desidera utilizzare i moduli.\n\n\n\n\nMappa dei controller\n\n\nE' possibile configurare la mappa del controller per superare i vincoli degli ID del controller e dei nomi di classe descritti in precedenza. Ci\u00f2 \u00e8 principalmente utile quando si utilizzano controllori di terze parti e non si ha il controllo sui nomi delle classi.\nE' possibile configurare la mappa dei controller nella configurazione dell'applicazione.\n\n\nEsempio:\n\n\n[\n    'controllerMap' =\n [\n        // declares \"account\" controller using a class name\n        'account' =\n 'app\\controllers\\UserController',\n\n        // declares \"article\" controller using a configuration array\n        'article' =\n [\n            'class' =\n 'app\\controllers\\PostController',\n            'enableCsrfValidation' =\n false,\n        ],\n    ],\n]\n\n\n\nController di default\n\n\nOgni applicazione dispone di un controller predefinito specificato tramite la propriet\u00e0 \nyii \\ base \\ Application :: $ defaultRoute\n. Quando una richiesta non specifica un percorso, verr\u00e0 utilizzato il percorso specificato da questa propriet\u00e0. Per le applicazioni Web, il suo valore \u00e8 \nsite\n, mentre per le applicazioni tramite console \u00e8 \nhelp\n.\nE' possibile modificare il controller di default con la seguente configurazione dell'applicazione:\n\n\n[\n    'defaultRoute' =\n 'main',\n]\n\n\n\nCreazione delle azioni\n\n\nLa creazione delle azioni \u00e8 semplice, come definite i cosiddetti \"metodi di azione\" in una classe controller. Un metodo di azione \u00e8 un metodo \"pubblico\" il nome inizia con un \naction\n. Il valore restituito da un metodo di azione rappresenta i dati di risposta che dovranno essere inviati poi all'utente finale. Il seguente codice definisce due azioni: l'azione \nindex\n e l'azione \nhello-world\n:\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public function actionIndex(){\n\n        return $this-\nrender('index');\n\n    }\n    public function actionHelloWorld(){\n\n        return 'Hello World';\n\n    }\n}\n\n\n\nID dell'azione\n\n\nUn'azione \u00e8 spesso progettata per eseguire una particolare manipolazione di una risorsa. Per questo motivo, gli ID dell'azione sono solitamente verbi ( come per esempio \nview\n, \nupdate\n, ect..).\n\n\nPer impostazione predefinita, l'ID dell'azione deve contenere solo questi caratteri: lettere minuscole,cifre,sottolineature,e trattini. Ad esempio, \nview\n,\nupdate2\n, e \ncomment-post\n sono tutti ID di azioni valide, mentre \nview?\n e \nUpdate\n non lo sono.\n\n\nE' possibile creare azioni in due modi: azioni in linea e azioni autonome. Un'azione inline \u00e8 definita come un metodo della classe controller, mentre un'azione autonoma \u00e8 una classe che estende \n yii \\ base \\ Action \n o le sue classi figlio. Le azioni in linea sono pi\u00f9 veloci e semplici da creare e sono spesso preferite se non si intende riutilizzarle. Le azioni autonome invece sono principalmente create per essere utilizzate in diversi controller o essere ridistribuite come estensioni.\n\n\nAzioni in linea (inline)\n\n\nI nomi dei metodi di azione sono derivati dal proprio ID secondo la seguente procedura:\n1. Ruotare la prima lettera in ogni parola dell'ID dell'azione in caso di maiuscolo.\n2. Rimuovere i trattini.\n3. Usare il prefisso \naction\n.\n\n\nAd esempio \nindex\n diventa \nactonIndex\n e \nhello-world\n diventa \nactionHelloWorld\n.\n\n\n\n\nWarning\n\n\nI nomi dei metodi d'azione sono sensibili alla distinzione tra minuscole e maiuscole. Se si dispone di un metodo denominato \nActionIndex\n, non verr\u00e0 considerato come un metodo di azione e pertanto la richiesta per l'azione \nindex\n provocher\u00e0 un'eccezione. Si noti inoltre che i metodi d'azione devono essere pubblici. Un metodo provato o privato \nNON\n definisce un'azione in linea.\n\n\n\n\nAzioni autonome (standalone)\n\n\nPer utilizzare un'azione autonoma, devi dichiararla nella mappa d'azione prevenendo il metodo \n yii \\ base \\ Controller :: actions() \n nelle classi di controllo, come nel seguente esempio:\n\n\npublic function actions(){\n\n    return [\n        // declares \"error\" action using a class name\n        'error' =\n 'yii\\web\\ErrorAction',\n\n        // declares \"view\" action using a configuration array\n        'view' =\n [\n            'class' =\n 'yii\\web\\ViewAction',\n            'viewPrefix' =\n '',\n        ],\n    ];\n}\n\n\n\nCome si pu\u00f2 vedere, il metodo \nactions()\n dovrebbe restituire un array dove i valori sono l'ID delle azioni e il loro nome. A differenza delle azioni in linea, gli ID di azione per azioni autonome possono contenere caratteri arbitrari, a condizione che siano dichiarati nel metodo \nactions()\n.\n\n\nPer creare una classe di azioni autonome, \u00e8 necessario estendere \n yii \\ base \\ Action \n o una sua classe figlia, e implementare un metodo denominato \nrun()\n.\n\n\n?php\nnamespace app\\components;\n\nuse yii\\base\\Action;\n\nclass HelloWorldAction extends Action{\n\n    public function run(){\n\n        return \"Hello World\";\n    }\n}\n\n\n\nRisultati dell'azione\n\n\nIl valore restituito da un metodo di azione ( o del metodo \nrun()\n) \u00e8 molto significativo. Questo valore pu\u00f2 essere un oggetto di risposta che verr\u00e0 inviato all'utente finale come risposta.\n\n\n\n\nPer applicazioni Web, il valore di ritorno pu\u00f2 essere anche un dato arbitrario che verr\u00e0 assegnato ai dati di \n yii \\ web \\ Response :: $ \n e deve essere ulteriormente convertito in una stringa che rappresenta il corpo della risposta.\n\n\nPer le applicazioni tramite console, il valore di ritorno pu\u00f2 anche essere un intero che rappresenta lo stato di uscita dell'esecuzione del comando.\n\n\n\n\nNegli esempi mostrati sopra, i risultati dell'azione sono tutte stringhe che saranno trattate come il corpo di risposta da inviare all'utente finale.\nIl seguente esempio vi mostra come un'azione pu\u00f2 reindirizzare il browser a un nuovo URL restituendo un oggetto di risposta ( perch\u00e8 il metodo \nredirect()\n restituisce un oggetto in risposta).\n\n\npublic function actionForward(){\n\n    // redirect the user browser to http://example.com\n    return $this-\nredirect('http://example.com');\n}\n\n\n\nParametri dell'azione\n\n\nI metodi di azione delle azioni in linea, dei metodi \nrun()\n, e per le azioni autonome possono assumere parametri, chiamati \n parametri d'azione \n. I loro valori sono ottenuti dalle richieste che vengono effettuate. Per le applicazioni Web, viene richiamato il valore di ogni parametro d'azione\n$_GET\n pi\u00f9 il nome del parametro come chiave, mentre per le applicazioni tramite console, questi parametri corrispondono agli argomenti della riga di comando.\n\n\nNell'esempio seguente, l'azione \nview\n ( azione in linea ) ha dichiarato due parametri: \n$id\n e \n$version\n.\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    public function actionView($id, $version = null){\n\n        // ...\n    }\n}\n\n\n\nI parametri della nostra azione saranno popolati come segue per le possibili richieste che possiamo effettuare:\n- \nhttp://hostname/index.php?r=post/view\nid=123\n: il parametro \n$id\n verr\u00e0 compilato con il valore \n123\n, mentre \n$version\n \u00e8 ancora \nnull\n perch\u00e8 non esiste alcun parametro di query \nversion\n.\n- \nhttp://hostname/index.php?r=post/view\nid=123\nversion=2\n: I due parametri \n$id\n e \n$version\n sono riempiti con i valori di \n123\n e \n2\n.\n- \nhttp://hostname/index.php?r=post/view\n: viene generata un'eccezione perch\u00e8 il parametro \n$id\n richiesto non \u00e8 fornito nella richiesta.\n- \nhttp://hostname/index.php?r=post/view\nid[]=123\n: verr\u00e0 generata anche qu\u00ec un'eccezione perch\u00e8 il parametro \n$id\n riceve un valore di array inaspettato, come \n['123']\n.\n\n\nSe desideriamo che un parametro di azione possa accettare valori come matrice,array, e necessario distinguerlo come segue:\n\n\npublic function actionView(array $id, $version = null){\n\n    // ...\n}\n\n\n\nOra se la richiesta fosse \nhttp://hostname/index.php?r=post/view\nid[]=123\n, il parametro \n$id\n prender\u00e0 il valore di \n['123']\n. Se la richiesta fosse \nhttp://hostname/index.php?r=post/view\nid=123\n il parametro \n$id\n ricever\u00e0 ancora lo stesso valore dell'array perch\u00e8 il valore scalare \n'123'\n verr\u00e0 auomtaticamente trasformato in array.\nGli esempi precedenti mostrano principalmente come funzionano i parametri d'azione per le applicazioni Web.\n\n\nAzioni predefinite\n\n\nOgni controller ha un'azione predefinita specificata tramite la propriet\u00e0 \n yii \\ base \\ Controller :: $defaultAction \n. Quando un percorso contiene solo il controller ID, significa che viene richiesta l'azione predefinita del controller specificato.\nPer impostazione predefinita, questa azione \u00e8 impostata come \nindex\n. Se si desidera modificare il valore predefinito, vi baster\u00e0 sovrascrivere questa propriet\u00e0 nella classe controller, come segue nell'esempio:\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public $defaultAction = 'home';\n\n    public function actionHome(){\n\n        return $this-\nrender('home');\n    }\n}\n\n\n\nCiclo di vita del controllore\n\n\nQuando si elabora una richiesta, un'applicazione creer\u00e0 un controller di base al percorso richiesto. Il controllore sar\u00e0 sottoposto al seguente ciclo di vita per soddisfare la richiesta:\n\n\n\n\nIl metodo \n yii \\ base \\ Controller :: init() \n viene chiamato dopo che il controller viene creato e configurato.\n\n\nIl controller crea un oggetto di azione in base all'ID dell'azione richiesta:\n\n\nSe l'ID dell'azione non \u00e8 specificato, verr\u00e0 utilizzato l'ID dell'azione predefinita.\n\n\nSe l'ID dell'azione si trova nella mappa d'azione, verr\u00e0 creata un'azione autonoma.\n\n\nSe l'ID dell'azione \u00e8 il risultato corrispondente a un metodo d'azione, verr\u00e0 creata una nuova azione in linea;\n\n\nIn caso contrario verr\u00e0 generata un'eccezione.\n\n\n\n\n\n\nIl controllore chiama sequenzialmente il metodo \nbeforeAction()\n  dell'applicazione.\n\n\nSe una delle chiamate restituisce \nfalse\n, il resto dei metodi \nbeforeAction()\n non chiamati verranno ignorati e l'esecuzione dell'azione verr\u00e0 annullata.\n\n\nPer impostazione predefinita, ogni chiamata del metodo \nbeforeAction()\n innescher\u00e0 un evento \nbeforeAction\n a cui \u00e8 possibile associare un gestore.\n\n\n\n\n\n\nIl controllore esegue l'azione.\n\n\nI parametri dell'azione saranno analizzati e popolati dai dati di richiesta.\n\n\n\n\n\n\nIl controllore chiama sequenzialmente il metodo del controller \nafterAction()\n.\n\n\nPer impostazione predefinita, ogni chiamata del metodo \nafterAction()\n innescher\u00e0 un evento \nafterAction\n a cui \u00e8 possibile associare un gestore.\n\n\n\n\n\n\nL'applicazione prender\u00e0 il risultato dell'azione e lo assegner\u00e0 alla risposta.",
            "title": "Controllori"
        },
        {
            "location": "/application-structure/sub-controllers/#controllori-controllers",
            "text": "I controllori(controller) sono parte dell'architettura MVC. Sono oggetti di classi che si estendono da  yii \\ base \\ Controller  e sono responsabili delle richieste di elaborazione e della generazione di risposte. In particolare, dopo aver assunto il controllo delle applicazioni, i controller analizzeranno i dati ricevuti dalla richieste in entrata, li passano ai modelli, iniettano i risultati dei modelli nelle viste(view) e, infine, generano risposte in uscita.",
            "title": "Controllori  (Controllers)"
        },
        {
            "location": "/application-structure/sub-controllers/#azioni",
            "text": "I controller sono composti da azioni che sono le unit\u00e0 pi\u00f9 semplici che gli utenti finali possono richiederne l'esecuzione. Un controller pu\u00f2 avere una o pi\u00f9 azioni.\nL'esempio seguente mostra un controller  post  con due azioni: azione di vista (  view ) e azione di creazione (  create ):  namespace app\\controllers;\n\nuse Yii;\nuse app\\models\\Post;\nuse yii\\web\\Controller;\nuse yii\\web\\NotFoundHttpException;\n\nclass PostController extends Controller{\n    public function actionView($id){\n        $model = Post::findOne($id);\n        if ($model === null) {\n            throw new NotFoundHttpException;\n        }\n\n        return $this- render('view', [\n            'model' =  $model,\n        ]);\n    }\n\n    public function actionCreate(){\n        $model = new Post;\n\n        if ($model- load(Yii::$app- request- post())   $model- save()) {\n            return $this- redirect(['view', 'id' =  $model- id]);\n        } else {\n            return $this- render('create', [\n                'model' =  $model,\n            ]);\n        }\n    }\n}  Nell'azione di vista( definita dal metodo  actionView() ),carica il modello secondo l'ID del modello richiesto. Se il modello viene caricato correttamente, lo visualizzer\u00e0 utilizzando un vista denominata  view . Altrimenti verr\u00e0 lanciata un'eccezione.  Nell'azione di creazione( definita dal metodo  actionCreate() ), carica il modello secondo l'ID del modello richiesto. In primo luogo cerca di popolare una nuova istanza del modello utilizzando i dati di richiesta e salvarli all'interno del modello. Se entrambe le azioni avvengono con successo, reindirizzer\u00e0 il browser all'azione  view  con l'ID del modello appena creato. Altrimenti verr\u00e0 visualizzata la vista di creazione ( create ) attraverso la quale gli utenti possono fornire l'input necessario.",
            "title": "Azioni"
        },
        {
            "location": "/application-structure/sub-controllers/#itinerari",
            "text": "Gli utenti finali gestiscono le azioni attraverso i percorsi. Un percorso \u00e8 una stringa che consiste nelle seguenti parti:   un modulo ID: questo esiste solo se il controller appartiene a un modulo non applicativo;  un controller ID: una stringa che identifica in modo univoco il controller tra tutti i controller della stessa applicazione;  un ID d'azione: una stringa che identifica in modo univoco l'azione tra tutte le azioni all'interno dello stesso controller.   I percorsi hanno il seguente formato:  ControllerID/ActionID  oppure il seguente formato se il controller appartiene a un modulo:  ModuleID/ControllerID/ActionID  Quindi, se un utente possa richiedere il seguente URL (http://hostname/index.php?r=site/index), verr\u00e0 eseguita l'azione di  index  nel controller del  site .",
            "title": "Itinerari"
        },
        {
            "location": "/application-structure/sub-controllers/#creazione-di-un-controller",
            "text": "Nelle applicazioni Web, i controller devono estendere  yii \\ web \\ Controller . Analogamente nelle applicazioni console,i controller devono estendersi da  yii \\ web \\ Controller . Il seguente codice definisce un controller  site .  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n}  Di solito, un controllore \u00e8 progettato per gestire le richieste relative a un particolare tipo di risorsa. Per questo motivo, gli ID controller sono spesso nomi che si riferiscono ai tipi delle risorse che gestiscono. Ad esempio, \u00e8 possibile utilizzare  article  come ID di un controller che gestisce i dati dell'articolo.  Per impostazione predefinita, gli ID controller devono contenere solo questi caratteri: lettere minuscole, cifre, sottolineature, trattini e barre in avanti. Ad esempio,  article  e  post-comment  sono entrambi ID controller validi, mentre  article? , PostComment , admin\\post  non lo sono.  Un ID controller pu\u00f2 anche contenere un prefisso della sotto-directory. Ad esempio,  admin/article  sta per un controller  article  nella sotto-directory  admin  sotto lo spazio dei nomi del controller. I caratteri validi per i prefissi della sotto-directory includono: lettere maiuscole o minuscole, cifre, sottolineature, trattini, ect.",
            "title": "Creazione di un controller"
        },
        {
            "location": "/application-structure/sub-controllers/#nome-del-codice-dei-controller",
            "text": "I nomi delle classi di controller possono essere derivati da un ID controller secondo la seguente procedura:   ruotare la prima lettera in ogni parola separata da trattini in maiuscolo. Notare che se l'ID del controller contiene barre di scorrimento, questa regola si applica solo alla parte dopo l'ultima barra dell'ID;  rimuovere i trattini e sostituire gli \"slash\" con i \"backslash\".  aggiungi il suffisso  Controller .  prendere il namespace del controller.   Di seguito sono riportati alcuni esempi, supponendo che i namespace dei controller prendano il valore predefinito  app\\controllers :   article  diventa  app\\controllers\\ArticleController ;  post-comment  diventa  app\\controllers\\PostCommentController ;  admin/post-comment  diventa  app\\controllers\\admin\\PostCommentController ;  adminPanels/post-comment  diventa  app\\controllers\\adminPanels\\PostCommentController .   Le classi del controllore devono essere  autoloadable . Per questo motivo, negli esempi precedenti, la classe controller  article  dovrebbe essere salvata dove lo pseudonimo \u00e8  @app/controllers/ArticleController.php ; mentre il controller  admin/post-comment  dovrebbero essere in  @app/controllers/admin/PostCommentController.php .   Info  L'ultimo esempio  admin/post-comment  mostra come \u00e8 possibile inserire un controller sotto una sotto-directory del namespace del controller. Questo \u00e8 utile quando si desidera organizzare i controller in pi\u00f9 categorie e non si desidera utilizzare i moduli.",
            "title": "Nome del codice dei controller"
        },
        {
            "location": "/application-structure/sub-controllers/#mappa-dei-controller",
            "text": "E' possibile configurare la mappa del controller per superare i vincoli degli ID del controller e dei nomi di classe descritti in precedenza. Ci\u00f2 \u00e8 principalmente utile quando si utilizzano controllori di terze parti e non si ha il controllo sui nomi delle classi.\nE' possibile configurare la mappa dei controller nella configurazione dell'applicazione.  Esempio:  [\n    'controllerMap' =  [\n        // declares \"account\" controller using a class name\n        'account' =  'app\\controllers\\UserController',\n\n        // declares \"article\" controller using a configuration array\n        'article' =  [\n            'class' =  'app\\controllers\\PostController',\n            'enableCsrfValidation' =  false,\n        ],\n    ],\n]",
            "title": "Mappa dei controller"
        },
        {
            "location": "/application-structure/sub-controllers/#controller-di-default",
            "text": "Ogni applicazione dispone di un controller predefinito specificato tramite la propriet\u00e0  yii \\ base \\ Application :: $ defaultRoute . Quando una richiesta non specifica un percorso, verr\u00e0 utilizzato il percorso specificato da questa propriet\u00e0. Per le applicazioni Web, il suo valore \u00e8  site , mentre per le applicazioni tramite console \u00e8  help .\nE' possibile modificare il controller di default con la seguente configurazione dell'applicazione:  [\n    'defaultRoute' =  'main',\n]",
            "title": "Controller di default"
        },
        {
            "location": "/application-structure/sub-controllers/#creazione-delle-azioni",
            "text": "La creazione delle azioni \u00e8 semplice, come definite i cosiddetti \"metodi di azione\" in una classe controller. Un metodo di azione \u00e8 un metodo \"pubblico\" il nome inizia con un  action . Il valore restituito da un metodo di azione rappresenta i dati di risposta che dovranno essere inviati poi all'utente finale. Il seguente codice definisce due azioni: l'azione  index  e l'azione  hello-world :  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public function actionIndex(){\n\n        return $this- render('index');\n\n    }\n    public function actionHelloWorld(){\n\n        return 'Hello World';\n\n    }\n}",
            "title": "Creazione delle azioni"
        },
        {
            "location": "/application-structure/sub-controllers/#id-dellazione",
            "text": "Un'azione \u00e8 spesso progettata per eseguire una particolare manipolazione di una risorsa. Per questo motivo, gli ID dell'azione sono solitamente verbi ( come per esempio  view ,  update , ect..).  Per impostazione predefinita, l'ID dell'azione deve contenere solo questi caratteri: lettere minuscole,cifre,sottolineature,e trattini. Ad esempio,  view , update2 , e  comment-post  sono tutti ID di azioni valide, mentre  view?  e  Update  non lo sono.  E' possibile creare azioni in due modi: azioni in linea e azioni autonome. Un'azione inline \u00e8 definita come un metodo della classe controller, mentre un'azione autonoma \u00e8 una classe che estende   yii \\ base \\ Action   o le sue classi figlio. Le azioni in linea sono pi\u00f9 veloci e semplici da creare e sono spesso preferite se non si intende riutilizzarle. Le azioni autonome invece sono principalmente create per essere utilizzate in diversi controller o essere ridistribuite come estensioni.",
            "title": "ID dell'azione"
        },
        {
            "location": "/application-structure/sub-controllers/#azioni-in-linea-inline",
            "text": "I nomi dei metodi di azione sono derivati dal proprio ID secondo la seguente procedura:\n1. Ruotare la prima lettera in ogni parola dell'ID dell'azione in caso di maiuscolo.\n2. Rimuovere i trattini.\n3. Usare il prefisso  action .  Ad esempio  index  diventa  actonIndex  e  hello-world  diventa  actionHelloWorld .   Warning  I nomi dei metodi d'azione sono sensibili alla distinzione tra minuscole e maiuscole. Se si dispone di un metodo denominato  ActionIndex , non verr\u00e0 considerato come un metodo di azione e pertanto la richiesta per l'azione  index  provocher\u00e0 un'eccezione. Si noti inoltre che i metodi d'azione devono essere pubblici. Un metodo provato o privato  NON  definisce un'azione in linea.",
            "title": "Azioni in linea (inline)"
        },
        {
            "location": "/application-structure/sub-controllers/#azioni-autonome-standalone",
            "text": "Per utilizzare un'azione autonoma, devi dichiararla nella mappa d'azione prevenendo il metodo   yii \\ base \\ Controller :: actions()   nelle classi di controllo, come nel seguente esempio:  public function actions(){\n\n    return [\n        // declares \"error\" action using a class name\n        'error' =  'yii\\web\\ErrorAction',\n\n        // declares \"view\" action using a configuration array\n        'view' =  [\n            'class' =  'yii\\web\\ViewAction',\n            'viewPrefix' =  '',\n        ],\n    ];\n}  Come si pu\u00f2 vedere, il metodo  actions()  dovrebbe restituire un array dove i valori sono l'ID delle azioni e il loro nome. A differenza delle azioni in linea, gli ID di azione per azioni autonome possono contenere caratteri arbitrari, a condizione che siano dichiarati nel metodo  actions() .  Per creare una classe di azioni autonome, \u00e8 necessario estendere   yii \\ base \\ Action   o una sua classe figlia, e implementare un metodo denominato  run() .  ?php\nnamespace app\\components;\n\nuse yii\\base\\Action;\n\nclass HelloWorldAction extends Action{\n\n    public function run(){\n\n        return \"Hello World\";\n    }\n}",
            "title": "Azioni autonome (standalone)"
        },
        {
            "location": "/application-structure/sub-controllers/#risultati-dellazione",
            "text": "Il valore restituito da un metodo di azione ( o del metodo  run() ) \u00e8 molto significativo. Questo valore pu\u00f2 essere un oggetto di risposta che verr\u00e0 inviato all'utente finale come risposta.   Per applicazioni Web, il valore di ritorno pu\u00f2 essere anche un dato arbitrario che verr\u00e0 assegnato ai dati di   yii \\ web \\ Response :: $   e deve essere ulteriormente convertito in una stringa che rappresenta il corpo della risposta.  Per le applicazioni tramite console, il valore di ritorno pu\u00f2 anche essere un intero che rappresenta lo stato di uscita dell'esecuzione del comando.   Negli esempi mostrati sopra, i risultati dell'azione sono tutte stringhe che saranno trattate come il corpo di risposta da inviare all'utente finale.\nIl seguente esempio vi mostra come un'azione pu\u00f2 reindirizzare il browser a un nuovo URL restituendo un oggetto di risposta ( perch\u00e8 il metodo  redirect()  restituisce un oggetto in risposta).  public function actionForward(){\n\n    // redirect the user browser to http://example.com\n    return $this- redirect('http://example.com');\n}",
            "title": "Risultati dell'azione"
        },
        {
            "location": "/application-structure/sub-controllers/#parametri-dellazione",
            "text": "I metodi di azione delle azioni in linea, dei metodi  run() , e per le azioni autonome possono assumere parametri, chiamati   parametri d'azione  . I loro valori sono ottenuti dalle richieste che vengono effettuate. Per le applicazioni Web, viene richiamato il valore di ogni parametro d'azione $_GET  pi\u00f9 il nome del parametro come chiave, mentre per le applicazioni tramite console, questi parametri corrispondono agli argomenti della riga di comando.  Nell'esempio seguente, l'azione  view  ( azione in linea ) ha dichiarato due parametri:  $id  e  $version .  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    public function actionView($id, $version = null){\n\n        // ...\n    }\n}  I parametri della nostra azione saranno popolati come segue per le possibili richieste che possiamo effettuare:\n-  http://hostname/index.php?r=post/view id=123 : il parametro  $id  verr\u00e0 compilato con il valore  123 , mentre  $version  \u00e8 ancora  null  perch\u00e8 non esiste alcun parametro di query  version .\n-  http://hostname/index.php?r=post/view id=123 version=2 : I due parametri  $id  e  $version  sono riempiti con i valori di  123  e  2 .\n-  http://hostname/index.php?r=post/view : viene generata un'eccezione perch\u00e8 il parametro  $id  richiesto non \u00e8 fornito nella richiesta.\n-  http://hostname/index.php?r=post/view id[]=123 : verr\u00e0 generata anche qu\u00ec un'eccezione perch\u00e8 il parametro  $id  riceve un valore di array inaspettato, come  ['123'] .  Se desideriamo che un parametro di azione possa accettare valori come matrice,array, e necessario distinguerlo come segue:  public function actionView(array $id, $version = null){\n\n    // ...\n}  Ora se la richiesta fosse  http://hostname/index.php?r=post/view id[]=123 , il parametro  $id  prender\u00e0 il valore di  ['123'] . Se la richiesta fosse  http://hostname/index.php?r=post/view id=123  il parametro  $id  ricever\u00e0 ancora lo stesso valore dell'array perch\u00e8 il valore scalare  '123'  verr\u00e0 auomtaticamente trasformato in array.\nGli esempi precedenti mostrano principalmente come funzionano i parametri d'azione per le applicazioni Web.",
            "title": "Parametri dell'azione"
        },
        {
            "location": "/application-structure/sub-controllers/#azioni-predefinite",
            "text": "Ogni controller ha un'azione predefinita specificata tramite la propriet\u00e0   yii \\ base \\ Controller :: $defaultAction  . Quando un percorso contiene solo il controller ID, significa che viene richiesta l'azione predefinita del controller specificato.\nPer impostazione predefinita, questa azione \u00e8 impostata come  index . Se si desidera modificare il valore predefinito, vi baster\u00e0 sovrascrivere questa propriet\u00e0 nella classe controller, come segue nell'esempio:  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public $defaultAction = 'home';\n\n    public function actionHome(){\n\n        return $this- render('home');\n    }\n}",
            "title": "Azioni predefinite"
        },
        {
            "location": "/application-structure/sub-controllers/#ciclo-di-vita-del-controllore",
            "text": "Quando si elabora una richiesta, un'applicazione creer\u00e0 un controller di base al percorso richiesto. Il controllore sar\u00e0 sottoposto al seguente ciclo di vita per soddisfare la richiesta:   Il metodo   yii \\ base \\ Controller :: init()   viene chiamato dopo che il controller viene creato e configurato.  Il controller crea un oggetto di azione in base all'ID dell'azione richiesta:  Se l'ID dell'azione non \u00e8 specificato, verr\u00e0 utilizzato l'ID dell'azione predefinita.  Se l'ID dell'azione si trova nella mappa d'azione, verr\u00e0 creata un'azione autonoma.  Se l'ID dell'azione \u00e8 il risultato corrispondente a un metodo d'azione, verr\u00e0 creata una nuova azione in linea;  In caso contrario verr\u00e0 generata un'eccezione.    Il controllore chiama sequenzialmente il metodo  beforeAction()   dell'applicazione.  Se una delle chiamate restituisce  false , il resto dei metodi  beforeAction()  non chiamati verranno ignorati e l'esecuzione dell'azione verr\u00e0 annullata.  Per impostazione predefinita, ogni chiamata del metodo  beforeAction()  innescher\u00e0 un evento  beforeAction  a cui \u00e8 possibile associare un gestore.    Il controllore esegue l'azione.  I parametri dell'azione saranno analizzati e popolati dai dati di richiesta.    Il controllore chiama sequenzialmente il metodo del controller  afterAction() .  Per impostazione predefinita, ogni chiamata del metodo  afterAction()  innescher\u00e0 un evento  afterAction  a cui \u00e8 possibile associare un gestore.    L'applicazione prender\u00e0 il risultato dell'azione e lo assegner\u00e0 alla risposta.",
            "title": "Ciclo di vita del controllore"
        },
        {
            "location": "/application-structure/sub-models/",
            "text": "Modelli  (Models)\n\n\nI modelli sono parte dell'architettura MVC. Sono oggetti che rappresentano dati aziendali, regole e logica dell'applicazione. \n\n\nE' possibile creare classi model estendendo \n yii \\ base \\ Model \n o le sue classi figlio. Questa classe supporta molte funzioni utili:\n\n\n\n\nAttributi\n: rappresentano i dati aziendali ed \u00e8 possibile accedervi come propriet\u00e0 di oggetti normali;\n\n\nEtichette di attributi\n: permette di specificare le etichette di visualizzazione per gli attributi;\n\n\nAssegnazione massiva\n: supporta la popolazione di attributi multipli in un solo passsaggio;\n\n\nRegole di convalida\n: assicura che i dati di input vadano bene in base alle regole di convalida dichiarate;\n\n\nEsportazione dei dati\n: consente di esportare i dati del modello in termini di matrici con formati personalizzabili.\n\n\n\n\nLa classe \nModel\n \u00e8 anche la classe base per i modelli pi\u00f9 avanzati, ad esempio \n Active Record \n.\n\n\nAttributi\n\n\nOgni attributo \u00e8 come una propriet\u00e0 accessibile a livello pubblico di un modello. Il metodo \n yii \\ base \\ Model :: attributes() \n specifica quali attributi ha una classe modello.\n\n\nE' possibile accedere a un attributo come l'accesso a una propriet\u00e0 di oggetto normale: \n\n\nEsempio:\n\n\n$model = new \\app\\models\\ContactForm;\n\n// \"name\" is an attribute of ContactForm\n$model-\nname = 'example';\necho $model-\nname;\n\n\n\nE' inoltre possibile accedere agli attributi come l'accesso agli elementi dell'array, grazie al supporto per \n ArrayAccess \n e  Traversable ***.\n\n\n$model = new \\app\\models\\ContactForm;\n\n// accessing attributes like array elements\n$model['name'] = 'example';\necho $model['name'];\n\n// Model is traversable using foreach.\nforeach ($model as $name =\n $value) {\n    echo \"$name: $value\\n\";\n}\n\n\n\nDefinizione degli attributi\n\n\nPer impostazione predefinita, se la classe del modello si estende direttamente da \n yii \\ base \\ Model \n, tutte le sue variabili non statiche di membro pubblico sono attributi. Ad esempio, la classe del modello \nContactForm\n sotto ha quattro attributi: \nname\n, \nemail\n, \nsubject\n e \nbody\n. Il modello \nContactForm\n viene utilizzato per rappresentare i dati di input ricevuti da un modulo HTML.\n\n\nnamespace app\\models;\n\nuse yii\\base\\Model;\n\nclass ContactForm extends Model{\n\n    public $name;\n    public $email;\n    public $subject;\n    public $body;\n}\n\n\n\nEtichette di attributi\n\n\nQuando si visualizzano valori o otteniamo input per gli attributi, spesso \u00e8 necessario visualizzare alcune etichette associate agli attributi. Ad esempio, dato un attributo denominato, \nfirstName\n, e possibile visualizzare un'etichetta \nFirst Name\n che sia pi\u00f9 facile da usare quando viene visualizzata per mandare all'utente messaggi di errore oppure etichette di input.\n\n\nE' possibile ottenere l'etichetta di un attributo chiamando \n yii \\ base \\ Model :: getAttributeLabel() \n. Per esempio:\n\n\n$model = new \\app\\models\\ContactForm;\n\n// displays \"Name\"\necho $model-\ngetAttributeLabel('name');\n\n\n\nPer impostazione predefinita, le etichette degli attributi vengono generate automaticamente da nomi degli attributi. La generazione viene fatta con il metodo \n yii \\ base \\ Model :: generateAttributeLabel() \n. Alcuni esempi: \nusername\n diventa \nUsername\n, \nfirstName\n diventa \nFirst Name\n.\n\n\nSe non si desidare utilizzare etichette generate automaticamente, \u00e8 possibile ignorare \n yii \\ base \\ Model :: attributeLabels() \n per dichiarare esplicitamente le etichette degli attributi.\n\n\nEsempio:\n\n\nnamespace app\\models;\n\nuse yii\\base\\Model;\n\nclass ContactForm extends Model{\n\n    public $name;\n    public $email;\n    public $subject;\n    public $body;\n\n    public function attributeLabels(){\n\n        return [\n            'name' =\n 'Your name',\n            'email' =\n 'Your email address',\n            'subject' =\n 'Subject',\n            'body' =\n 'Content',\n        ];\n    }\n}\n\n\n\nPer le applicazioni che supportano pi\u00f9 lingue, \u00e8 possibile tradurre le etichette degli attributi. Questo pu\u00f2 essere fatto anche all'interno del metodo \nattributeLabels()\n, come nel seguente esempio:\n\n\npublic function attributeLabels(){\n\n    return [\n        'name' =\n \\Yii::t('app', 'Your name'),\n        'email' =\n \\Yii::t('app', 'Your email address'),\n        'subject' =\n \\Yii::t('app', 'Subject'),\n        'body' =\n \\Yii::t('app', 'Content'),\n    ];\n}\n\n\n\nE' possibile definire anche etichette degli attributi. Ad esempio, in base allo scenario in cui \u00e8 stato utilizzato il modello, \u00e8 possibile restituire diverse etichette per lo stesso attributo\n\n\n\n\nNote\n\n\nLe etichette degli attributi fanno parte delle stesse view(viste). Ma la dichiarazione di etichette nei modelli \u00e8 spesso molto conveniente ed \u00e8 molto comodo per avere un codice pi\u00f9 pulito e riutilizzabile.\n\n\n\n\nScenari\n\n\nUn modello pu\u00e0 essere utilizzato in diversi scenari. Ad esempio, un modello \nUser\n pu\u00f2 essere utilizzato per raccogliere gli ingressi di login utente, ma pu\u00f2 essere utilizzato anche per la registrazione di utenti. In diversi scenari, un modello pu\u00f2 utilizzare regole e logiche differenti. Ad esempio, l'attributo \nemail\n pu\u00f2 essere richiesto sia durante la registrazione degli utenti, ma non \u00e8 cos\u00ec durante la fase di login.\n\n\nUn modello utilizza la propriet\u00e0 \n scenario yii \\ base \\ Model :: \n per tenere traccia dello scenario in cui viene utilizzato. Per impostazione predefinita, un modello supporta solo un singolo scenario denominato \ndefault\n. Il seguente codice mostra due modi per impostare lo scenario di un modello:\n\n\n// scenario is set as a property\n$model = new User;\n$model-\nscenario = User::SCENARIO_LOGIN;\n\n// scenario is set through configuration\n$model = new User(['scenario' =\n User::SCENARIO_LOGIN]);\n\n\n\nPer impostazione predefinita, gli scenari supportati da un modello sono determinati dalle regole di convalida dichiarate nel modello. Tuttavia, \u00e8 possivile personalizzare questo comportamento prevenendo il meodo \n yii \\ base \\ Model :: scenari() \n, ad esempio:\n\n\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass User extends ActiveRecord{\n\n    const SCENARIO_LOGIN = 'login';\n    const SCENARIO_REGISTER = 'register';\n\n    public function scenarios(){\n\n        return [\n            self::SCENARIO_LOGIN =\n ['username', 'password'],\n            self::SCENARIO_REGISTER =\n ['username', 'email', 'password'],\n        ];\n    }\n}\n\n\n\nIl metodo \nscenarios()\n restituisce un array le cui chiavi sono i nomi di scenari e valori relativi agli attributi attivi. Un attributo attivo pu\u00f2 essere assegnato massicciamente e soggetto alla convalida. Nell'esempio precedente, gli attributi \nusername\n e \npassword\n sono attivi nello scenario \nlogin\n; mentre nello scenario \nregister\n, \nemail\n\u00e8 lo stesso attivo oltre a \nusername\n e \npassword\n.\n\n\nL'implementazione predefinita \nscenarios()\nrestituira tutti gli scenari trovati nel metodo di dichiarazione della regola valid \n yii \\ base \\ Model :: rules() \n. Quando si sceglie \nscenarios()\n, se si desidare introdurre nuovi scenari in aggiunta a quelli predefiniti, \u00e8 possibile scrivere un codice come segue:\n\n\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass User extends ActiveRecord{\n\n    const SCENARIO_LOGIN = 'login';\n    const SCENARIO_REGISTER = 'register';\n\n    public function scenarios(){\n\n        $scenarios = parent::scenarios();\n        $scenarios[self::SCENARIO_LOGIN] = ['username', 'password'];\n        $scenarios[self::SCENARIO_REGISTER] = ['username', 'email', 'password'];\n        return $scenarios;\n    }\n}\n\n\n\nRegole di convalida\n\n\nQuando i dati di un modello vengono ricevuti dagli utenti finali, deve essere convalidati per assicrarsi che soddisfino determinate regole ( chiamate \n regole di convalida \n). Ad esempio, dato un modello \nContactForm\n, \u00e8 possibile assicurarsi che tutti gli attributi non siano vuoti e che l'attributo \nemail\n contenga un indirizzo email valido. Se i valori di alcuni attributi non soddisfano le regole corrispondenti, \u00e8 necessario visualizzare i messaggi di errore appropriati per aiutare l'utente a correggere gli errori.\n\n\nPuoi chiamare il metodo \nyii \\ base \\ Model :: validate()\n per convalidare i dati ricevuti. Il metodo utilizzer\u00e0 le regole di convalida dichiarate all'interno del nostro modello. Se non viene trovato alcun errore, esso restituir\u00e0 \ntrue\n. In caso contrario, manterr\u00e0 gli errori nella propriet\u00e0 \n yii \\ base \\ Model :: errors \n e restituir\u00e0 \nfalse\n. Per esempio:\n\n\n$model = new \\app\\models\\ContactForm;\n\n// populate model attributes with user inputs\n$model-\nattributes = \\Yii::$app-\nrequest-\npost('ContactForm');\n\nif ($model-\nvalidate()) {\n    // all inputs are valid\n} else {\n    // validation failed: $errors is an array containing error messages\n    $errors = $model-\nerrors;\n}\n\n\n\nPer dichiarare regole di convalida associate a un modello, dovete aggiungere il metodo \n yii \\ base \\ Model :: rules() \n restituendo le regole che gli attributi del modello devono soddisfare. L'esempio seguente mostra le regole di convalida dichiarate per il modello \nContactForm\n:\n\n\npublic function rules(){\n\n    return [\n        // the name, email, subject and body attributes are required\n        [['name', 'email', 'subject', 'body'], 'required'],\n\n        // the email attribute should be a valid email address\n        ['email', 'email'],\n    ];\n}\n\n\n\nUna regola pu\u00f2 essere utilizzata per convalidare uno o pi\u00f9 attributi, e un attributo pu\u00f2 essere convalidato da una o pi\u00f9 regole.\nA volte, \u00e8 possibile che una regola venga applicata solo in alcuni scenari. A tal fine, \u00e8 possibile specificare la propriet\u00e0 \non\n ad una regola.\n\n\nEsempio:\n\n\npublic function rules(){\n\n    return [\n        // username, email and password are all required in \"register\" scenario\n        [['username', 'email', 'password'], 'required', 'on' =\n self::SCENARIO_REGISTER],\n\n        // username and password are required in \"login\" scenario\n        [['username', 'password'], 'required', 'on' =\n self::SCENARIO_LOGIN],\n    ];\n}\n\n\n\nSe non si specifica la propriet\u00e0 \non\n, questa regola verr\u00e0 applicata in tutti gli scenari. Una regola, viene definita \n attiva \n se pu\u00f2 essere applicata nello scenario del modello corrente.\n\n\nUn attributo verr\u00e0 convalidato se e solo se \u00e8 un attributo attivo dichiarato nel metodo \nscenarios()\n e associato a una o pi\u00f9 regole attive dichiarate nel metodo \nrules()\n.\n\n\nAssegnazione massiva\n\n\nL'assegnazione massiva \u00e8 un modo conveniente per popolare un modello con gli ingressi utente utilizzando una sola riga di codice. Consente di popolare gli attributi di un modello  assegnando i dati di input direttamente alla propriet\u00e0 del nostro modulo. Le seguenti due righe di codice sono equivalenti, entrambi associano i dati del modulo inviati dagli utenti finali agli attributi del modello \nContactForm\n. Chiaramente, il primo, \u00e8 pi\u00f9 pulito e meno erroneo del secondo:\n\n\n$model = new \\app\\models\\ContactForm;\n$model-\nattributes = \\Yii::$app-\nrequest-\npost('ContactForm');\n\n$model = new \\app\\models\\ContactForm;\n$data = \\Yii::$app-\nrequest-\npost('ContactForm', []);\n$model-\nname = isset($data['name']) ? $data['name'] : null;\n$model-\nemail = isset($data['email']) ? $data['email'] : null;\n$model-\nsubject = isset($data['subject']) ? $data['subject'] : null;\n$model-\nbody = isset($data['body']) ? $data['body'] : null;\n\n\n\nAttributi sicuri\n\n\nL'assegnazione massiva si applica solo ai cosiddetti  \n attributi sicuri \n che sono gli attributi elencati negli scenari del modello corrente. Ad esempio, se il modello \nUser\n ha la seguente dichiarazione di scenari, allora quando lo scenario corrente \u00e8 \nlogin\n, solo l'\nusername\n e \npassword\n pu\u00f2 essere assegnato massivamente. Qualsiasi altro attributo sar\u00e0 mantenuto intatto.\n\n\npublic function scenarios(){\n\n    return [\n        self::SCENARIO_LOGIN =\n ['username', 'password'],\n        self::SCENARIO_REGISTER =\n ['username', 'email', 'password'],\n    ];\n}\n\n\n\n\n\nNote\n\n\nIl motivo per cui l'assegnazione di massa si applica solo agli attributi sicuri, \u00e8 perch\u00e8 si desidera controllare quali attributi possono essere modificati dagli utenti finali. Ad esempio, se il modello \nUser\n dispone di un attributo \npermission\n che determina l'autorizzazione assegnata all'utente, si desidera modificare tale attributo dagli amministratori solo tramite un'interfaccia backend.\n\n\n\n\nPer rendere un attributo sicuro, viene fornito un alias chiamato \nsafe\n. E' un alias di validazione speciale in modo da poter dichiarare un attributo sicuro senza effettuare la convalida. Ad esempio, le seguenti regole dichiarano che sia \ntitle\n che \ndescription\n siano attributi sicuri.\n\n\npublic function rules(){\n\n    return [\n        [['title', 'description'], 'safe'],\n\n    ];\n}\n\n\n\nAttributi non sicuri\n\n\nCome detto in precedenza, il metodo \nscenarios()\n serve per due scopi: determinare quali attributi devono essere convalidati e determinare quali attributi sono sicuri. In alcuni casi rari, si potrebbe desiderare di convalidare un attributo, ma non si desidera contrassegnarlo. Puoi farlo configurando un punto esclamativo \n!\n al nome dell'attributo quando lo dichiari all'interno del metodo \nscenarios()\n, come l'esempio dell'attributo \nsecret\n nel seguente esempio:\n\n\npublic function scenarios(){\n\n    return [\n        self::SCENARIO_LOGIN =\n ['username', 'password', '!secret'],\n\n    ];\n}\n\n\n\nQuando il modello \u00e8 nello scenario \nlogin\n, tutti e tre gli attributi verranno convalidati. Tuttavia, solo gli attributi \nusername\n e \npassword\n possono essere assegnati in modo massivo. Per assegnare un valore di input all'attributo \nsecret\n, dobbiamo farlo in modo esplicito\n\n\n$model-\nsecret = $secret;\n\n\n\nLa stessa cosa pu\u00f2 essere fatta nel metodo \nrules()\n.\n\n\npublic function rules(){\n\n    return [\n        [['username', 'password', '!secret'], 'required', 'on' =\n 'login']\n    ];\n}\n\n\n\nIn questo caso gli attributi \nusername\n, \npassword\n e \nsecret\n sono necessari, ma \nsecret\n deve essere assegnato in modo esplicito.\n\n\nEsportazione dei dati\n\n\nI modelli spesso devono essere esportati in diversi formati. Ad esempio, \u00e8 possibile convertire una raccolta di modeli in formato JSON o Excel. Il processo di esportazione pu\u00f2 essere suddiviso in due fasi indipendenti:\n- i modelli vengono convertiti in array;\n- gli array vengono convertiti in formati di destinazione.\n\n\nPuoi concentrarti solo sul primo passo, perch\u00e8 il secondo pu\u00f2 essere raggiungo da formattatori di dati generici, come \n yii \\ web \\ JsonResponseFormatter \n.\n\n\nIl modo pi\u00f9 semplice per convertire un modello in un array \u00e8 quello di utilizzare la propriet\u00e0 \n yii \\ base \\ Model :: $attributes \n. Per esempio:\n\n\n$post = \\app\\models\\Post::findOne(100);\n$array = $post-\nattributes;\n\n\n\nPer impostazione predefinita, la propriet\u00e0 \nattributes\n restituir\u00e0 i valori di tutti gli attributi dichiarati in \n yii \\ base \\ Model :: () \n.\n\n\nUn modo pi\u00f9 flessibile e potente per convertire un modello in un array \u00e8 quello di utilizzare il metodo \nyii\\ base \\ Model :: to Array()\n. Il suo comportamento predefinito \u00e8 lo stesso di quello del metodo \nattributes\n. Tuttavia, consente di scegliere quali elementi di dati ( chiamati \ncampi\n), bisogna inserire nell'array risultante e come dovrebbero essere formattati.\n\n\nCampi\n\n\nUn campo \u00e8 semplicemente un elemento denominato nell'array ottenuto chiamando il metodo \nyii \\ base \\ Model :: toArray()\n di un modello.\n\n\nPer impostazione predefinita, i nomi dei campi sono equivalenti ai nomi degli attributi. Tuttavia, \u00e8 possibile modificare questo comportamento dichiarando i metodi \nfields()\n e / o \nextraFields()\n. Entrambi i metodi devono restituire un elenco delle definizione dei campi. I campi definiti da \nfields()\n sono campi predefiniti, il che significa che \ntoArray()\n restituir\u00e0 questi campi per impostazione predefinita. Il metodo \nextraFields()\n definisce campi aggiuntivi disponibili che possono anche essere restituiti dal metodo \ntoArray()\n affinch\u00e8 si specifichi tramite il parametro \n$expand\n. Ad esempio, il codice riportato di seguito restituir\u00e0 tutti i campi definiti \nfields()\n e i campi \nprettyName\n e \nfullAddress\n se sono definiti \nextraFields()\n.\n\n\n$array = $model-\ntoArray([], ['prettyName', 'fullAddress']);\n\n\n\nE' possibile ignorare \nfields()\n per aggiungere,rimuovere, rinominare o ridefinire i campi. Il valore restituito dal metodo \n`fields()\n dovr\u00e0 essere un array. I nomi dell'array sono i nomi dei campi e i valori dell'array sono le corrispondenti definizioni dei campi che possono essere nomi di propriet\u00e0/attributi o funzioni anonime che restituiscono i valori del campo corrispondente. Nel caso speciale quando un nome di un campo \u00e8 uguale al suo nome dell'attributo, \u00e8 possibile ignorare il nome dell'array. Per esempio:\n\n\n// explicitly list every field, best used when you want to make sure the changes\n// in your DB table or model attributes do not cause your field changes (to keep API backward compatibility).\npublic function fields(){\n\n    return [\n        // field name is the same as the attribute name\n        'id',\n\n        // field name is \"email\", the corresponding attribute name is \"email_address\"\n        'email' =\n 'email_address',\n\n        // field name is \"name\", its value is defined by a PHP callback\n        'name' =\n function () {\n            return $this-\nfirst_name . ' ' . $this-\nlast_name;\n        },\n    ];\n}\n\n// filter out some fields, best used when you want to inherit the parent implementation\n// and blacklist some sensitive fields.\npublic function fields(){\n\n    $fields = parent::fields();\n\n    // remove fields that contain sensitive information\n    unset($fields['auth_key'], $fields['password_hash'], $fields['password_reset_token']);\n\n    return $fields;\n}\n\n\n\n\n\nWarning\n\n\nPer impostazione predefinita tutti gli attributi di un modello saranno inclusi nell'array esportato, \u00e8 necessario esaminare i dati per assicurarsi di non contenere informazioni sensibili. Se ci sono tali informazioni, dovresti ignorare il metodo \nfields()\n per filtrarli. Nell'esempio sopra, abbiamo scelto di filtrare \nauth_key\n, \npassword_hash\n e \npassword_reset_token\n.",
            "title": "Modelli"
        },
        {
            "location": "/application-structure/sub-models/#modelli-models",
            "text": "I modelli sono parte dell'architettura MVC. Sono oggetti che rappresentano dati aziendali, regole e logica dell'applicazione.   E' possibile creare classi model estendendo   yii \\ base \\ Model   o le sue classi figlio. Questa classe supporta molte funzioni utili:   Attributi : rappresentano i dati aziendali ed \u00e8 possibile accedervi come propriet\u00e0 di oggetti normali;  Etichette di attributi : permette di specificare le etichette di visualizzazione per gli attributi;  Assegnazione massiva : supporta la popolazione di attributi multipli in un solo passsaggio;  Regole di convalida : assicura che i dati di input vadano bene in base alle regole di convalida dichiarate;  Esportazione dei dati : consente di esportare i dati del modello in termini di matrici con formati personalizzabili.   La classe  Model  \u00e8 anche la classe base per i modelli pi\u00f9 avanzati, ad esempio   Active Record  .",
            "title": "Modelli  (Models)"
        },
        {
            "location": "/application-structure/sub-models/#attributi",
            "text": "Ogni attributo \u00e8 come una propriet\u00e0 accessibile a livello pubblico di un modello. Il metodo   yii \\ base \\ Model :: attributes()   specifica quali attributi ha una classe modello.  E' possibile accedere a un attributo come l'accesso a una propriet\u00e0 di oggetto normale:   Esempio:  $model = new \\app\\models\\ContactForm;\n\n// \"name\" is an attribute of ContactForm\n$model- name = 'example';\necho $model- name;  E' inoltre possibile accedere agli attributi come l'accesso agli elementi dell'array, grazie al supporto per   ArrayAccess   e  Traversable ***.  $model = new \\app\\models\\ContactForm;\n\n// accessing attributes like array elements\n$model['name'] = 'example';\necho $model['name'];\n\n// Model is traversable using foreach.\nforeach ($model as $name =  $value) {\n    echo \"$name: $value\\n\";\n}",
            "title": "Attributi"
        },
        {
            "location": "/application-structure/sub-models/#definizione-degli-attributi",
            "text": "Per impostazione predefinita, se la classe del modello si estende direttamente da   yii \\ base \\ Model  , tutte le sue variabili non statiche di membro pubblico sono attributi. Ad esempio, la classe del modello  ContactForm  sotto ha quattro attributi:  name ,  email ,  subject  e  body . Il modello  ContactForm  viene utilizzato per rappresentare i dati di input ricevuti da un modulo HTML.  namespace app\\models;\n\nuse yii\\base\\Model;\n\nclass ContactForm extends Model{\n\n    public $name;\n    public $email;\n    public $subject;\n    public $body;\n}",
            "title": "Definizione degli attributi"
        },
        {
            "location": "/application-structure/sub-models/#etichette-di-attributi",
            "text": "Quando si visualizzano valori o otteniamo input per gli attributi, spesso \u00e8 necessario visualizzare alcune etichette associate agli attributi. Ad esempio, dato un attributo denominato,  firstName , e possibile visualizzare un'etichetta  First Name  che sia pi\u00f9 facile da usare quando viene visualizzata per mandare all'utente messaggi di errore oppure etichette di input.  E' possibile ottenere l'etichetta di un attributo chiamando   yii \\ base \\ Model :: getAttributeLabel()  . Per esempio:  $model = new \\app\\models\\ContactForm;\n\n// displays \"Name\"\necho $model- getAttributeLabel('name');  Per impostazione predefinita, le etichette degli attributi vengono generate automaticamente da nomi degli attributi. La generazione viene fatta con il metodo   yii \\ base \\ Model :: generateAttributeLabel()  . Alcuni esempi:  username  diventa  Username ,  firstName  diventa  First Name .  Se non si desidare utilizzare etichette generate automaticamente, \u00e8 possibile ignorare   yii \\ base \\ Model :: attributeLabels()   per dichiarare esplicitamente le etichette degli attributi.  Esempio:  namespace app\\models;\n\nuse yii\\base\\Model;\n\nclass ContactForm extends Model{\n\n    public $name;\n    public $email;\n    public $subject;\n    public $body;\n\n    public function attributeLabels(){\n\n        return [\n            'name' =  'Your name',\n            'email' =  'Your email address',\n            'subject' =  'Subject',\n            'body' =  'Content',\n        ];\n    }\n}  Per le applicazioni che supportano pi\u00f9 lingue, \u00e8 possibile tradurre le etichette degli attributi. Questo pu\u00f2 essere fatto anche all'interno del metodo  attributeLabels() , come nel seguente esempio:  public function attributeLabels(){\n\n    return [\n        'name' =  \\Yii::t('app', 'Your name'),\n        'email' =  \\Yii::t('app', 'Your email address'),\n        'subject' =  \\Yii::t('app', 'Subject'),\n        'body' =  \\Yii::t('app', 'Content'),\n    ];\n}  E' possibile definire anche etichette degli attributi. Ad esempio, in base allo scenario in cui \u00e8 stato utilizzato il modello, \u00e8 possibile restituire diverse etichette per lo stesso attributo   Note  Le etichette degli attributi fanno parte delle stesse view(viste). Ma la dichiarazione di etichette nei modelli \u00e8 spesso molto conveniente ed \u00e8 molto comodo per avere un codice pi\u00f9 pulito e riutilizzabile.",
            "title": "Etichette di attributi"
        },
        {
            "location": "/application-structure/sub-models/#scenari",
            "text": "Un modello pu\u00e0 essere utilizzato in diversi scenari. Ad esempio, un modello  User  pu\u00f2 essere utilizzato per raccogliere gli ingressi di login utente, ma pu\u00f2 essere utilizzato anche per la registrazione di utenti. In diversi scenari, un modello pu\u00f2 utilizzare regole e logiche differenti. Ad esempio, l'attributo  email  pu\u00f2 essere richiesto sia durante la registrazione degli utenti, ma non \u00e8 cos\u00ec durante la fase di login.  Un modello utilizza la propriet\u00e0   scenario yii \\ base \\ Model ::   per tenere traccia dello scenario in cui viene utilizzato. Per impostazione predefinita, un modello supporta solo un singolo scenario denominato  default . Il seguente codice mostra due modi per impostare lo scenario di un modello:  // scenario is set as a property\n$model = new User;\n$model- scenario = User::SCENARIO_LOGIN;\n\n// scenario is set through configuration\n$model = new User(['scenario' =  User::SCENARIO_LOGIN]);  Per impostazione predefinita, gli scenari supportati da un modello sono determinati dalle regole di convalida dichiarate nel modello. Tuttavia, \u00e8 possivile personalizzare questo comportamento prevenendo il meodo   yii \\ base \\ Model :: scenari()  , ad esempio:  namespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass User extends ActiveRecord{\n\n    const SCENARIO_LOGIN = 'login';\n    const SCENARIO_REGISTER = 'register';\n\n    public function scenarios(){\n\n        return [\n            self::SCENARIO_LOGIN =  ['username', 'password'],\n            self::SCENARIO_REGISTER =  ['username', 'email', 'password'],\n        ];\n    }\n}  Il metodo  scenarios()  restituisce un array le cui chiavi sono i nomi di scenari e valori relativi agli attributi attivi. Un attributo attivo pu\u00f2 essere assegnato massicciamente e soggetto alla convalida. Nell'esempio precedente, gli attributi  username  e  password  sono attivi nello scenario  login ; mentre nello scenario  register ,  email \u00e8 lo stesso attivo oltre a  username  e  password .  L'implementazione predefinita  scenarios() restituira tutti gli scenari trovati nel metodo di dichiarazione della regola valid   yii \\ base \\ Model :: rules()  . Quando si sceglie  scenarios() , se si desidare introdurre nuovi scenari in aggiunta a quelli predefiniti, \u00e8 possibile scrivere un codice come segue:  namespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass User extends ActiveRecord{\n\n    const SCENARIO_LOGIN = 'login';\n    const SCENARIO_REGISTER = 'register';\n\n    public function scenarios(){\n\n        $scenarios = parent::scenarios();\n        $scenarios[self::SCENARIO_LOGIN] = ['username', 'password'];\n        $scenarios[self::SCENARIO_REGISTER] = ['username', 'email', 'password'];\n        return $scenarios;\n    }\n}",
            "title": "Scenari"
        },
        {
            "location": "/application-structure/sub-models/#regole-di-convalida",
            "text": "Quando i dati di un modello vengono ricevuti dagli utenti finali, deve essere convalidati per assicrarsi che soddisfino determinate regole ( chiamate   regole di convalida  ). Ad esempio, dato un modello  ContactForm , \u00e8 possibile assicurarsi che tutti gli attributi non siano vuoti e che l'attributo  email  contenga un indirizzo email valido. Se i valori di alcuni attributi non soddisfano le regole corrispondenti, \u00e8 necessario visualizzare i messaggi di errore appropriati per aiutare l'utente a correggere gli errori.  Puoi chiamare il metodo  yii \\ base \\ Model :: validate()  per convalidare i dati ricevuti. Il metodo utilizzer\u00e0 le regole di convalida dichiarate all'interno del nostro modello. Se non viene trovato alcun errore, esso restituir\u00e0  true . In caso contrario, manterr\u00e0 gli errori nella propriet\u00e0   yii \\ base \\ Model :: errors   e restituir\u00e0  false . Per esempio:  $model = new \\app\\models\\ContactForm;\n\n// populate model attributes with user inputs\n$model- attributes = \\Yii::$app- request- post('ContactForm');\n\nif ($model- validate()) {\n    // all inputs are valid\n} else {\n    // validation failed: $errors is an array containing error messages\n    $errors = $model- errors;\n}  Per dichiarare regole di convalida associate a un modello, dovete aggiungere il metodo   yii \\ base \\ Model :: rules()   restituendo le regole che gli attributi del modello devono soddisfare. L'esempio seguente mostra le regole di convalida dichiarate per il modello  ContactForm :  public function rules(){\n\n    return [\n        // the name, email, subject and body attributes are required\n        [['name', 'email', 'subject', 'body'], 'required'],\n\n        // the email attribute should be a valid email address\n        ['email', 'email'],\n    ];\n}  Una regola pu\u00f2 essere utilizzata per convalidare uno o pi\u00f9 attributi, e un attributo pu\u00f2 essere convalidato da una o pi\u00f9 regole.\nA volte, \u00e8 possibile che una regola venga applicata solo in alcuni scenari. A tal fine, \u00e8 possibile specificare la propriet\u00e0  on  ad una regola.  Esempio:  public function rules(){\n\n    return [\n        // username, email and password are all required in \"register\" scenario\n        [['username', 'email', 'password'], 'required', 'on' =  self::SCENARIO_REGISTER],\n\n        // username and password are required in \"login\" scenario\n        [['username', 'password'], 'required', 'on' =  self::SCENARIO_LOGIN],\n    ];\n}  Se non si specifica la propriet\u00e0  on , questa regola verr\u00e0 applicata in tutti gli scenari. Una regola, viene definita   attiva   se pu\u00f2 essere applicata nello scenario del modello corrente.  Un attributo verr\u00e0 convalidato se e solo se \u00e8 un attributo attivo dichiarato nel metodo  scenarios()  e associato a una o pi\u00f9 regole attive dichiarate nel metodo  rules() .",
            "title": "Regole di convalida"
        },
        {
            "location": "/application-structure/sub-models/#assegnazione-massiva",
            "text": "L'assegnazione massiva \u00e8 un modo conveniente per popolare un modello con gli ingressi utente utilizzando una sola riga di codice. Consente di popolare gli attributi di un modello  assegnando i dati di input direttamente alla propriet\u00e0 del nostro modulo. Le seguenti due righe di codice sono equivalenti, entrambi associano i dati del modulo inviati dagli utenti finali agli attributi del modello  ContactForm . Chiaramente, il primo, \u00e8 pi\u00f9 pulito e meno erroneo del secondo:  $model = new \\app\\models\\ContactForm;\n$model- attributes = \\Yii::$app- request- post('ContactForm');\n\n$model = new \\app\\models\\ContactForm;\n$data = \\Yii::$app- request- post('ContactForm', []);\n$model- name = isset($data['name']) ? $data['name'] : null;\n$model- email = isset($data['email']) ? $data['email'] : null;\n$model- subject = isset($data['subject']) ? $data['subject'] : null;\n$model- body = isset($data['body']) ? $data['body'] : null;",
            "title": "Assegnazione massiva"
        },
        {
            "location": "/application-structure/sub-models/#attributi-sicuri",
            "text": "L'assegnazione massiva si applica solo ai cosiddetti    attributi sicuri   che sono gli attributi elencati negli scenari del modello corrente. Ad esempio, se il modello  User  ha la seguente dichiarazione di scenari, allora quando lo scenario corrente \u00e8  login , solo l' username  e  password  pu\u00f2 essere assegnato massivamente. Qualsiasi altro attributo sar\u00e0 mantenuto intatto.  public function scenarios(){\n\n    return [\n        self::SCENARIO_LOGIN =  ['username', 'password'],\n        self::SCENARIO_REGISTER =  ['username', 'email', 'password'],\n    ];\n}   Note  Il motivo per cui l'assegnazione di massa si applica solo agli attributi sicuri, \u00e8 perch\u00e8 si desidera controllare quali attributi possono essere modificati dagli utenti finali. Ad esempio, se il modello  User  dispone di un attributo  permission  che determina l'autorizzazione assegnata all'utente, si desidera modificare tale attributo dagli amministratori solo tramite un'interfaccia backend.   Per rendere un attributo sicuro, viene fornito un alias chiamato  safe . E' un alias di validazione speciale in modo da poter dichiarare un attributo sicuro senza effettuare la convalida. Ad esempio, le seguenti regole dichiarano che sia  title  che  description  siano attributi sicuri.  public function rules(){\n\n    return [\n        [['title', 'description'], 'safe'],\n\n    ];\n}",
            "title": "Attributi sicuri"
        },
        {
            "location": "/application-structure/sub-models/#attributi-non-sicuri",
            "text": "Come detto in precedenza, il metodo  scenarios()  serve per due scopi: determinare quali attributi devono essere convalidati e determinare quali attributi sono sicuri. In alcuni casi rari, si potrebbe desiderare di convalidare un attributo, ma non si desidera contrassegnarlo. Puoi farlo configurando un punto esclamativo  !  al nome dell'attributo quando lo dichiari all'interno del metodo  scenarios() , come l'esempio dell'attributo  secret  nel seguente esempio:  public function scenarios(){\n\n    return [\n        self::SCENARIO_LOGIN =  ['username', 'password', '!secret'],\n\n    ];\n}  Quando il modello \u00e8 nello scenario  login , tutti e tre gli attributi verranno convalidati. Tuttavia, solo gli attributi  username  e  password  possono essere assegnati in modo massivo. Per assegnare un valore di input all'attributo  secret , dobbiamo farlo in modo esplicito  $model- secret = $secret;  La stessa cosa pu\u00f2 essere fatta nel metodo  rules() .  public function rules(){\n\n    return [\n        [['username', 'password', '!secret'], 'required', 'on' =  'login']\n    ];\n}  In questo caso gli attributi  username ,  password  e  secret  sono necessari, ma  secret  deve essere assegnato in modo esplicito.",
            "title": "Attributi non sicuri"
        },
        {
            "location": "/application-structure/sub-models/#esportazione-dei-dati",
            "text": "I modelli spesso devono essere esportati in diversi formati. Ad esempio, \u00e8 possibile convertire una raccolta di modeli in formato JSON o Excel. Il processo di esportazione pu\u00f2 essere suddiviso in due fasi indipendenti:\n- i modelli vengono convertiti in array;\n- gli array vengono convertiti in formati di destinazione.  Puoi concentrarti solo sul primo passo, perch\u00e8 il secondo pu\u00f2 essere raggiungo da formattatori di dati generici, come   yii \\ web \\ JsonResponseFormatter  .  Il modo pi\u00f9 semplice per convertire un modello in un array \u00e8 quello di utilizzare la propriet\u00e0   yii \\ base \\ Model :: $attributes  . Per esempio:  $post = \\app\\models\\Post::findOne(100);\n$array = $post- attributes;  Per impostazione predefinita, la propriet\u00e0  attributes  restituir\u00e0 i valori di tutti gli attributi dichiarati in   yii \\ base \\ Model :: ()  .  Un modo pi\u00f9 flessibile e potente per convertire un modello in un array \u00e8 quello di utilizzare il metodo  yii\\ base \\ Model :: to Array() . Il suo comportamento predefinito \u00e8 lo stesso di quello del metodo  attributes . Tuttavia, consente di scegliere quali elementi di dati ( chiamati  campi ), bisogna inserire nell'array risultante e come dovrebbero essere formattati.",
            "title": "Esportazione dei dati"
        },
        {
            "location": "/application-structure/sub-models/#campi",
            "text": "Un campo \u00e8 semplicemente un elemento denominato nell'array ottenuto chiamando il metodo  yii \\ base \\ Model :: toArray()  di un modello.  Per impostazione predefinita, i nomi dei campi sono equivalenti ai nomi degli attributi. Tuttavia, \u00e8 possibile modificare questo comportamento dichiarando i metodi  fields()  e / o  extraFields() . Entrambi i metodi devono restituire un elenco delle definizione dei campi. I campi definiti da  fields()  sono campi predefiniti, il che significa che  toArray()  restituir\u00e0 questi campi per impostazione predefinita. Il metodo  extraFields()  definisce campi aggiuntivi disponibili che possono anche essere restituiti dal metodo  toArray()  affinch\u00e8 si specifichi tramite il parametro  $expand . Ad esempio, il codice riportato di seguito restituir\u00e0 tutti i campi definiti  fields()  e i campi  prettyName  e  fullAddress  se sono definiti  extraFields() .  $array = $model- toArray([], ['prettyName', 'fullAddress']);  E' possibile ignorare  fields()  per aggiungere,rimuovere, rinominare o ridefinire i campi. Il valore restituito dal metodo  `fields()  dovr\u00e0 essere un array. I nomi dell'array sono i nomi dei campi e i valori dell'array sono le corrispondenti definizioni dei campi che possono essere nomi di propriet\u00e0/attributi o funzioni anonime che restituiscono i valori del campo corrispondente. Nel caso speciale quando un nome di un campo \u00e8 uguale al suo nome dell'attributo, \u00e8 possibile ignorare il nome dell'array. Per esempio:  // explicitly list every field, best used when you want to make sure the changes\n// in your DB table or model attributes do not cause your field changes (to keep API backward compatibility).\npublic function fields(){\n\n    return [\n        // field name is the same as the attribute name\n        'id',\n\n        // field name is \"email\", the corresponding attribute name is \"email_address\"\n        'email' =  'email_address',\n\n        // field name is \"name\", its value is defined by a PHP callback\n        'name' =  function () {\n            return $this- first_name . ' ' . $this- last_name;\n        },\n    ];\n}\n\n// filter out some fields, best used when you want to inherit the parent implementation\n// and blacklist some sensitive fields.\npublic function fields(){\n\n    $fields = parent::fields();\n\n    // remove fields that contain sensitive information\n    unset($fields['auth_key'], $fields['password_hash'], $fields['password_reset_token']);\n\n    return $fields;\n}   Warning  Per impostazione predefinita tutti gli attributi di un modello saranno inclusi nell'array esportato, \u00e8 necessario esaminare i dati per assicurarsi di non contenere informazioni sensibili. Se ci sono tali informazioni, dovresti ignorare il metodo  fields()  per filtrarli. Nell'esempio sopra, abbiamo scelto di filtrare  auth_key ,  password_hash  e  password_reset_token .",
            "title": "Campi"
        },
        {
            "location": "/application-structure/sub-views/",
            "text": "Viste (views)\n\n\nLe viste sono parte dell'architettura MVC. Essi sono responsabili del codice per la presentazione dei dati agli utenti finali. In un'applicazione Web, le visualizzazioni vengono generalmente create in termini di modelli di visualizzazione che sono file di script PHP contenenti principalmente codice HTML e codice PHP. Sono gestiti dalla \"view application component\u201c che fornisce metodi comunemente utilizzati per facilitare la composizione e la visualizzazione delle view.\n\n\nCreazione di viste\n\n\nCome gi\u00e0 detto, una vista \u00e8 semplicemente uno script PHP mescolato con codice HTML e PHP. Di seguito \u00e8 riportata una vista che presenta un modulo di accesso. Come potete vedere, il codice PHP viene visualizzato per generare contenuto dinamico, come il titolo della pagina e il modulo, mentre il codice HTML li organizza in una pagina HTML presentabile.\n\n\n?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\ActiveForm;\n\n/* @var $this yii\\web\\View */\n/* @var $form yii\\widgets\\ActiveForm */\n/* @var $model app\\models\\LoginForm */\n\n$this-\ntitle = 'Login';\n?\n\n\nh1\n?= Html::encode($this-\ntitle) ?\n/h1\n\n\n\np\nPlease fill out the following fields to login:\n/p\n\n\n\n?php $form = ActiveForm::begin(); ?\n\n    \n?= $form-\nfield($model, 'username') ?\n\n    \n?= $form-\nfield($model, 'password')-\npasswordInput() ?\n\n    \n?= Html::submitButton('Login') ?\n  \n\n?php ActiveForm::end(); ?\n\n\n\n\nAll'interno di una vista, \u00e8 possibile accedere a alla variabile \n$this\n, che si riferisce alla gestione della struttura di visualizzazione e al rendering di questo modello di visualizzazione.\n\n\nOltre a \nthis\n, ci possono essere altre variabili predefinite in una vista, come \n$model\n nell'esempio precedente. \n\n\n\n\nTip\n\n\nLe variabili predefinite sono elencate in un blocco di commento all'inizio di una vista in modo che possano essere riconosciute da IDE. E' anche un buon modo per documentare le tue opinioni.\n\n\n\n\nSicurezza\n\n\nQuando si creano viste che generano pagine HTML, \u00e8 importante che i dati provenienti dagli utenti finali siano controllati. Altrimenti la tua applicazione potrebbe essere soggetta agli attachi di \n scripting cross-site \n.\n\n\nPer visualizzare un testo semplice, abbiamo bisogno di codificarlo come prima cosa chiamando \n yii \\ helpers \\ Html :: encode() \n. Ad esempio, il seguente codice codifica il nome utente prima di visualizzarlo:\n\n\n?php\nuse yii\\helpers\\Html;\n?\n\n\n\ndiv class=\"username\"\n\n    \n?= Html::encode($user-\nname) ?\n\n\n/div\n\n\n\n\nPer visualizzare il contenuto HTML, utilizzare \n yii \\ helpers \\ HtmlPurifier \n per filtrare prima il contenuto. Ad esempio, il codice seguente filtra il contenuto postale prima di visualizzarlo:\n\n\n?php\nuse yii\\helpers\\HtmlPurifier;\n?\n\n\n\ndiv class=\"post\"\n\n    \n?= HtmlPurifier::process($post-\ntext) ?\n\n\n/div\n\n\n\n\n\n\nTip\n\n\nMentre HTML Purifier fa un ottimo lavoro per rendere l'output sicuro, non \u00e8 veloce. E' opportuno considerare la memorizzazione nella cache del risultato di filtraggio se la tua applicazione richiede elevate prestazioni.\n\n\n\n\nOrganizzazione delle viste\n\n\nCome controllers e models, ci sono convenzioni per organizzare le viste:\n\n\n\n\nPer le visualizzazioni rese da un controller, dovrebbero essere posizionate sotto la directory \n@app/views/ControllerID\n per impostazione predefinita, dove \nControllerID\n si riferisce all'ID del controller. Ad esempio, se la classe controller \u00e8 \nPostController\n, la directory sarebbe \n@app/views/post\n; se \u00e8 \nPostCommentController\n, la directory sarebbe \napp/views/post-comment\n. Nel caso in cui il controller appartiene a un modulo della directory si troverebbe \nviews/ControllerID\n sotto \n yii \\ base \\ Module :: basePath \n.\n\n\nPer le viste rese da un widget, dovrebbero essere posizionate sotto la \nWidgetPath/views\n directory per impostazione predefinita, dove si trova la directory \nWidgetPath\n contenente il file della classe widget.\n\n\nPer le visualizzazioni rese da altri oggetti, si consiglia di seguire la convenzione simile a quella relativa ai widget.\n\n\n\n\nE' possibile personalizzare queste directory di visualizzazione predefinite, usando il metodo \n yii \\ base \\ ViewContextInterface :: getViewPath() \n dei controller o dei widget.\n\n\nViste di rendering\n\n\nE' possibile restituire visualizzazioni in controller, widget o in qualsiasi altro luogo chiamando metodi di rendering delle visualizzazioni. Questi metodi condividono una firma simile mostrata come segue.\n\n\n/**\n* @param string $view view name or file path, depending on the actual rendering method\n* @param array $params the data to be passed to the view\n* @return string rendering result\n*/\nmethodName($view, $params = [])\n\n\n\nRendering nei controllori (controller)\n\n\nAll'interno dei controllori, \u00e8 possibile chiamare i seguenti metodi di controllo per restituire le view:\n\n\n\n\nrender()\n: restituisce una vista denominata e gli applica un layout al risultato di rendering.\n\n\nrenderPartial()\n: restituisce una vista denominata senza alcun layout.\n\n\nrenderAjax()\n: restituisce una vista denominata senza alcun layout e ci aggiunge tutti gli script e file JS / CSS registrati. Viene di solito usato come risposta alle richieste Web di AJAX.\n\n\nrenderFile()\n: restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.\n\n\nrenderContent()\n: restituisce una stringa statica incorporandola nel layout attualmente applicabile.\n\n\n\n\nPer esempio:\n\n\nnamespace app\\controllers;\n\nuse Yii;\nuse app\\models\\Post;\nuse yii\\web\\Controller;\nuse yii\\web\\NotFoundHttpException;\n\nclass PostController extends Controller{\n\n    public function actionView($id){\n\n        $model = Post::findOne($id);\n        if ($model === null) {\n            throw new NotFoundHttpException;\n        }\n\n        // renders a view named \"view\" and applies a layout to it\n        return $this-\nrender('view', [\n            'model' =\n $model,\n        ]);\n    }\n}\n\n\n\nRendering nei widget\n\n\nNei widget \u00e8 possibile chiamare i seguneti widget per restituire le view:\n\n\n\n\nrender()\n: restituisce una vista denominata.\n\n\nrenderFile()\n: restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.\n\n\n\n\nPer esempio:\n\n\nnamespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass ListWidget extends Widget{\n\n    public $items = [];\n\n    public function run(){\n\n        // renders a view named \"list\"\n        return $this-\nrender('list', [\n            'items' =\n $this-\nitems,\n        ]);\n    }\n}\n\n\n\nRendering nelle viste (view)\n\n\nE' possibile eseguire una visualizzazione in un'altra visione chiamando uno dei seguenti metodi forniti dal \"view component\":\n\n\n\n\nrender()\n: restituisce una vista denominata.\n\n\nrenderAjax()\n: restituisce una vista denominata e ci aggiunge tutti gli script e file JS / CSS registrati. Viene di solito usato come risposta alle richieste Web di AJAX.\n\n\nrenderFile()\n: restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.\n\n\n\n\nAd esempio, il codice riportato di seguito in una visualizzazione restituisce il file di visualizzazione \n_overview.php\n nella stessa directory della view attualmente resa. Ricorda che \n$this\n si riferisce al componente stesso di view:\n\n\n?= $this-\nrender('_overview') ?\n\n\n\n\nViste denominate\n\n\nUn nome di visualizzazione viene convertito nel percorso del file di viisualizzazzione corrispondente in base alle seguenti regole:\n\n\n\n\nUn nome di visualizzazione pu\u00f2 omettere il nome dell'estensione del file. In questo caso, \n.php\n verr\u00e0 utilizzato come estensione. Ad esempio, il nome della vista \nabout\n corrisponde al nome del file \nabout.php\n.\n\n\nSe il nome della visualizzazione inizia con \n//\n, il percorso del file corrispondente dovrebbe essere \n@app/views/ViewName\n. Cio\u00e8, la vista viene visualizzata sotto il metodo \nviewPath()\n. Ad esempio,\n//site/about\n verr\u00e0 convertito in \n@app/views/site/about.php\n.\n\n\nSe il nome della visualizzione inizia con \n/\n, il percorso del file viene formato prefigurando il nome della vista con il metodo \nviewPath()\n del modulo attualmente attivo. Se non esiste un modulo attivo, verr\u00e0 utilizzato \n@app/views/ViewName\n. Ad esempio, \n/user/create\n verr\u00e0 convertito in \n@aap/modules/views/user/create.php\n se attualmente il modulo attivo \u00e8 \nuser\n. Se non esiste un modulo attivo, il percorso del file di visualizzazione sar\u00e0 \n@app/views/user/create.php\n.\n\n\nSe la vista viene eseguita con un \"context\" e implementa \n yii \\ base \\ ViewContextInterface \n, il percorso del file di visualizzazione viene formato prefigurando il percorso di visualizzazione del context con il nome della vista. Questo principalmente si applica ai punti di vista resti all'interno di controller e widget. Ad esempio, \nabout\n verr\u00e0 convertito \n@app/views/site/about.php\n se il contesto \u00e8 il controller \nSiteController\n.\n\n\nSe una vista viene visualizzata in un'altra visualizzazione, la directory contenente l'altro file di visualizzazione sar\u00e0 il prefisso al nuovo nome di visualizzazione per formare il percorso effettivo. Ad esempio, \nitem\n verr\u00e0 convertito in \n@app/views/site/about.php\n se viene visualizzato nella vista \n@app/views/post/index.php\n.\n\n\n\n\nSecondo le regole precedenti, la chiamata \n$this-\nrender('view')\n in un controller \napp\\controllers\\PostController\n restituir\u00e0 effettivamente il file di visualizzazione \n@app/views/post/view.php\n, mentre quando richiamiamo \n$this-\nrender('_overview')\n di quella vista restituir\u00e0 il file di visualizzazione \n@app/views/post/_overview.php\n.\n\n\nAccesso ai dati nelle viste\n\n\nEsistono due approcci per accedere ai dati all'interno di una vista: push e pull.\n\n\nPassando i dati come secondo parametro ai metodi di views, significa che si sta utilizzando l'approccio push. I dati dovrebbero essere rappresentati come una matrice di coppie nome-valore. Quando viene eseguito il rendering della view, la funzione PHP \nextract()\n viene usata quando voglia che il nostro array venga estratto e associato a variabili distinte nella nostra vista. Ad esempio, il seguente codice di rendering della vista di un controller invier\u00e0 due varabili alla views \nreport\n: \n$foo = \\\n e \n$bar = 2\n.\n\n\necho $this-\nrender('report', [\n    'foo' =\n 1,\n    'bar' =\n 2,\n]);\n\n\n\nL'approccio pull permetter\u00e0 di recuperare attivamente i dati dalla componente di visualizzazione o da altri oggetti accessibili nelle viste ( ad esempio \nYii::$app\n). Utilizzando il seguente codice come esempio, all'interno della vista \u00e8 possibile ottenere l'oggetto controller dall'espressione \n$this-\ncontext\n. Di conseguenza, \u00e8 possibile accedere a qualsiasi propriet\u00e0 o metodo del controller nella views di \nreport\n, ad esempio l'ID del controller come mostrato di seguito:\n\n\nThe controller ID is: \n?= $this-\ncontext-\nid ?\n\n\n\n\nL'approccio push \u00e8 solitamente il modo preferito perch\u00e8 permette di accedere ai dati delle viste, poich\u00e8 rende le visualizzazioni meno dipendenti dagli oggetti di contesto. Il suo svantaggio \u00e8 che \u00e8 necessario costruire manualmente l'array di dati tutto il tempo, che potrebbe diventare noioso e soggetto a errori se una vista \u00e8 condivisa e resa in luoghi diversi.\n\n\nCondivisione dei dati tra le viste\n\n\nIl componente di visualizzazione fornisce la propriet\u00e0 \nparams\n che \u00e8 possibile utilizzare per condividere i dati tra le viste. \nAd esempio, in una view \nabout\n, \u00e8 possibile avere il seguente codice che specifica il segmento corrente dei breadcrumb.\n\n\n$this-\nparams['breadcrumbs'][] = 'About Us';\n\n\n\nQuando nel file di layout puoi visualizzare i breadcrumb usando i dati passati attraverso parametri:\n\n\n?= yii\\widgets\\Breadcrumbs::widget([\n    'links' =\n isset($this-\nparams['breadcrumbs']) ? $this-\nparams['breadcrumbs'] : [],\n]) ?\n\n\n\n\nLayout\n\n\nI layout sono un tipo speciale di viste che rappresentano le parti comune di pi\u00f9 viste. Ad esempio, le pagine per la maggior parte delle applicazioni Web condividono la stessa intestazione e il pi\u00e8 di pagina, Mentre \u00e8 possibile ripetere la stessa intestazione e il pi\u00e8 di pagina ad ogni vista, un modo migliore \u00e8 quello di farlo una volta in un layout e poi incorporarlo ad esso.\n\n\nCreazioen di un layout\n\n\nI layout sono anche viste, ed essendo delle viste possono essere create come in modo molto simile. Per impostazione predefinita, i layout sono memorizzati nella directory \n@app/views/layouts\n. Per i layout utilizzati all'interno di una modulo, devono essere memorizzati nella directory \nviews/layouts\n sotto \nyii \\ base \\ Module :: basePath\n. E' possibile personalizzare la directory di layout predefinita configurando la propriet\u00e0 \nyii \\ base \\ Module :: layoutPath\n dell'applicazione o dei moduli.\n\n\nL'esempio seguente mostra come appare un layout. Si noti che a scopo illustrativo, abbiamo notevolmente semplificato il codice nel layout. In pratica, potresti voler aggiungere pi\u00f9 contenuti ad esso, come \"head tag\", menu principale, ecc.\n\n\n?php\nuse yii\\helpers\\Html;\n\n/* @var $this yii\\web\\View */\n/* @var $content string */\n?\n\n\n?php $this-\nbeginPage() ?\n\n\n!DOCTYPE html\n\n\nhtml lang=\"en\"\n\n\nhead\n\n    \nmeta charset=\"UTF-8\"/\n\n    \n?= Html::csrfMetaTags() ?\n\n    \ntitle\n?= Html::encode($this-\ntitle) ?\n/title\n\n    \n?php $this-\nhead() ?\n\n\n/head\n\n\nbody\n\n\n?php $this-\nbeginBody() ?\n\n    \nheader\nMy Company\n/header\n\n    \n?= $content ?\n\n    \nfooter\ncopy; 2014 by My Company\n/footer\n\n\n?php $this-\nendBody() ?\n\n\n/body\n\n\n/html\n\n\n?php $this-\nendPage() ?\n\n\n\n\nCome puoi vedere, il layout genera i tag HTML comuni a tutte le pagine. All'interno della sezione \nbody\n, il layout richiama la variabile \n$content\n che rappresenta il risultato del rendering delle viste del contenuto e viene inserito nel layout quando viene chiamato \nyii \\ base \\ Controller :: render()\n.\n\n\nLa maggior parte dei layout dovrebbe chiamare i seguenti metodi come mostrato nel codice sopra. Questi metodi attivano principalmente eventi relativi al processo di rendering in modo che gli script e i tag registrati in altri luoghi possano essere iniettati correttamente nelle posizioni in cui vengono chiamati questi metodi.\n\n\n\n\nbeginPage()\n: questo metodo dovrebbe essere chiamato all'inizio del layout. Si innesca l'evento \nl'EVENT_BEGIN_PAGE\n  che indica l'inizio di una pagina.\n\n\nendPage()\n: questo metodo dovrebbe essere chiamato alla file del layout. Si innesca l'evento \nl'EVENT_END_PAGE\n che indica la fine di una partita.\n\n\nhead()\n: questo metodo dovrebbe essere chiamato all'interno del tag \nhead\n nella sezione di una pagina HTML. Genera un segnaposto che verr\u00e0 sostituito con il codice HTML head registrato ( ad es. Tag link, meta tag) quando una pagina termina in rendering.\n\n\nbeginBody()\n: questo metodo dovrebbe essere chiamato all'inizio della sezione \nbody\n. Si innesca l'evento \nl'EVENT_BEGIN_BODY\n e genera una segnaposto che sar\u00e0 sostituito dal codice HTML registrato ( ad es. Javascript()) destinato al corpo del nostro programma.\n\n\nendBody()\n: questo metodo dovrebbe essere chiamato alla fine della sezione \nbody\n. Si innesca l'evento \nl'EVENT_END_BODY\n e genera un segnaposto che sar\u00e0 sostituito dal codice HTML registrato  ( ad es. Javascript()) destinato alla posizione finale del corpo del programma.\n\n\n\n\nAccesso ai dati nei layout\n\n\nAll'interno di un layout, hai accesso a due variabili predefinite: \n$this\n e \n$content\n, Il primo si riferisce alla componente della vista, come nelle viste normali, mentre il secondo contiene il risultato del rendering di una vista del contenuto che viene renderizzata chiamando il metodo \nrender()\n nei controller.\n\n\nSe si desidera accedere ad altri dati nei layout, \u00e8 necessario utilizzare il metodo pull ( come descritto nella sottosezione \"Accesso ai dati nella vista ). Se si desidera trasferire dati da una vista di contenuto a un layout, \u00e8 possibile utilizzare il metodo descritto nella sottosezione \"Viste di condivisione dati\".\n\n\nUtilizzando i layout\n\n\nCome descritto nella sottosezione \"Rendering nei Controller, quando si esegue il rendering di una vista chiamando il metodo \nrender()\n in un controller, verr\u00e0 applicato un layout al risultato del rendering. Per impostazione predefinita, verr\u00e0 utilizzato il layout \n@app/views/layouts/main.php\n.\n\n\nE' possibile utilizzare un layout diverso configurando il layout \nyii \\ base \\ Application :: $\n o \nyii \\ base \\ Controller :: $\n. Il primo regola il layout utilizzato da tutti i controller, mentre il secondo sovrascrive il primo per i singoli controller. Ad esempio, il codice seguente rende il controller \npost\n da utilizzare come layout durante il rendering delle sue viste. ( url file: \n@app/views/layouts/post.php\n). Altri controller, supponendo che la loro propriet\u00e0 \nlayout\n non sia stata modificata, utilizzeranno comunque \n@app/views/layouts/main.php\n il layout di default.\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    public $layout = 'post';\n\n    // ...\n}\n\n\n\nPer i controllori appartenenti a un modulo, \u00e8 possibile configurare anche la propriet\u00e0 di layout del modulo per utilizzare un particolare layout per questi controller.\n\n\nPoich\u00e8 la propriet\u00e0 \nlayout\n pu\u00f2 essere configurata a diversi livelli ( controller,moduli,applicazione ), dietro la scena, Yii prende due passaggi per determinare qual \u00e8 il file di layout effettivo utilizzato per un particolare controller.\n\n\nNel primo passaggio, determina il valore di layout e il modulo di contesto:\n\n\n\n\nSe la propriet\u00e0 di layout del controller \n yii \\ base \\ Controller :: $ \n non \u00e8 \nnull\n, \u00e8 consigliabile usarlo come valore di layout e il modulo del controller come modulo del contesto.\n\n\nSe la propriet\u00e0 di layout del controller \n yii \\ base \\ Controller :: $ \n \u00e8 \nnull\n, conviene cercare tra tutti i moduli degli antenati ( inclusa l'applicazione stessa ) del controller e trovare il primo modulo la cui propriet\u00e0 layout non \u00e8 \nnull\n. Usa quel modulo e il suo valore di layout come modulo di contesto e valore scelto. Se tale modulo non pu\u00f2 essere trovato, significa che non verr\u00e0 applicato alcun layout.\n\n\n\n\nNella seconda fase, determina il file di layout effettivo di base al valore di layout e al modulo di contesto determinato nel primo passaggio. Il valore di layout pu\u00f2 essere:\n\n\n\n\nun percorso alias ( es. \n@app/views/layouts/main\n).\n\n\nun percorso assoluto ( es. \n/main\n): il valore del layout inizia con una barra. Il file di layout effettivo verr\u00e0 cercato sotto \n yii \\ base \\ Application :: layoutPath \n dell'applicazione che viene impostato automaticamente \n@app/views/layouts\n.\n\n\nun percorso relativo (es. \nmain\n): il file di layout effettivo verr\u00e0 cercato sotto \nyii \\ base \\ Module :: layoutPath\n del modulo di contesto, che per impostazione predefinita si trova nella directory \nviews/layouts\n sotto \n yii \\ base \\ Module :: basePath \n.\n\n\nil valore booleano \nfalse\n: non verr\u00e0 applicato alcun layout.\n\n\n\n\nSe il valore di layout non contiene un'estensione di file, utilizzer\u00e0 quella predefinita \n.php\n.\n\n\nLayout nidificati\n\n\nA volte potresti voler annidare un layout in un altro. Ad esempio, in diverse sezioni di un sito Web, se si desidera utilizzare layout diversi, mentre tutti questi layout condividono lo stesso layout di base che genera la struttura generale della pagina HTML5. E' possibile raggiungere questo obiettivo chiamando il metodo \nbeginContent()\n e \nendContent()\n nei layout figli come il seguente:\n\n\n?php $this-\nbeginContent('@app/views/layouts/base.php'); ?\n\n\n...child layout content here...\n\n\n?php $this-\nendContent(); ?\n\n\n\n\nCome mostrato sopra, il contenuto del layout figlio deve essere racchiuso tra \nbeginContent()\n e \nendContent()\n. Il parametro passato a \nbeginContent()\n specifica qual \u00e8 il layout principale. Pu\u00f2 essere un file di layout o un alias. \n\n\nUtilizzando l'approccio sopra, \u00e8 possibile nidificare i layout in pi\u00f9 livelli.\n\n\nUsare i blocchi\n\n\nI blocchi consentono di specificare il contenuto della vista in un punto mentre lo si visualizza in un altro. Sono spesso usati insieme ai layout. Ad esempio, \u00e8 possibile definire un blocco in una vista del contenuto e visualizzarlo nel layout.\n\n\nI metodi si chiamano \nbeginBlock()\n e \nendBlock()\n. E' possibile accedere al blocco tramite \n$view-\nblocks[$blockID]\n, dove a \n$blockID\n verr\u00e0 assegnato un ID univoco al momento della sua definizione.\n\n\nL'esempio seguente mostra come utilizzare i blocchi per personalizzare parti specifiche di un layout in una vista del contenuto.\n\n\nInnanzitutto, in una vista del contenuto, possiamo definire uno o pi\u00f9 blocchi ( come segue ):\n\n\n...\n\n\n?php $this-\nbeginBlock('block1'); ?\n\n\n...content of block1...\n\n\n?php $this-\nendBlock(); ?\n\n\n...\n\n\n?php $this-\nbeginBlock('block3'); ?\n\n\n...content of block3...\n\n\n?php $this-\nendBlock(); ?\n\n\n\n\nQuindi nella vista layout possiamo visualizzare i blocchi se sono disponibili o visualizzare i contenuti predefiniti se un blocco non \u00e8 definito.\n\n\n...\n\n?php if (isset($this-\nblocks['block1'])): ?\n\n    \n?= $this-\nblocks['block1'] ?\n\n\n?php else: ?\n\n    ... default content for block1 ...\n\n?php endif; ?\n\n\n...\n\n\n?php if (isset($this-\nblocks['block2'])): ?\n\n    \n?= $this-\nblocks['block2'] ?\n\n\n?php else: ?\n\n    ... default content for block2 ...\n\n?php endif; ?\n\n\n...\n\n\n?php if (isset($this-\nblocks['block3'])): ?\n\n    \n?= $this-\nblocks['block3'] ?\n\n\n?php else: ?\n\n    ... default content for block3 ...\n\n?php endif; ?\n\n...\n\n\n\nUtilizzo del \"View Components\"\n\n\nVisualizza componenti ( o View COmponents) offre molte funzionalit\u00e0 relative alla vista. Mentre \u00e8 possibile ottenere i componenti di visualizzazione creando singole istanze di \n yii \\ base \\ View \n o della relativa classe figlio, nella maggior parte dei casi si utilizzer\u00e0 principalmente il componente \nview\n dell'applicazione. E' possibile configurare questo componente nella configurazione dell'applicazione come la seguente:\n\n\n[\n    // ...\n    'components' =\n [\n        'view' =\n [\n            'class' =\n 'app\\components\\View',\n        ],\n        // ...\n    ],\n]\n\n\n\ni componenti View forniscono le seguenti utili funzionalit\u00e0 relative alla vista, ciascuna descritta in maggiori dettagli in una sezione separata:\n\n\n\n\ntematizzazione(theming)\n: consente di sviluppare e modificare il tema per il proprio sito Web.\n\n\ncatching dei frammenti\n: consente di memorizzare nella cache un frammento all'interno di una pagina Web.\n\n\ngestione degli script client\n: supporta la registrazione e il rendering di CSS e JavaScript.\n\n\ngestione dei pacchetti di asset\n: supporta la registrazione e il rendering di pacchetti e di risorse.\n\n\nmotori di template alternativi\n: consente di utilizzare altri motori di template, come \nTwig\n, \nSmarty\n.\n\n\n\n\nE' inoltre possibile utilizzare frequentamente le seguenti funzionalit\u00e0 secondarie ma utili durante lo sviluppo di pagine Web.\n\n\nImpostazione dei titoli delle pagine\n\n\nOgni pagina Web dovrebbe avere un titolo. Normalmente il tag del titolo viene visualizzato in un layout. Tuttavia, in pratica il titolo \u00e8 spesso determinato nelle visualizzazioni del contenuto piuttosto che nei layout. Per risolvere questo problema, \nyii \\ web \\ View\n fornisce la propriet\u00e0 \ntitle\n per consentire il passaggio delle informazioni sul titolo dalle viste del contenuto ai layout.\n\n\nPer utilizzare questa funzione, in ciascuna vista del contenuto, \u00e8 possibile impostare il titolo della pagina come segue:\n\n\n?php\n$this-\ntitle = 'My page title';\n?\n\n\n\n\nQuindi, nei layout, assicurati di avere il seguente codice nella sezione \nhead\n:\n\n\ntitle\n?= Html::encode($this-\ntitle) ?\n/title\n\n\n\n\nRegistrazione dei meta tag\n\n\nLe pagine Web di solito hanno bisogno di generare vari meta tag richiesti da parti diverse. Come i titoli di pagina, i meta tag compaiono nella sezione \nhead\n e di solito sono generati nei layout.\n\n\nSe si desidera specificare quali metatag generati nelle viste del contenuto, \u00e8 possibile chiamare \nyii \\ web \\ View :: registerMetaTag()\n in una vista del contenuto, come la seguente:\n\n\n?php\n$this-\nregisterMetaTag(['name' =\n 'keywords', 'content' =\n 'yii, framework, php']);\n?\n\n\n\n\nIl codice sopra riportato registrer\u00e0 un meta tag \"keywords\" con il componente di visualizzazione. Il meta tag registrato viene visualizzato dopo che il layout ha completato il rendering. Il seguente codice HTML verr\u00e0 generato e inserito nel punto in cui si chiama \n yii \\ web \\ View :: head() \n nei layout:\n\n\nmeta name=\"keywords\" content=\"yii, framework, php\"\n\n\n\n\nNota che se chiami pi\u00f9 volte \n yii \\ web \\ View :: registerMetaTag() \n, registrer\u00e0 pi\u00f9 meta tag, indipendentemente dal fatto che i meta tag siano uguali o meno.\nPer assicurarti che ci sia solo una singola istanza di un tipo di meta tag, puoi specificare una chiave come secondo parametro quando chiami il metodo. Ad esempio, il seguente codice registra due meta tag \"description\".\nTuttavia, verr\u00e0 reso solo il secondo.\n\n\n$this-\nregisterMetaTag(['name' =\n 'description', 'content' =\n 'This is my cool website made with Yii!'], 'description');\n$this-\nregisterMetaTag(['name' =\n 'description', 'content' =\n 'This website is about funny raccoons.'], 'description');\n\n\n\nRegistrazione dei tag nei collegamenti\n\n\nCome i meta tag, i tag di collegamento sono utili in molti casi, come personalizzare le favicon, puntare al feed RSS. Puoi lavorare con tag di collegamento in modo simile ai meta tag usando \n yii \\ web \\ View :: registerLinkTag() \n. Ad esempio, in una vista del contenuto, puoi registrare un tag link come segue:\n\n\n$this-\nregisterLinkTag([\n    'title' =\n 'Live News for Yii',\n    'rel' =\n 'alternate',\n    'type' =\n 'application/rss+xml',\n    'href' =\n 'http://www.yiiframework.com/rss.xml/',\n]);\n\n\n\nIl codice precedente comporter\u00e0\n\n\nlink title=\"Live News for Yii\" rel=\"alternate\" type=\"application/rss+xml\" href=\"http://www.yiiframework.com/rss.xml/\"\n\n\n\n\nSimile al metodo \nregisterMetaTag()\n, \u00e8 possibile specificare una chiave quando si chiama \nregisterLinkTag()\n per evitare di generare tag di collegamento ripetuti.\n\n\nVisualizzazione degli eventi\n\n\nI componenti di visualizzazione attivano numerosi eventi durante il processo di visualizzazione della vista. E' possibile rispondere a questi eventi per iniettare il contenuto di viste o elaborare i risultati del rendering prima che vengano inviati agli utenti finali.\n\n\n-\nEVENT_BEFORE_RENDER\n: attivato dall'inizio del rendering di un file in un controller. I gestori di questo evento possono impostare \nyii \\ base \\ ViewEvent :: $isValid\n ad essere \nfalse\n per annullare il processo di rendering. \n- \nEVENT_AFTER_RENDER\n: attivato dopo il rendering di un file tramite la chiamata del metodo \nyii \\ base \\ View :: afterRender()\n. I gestori di questo evento possono ottenere il risultato del rendering tramite l'output \nyii \\ base \\ ViewEvent :: $\n e possono modificare questa propriet\u00e0 per modificare il risultato del rendering.\n- \nEVENT_BEGIN_PAGE\n: attivato dalla chiamata del metodo \nyii \\ base \\ View :: beginPage()\n nei layout.\n- \nEVENT_END_PAGE\n: attivato dalla chiamata del metodo \nyii \\ base \\ View :: endPage()\n nei layout.\n- \nEVENT_BEGIN_BODY\n: attivato dalla chiamata del metodo \nyii \\ base \\ View :: beginBody()\n nei layout.\n- \nEVENT_END_BODY\n: attivato dalla chiamata del metodo \nyii \\ base \\ View :: endBody()\n nei layout. \n\n\nAd esempio, il codice seguente applica la data corrente alla fine del corpo della pagina:\n\n\n\\Yii::$app-\nview-\non(View::EVENT_END_BODY, function () {\n    echo date('Y-m-d');\n});\n\n\n\nRendering di pagine statiche\n\n\nLe pagine statiche si riferiscono a quelle pagine Web il cui contenuto principale \u00e8 per lo pi\u00f9 statico senza la necessit\u00e0 di accedere ai dati dinamici trasferiti dai controller.\n\n\nE' possibile generare pagine statiche inserendo il proprio codice nella vista e quindi utilizzando il codice come segue in un controller:\n\n\npublic function actionAbout(){\n\n    return $this-\nrender('about');\n\n}\n\n\n\nSe un sito Web contiene molte pagine statiche, sarebbe molto noioso ripetere il codice simile molte volte. Per risolvere questo problema, \u00e8 possibile introdurre un'azione autonoma denominata \n yii \\ base \\ ViewAction \n in un controller. Per esempio:\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public function actions(){\n\n        return [\n            'page' =\n [\n                'class' =\n 'yii\\web\\ViewAction',\n            ],\n        ];\n    }\n}\n\n\n\nOra se crei una vista \nabout\n sotto la directory \n@app/views/site/pages\n, sarai in grado di visualizzare questa vista con il seguente URL:\n\n\nhttp://localhost/index.php?r=site%2Fpage\nview=about\n\n\n\nIl parametro \nview\n passato in modo \nGET\n dice al metodo \nyii \\ web \\ ViewAction\n quale vista \u00e8 richiesta. L'azione cercher\u00e0 quindi questa vista sotto la directory \n@app/views/site/pages\n. E' possibile configurare \nyii \\ web \\ ViewAction :: $viewPrefix\n per modificare la directory per la ricerca di queste viste.",
            "title": "Viste"
        },
        {
            "location": "/application-structure/sub-views/#viste-views",
            "text": "Le viste sono parte dell'architettura MVC. Essi sono responsabili del codice per la presentazione dei dati agli utenti finali. In un'applicazione Web, le visualizzazioni vengono generalmente create in termini di modelli di visualizzazione che sono file di script PHP contenenti principalmente codice HTML e codice PHP. Sono gestiti dalla \"view application component\u201c che fornisce metodi comunemente utilizzati per facilitare la composizione e la visualizzazione delle view.",
            "title": "Viste (views)"
        },
        {
            "location": "/application-structure/sub-views/#creazione-di-viste",
            "text": "Come gi\u00e0 detto, una vista \u00e8 semplicemente uno script PHP mescolato con codice HTML e PHP. Di seguito \u00e8 riportata una vista che presenta un modulo di accesso. Come potete vedere, il codice PHP viene visualizzato per generare contenuto dinamico, come il titolo della pagina e il modulo, mentre il codice HTML li organizza in una pagina HTML presentabile.  ?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\ActiveForm;\n\n/* @var $this yii\\web\\View */\n/* @var $form yii\\widgets\\ActiveForm */\n/* @var $model app\\models\\LoginForm */\n\n$this- title = 'Login';\n?  h1 ?= Html::encode($this- title) ? /h1  p Please fill out the following fields to login: /p  ?php $form = ActiveForm::begin(); ? \n     ?= $form- field($model, 'username') ? \n     ?= $form- field($model, 'password')- passwordInput() ? \n     ?= Html::submitButton('Login') ?    ?php ActiveForm::end(); ?   All'interno di una vista, \u00e8 possibile accedere a alla variabile  $this , che si riferisce alla gestione della struttura di visualizzazione e al rendering di questo modello di visualizzazione.  Oltre a  this , ci possono essere altre variabili predefinite in una vista, come  $model  nell'esempio precedente.    Tip  Le variabili predefinite sono elencate in un blocco di commento all'inizio di una vista in modo che possano essere riconosciute da IDE. E' anche un buon modo per documentare le tue opinioni.",
            "title": "Creazione di viste"
        },
        {
            "location": "/application-structure/sub-views/#sicurezza",
            "text": "Quando si creano viste che generano pagine HTML, \u00e8 importante che i dati provenienti dagli utenti finali siano controllati. Altrimenti la tua applicazione potrebbe essere soggetta agli attachi di   scripting cross-site  .  Per visualizzare un testo semplice, abbiamo bisogno di codificarlo come prima cosa chiamando   yii \\ helpers \\ Html :: encode()  . Ad esempio, il seguente codice codifica il nome utente prima di visualizzarlo:  ?php\nuse yii\\helpers\\Html;\n?  div class=\"username\" \n     ?= Html::encode($user- name) ?  /div   Per visualizzare il contenuto HTML, utilizzare   yii \\ helpers \\ HtmlPurifier   per filtrare prima il contenuto. Ad esempio, il codice seguente filtra il contenuto postale prima di visualizzarlo:  ?php\nuse yii\\helpers\\HtmlPurifier;\n?  div class=\"post\" \n     ?= HtmlPurifier::process($post- text) ?  /div    Tip  Mentre HTML Purifier fa un ottimo lavoro per rendere l'output sicuro, non \u00e8 veloce. E' opportuno considerare la memorizzazione nella cache del risultato di filtraggio se la tua applicazione richiede elevate prestazioni.",
            "title": "Sicurezza"
        },
        {
            "location": "/application-structure/sub-views/#organizzazione-delle-viste",
            "text": "Come controllers e models, ci sono convenzioni per organizzare le viste:   Per le visualizzazioni rese da un controller, dovrebbero essere posizionate sotto la directory  @app/views/ControllerID  per impostazione predefinita, dove  ControllerID  si riferisce all'ID del controller. Ad esempio, se la classe controller \u00e8  PostController , la directory sarebbe  @app/views/post ; se \u00e8  PostCommentController , la directory sarebbe  app/views/post-comment . Nel caso in cui il controller appartiene a un modulo della directory si troverebbe  views/ControllerID  sotto   yii \\ base \\ Module :: basePath  .  Per le viste rese da un widget, dovrebbero essere posizionate sotto la  WidgetPath/views  directory per impostazione predefinita, dove si trova la directory  WidgetPath  contenente il file della classe widget.  Per le visualizzazioni rese da altri oggetti, si consiglia di seguire la convenzione simile a quella relativa ai widget.   E' possibile personalizzare queste directory di visualizzazione predefinite, usando il metodo   yii \\ base \\ ViewContextInterface :: getViewPath()   dei controller o dei widget.",
            "title": "Organizzazione delle viste"
        },
        {
            "location": "/application-structure/sub-views/#viste-di-rendering",
            "text": "E' possibile restituire visualizzazioni in controller, widget o in qualsiasi altro luogo chiamando metodi di rendering delle visualizzazioni. Questi metodi condividono una firma simile mostrata come segue.  /**\n* @param string $view view name or file path, depending on the actual rendering method\n* @param array $params the data to be passed to the view\n* @return string rendering result\n*/\nmethodName($view, $params = [])",
            "title": "Viste di rendering"
        },
        {
            "location": "/application-structure/sub-views/#rendering-nei-controllori-controller",
            "text": "All'interno dei controllori, \u00e8 possibile chiamare i seguenti metodi di controllo per restituire le view:   render() : restituisce una vista denominata e gli applica un layout al risultato di rendering.  renderPartial() : restituisce una vista denominata senza alcun layout.  renderAjax() : restituisce una vista denominata senza alcun layout e ci aggiunge tutti gli script e file JS / CSS registrati. Viene di solito usato come risposta alle richieste Web di AJAX.  renderFile() : restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.  renderContent() : restituisce una stringa statica incorporandola nel layout attualmente applicabile.   Per esempio:  namespace app\\controllers;\n\nuse Yii;\nuse app\\models\\Post;\nuse yii\\web\\Controller;\nuse yii\\web\\NotFoundHttpException;\n\nclass PostController extends Controller{\n\n    public function actionView($id){\n\n        $model = Post::findOne($id);\n        if ($model === null) {\n            throw new NotFoundHttpException;\n        }\n\n        // renders a view named \"view\" and applies a layout to it\n        return $this- render('view', [\n            'model' =  $model,\n        ]);\n    }\n}",
            "title": "Rendering nei controllori (controller)"
        },
        {
            "location": "/application-structure/sub-views/#rendering-nei-widget",
            "text": "Nei widget \u00e8 possibile chiamare i seguneti widget per restituire le view:   render() : restituisce una vista denominata.  renderFile() : restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.   Per esempio:  namespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass ListWidget extends Widget{\n\n    public $items = [];\n\n    public function run(){\n\n        // renders a view named \"list\"\n        return $this- render('list', [\n            'items' =  $this- items,\n        ]);\n    }\n}",
            "title": "Rendering nei widget"
        },
        {
            "location": "/application-structure/sub-views/#rendering-nelle-viste-view",
            "text": "E' possibile eseguire una visualizzazione in un'altra visione chiamando uno dei seguenti metodi forniti dal \"view component\":   render() : restituisce una vista denominata.  renderAjax() : restituisce una vista denominata e ci aggiunge tutti gli script e file JS / CSS registrati. Viene di solito usato come risposta alle richieste Web di AJAX.  renderFile() : restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.   Ad esempio, il codice riportato di seguito in una visualizzazione restituisce il file di visualizzazione  _overview.php  nella stessa directory della view attualmente resa. Ricorda che  $this  si riferisce al componente stesso di view:  ?= $this- render('_overview') ?",
            "title": "Rendering nelle viste (view)"
        },
        {
            "location": "/application-structure/sub-views/#viste-denominate",
            "text": "Un nome di visualizzazione viene convertito nel percorso del file di viisualizzazzione corrispondente in base alle seguenti regole:   Un nome di visualizzazione pu\u00f2 omettere il nome dell'estensione del file. In questo caso,  .php  verr\u00e0 utilizzato come estensione. Ad esempio, il nome della vista  about  corrisponde al nome del file  about.php .  Se il nome della visualizzazione inizia con  // , il percorso del file corrispondente dovrebbe essere  @app/views/ViewName . Cio\u00e8, la vista viene visualizzata sotto il metodo  viewPath() . Ad esempio, //site/about  verr\u00e0 convertito in  @app/views/site/about.php .  Se il nome della visualizzione inizia con  / , il percorso del file viene formato prefigurando il nome della vista con il metodo  viewPath()  del modulo attualmente attivo. Se non esiste un modulo attivo, verr\u00e0 utilizzato  @app/views/ViewName . Ad esempio,  /user/create  verr\u00e0 convertito in  @aap/modules/views/user/create.php  se attualmente il modulo attivo \u00e8  user . Se non esiste un modulo attivo, il percorso del file di visualizzazione sar\u00e0  @app/views/user/create.php .  Se la vista viene eseguita con un \"context\" e implementa   yii \\ base \\ ViewContextInterface  , il percorso del file di visualizzazione viene formato prefigurando il percorso di visualizzazione del context con il nome della vista. Questo principalmente si applica ai punti di vista resti all'interno di controller e widget. Ad esempio,  about  verr\u00e0 convertito  @app/views/site/about.php  se il contesto \u00e8 il controller  SiteController .  Se una vista viene visualizzata in un'altra visualizzazione, la directory contenente l'altro file di visualizzazione sar\u00e0 il prefisso al nuovo nome di visualizzazione per formare il percorso effettivo. Ad esempio,  item  verr\u00e0 convertito in  @app/views/site/about.php  se viene visualizzato nella vista  @app/views/post/index.php .   Secondo le regole precedenti, la chiamata  $this- render('view')  in un controller  app\\controllers\\PostController  restituir\u00e0 effettivamente il file di visualizzazione  @app/views/post/view.php , mentre quando richiamiamo  $this- render('_overview')  di quella vista restituir\u00e0 il file di visualizzazione  @app/views/post/_overview.php .",
            "title": "Viste denominate"
        },
        {
            "location": "/application-structure/sub-views/#accesso-ai-dati-nelle-viste",
            "text": "Esistono due approcci per accedere ai dati all'interno di una vista: push e pull.  Passando i dati come secondo parametro ai metodi di views, significa che si sta utilizzando l'approccio push. I dati dovrebbero essere rappresentati come una matrice di coppie nome-valore. Quando viene eseguito il rendering della view, la funzione PHP  extract()  viene usata quando voglia che il nostro array venga estratto e associato a variabili distinte nella nostra vista. Ad esempio, il seguente codice di rendering della vista di un controller invier\u00e0 due varabili alla views  report :  $foo = \\  e  $bar = 2 .  echo $this- render('report', [\n    'foo' =  1,\n    'bar' =  2,\n]);  L'approccio pull permetter\u00e0 di recuperare attivamente i dati dalla componente di visualizzazione o da altri oggetti accessibili nelle viste ( ad esempio  Yii::$app ). Utilizzando il seguente codice come esempio, all'interno della vista \u00e8 possibile ottenere l'oggetto controller dall'espressione  $this- context . Di conseguenza, \u00e8 possibile accedere a qualsiasi propriet\u00e0 o metodo del controller nella views di  report , ad esempio l'ID del controller come mostrato di seguito:  The controller ID is:  ?= $this- context- id ?   L'approccio push \u00e8 solitamente il modo preferito perch\u00e8 permette di accedere ai dati delle viste, poich\u00e8 rende le visualizzazioni meno dipendenti dagli oggetti di contesto. Il suo svantaggio \u00e8 che \u00e8 necessario costruire manualmente l'array di dati tutto il tempo, che potrebbe diventare noioso e soggetto a errori se una vista \u00e8 condivisa e resa in luoghi diversi.",
            "title": "Accesso ai dati nelle viste"
        },
        {
            "location": "/application-structure/sub-views/#condivisione-dei-dati-tra-le-viste",
            "text": "Il componente di visualizzazione fornisce la propriet\u00e0  params  che \u00e8 possibile utilizzare per condividere i dati tra le viste. \nAd esempio, in una view  about , \u00e8 possibile avere il seguente codice che specifica il segmento corrente dei breadcrumb.  $this- params['breadcrumbs'][] = 'About Us';  Quando nel file di layout puoi visualizzare i breadcrumb usando i dati passati attraverso parametri:  ?= yii\\widgets\\Breadcrumbs::widget([\n    'links' =  isset($this- params['breadcrumbs']) ? $this- params['breadcrumbs'] : [],\n]) ?",
            "title": "Condivisione dei dati tra le viste"
        },
        {
            "location": "/application-structure/sub-views/#layout",
            "text": "I layout sono un tipo speciale di viste che rappresentano le parti comune di pi\u00f9 viste. Ad esempio, le pagine per la maggior parte delle applicazioni Web condividono la stessa intestazione e il pi\u00e8 di pagina, Mentre \u00e8 possibile ripetere la stessa intestazione e il pi\u00e8 di pagina ad ogni vista, un modo migliore \u00e8 quello di farlo una volta in un layout e poi incorporarlo ad esso.",
            "title": "Layout"
        },
        {
            "location": "/application-structure/sub-views/#creazioen-di-un-layout",
            "text": "I layout sono anche viste, ed essendo delle viste possono essere create come in modo molto simile. Per impostazione predefinita, i layout sono memorizzati nella directory  @app/views/layouts . Per i layout utilizzati all'interno di una modulo, devono essere memorizzati nella directory  views/layouts  sotto  yii \\ base \\ Module :: basePath . E' possibile personalizzare la directory di layout predefinita configurando la propriet\u00e0  yii \\ base \\ Module :: layoutPath  dell'applicazione o dei moduli.  L'esempio seguente mostra come appare un layout. Si noti che a scopo illustrativo, abbiamo notevolmente semplificato il codice nel layout. In pratica, potresti voler aggiungere pi\u00f9 contenuti ad esso, come \"head tag\", menu principale, ecc.  ?php\nuse yii\\helpers\\Html;\n\n/* @var $this yii\\web\\View */\n/* @var $content string */\n?  ?php $this- beginPage() ?  !DOCTYPE html  html lang=\"en\"  head \n     meta charset=\"UTF-8\"/ \n     ?= Html::csrfMetaTags() ? \n     title ?= Html::encode($this- title) ? /title \n     ?php $this- head() ?  /head  body  ?php $this- beginBody() ? \n     header My Company /header \n     ?= $content ? \n     footer copy; 2014 by My Company /footer  ?php $this- endBody() ?  /body  /html  ?php $this- endPage() ?   Come puoi vedere, il layout genera i tag HTML comuni a tutte le pagine. All'interno della sezione  body , il layout richiama la variabile  $content  che rappresenta il risultato del rendering delle viste del contenuto e viene inserito nel layout quando viene chiamato  yii \\ base \\ Controller :: render() .  La maggior parte dei layout dovrebbe chiamare i seguenti metodi come mostrato nel codice sopra. Questi metodi attivano principalmente eventi relativi al processo di rendering in modo che gli script e i tag registrati in altri luoghi possano essere iniettati correttamente nelle posizioni in cui vengono chiamati questi metodi.   beginPage() : questo metodo dovrebbe essere chiamato all'inizio del layout. Si innesca l'evento  l'EVENT_BEGIN_PAGE   che indica l'inizio di una pagina.  endPage() : questo metodo dovrebbe essere chiamato alla file del layout. Si innesca l'evento  l'EVENT_END_PAGE  che indica la fine di una partita.  head() : questo metodo dovrebbe essere chiamato all'interno del tag  head  nella sezione di una pagina HTML. Genera un segnaposto che verr\u00e0 sostituito con il codice HTML head registrato ( ad es. Tag link, meta tag) quando una pagina termina in rendering.  beginBody() : questo metodo dovrebbe essere chiamato all'inizio della sezione  body . Si innesca l'evento  l'EVENT_BEGIN_BODY  e genera una segnaposto che sar\u00e0 sostituito dal codice HTML registrato ( ad es. Javascript()) destinato al corpo del nostro programma.  endBody() : questo metodo dovrebbe essere chiamato alla fine della sezione  body . Si innesca l'evento  l'EVENT_END_BODY  e genera un segnaposto che sar\u00e0 sostituito dal codice HTML registrato  ( ad es. Javascript()) destinato alla posizione finale del corpo del programma.",
            "title": "Creazioen di un layout"
        },
        {
            "location": "/application-structure/sub-views/#accesso-ai-dati-nei-layout",
            "text": "All'interno di un layout, hai accesso a due variabili predefinite:  $this  e  $content , Il primo si riferisce alla componente della vista, come nelle viste normali, mentre il secondo contiene il risultato del rendering di una vista del contenuto che viene renderizzata chiamando il metodo  render()  nei controller.  Se si desidera accedere ad altri dati nei layout, \u00e8 necessario utilizzare il metodo pull ( come descritto nella sottosezione \"Accesso ai dati nella vista ). Se si desidera trasferire dati da una vista di contenuto a un layout, \u00e8 possibile utilizzare il metodo descritto nella sottosezione \"Viste di condivisione dati\".",
            "title": "Accesso ai dati nei layout"
        },
        {
            "location": "/application-structure/sub-views/#utilizzando-i-layout",
            "text": "Come descritto nella sottosezione \"Rendering nei Controller, quando si esegue il rendering di una vista chiamando il metodo  render()  in un controller, verr\u00e0 applicato un layout al risultato del rendering. Per impostazione predefinita, verr\u00e0 utilizzato il layout  @app/views/layouts/main.php .  E' possibile utilizzare un layout diverso configurando il layout  yii \\ base \\ Application :: $  o  yii \\ base \\ Controller :: $ . Il primo regola il layout utilizzato da tutti i controller, mentre il secondo sovrascrive il primo per i singoli controller. Ad esempio, il codice seguente rende il controller  post  da utilizzare come layout durante il rendering delle sue viste. ( url file:  @app/views/layouts/post.php ). Altri controller, supponendo che la loro propriet\u00e0  layout  non sia stata modificata, utilizzeranno comunque  @app/views/layouts/main.php  il layout di default.  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    public $layout = 'post';\n\n    // ...\n}  Per i controllori appartenenti a un modulo, \u00e8 possibile configurare anche la propriet\u00e0 di layout del modulo per utilizzare un particolare layout per questi controller.  Poich\u00e8 la propriet\u00e0  layout  pu\u00f2 essere configurata a diversi livelli ( controller,moduli,applicazione ), dietro la scena, Yii prende due passaggi per determinare qual \u00e8 il file di layout effettivo utilizzato per un particolare controller.  Nel primo passaggio, determina il valore di layout e il modulo di contesto:   Se la propriet\u00e0 di layout del controller   yii \\ base \\ Controller :: $   non \u00e8  null , \u00e8 consigliabile usarlo come valore di layout e il modulo del controller come modulo del contesto.  Se la propriet\u00e0 di layout del controller   yii \\ base \\ Controller :: $   \u00e8  null , conviene cercare tra tutti i moduli degli antenati ( inclusa l'applicazione stessa ) del controller e trovare il primo modulo la cui propriet\u00e0 layout non \u00e8  null . Usa quel modulo e il suo valore di layout come modulo di contesto e valore scelto. Se tale modulo non pu\u00f2 essere trovato, significa che non verr\u00e0 applicato alcun layout.   Nella seconda fase, determina il file di layout effettivo di base al valore di layout e al modulo di contesto determinato nel primo passaggio. Il valore di layout pu\u00f2 essere:   un percorso alias ( es.  @app/views/layouts/main ).  un percorso assoluto ( es.  /main ): il valore del layout inizia con una barra. Il file di layout effettivo verr\u00e0 cercato sotto   yii \\ base \\ Application :: layoutPath   dell'applicazione che viene impostato automaticamente  @app/views/layouts .  un percorso relativo (es.  main ): il file di layout effettivo verr\u00e0 cercato sotto  yii \\ base \\ Module :: layoutPath  del modulo di contesto, che per impostazione predefinita si trova nella directory  views/layouts  sotto   yii \\ base \\ Module :: basePath  .  il valore booleano  false : non verr\u00e0 applicato alcun layout.   Se il valore di layout non contiene un'estensione di file, utilizzer\u00e0 quella predefinita  .php .",
            "title": "Utilizzando i layout"
        },
        {
            "location": "/application-structure/sub-views/#layout-nidificati",
            "text": "A volte potresti voler annidare un layout in un altro. Ad esempio, in diverse sezioni di un sito Web, se si desidera utilizzare layout diversi, mentre tutti questi layout condividono lo stesso layout di base che genera la struttura generale della pagina HTML5. E' possibile raggiungere questo obiettivo chiamando il metodo  beginContent()  e  endContent()  nei layout figli come il seguente:  ?php $this- beginContent('@app/views/layouts/base.php'); ? \n\n...child layout content here... ?php $this- endContent(); ?   Come mostrato sopra, il contenuto del layout figlio deve essere racchiuso tra  beginContent()  e  endContent() . Il parametro passato a  beginContent()  specifica qual \u00e8 il layout principale. Pu\u00f2 essere un file di layout o un alias.   Utilizzando l'approccio sopra, \u00e8 possibile nidificare i layout in pi\u00f9 livelli.",
            "title": "Layout nidificati"
        },
        {
            "location": "/application-structure/sub-views/#usare-i-blocchi",
            "text": "I blocchi consentono di specificare il contenuto della vista in un punto mentre lo si visualizza in un altro. Sono spesso usati insieme ai layout. Ad esempio, \u00e8 possibile definire un blocco in una vista del contenuto e visualizzarlo nel layout.  I metodi si chiamano  beginBlock()  e  endBlock() . E' possibile accedere al blocco tramite  $view- blocks[$blockID] , dove a  $blockID  verr\u00e0 assegnato un ID univoco al momento della sua definizione.  L'esempio seguente mostra come utilizzare i blocchi per personalizzare parti specifiche di un layout in una vista del contenuto.  Innanzitutto, in una vista del contenuto, possiamo definire uno o pi\u00f9 blocchi ( come segue ):  ... ?php $this- beginBlock('block1'); ? \n\n...content of block1... ?php $this- endBlock(); ? \n\n... ?php $this- beginBlock('block3'); ? \n\n...content of block3... ?php $this- endBlock(); ?   Quindi nella vista layout possiamo visualizzare i blocchi se sono disponibili o visualizzare i contenuti predefiniti se un blocco non \u00e8 definito.  ... ?php if (isset($this- blocks['block1'])): ? \n     ?= $this- blocks['block1'] ?  ?php else: ? \n    ... default content for block1 ... ?php endif; ? \n\n... ?php if (isset($this- blocks['block2'])): ? \n     ?= $this- blocks['block2'] ?  ?php else: ? \n    ... default content for block2 ... ?php endif; ? \n\n... ?php if (isset($this- blocks['block3'])): ? \n     ?= $this- blocks['block3'] ?  ?php else: ? \n    ... default content for block3 ... ?php endif; ? \n...",
            "title": "Usare i blocchi"
        },
        {
            "location": "/application-structure/sub-views/#utilizzo-del-view-components",
            "text": "Visualizza componenti ( o View COmponents) offre molte funzionalit\u00e0 relative alla vista. Mentre \u00e8 possibile ottenere i componenti di visualizzazione creando singole istanze di   yii \\ base \\ View   o della relativa classe figlio, nella maggior parte dei casi si utilizzer\u00e0 principalmente il componente  view  dell'applicazione. E' possibile configurare questo componente nella configurazione dell'applicazione come la seguente:  [\n    // ...\n    'components' =  [\n        'view' =  [\n            'class' =  'app\\components\\View',\n        ],\n        // ...\n    ],\n]  i componenti View forniscono le seguenti utili funzionalit\u00e0 relative alla vista, ciascuna descritta in maggiori dettagli in una sezione separata:   tematizzazione(theming) : consente di sviluppare e modificare il tema per il proprio sito Web.  catching dei frammenti : consente di memorizzare nella cache un frammento all'interno di una pagina Web.  gestione degli script client : supporta la registrazione e il rendering di CSS e JavaScript.  gestione dei pacchetti di asset : supporta la registrazione e il rendering di pacchetti e di risorse.  motori di template alternativi : consente di utilizzare altri motori di template, come  Twig ,  Smarty .   E' inoltre possibile utilizzare frequentamente le seguenti funzionalit\u00e0 secondarie ma utili durante lo sviluppo di pagine Web.",
            "title": "Utilizzo del \"View Components\""
        },
        {
            "location": "/application-structure/sub-views/#impostazione-dei-titoli-delle-pagine",
            "text": "Ogni pagina Web dovrebbe avere un titolo. Normalmente il tag del titolo viene visualizzato in un layout. Tuttavia, in pratica il titolo \u00e8 spesso determinato nelle visualizzazioni del contenuto piuttosto che nei layout. Per risolvere questo problema,  yii \\ web \\ View  fornisce la propriet\u00e0  title  per consentire il passaggio delle informazioni sul titolo dalle viste del contenuto ai layout.  Per utilizzare questa funzione, in ciascuna vista del contenuto, \u00e8 possibile impostare il titolo della pagina come segue:  ?php\n$this- title = 'My page title';\n?   Quindi, nei layout, assicurati di avere il seguente codice nella sezione  head :  title ?= Html::encode($this- title) ? /title",
            "title": "Impostazione dei titoli delle pagine"
        },
        {
            "location": "/application-structure/sub-views/#registrazione-dei-meta-tag",
            "text": "Le pagine Web di solito hanno bisogno di generare vari meta tag richiesti da parti diverse. Come i titoli di pagina, i meta tag compaiono nella sezione  head  e di solito sono generati nei layout.  Se si desidera specificare quali metatag generati nelle viste del contenuto, \u00e8 possibile chiamare  yii \\ web \\ View :: registerMetaTag()  in una vista del contenuto, come la seguente:  ?php\n$this- registerMetaTag(['name' =  'keywords', 'content' =  'yii, framework, php']);\n?   Il codice sopra riportato registrer\u00e0 un meta tag \"keywords\" con il componente di visualizzazione. Il meta tag registrato viene visualizzato dopo che il layout ha completato il rendering. Il seguente codice HTML verr\u00e0 generato e inserito nel punto in cui si chiama   yii \\ web \\ View :: head()   nei layout:  meta name=\"keywords\" content=\"yii, framework, php\"   Nota che se chiami pi\u00f9 volte   yii \\ web \\ View :: registerMetaTag()  , registrer\u00e0 pi\u00f9 meta tag, indipendentemente dal fatto che i meta tag siano uguali o meno.\nPer assicurarti che ci sia solo una singola istanza di un tipo di meta tag, puoi specificare una chiave come secondo parametro quando chiami il metodo. Ad esempio, il seguente codice registra due meta tag \"description\".\nTuttavia, verr\u00e0 reso solo il secondo.  $this- registerMetaTag(['name' =  'description', 'content' =  'This is my cool website made with Yii!'], 'description');\n$this- registerMetaTag(['name' =  'description', 'content' =  'This website is about funny raccoons.'], 'description');",
            "title": "Registrazione dei meta tag"
        },
        {
            "location": "/application-structure/sub-views/#registrazione-dei-tag-nei-collegamenti",
            "text": "Come i meta tag, i tag di collegamento sono utili in molti casi, come personalizzare le favicon, puntare al feed RSS. Puoi lavorare con tag di collegamento in modo simile ai meta tag usando   yii \\ web \\ View :: registerLinkTag()  . Ad esempio, in una vista del contenuto, puoi registrare un tag link come segue:  $this- registerLinkTag([\n    'title' =  'Live News for Yii',\n    'rel' =  'alternate',\n    'type' =  'application/rss+xml',\n    'href' =  'http://www.yiiframework.com/rss.xml/',\n]);  Il codice precedente comporter\u00e0  link title=\"Live News for Yii\" rel=\"alternate\" type=\"application/rss+xml\" href=\"http://www.yiiframework.com/rss.xml/\"   Simile al metodo  registerMetaTag() , \u00e8 possibile specificare una chiave quando si chiama  registerLinkTag()  per evitare di generare tag di collegamento ripetuti.",
            "title": "Registrazione dei tag nei collegamenti"
        },
        {
            "location": "/application-structure/sub-views/#visualizzazione-degli-eventi",
            "text": "I componenti di visualizzazione attivano numerosi eventi durante il processo di visualizzazione della vista. E' possibile rispondere a questi eventi per iniettare il contenuto di viste o elaborare i risultati del rendering prima che vengano inviati agli utenti finali.  - EVENT_BEFORE_RENDER : attivato dall'inizio del rendering di un file in un controller. I gestori di questo evento possono impostare  yii \\ base \\ ViewEvent :: $isValid  ad essere  false  per annullare il processo di rendering. \n-  EVENT_AFTER_RENDER : attivato dopo il rendering di un file tramite la chiamata del metodo  yii \\ base \\ View :: afterRender() . I gestori di questo evento possono ottenere il risultato del rendering tramite l'output  yii \\ base \\ ViewEvent :: $  e possono modificare questa propriet\u00e0 per modificare il risultato del rendering.\n-  EVENT_BEGIN_PAGE : attivato dalla chiamata del metodo  yii \\ base \\ View :: beginPage()  nei layout.\n-  EVENT_END_PAGE : attivato dalla chiamata del metodo  yii \\ base \\ View :: endPage()  nei layout.\n-  EVENT_BEGIN_BODY : attivato dalla chiamata del metodo  yii \\ base \\ View :: beginBody()  nei layout.\n-  EVENT_END_BODY : attivato dalla chiamata del metodo  yii \\ base \\ View :: endBody()  nei layout.   Ad esempio, il codice seguente applica la data corrente alla fine del corpo della pagina:  \\Yii::$app- view- on(View::EVENT_END_BODY, function () {\n    echo date('Y-m-d');\n});",
            "title": "Visualizzazione degli eventi"
        },
        {
            "location": "/application-structure/sub-views/#rendering-di-pagine-statiche",
            "text": "Le pagine statiche si riferiscono a quelle pagine Web il cui contenuto principale \u00e8 per lo pi\u00f9 statico senza la necessit\u00e0 di accedere ai dati dinamici trasferiti dai controller.  E' possibile generare pagine statiche inserendo il proprio codice nella vista e quindi utilizzando il codice come segue in un controller:  public function actionAbout(){\n\n    return $this- render('about');\n\n}  Se un sito Web contiene molte pagine statiche, sarebbe molto noioso ripetere il codice simile molte volte. Per risolvere questo problema, \u00e8 possibile introdurre un'azione autonoma denominata   yii \\ base \\ ViewAction   in un controller. Per esempio:  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public function actions(){\n\n        return [\n            'page' =  [\n                'class' =  'yii\\web\\ViewAction',\n            ],\n        ];\n    }\n}  Ora se crei una vista  about  sotto la directory  @app/views/site/pages , sarai in grado di visualizzare questa vista con il seguente URL:  http://localhost/index.php?r=site%2Fpage view=about  Il parametro  view  passato in modo  GET  dice al metodo  yii \\ web \\ ViewAction  quale vista \u00e8 richiesta. L'azione cercher\u00e0 quindi questa vista sotto la directory  @app/views/site/pages . E' possibile configurare  yii \\ web \\ ViewAction :: $viewPrefix  per modificare la directory per la ricerca di queste viste.",
            "title": "Rendering di pagine statiche"
        },
        {
            "location": "/application-structure/sub-modules/",
            "text": "Moduli  (Modules)\n\n\nI moduli sono unit\u00e0 software autonome costituite da modelli, viste, controller e altri componenti di supporto. Gli utenti finali possono accedere ai controller di un modulo quando \u00e8 installato nell'applicazione. Per questi motivi, i moduli sono spesso visti come mini-applicazioni. I moduli differiscono dalle applicazioni in quanto i moduli non possono essere distribuiti da soli e devono risiedere all'interno dell'applicazioni.\n\n\nCreazione di moduli\n\n\nUn modulo \u00e8 organizzato come una directory chiamata \nyii \\ base \\ Module :: base Path\n del modulo. All'interno della directory, ci sono sub-directory, ad esempio \ncontrollers\n,\nmodels\n,\nviews\n, che detengono i controller, i modelli, le viste e altro codice, proprio come in un'applicazione. L'esempio seguente mostra il contenuto all'interno di un modulo:\n\n\nforum/\n    Module.php                   the module class file\n    controllers/                 containing controller class files\n        DefaultController.php    the default controller class file\n    models/                      containing model class files\n    views/                       containing controller view and layout files\n        layouts/                 containing layout view files\n        default/                 containing view files for DefaultController\n            index.php            the index view file\n\n\n\nClassi del modulo\n\n\nOgni modulo dovrebbe avere una classe di modulo univoca che si estende dai \nyii \\ base \\ Module\n. La classe dovrebbe trovarsi direttamente sotto il modulo \nyii \\ base \\ Module :: basePath\n e dovrebbe essere caricabile automaticamente. Quando si accede a un modulo, verr\u00e0 creata una singola istanza della classe modulo corrispondente. Come le istanze dell'applicazione, le istanze del modulo vengono utilizzate per condividere dati e componenti per il codice all'interno dei moduli.\n\n\nQuello che segue \u00e8 un esempio di come pu\u00f2 essere una classe di modulo:\n\n\nnamespace app\\modules\\forum;\n\nclass Module extends \\yii\\base\\Module{\n\n    public function init(){\n\n        parent::init();\n\n        $this-\nparams['foo'] = 'bar';\n        // ...  other initialization code ...\n    }\n}\n\n\n\nSe il metodo \ninit()\n contiene molto codice che inizializza la propriet\u00e0 del modulo, \u00e8 possibile salvarle anche in termini di configurazione e caricarlo con il seguente codice in \ninit()\n:\n\n\npublic function init(){\n\n    parent::init();\n    // initialize the module with the configuration loaded from config.php\n    \\Yii::configure($this, require __DIR__ . '/config.php');\n}\n\n\n\ndove il file di configurazione \nconfig.php\n pu\u00f2 contenere il seguente contenuto, simile a quello in una configurazione dell'applicazione.\n\n\n?php\nreturn [\n    'components' =\n [\n        // list of component configurations\n    ],\n    'params' =\n [\n        // list of parameters\n    ],\n];\n\n\n\nController nei moduli\n\n\nQuando si creano i controller in un modulo, una convenzione consiste nel mettere le classi controller sotto il namespace \ncontrollers\n. Ci\u00f2 significa anche che i file di classe del controller devono essere inseriti nella directory \ncontroller\n all'interno del modulo \nyii \\ base \\ Module :: basePath\n. Ad esempio, per creare un controller \npost\n nel modulo \nforum\n mostrato nell'ultima sottosezione, \u00e8 necessario dichiarare la classe controller come segue:\n\n\nnamespace app\\modules\\forum\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    // ...\n\n}\n\n\n\nE' possibile personalizzare i namespace delle classi controller configurando la propriet\u00e0 \nyii \\ base \\ Module :: $controllerNamespace\n. Nel caso in cui alcuni controller si trovino al di fuori di questi namespaces, \u00e8 possibile renderli accessibili configurando la propriet\u00e0 \nyii \\ base \\ Module :: $controllerMap\n, in modo simile a ci\u00f2 che si fa in un'applicazione.\n\n\nViste nei moduli\n\n\nLe viste in un modulo dovrebbero essere inserite nella directory \nviews\n all'interno del modulo \nyii \\ base \\ Module :: basePath\n. Per le viste visualizzate da un controller nel modulo, devono essere inserite nella directory \nviews/ControllerID\n, dove \nControllerID\n fa riferimento all'ID del controller. Ad esempio, se la classe controller \u00e8 \nPostController\n, la directory dpvrebbe trovarsi in \nviews/post\n all'interno del modulo \nyii \\ base \\ Module :: basePath\n.\n\n\nUn modulo pu\u00f2 specificare un layout che viene applicato alle viste visualizzate dai controller del modulo. Il layout deve essere inserito nella directory \nviews/layouts\n per impostazione predefinita e \u00e8 necessario configurare la propriet\u00e0 \nyii \\ base \\ Module :: $layout\n in modo che punti al nome del layout. Se non si configura la propriet\u00e0 \nlayout\n, verr\u00e0 utilizzato il layout dell'applicazione.\n\n\nComandi della console nei moduli\n\n\nIl tuo modulo potrebbe anche dichiarare comandi, che saranno disponibili attraverso la modalit\u00e0 Console. Affinch\u00e8 l'utilit\u00e0 della riga di comando visualizzi i comandi, sar\u00e0 necessario modificare la propriet\u00e0 \nyii \\ base \\ Module :: $controllerNamespace\n, quando Yii viene eseguito in modalit\u00e0 console e puntarlo verso i namespace dei comandi.\n\n\nUn modo per ottenerlo \u00e8 testare il tipo di istanza dell'applicazione Yii nel metodo \ninit()\n del modulo:\n\n\npublic function init(){\n\n    parent::init();\n    if (Yii::$app instanceof \\yii\\console\\Application) {\n        $this-\ncontrollerNamespace = 'app\\modules\\forum\\commands';\n    }\n}\n\n\n\nI tuoi comandi saranno quindi disponibili dalla riga di comando utilizzando il seguente percorso:\n\n\nyii \nmodule_id\n/\ncommand\n/\nsub_command\n\n\n\n\nUtilizzo dei moduli\n\n\nPer utilizzare un modulo in un'applicazione, \u00e8 sufficiente configurare l'applicazione elencando il modulo nella propriet\u00e0 \nyii \\ base \\ Application :: modules\n dell'applicazione. Il seguente codice nella configurazione dell'applicazione utilizza il modulo \nforum\n:\n\n\n[\n    'modules' =\n [\n        'forum' =\n [\n            'class' =\n 'app\\modules\\forum\\Module',\n            // ... other configurations for the module ...\n        ],\n    ],\n]\n\n\n\nLa propriet\u00e0 \nyii \\ base \\ Application :: modules\n accetta una serie di configurazioni dei moduli. Ogni chiave dell'array rappresenta un ID modulo che identifica in modo univoco il modulo tra tutti i moduli dell'applicazione e il valore dell'array corrispondente \u00e8 una configurazione per la creazione del modulo.\n\n\nItinerari\n\n\nCome riusciamo ad accedere ai controller in un'applicazione, allora stesso modo, i percorsi vengono utilizzati per indirizzare i controller in un modulo. Una rotta per un controller all'interno di un modulo deve ininziare con l'ID modulo seguito dall'ID controller e dall'ID azione. Ad esempio, se un'applicazione utilizza un modulo denominato \nforum\n, la rotta \nforum/post/index\n rappresenterebbe l'azione \nindex\n del \npost\n controller nel modulo. Se la route contiene solo l'ID del modulo, la propriet\u00e0 \nyii \\ base \\ Module :: $defaultRoute\n, che per impostazione predefinit\u00e0 sar\u00e0 \ndefault\n, determiner\u00e0 quale controller/azione deve essere utilizzato. Ci\u00f2 significa che un percorso \nforum\n rappresenterebbe il \ndefault\ncontroller nel modulo \nforum\n.\n\n\nAccesso ai moduli\n\n\nAll'interno di un modulo, potrebbe essere spesso necessario ottenere l'istanza della classe del modulo in modo che sia possibile accedere all'ID del modulo, ai parametri del modulo, ai componenti del modulo, ecc. E' possibile farlo utilizzando la seguente dichiarazione:\n\n\n$module = MyModuleClass::getInstance();\n\n\n\ndove \nMyModuleClass\n si riferisce al nome della classe del modulo a cui sei interessato. Il metodo \ngetIstance()\n restituir\u00e0 l'istanza attualmente richiesta della classe del modulo. Se il modulo non viene richiesto, il metodo restituir\u00e0 \nnull\n. Si noti che non si desidera creare manualmente una nuova istanza della classe modulo perch\u00e8 sar\u00e0 diversa da quella creata da Yii in risposta a una richiesta.\n\n\n\n\nNote\n\n\nQuando si sviluppa un modulo, non si deve presumente che il modulo utilizzer\u00e0 un ID fisso. Questo perch\u00e8 un modulo pu\u00f2 essere associato a un ID arbitrario quando viene utilizzato in un'applicazione o in un altro modulo. Per ottenere l'ID del modulo, \u00e8 necessario utilizzare l'approccio descritto in precedenza per ottenere prima l'istanza del modulo, e quindi ottenere l'ID tramite \n$module-\nid\n.\n\n\n\n\nPuoi anche accedere all'istanza di un modulo usando i seguenti approcci:\n\n\n// get the child module whose ID is \"forum\"\n$module = \\Yii::$app-\ngetModule('forum');\n\n// get the module to which the currently requested controller belongs\n$module = \\Yii::$app-\ncontroller-\nmodule;\n\n\n\nIl primo approccio \u00e8 utile solo quando si conosce l'ID del modulo, mentre il secondo approccio \u00e8 pi\u00f9 utile quando si conoscono i controller richiesti.\n\n\nUna volta ottenuta l'istanza del modulo, \u00e8 possibile accedere ai parametri e ai componenti registrati con il modulo.\nPer esempio:\n\n\n$maxPostCount = $module-\nparams['maxPostCount'];\n\n\n\nModuli di bootstrap\n\n\nAlcuni moduli potrebbero essere eseguiti per ogni richiesta. Il modulo di debug \u00e8 un esempio. Per fare ci\u00f2, dobbiamo elencare gli ID di tali moduli nella propriet\u00e0 \nbootstrap\n dell'applicazione.\n\n\nAd esempio, la seguente configurazione dell'applicazione assicura che il modulo \ndebug\n sia sempre caricato:\n\n\n[\n    'bootstrap' =\n [\n        'debug',\n    ],\n\n    'modules' =\n [\n        'debug' =\n 'yii\\debug\\Module',\n    ],\n]\n\n\n\nModuli annidati\n\n\nI moduli possono essere annidati a livelli illimitati. Cio\u00e8, un modulo pu\u00f2 contenere un altro modulo che pu\u00f2 contenere a sua volta un altro modulo. Chiamiamo il precedente \"modulo padre\" mentre il secondo \"modulo figlio\". I moduli figli devono essere dichiarati nella propriet\u00e0 \nyii \\ base \\ Module :: modules\n dei rispettivi moduli genitori. \n\n\nPer esempio:\n\n\nnamespace app\\modules\\forum;\n\nclass Module extends \\yii\\base\\Module{\n\n    public function init(){\n\n        parent::init();\n\n        $this-\nmodules = [\n            'admin' =\n [\n                // you should consider using a shorter namespace here!\n                'class' =\n 'app\\modules\\forum\\modules\\admin\\Module',\n            ],\n        ];\n    }\n}\n\n\n\nPer un controller al'interno di un modulo nidificato, la sua route dovrebbe includere gli ID di tutti i suoi moduli antenati. Ad esempio, la rotta \nforum/admin/dashboard/index\n rappresenta l'azione \nindex\n del controller \ndashboard\n nel modulo \nadmin\n che \u00e8 un modulo figlio del modulo \nforum\n.\n\n\n\n\nNote\n\n\nil metodo \ngetModule()\n restituisce solo il modulo figlio che appartiene direttamente al suo genitore. La propriet\u00e0 \nyii \\ base \\ Application :: $loadedModules\n mantiene un elenco di moduli caricati, compresi i bambini diretti e quelli nidificati, indicizzati dai loro nomi di classe.\n\n\n\n\nAccessi ai componenti all'interno dei moduli\n\n\nLa versione 2.0.13 supporta l'attraversamento dell'albero. Ci\u00f2 consente agli sviluppatori di fare riferimento a componenti (applicazioni) tramite il localizzatore di servizio che \u00e8 il loro modulo. Ci\u00f2 significa che \u00e8 preferibile utilizzare \n$module-\nget('db')\n oltre \nYii::$app-\nget('db')\n. L'utente di un modulo \u00e8 in grado di specificare un componente specifico da utilizzare per il modulo nel caso sia necessario un componente diverso (configurazione).\n\n\nAd esempio, considera questa configurazione dell'applicazione:\n\n\n'components' =\n [\n    'db' =\n [\n        'tablePrefix' =\n 'main_',\n    ],\n],\n'modules' =\n [\n    'mymodule' =\n [\n        'components' =\n [\n            'db' =\n [\n                'tablePrefix' =\n 'module_',\n            ],\n        ],\n    ],\n],\n\n\n\nLe tabelle del database dell'applicazione saranno precedute da prefisso con \nmain_\n tutte le tabelle dei moduli \nmodule_\n.",
            "title": "Moduli"
        },
        {
            "location": "/application-structure/sub-modules/#moduli-modules",
            "text": "I moduli sono unit\u00e0 software autonome costituite da modelli, viste, controller e altri componenti di supporto. Gli utenti finali possono accedere ai controller di un modulo quando \u00e8 installato nell'applicazione. Per questi motivi, i moduli sono spesso visti come mini-applicazioni. I moduli differiscono dalle applicazioni in quanto i moduli non possono essere distribuiti da soli e devono risiedere all'interno dell'applicazioni.",
            "title": "Moduli  (Modules)"
        },
        {
            "location": "/application-structure/sub-modules/#creazione-di-moduli",
            "text": "Un modulo \u00e8 organizzato come una directory chiamata  yii \\ base \\ Module :: base Path  del modulo. All'interno della directory, ci sono sub-directory, ad esempio  controllers , models , views , che detengono i controller, i modelli, le viste e altro codice, proprio come in un'applicazione. L'esempio seguente mostra il contenuto all'interno di un modulo:  forum/\n    Module.php                   the module class file\n    controllers/                 containing controller class files\n        DefaultController.php    the default controller class file\n    models/                      containing model class files\n    views/                       containing controller view and layout files\n        layouts/                 containing layout view files\n        default/                 containing view files for DefaultController\n            index.php            the index view file",
            "title": "Creazione di moduli"
        },
        {
            "location": "/application-structure/sub-modules/#classi-del-modulo",
            "text": "Ogni modulo dovrebbe avere una classe di modulo univoca che si estende dai  yii \\ base \\ Module . La classe dovrebbe trovarsi direttamente sotto il modulo  yii \\ base \\ Module :: basePath  e dovrebbe essere caricabile automaticamente. Quando si accede a un modulo, verr\u00e0 creata una singola istanza della classe modulo corrispondente. Come le istanze dell'applicazione, le istanze del modulo vengono utilizzate per condividere dati e componenti per il codice all'interno dei moduli.  Quello che segue \u00e8 un esempio di come pu\u00f2 essere una classe di modulo:  namespace app\\modules\\forum;\n\nclass Module extends \\yii\\base\\Module{\n\n    public function init(){\n\n        parent::init();\n\n        $this- params['foo'] = 'bar';\n        // ...  other initialization code ...\n    }\n}  Se il metodo  init()  contiene molto codice che inizializza la propriet\u00e0 del modulo, \u00e8 possibile salvarle anche in termini di configurazione e caricarlo con il seguente codice in  init() :  public function init(){\n\n    parent::init();\n    // initialize the module with the configuration loaded from config.php\n    \\Yii::configure($this, require __DIR__ . '/config.php');\n}  dove il file di configurazione  config.php  pu\u00f2 contenere il seguente contenuto, simile a quello in una configurazione dell'applicazione.  ?php\nreturn [\n    'components' =  [\n        // list of component configurations\n    ],\n    'params' =  [\n        // list of parameters\n    ],\n];",
            "title": "Classi del modulo"
        },
        {
            "location": "/application-structure/sub-modules/#controller-nei-moduli",
            "text": "Quando si creano i controller in un modulo, una convenzione consiste nel mettere le classi controller sotto il namespace  controllers . Ci\u00f2 significa anche che i file di classe del controller devono essere inseriti nella directory  controller  all'interno del modulo  yii \\ base \\ Module :: basePath . Ad esempio, per creare un controller  post  nel modulo  forum  mostrato nell'ultima sottosezione, \u00e8 necessario dichiarare la classe controller come segue:  namespace app\\modules\\forum\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    // ...\n\n}  E' possibile personalizzare i namespace delle classi controller configurando la propriet\u00e0  yii \\ base \\ Module :: $controllerNamespace . Nel caso in cui alcuni controller si trovino al di fuori di questi namespaces, \u00e8 possibile renderli accessibili configurando la propriet\u00e0  yii \\ base \\ Module :: $controllerMap , in modo simile a ci\u00f2 che si fa in un'applicazione.",
            "title": "Controller nei moduli"
        },
        {
            "location": "/application-structure/sub-modules/#viste-nei-moduli",
            "text": "Le viste in un modulo dovrebbero essere inserite nella directory  views  all'interno del modulo  yii \\ base \\ Module :: basePath . Per le viste visualizzate da un controller nel modulo, devono essere inserite nella directory  views/ControllerID , dove  ControllerID  fa riferimento all'ID del controller. Ad esempio, se la classe controller \u00e8  PostController , la directory dpvrebbe trovarsi in  views/post  all'interno del modulo  yii \\ base \\ Module :: basePath .  Un modulo pu\u00f2 specificare un layout che viene applicato alle viste visualizzate dai controller del modulo. Il layout deve essere inserito nella directory  views/layouts  per impostazione predefinita e \u00e8 necessario configurare la propriet\u00e0  yii \\ base \\ Module :: $layout  in modo che punti al nome del layout. Se non si configura la propriet\u00e0  layout , verr\u00e0 utilizzato il layout dell'applicazione.",
            "title": "Viste nei moduli"
        },
        {
            "location": "/application-structure/sub-modules/#comandi-della-console-nei-moduli",
            "text": "Il tuo modulo potrebbe anche dichiarare comandi, che saranno disponibili attraverso la modalit\u00e0 Console. Affinch\u00e8 l'utilit\u00e0 della riga di comando visualizzi i comandi, sar\u00e0 necessario modificare la propriet\u00e0  yii \\ base \\ Module :: $controllerNamespace , quando Yii viene eseguito in modalit\u00e0 console e puntarlo verso i namespace dei comandi.  Un modo per ottenerlo \u00e8 testare il tipo di istanza dell'applicazione Yii nel metodo  init()  del modulo:  public function init(){\n\n    parent::init();\n    if (Yii::$app instanceof \\yii\\console\\Application) {\n        $this- controllerNamespace = 'app\\modules\\forum\\commands';\n    }\n}  I tuoi comandi saranno quindi disponibili dalla riga di comando utilizzando il seguente percorso:  yii  module_id / command / sub_command",
            "title": "Comandi della console nei moduli"
        },
        {
            "location": "/application-structure/sub-modules/#utilizzo-dei-moduli",
            "text": "Per utilizzare un modulo in un'applicazione, \u00e8 sufficiente configurare l'applicazione elencando il modulo nella propriet\u00e0  yii \\ base \\ Application :: modules  dell'applicazione. Il seguente codice nella configurazione dell'applicazione utilizza il modulo  forum :  [\n    'modules' =  [\n        'forum' =  [\n            'class' =  'app\\modules\\forum\\Module',\n            // ... other configurations for the module ...\n        ],\n    ],\n]  La propriet\u00e0  yii \\ base \\ Application :: modules  accetta una serie di configurazioni dei moduli. Ogni chiave dell'array rappresenta un ID modulo che identifica in modo univoco il modulo tra tutti i moduli dell'applicazione e il valore dell'array corrispondente \u00e8 una configurazione per la creazione del modulo.",
            "title": "Utilizzo dei moduli"
        },
        {
            "location": "/application-structure/sub-modules/#itinerari",
            "text": "Come riusciamo ad accedere ai controller in un'applicazione, allora stesso modo, i percorsi vengono utilizzati per indirizzare i controller in un modulo. Una rotta per un controller all'interno di un modulo deve ininziare con l'ID modulo seguito dall'ID controller e dall'ID azione. Ad esempio, se un'applicazione utilizza un modulo denominato  forum , la rotta  forum/post/index  rappresenterebbe l'azione  index  del  post  controller nel modulo. Se la route contiene solo l'ID del modulo, la propriet\u00e0  yii \\ base \\ Module :: $defaultRoute , che per impostazione predefinit\u00e0 sar\u00e0  default , determiner\u00e0 quale controller/azione deve essere utilizzato. Ci\u00f2 significa che un percorso  forum  rappresenterebbe il  default controller nel modulo  forum .",
            "title": "Itinerari"
        },
        {
            "location": "/application-structure/sub-modules/#accesso-ai-moduli",
            "text": "All'interno di un modulo, potrebbe essere spesso necessario ottenere l'istanza della classe del modulo in modo che sia possibile accedere all'ID del modulo, ai parametri del modulo, ai componenti del modulo, ecc. E' possibile farlo utilizzando la seguente dichiarazione:  $module = MyModuleClass::getInstance();  dove  MyModuleClass  si riferisce al nome della classe del modulo a cui sei interessato. Il metodo  getIstance()  restituir\u00e0 l'istanza attualmente richiesta della classe del modulo. Se il modulo non viene richiesto, il metodo restituir\u00e0  null . Si noti che non si desidera creare manualmente una nuova istanza della classe modulo perch\u00e8 sar\u00e0 diversa da quella creata da Yii in risposta a una richiesta.   Note  Quando si sviluppa un modulo, non si deve presumente che il modulo utilizzer\u00e0 un ID fisso. Questo perch\u00e8 un modulo pu\u00f2 essere associato a un ID arbitrario quando viene utilizzato in un'applicazione o in un altro modulo. Per ottenere l'ID del modulo, \u00e8 necessario utilizzare l'approccio descritto in precedenza per ottenere prima l'istanza del modulo, e quindi ottenere l'ID tramite  $module- id .   Puoi anche accedere all'istanza di un modulo usando i seguenti approcci:  // get the child module whose ID is \"forum\"\n$module = \\Yii::$app- getModule('forum');\n\n// get the module to which the currently requested controller belongs\n$module = \\Yii::$app- controller- module;  Il primo approccio \u00e8 utile solo quando si conosce l'ID del modulo, mentre il secondo approccio \u00e8 pi\u00f9 utile quando si conoscono i controller richiesti.  Una volta ottenuta l'istanza del modulo, \u00e8 possibile accedere ai parametri e ai componenti registrati con il modulo.\nPer esempio:  $maxPostCount = $module- params['maxPostCount'];",
            "title": "Accesso ai moduli"
        },
        {
            "location": "/application-structure/sub-modules/#moduli-di-bootstrap",
            "text": "Alcuni moduli potrebbero essere eseguiti per ogni richiesta. Il modulo di debug \u00e8 un esempio. Per fare ci\u00f2, dobbiamo elencare gli ID di tali moduli nella propriet\u00e0  bootstrap  dell'applicazione.  Ad esempio, la seguente configurazione dell'applicazione assicura che il modulo  debug  sia sempre caricato:  [\n    'bootstrap' =  [\n        'debug',\n    ],\n\n    'modules' =  [\n        'debug' =  'yii\\debug\\Module',\n    ],\n]",
            "title": "Moduli di bootstrap"
        },
        {
            "location": "/application-structure/sub-modules/#moduli-annidati",
            "text": "I moduli possono essere annidati a livelli illimitati. Cio\u00e8, un modulo pu\u00f2 contenere un altro modulo che pu\u00f2 contenere a sua volta un altro modulo. Chiamiamo il precedente \"modulo padre\" mentre il secondo \"modulo figlio\". I moduli figli devono essere dichiarati nella propriet\u00e0  yii \\ base \\ Module :: modules  dei rispettivi moduli genitori.   Per esempio:  namespace app\\modules\\forum;\n\nclass Module extends \\yii\\base\\Module{\n\n    public function init(){\n\n        parent::init();\n\n        $this- modules = [\n            'admin' =  [\n                // you should consider using a shorter namespace here!\n                'class' =  'app\\modules\\forum\\modules\\admin\\Module',\n            ],\n        ];\n    }\n}  Per un controller al'interno di un modulo nidificato, la sua route dovrebbe includere gli ID di tutti i suoi moduli antenati. Ad esempio, la rotta  forum/admin/dashboard/index  rappresenta l'azione  index  del controller  dashboard  nel modulo  admin  che \u00e8 un modulo figlio del modulo  forum .   Note  il metodo  getModule()  restituisce solo il modulo figlio che appartiene direttamente al suo genitore. La propriet\u00e0  yii \\ base \\ Application :: $loadedModules  mantiene un elenco di moduli caricati, compresi i bambini diretti e quelli nidificati, indicizzati dai loro nomi di classe.",
            "title": "Moduli annidati"
        },
        {
            "location": "/application-structure/sub-modules/#accessi-ai-componenti-allinterno-dei-moduli",
            "text": "La versione 2.0.13 supporta l'attraversamento dell'albero. Ci\u00f2 consente agli sviluppatori di fare riferimento a componenti (applicazioni) tramite il localizzatore di servizio che \u00e8 il loro modulo. Ci\u00f2 significa che \u00e8 preferibile utilizzare  $module- get('db')  oltre  Yii::$app- get('db') . L'utente di un modulo \u00e8 in grado di specificare un componente specifico da utilizzare per il modulo nel caso sia necessario un componente diverso (configurazione).  Ad esempio, considera questa configurazione dell'applicazione:  'components' =  [\n    'db' =  [\n        'tablePrefix' =  'main_',\n    ],\n],\n'modules' =  [\n    'mymodule' =  [\n        'components' =  [\n            'db' =  [\n                'tablePrefix' =  'module_',\n            ],\n        ],\n    ],\n],  Le tabelle del database dell'applicazione saranno precedute da prefisso con  main_  tutte le tabelle dei moduli  module_ .",
            "title": "Accessi ai componenti all'interno dei moduli"
        },
        {
            "location": "/application-structure/sub-filters/",
            "text": "Filtri (filters)\n\n\nI filtri sono oggetti che vengono eseguiti prima e / o dopo le azioni del controllore. Ad esempio, un filtro di controllo dell'accesso pu\u00f2 essere eseguito dalle azioni per garantire che sia loro consentito l'accesso da parte di determinati utenti finali; un filtro di compressione del contenuto pu\u00f2 essere eseguito dopo le azioni per comptrimere il contenuto della risposta prima di inviarlo agli utenti finali.\n\n\nUn filtro pu\u00f2 consistere in un pre-filtro (logica di filtraggio applicata prima delle azioni) e / o un post-filtro (logica applicata dopo le azioni).\n\n\nUtilizzando i filtri\n\n\nI filtri ahnno un comportamente abbastanza particolare. Pertanto, l'uso dei filtri \u00e8 uguale all'utilizzo dei \"behaviors\".E' possibile dichiarare i filtri di una classe controller sovrascrivendo il suo metodo \nbehaviors()\n come il seguente:\n\n\npublic function behaviors(){\n\n    return [\n        [\n            'class' =\n 'yii\\filters\\HttpCache',\n            'only' =\n ['index', 'view'],\n            'lastModified' =\n function ($action, $params) {\n                $q = new \\yii\\db\\Query();\n                return $q-\nfrom('user')-\nmax('updated_at');\n            },\n        ],\n    ];\n}\n\n\n\nPer impostazione predefinita, i filtri dichiarati in una classe controller verranno applicati a tutte le azioni in quel controller. Tuttavia, \u00e8 possibile specificare esplicitamente a quali azioni applicare il filtro configurando la propriet\u00e0 \nonly\n. Nell'esempio soprastante, il filtro \nHttpCache\n si applica solo alle azioni \nindex\n e \nview\n. E' anche possibile configurare la propriet\u00e0 \nexcept\n per mettere in blacklist alcune azioni dell'essere filtrate.\n\n\noltre ai controller, puoi anche dichiarare i filtri in un modulo o in un'applicazione. Quando lo fa, i filtri verranno applicate tutte le azioni di controllo che appartengono a tale modulo o applicazione, a meno che non si configurano i filtri \"only\" e \"except\" come descritto sopra.\n\n\n\n\nWarning\n\n\nQuando si dichiara filtri in moduli o applicazioni, \u00e8 necessario utilizzare percorsi invece di ID di azione nelle propriet\u00e0 \nonly\n e \nexcept\n. Questo perch\u00e8 gli ID d'azione da solo non possono specificare completamente le azioni nell'ambito di un modulo o di un'applicazione.\n\n\n\n\nQuando pi\u00f9 filtri sono configurati per una singola azione, vengnono applicati in base alle regole descritte di seguito:\n\n\n\n\nPre-filtraggio\n\n\nApplicare i filtri dichiarati nell'applicazione nell'ordine in cui sono elencati \nbehaviors()\n.\n\n\nApplicare i filtri dichiarati nel modulo nell'ordine in cui sono elencati \nbehaviors()\n.\n\n\nApplicare i filtri dichiarati nel controller nell'ordine in cui sono elencati \nbehaviors()\n.\n\n\nSe uno qualsiasi dei filtri annulla l'esecuzione dell'azione, i filtri (prefiltri e post-filtri) non verranno applicati.\n\n\n\n\n\n\nEsecuzione dell'azione de passa per il pre-filtro.\n\n\nPost-filtraggio\n\n\nApplicare i filtri dichiarati nel controller nell'ordine inverso in cui sono elencati \nbehaviors()\n.\n\n\nApplicare i filtri dichiarati nel modulo nell'ordine inverso in cui sono elencati \nbehaviors()\n.\n\n\nApplicare i filtri dichiarati nell'applicazione nell'ordine inverso in cui sono elencati \nbehaviors()\n.\n\n\n\n\n\n\n\n\nCreazione di filtri\n\n\nPer creare un nuovo filtro azione, dobbiamo estenderlo da \nyii \\ base \\ ActionFilter\n e sovrascrivi i metodi \nbeforeAction()\n e / o \nafterAction()\n. Il primo verr\u00e0 eseguito prima dell'esecuzione di un'azione mentre il secondo dopo l'esecuzione di un'azione. Il valore di ritorno di \nbeforeAction()\n determina se un'azione deve essere eseguita o meno. Se il valore \u00e8 \nfalse\n, i filtri dopo questo verranno saltati e l'azione non verr\u00e0 eseguita.\n\n\nL'esempio seguente mostra un filtro che registra il tempo di esecuzione dell'azione:\n\n\nnamespace app\\components;\n\nuse Yii;\nuse yii\\base\\ActionFilter;\n\nclass ActionTimeFilter extends ActionFilter{\n\n    private $_startTime;\n\n    public function beforeAction($action){\n\n        $this-\n_startTime = microtime(true);\n        return parent::beforeAction($action);\n    }\n\n    public function afterAction($action, $result){\n\n        $time = microtime(true) - $this-\n_startTime;\n        Yii::trace(\"Action '{$action-\nuniqueId}' spent $time second.\");\n        return parent::afterAction($action, $result);\n    }\n}\n\n\n\nFiltri principali\n\n\nYii fornisce un set di filtri comunemente usati, trovati principalmente sotto il namespace \nyii\\filters\n. Di seguit, introdurremo brevemente questi filtri.\n\n\nControllo all'accesso\n\n\nAccessControl\n fornisce un semplice controllo degli accessi basato su un insieme di regole. In particolare, prima che un'azione venga eseguita, AccessControl esaminer\u00e0 le regole elencate e trover\u00e0 il primo che corrisponde alle variabili di contesto correnti (come l'indirizzo IP dell'utente, lo stato di accesso dell'utente, ecc..). La regola di corrispondenza determiner\u00e0 se consentire o negare l'esecuzione dell'azione richiesta. Se nessuna regola corrisponde, l'accesso verr\u00e0 negato.\n\n\nL'esempio seguente mostra come consentire agli utenti autenticati di accedere alle azione \ncreate\n e \nupdate\n, mentre negando tutti gli altri utenti di accedere a queste due azioni.\n\n\nuse yii\\filters\\AccessControl;\n\npublic function behaviors(){\n\n    return [\n        'access' =\n [\n            'class' =\n AccessControl::className(),\n            'only' =\n ['create', 'update'],\n            'rules' =\n [\n                // allow authenticated users\n                [\n                    'allow' =\n true,\n                    'roles' =\n ['@'],\n                ],\n                // everything else is denied by default\n            ],\n        ],\n    ];\n}\n\n\n\nFiltri del metodo di autenticazione\n\n\nI filtri del metodo di autenticazione vengono utilizzati per autenticare un utente utilizzando vari metodi, come \nHTTP Basic Auth\n, \nOAuth 2\n. Queste classi di filtri sono tutte sotto il namespace \nyii\\filters\\auth\n.\n\n\nL'esempio seguente mostra come utilizzare \nyii \\ filters \\ auth \\ HttpBasicAuth\n per autenticare un utente utilizzando un token di accesso basato sul metodo di autenticazione HTTP di base. Si noti che affinch\u00e8 funzioni, la classe di identit\u00e0 dell'utente deve implementare il metodo \nfindIdentityByAccessToken()\n.\n\n\nuse yii\\filters\\auth\\HttpBasicAuth;\n\npublic function behaviors(){\n\n    return [\n        'basicAuth' =\n [\n            'class' =\n HttpBasicAuth::className(),\n        ],\n    ];\n}\n\n\n\nI filtri del metodo di autenticazione sono comunemente usati nell'implementazione delle API Restful.\n\n\nContentNegotiator\n\n\nContentNegotiator\n supporta la negoziazione del formato di risposta e la negoziazione della lingua dell'applicazione. Prover\u00e0 a determinare il formato di risposta e / o la lingua esaminando i parametri \nGET\n e l'intestazione HTTP \nAccept\n.\n\n\nNell'esempio seguente, ContentNegotiator \u00e8 configurato per supportare i formati di risposta JSON e XML e le lingue inglese (Stati Uniti) e tedesca.\n\n\nuse yii\\filters\\ContentNegotiator;\nuse yii\\web\\Response;\n\n\npublic function behaviors(){\n\n    return [\n        [\n            'class' =\n ContentNegotiator::className(),\n            'formats' =\n [\n                'application/json' =\n Response::FORMAT_JSON,\n                'application/xml' =\n Response::FORMAT_XML,\n            ],\n            'languages' =\n [\n                'en-US',\n                'de',\n            ],\n        ],\n    ];\n}\n\n\n\nSpesso i formati e le lingue di risposta devono essere determinati molto prima durante il ciclo di vita dell'applicazione. Per questo motivo, ContentNegotiator \u00e8 progettato in modo tale da poter essere utilizzato anche come componente di bootstrap oltre a essere utilizzato come filtro. Ad esempio, puoi configurarlo nella configurazione dell'applicazione come segue:\n\n\nuse yii\\filters\\ContentNegotiator;\nuse yii\\web\\Response;\n\n[\n    'bootstrap' =\n [\n        [\n            'class' =\n ContentNegotiator::className(),\n            'formats' =\n [\n                'application/json' =\n Response::FORMAT_JSON,\n                'application/xml' =\n Response::FORMAT_XML,\n            ],\n            'languages' =\n [\n                'en-US',\n                'de',\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nNote\n\n\nNel caso in cui il tipo di contenuto e la lingua preferiti non possano essere determinati da una richiesta, verranno utilizzati il primo formato e la lingua elencati nei campi \nformats\n e \nlanguages\n.\n\n\n\n\nHttpCache\n\n\nHttpCache\n implementa il caching sul lato client utilizzando le intestazioni HTTP \nLast-Modified\n e \nEtag\n.\nPer esempio:\n\n\nuse yii\\filters\\HttpCache;\n\npublic function behaviors(){\n\n    return [\n        [\n            'class' =\n HttpCache::className(),\n            'only' =\n ['index'],\n            'lastModified' =\n function ($action, $params) {\n                $q = new \\yii\\db\\Query();\n                return $q-\nfrom('user')-\nmax('updated_at');\n            },\n        ],\n    ];\n}\n\n\n\nPageCache\n\n\nPageCache\n implementa il catching lato server di pagine intere. Nell'esempio seguente, PageCache viene applicato all'azione \nindex\n per memorizzare nella cache l'intera pagina per un massimo di 60 secondi o finch\u00e8 il conteggio delle voci nella tabella \npost\n non cambia. Memorizza anche diverse versioni della pagina a seconda della lingua dell'applicazione scelta.\n\n\nuse yii\\filters\\PageCache;\nuse yii\\caching\\DbDependency;\n\npublic function behaviors(){\n\n    return [\n        'pageCache' =\n [\n            'class' =\n PageCache::className(),\n            'only' =\n ['index'],\n            'duration' =\n 60,\n            'dependency' =\n [\n                'class' =\n DbDependency::className(),\n                'sql' =\n 'SELECT COUNT(*) FROM post',\n            ],\n            'variations' =\n [\n                \\Yii::$app-\nlanguage,\n            ]\n        ],\n    ];\n}\n\n\n\nRateLimiter\n\n\nRateLimiter\n implementa un algoritmo di limitazione della velocit\u00e0 basato sull'algoritmo \nleaky bucket\n. Viene principalmente utilizzato nell'implementazione di ApiRESTful.\n\n\nVerbFilter\n\n\nVerbFilter\n controlla se i metodi di richiesta HTTP sono consentiti dalle azioni richieste. Se non \u00e8 consentito, generer\u00e0 un'eccezione HTTP 405. Nell'esempio seguente, VerbFIlter viene dichiarato per specificare un set tipico di metodi di richiesta consentiti per le azioni CRUD.\n\n\nuse yii\\filters\\VerbFilter;\n\npublic function behaviors(){\n\n    return [\n        'verbs' =\n [\n            'class' =\n VerbFilter::className(),\n            'actions' =\n [\n                'index'  =\n ['get'],\n                'view'   =\n ['get'],\n                'create' =\n ['get', 'post'],\n                'update' =\n ['get', 'put', 'post'],\n                'delete' =\n ['post', 'delete'],\n            ],\n        ],\n    ];\n}\n\n\n\nCors\n\n\nCondivisione delle risorse tra origini \nCORS\n \u00e8 un meccanismo che consente a molte risorse (ad es. Caratters, JavaScript, ecc..). Su una pagina Web di essere richieste da un altro dominio al di fuori del dominio da cui proviene la risorsa. In particolare, le chiamate AJAX di JavaScript possono utilizzare il meccanismo XMLHttpRequest. Tali richieste \"interdominio\" sarebbero altrimenti vietate dai browser Web, secondo la stessa politica di sicurezza dell'origine. CORS definisce un modo in cui il browser e il server possono interagire per determinare se consentire o meno la richiesta di origine incrociata.\n\n\nIl \nfiltro Cors\n deve essere definito prima dei filtri di autenticazione / autorizzazione per assicurarsi che le intestazioni CORS vengano sempre inviate.\n\n\nuse yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n\n    return ArrayHelper::merge([\n        [\n            'class' =\n Cors::className(),\n        ],\n    ], parent::behaviors());\n}\n\n\n\nControllare anche la sezione sui controller REST se si desidera aggiungere il filtro CORS a una classe \nyii \\ rest \\ ActiveController\n nella propria API.\n\n\nIl filtraggio Cors pu\u00f2 essere ottimizzato usando la propriet\u00e0 \n$Cors\n.\n\n\n\n\ncors['Origin']\n: array utilizzato per definire le origini consentite. Pu\u00f2 essere \n['*']\n(tutti) o \n['http://www.myserver.net', 'http://www.myotherserver.com']\n. Predefinito a \n['*']\n.\n\n\ncors['Access-Control-Request-Method']\n: rappresenta un array di verbi che sono consentiti da Yii come \n['GET', 'OPTIONS', 'HEAD']\n. L'array predefinito \u00e8 \n['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS']\n.\n\n\ncors['Access-Control-Request-Headers']\n: matrice di intestazioni consentite da Yii. Possono essere \n['*']\n tutte le intestazioni o specifiche \n['X-Request-With']\n. Predefinito a \n['*']\n.\n\n\ncors['Access-Control-Allow-Credentials']\n: questa regola controlla se la richiesta corrente pu\u00f2 essere fatta usando le credenziali. Pu\u00f2 essere \ntrue\n, \nfalse\n o \nnull\n(non impostato). Predefinito a \nnull\n.\n\n\ncors['Access-Control-Max-Age']\n: definisce la durata della richiesta pre-flight. Il valore predefinito \u00e8 \n86400\n.\n\n\n\n\nAd esempio, consentendo CORS come URL di origine (\nhttp://www.myserver.net\n) con il metodo \nGET\n, \nHEAD\n e \nOPTIONS\n:\n\n\nuse yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n    return ArrayHelper::merge([\n        [\n            'class' =\n Cors::className(),\n            'cors' =\n [\n                'Origin' =\n ['http://www.myserver.net'],\n                'Access-Control-Request-Method' =\n ['GET', 'HEAD', 'OPTIONS'],\n            ],\n        ],\n    ], parent::behaviors());\n}\n\n\n\nE' possibile ottimizzare le intestazioni CORS sostituendo i parametri predefiniti in base all'azione. Ad esempio aggiungendo \nAccess-Control-Allow-Credentials\n per l'azione di \nlogin\n potrebbe essere fatto in questo modo:\n\n\nuse yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n\n    return ArrayHelper::merge([\n        [\n            'class' =\n Cors::className(),\n            'cors' =\n [\n                'Origin' =\n ['http://www.myserver.net'],\n                'Access-Control-Request-Method' =\n ['GET', 'HEAD', 'OPTIONS'],\n            ],\n            'actions' =\n [\n                'login' =\n [\n                    'Access-Control-Allow-Credentials' =\n true,\n                ]\n            ]\n        ],\n    ], parent::behaviors());\n}",
            "title": "Filtri"
        },
        {
            "location": "/application-structure/sub-filters/#filtri-filters",
            "text": "I filtri sono oggetti che vengono eseguiti prima e / o dopo le azioni del controllore. Ad esempio, un filtro di controllo dell'accesso pu\u00f2 essere eseguito dalle azioni per garantire che sia loro consentito l'accesso da parte di determinati utenti finali; un filtro di compressione del contenuto pu\u00f2 essere eseguito dopo le azioni per comptrimere il contenuto della risposta prima di inviarlo agli utenti finali.  Un filtro pu\u00f2 consistere in un pre-filtro (logica di filtraggio applicata prima delle azioni) e / o un post-filtro (logica applicata dopo le azioni).",
            "title": "Filtri (filters)"
        },
        {
            "location": "/application-structure/sub-filters/#utilizzando-i-filtri",
            "text": "I filtri ahnno un comportamente abbastanza particolare. Pertanto, l'uso dei filtri \u00e8 uguale all'utilizzo dei \"behaviors\".E' possibile dichiarare i filtri di una classe controller sovrascrivendo il suo metodo  behaviors()  come il seguente:  public function behaviors(){\n\n    return [\n        [\n            'class' =  'yii\\filters\\HttpCache',\n            'only' =  ['index', 'view'],\n            'lastModified' =  function ($action, $params) {\n                $q = new \\yii\\db\\Query();\n                return $q- from('user')- max('updated_at');\n            },\n        ],\n    ];\n}  Per impostazione predefinita, i filtri dichiarati in una classe controller verranno applicati a tutte le azioni in quel controller. Tuttavia, \u00e8 possibile specificare esplicitamente a quali azioni applicare il filtro configurando la propriet\u00e0  only . Nell'esempio soprastante, il filtro  HttpCache  si applica solo alle azioni  index  e  view . E' anche possibile configurare la propriet\u00e0  except  per mettere in blacklist alcune azioni dell'essere filtrate.  oltre ai controller, puoi anche dichiarare i filtri in un modulo o in un'applicazione. Quando lo fa, i filtri verranno applicate tutte le azioni di controllo che appartengono a tale modulo o applicazione, a meno che non si configurano i filtri \"only\" e \"except\" come descritto sopra.   Warning  Quando si dichiara filtri in moduli o applicazioni, \u00e8 necessario utilizzare percorsi invece di ID di azione nelle propriet\u00e0  only  e  except . Questo perch\u00e8 gli ID d'azione da solo non possono specificare completamente le azioni nell'ambito di un modulo o di un'applicazione.   Quando pi\u00f9 filtri sono configurati per una singola azione, vengnono applicati in base alle regole descritte di seguito:   Pre-filtraggio  Applicare i filtri dichiarati nell'applicazione nell'ordine in cui sono elencati  behaviors() .  Applicare i filtri dichiarati nel modulo nell'ordine in cui sono elencati  behaviors() .  Applicare i filtri dichiarati nel controller nell'ordine in cui sono elencati  behaviors() .  Se uno qualsiasi dei filtri annulla l'esecuzione dell'azione, i filtri (prefiltri e post-filtri) non verranno applicati.    Esecuzione dell'azione de passa per il pre-filtro.  Post-filtraggio  Applicare i filtri dichiarati nel controller nell'ordine inverso in cui sono elencati  behaviors() .  Applicare i filtri dichiarati nel modulo nell'ordine inverso in cui sono elencati  behaviors() .  Applicare i filtri dichiarati nell'applicazione nell'ordine inverso in cui sono elencati  behaviors() .",
            "title": "Utilizzando i filtri"
        },
        {
            "location": "/application-structure/sub-filters/#creazione-di-filtri",
            "text": "Per creare un nuovo filtro azione, dobbiamo estenderlo da  yii \\ base \\ ActionFilter  e sovrascrivi i metodi  beforeAction()  e / o  afterAction() . Il primo verr\u00e0 eseguito prima dell'esecuzione di un'azione mentre il secondo dopo l'esecuzione di un'azione. Il valore di ritorno di  beforeAction()  determina se un'azione deve essere eseguita o meno. Se il valore \u00e8  false , i filtri dopo questo verranno saltati e l'azione non verr\u00e0 eseguita.  L'esempio seguente mostra un filtro che registra il tempo di esecuzione dell'azione:  namespace app\\components;\n\nuse Yii;\nuse yii\\base\\ActionFilter;\n\nclass ActionTimeFilter extends ActionFilter{\n\n    private $_startTime;\n\n    public function beforeAction($action){\n\n        $this- _startTime = microtime(true);\n        return parent::beforeAction($action);\n    }\n\n    public function afterAction($action, $result){\n\n        $time = microtime(true) - $this- _startTime;\n        Yii::trace(\"Action '{$action- uniqueId}' spent $time second.\");\n        return parent::afterAction($action, $result);\n    }\n}",
            "title": "Creazione di filtri"
        },
        {
            "location": "/application-structure/sub-filters/#filtri-principali",
            "text": "Yii fornisce un set di filtri comunemente usati, trovati principalmente sotto il namespace  yii\\filters . Di seguit, introdurremo brevemente questi filtri.",
            "title": "Filtri principali"
        },
        {
            "location": "/application-structure/sub-filters/#controllo-allaccesso",
            "text": "AccessControl  fornisce un semplice controllo degli accessi basato su un insieme di regole. In particolare, prima che un'azione venga eseguita, AccessControl esaminer\u00e0 le regole elencate e trover\u00e0 il primo che corrisponde alle variabili di contesto correnti (come l'indirizzo IP dell'utente, lo stato di accesso dell'utente, ecc..). La regola di corrispondenza determiner\u00e0 se consentire o negare l'esecuzione dell'azione richiesta. Se nessuna regola corrisponde, l'accesso verr\u00e0 negato.  L'esempio seguente mostra come consentire agli utenti autenticati di accedere alle azione  create  e  update , mentre negando tutti gli altri utenti di accedere a queste due azioni.  use yii\\filters\\AccessControl;\n\npublic function behaviors(){\n\n    return [\n        'access' =  [\n            'class' =  AccessControl::className(),\n            'only' =  ['create', 'update'],\n            'rules' =  [\n                // allow authenticated users\n                [\n                    'allow' =  true,\n                    'roles' =  ['@'],\n                ],\n                // everything else is denied by default\n            ],\n        ],\n    ];\n}",
            "title": "Controllo all'accesso"
        },
        {
            "location": "/application-structure/sub-filters/#filtri-del-metodo-di-autenticazione",
            "text": "I filtri del metodo di autenticazione vengono utilizzati per autenticare un utente utilizzando vari metodi, come  HTTP Basic Auth ,  OAuth 2 . Queste classi di filtri sono tutte sotto il namespace  yii\\filters\\auth .  L'esempio seguente mostra come utilizzare  yii \\ filters \\ auth \\ HttpBasicAuth  per autenticare un utente utilizzando un token di accesso basato sul metodo di autenticazione HTTP di base. Si noti che affinch\u00e8 funzioni, la classe di identit\u00e0 dell'utente deve implementare il metodo  findIdentityByAccessToken() .  use yii\\filters\\auth\\HttpBasicAuth;\n\npublic function behaviors(){\n\n    return [\n        'basicAuth' =  [\n            'class' =  HttpBasicAuth::className(),\n        ],\n    ];\n}  I filtri del metodo di autenticazione sono comunemente usati nell'implementazione delle API Restful.",
            "title": "Filtri del metodo di autenticazione"
        },
        {
            "location": "/application-structure/sub-filters/#contentnegotiator",
            "text": "ContentNegotiator  supporta la negoziazione del formato di risposta e la negoziazione della lingua dell'applicazione. Prover\u00e0 a determinare il formato di risposta e / o la lingua esaminando i parametri  GET  e l'intestazione HTTP  Accept .  Nell'esempio seguente, ContentNegotiator \u00e8 configurato per supportare i formati di risposta JSON e XML e le lingue inglese (Stati Uniti) e tedesca.  use yii\\filters\\ContentNegotiator;\nuse yii\\web\\Response;  public function behaviors(){\n\n    return [\n        [\n            'class' =  ContentNegotiator::className(),\n            'formats' =  [\n                'application/json' =  Response::FORMAT_JSON,\n                'application/xml' =  Response::FORMAT_XML,\n            ],\n            'languages' =  [\n                'en-US',\n                'de',\n            ],\n        ],\n    ];\n}  Spesso i formati e le lingue di risposta devono essere determinati molto prima durante il ciclo di vita dell'applicazione. Per questo motivo, ContentNegotiator \u00e8 progettato in modo tale da poter essere utilizzato anche come componente di bootstrap oltre a essere utilizzato come filtro. Ad esempio, puoi configurarlo nella configurazione dell'applicazione come segue:  use yii\\filters\\ContentNegotiator;\nuse yii\\web\\Response;\n\n[\n    'bootstrap' =  [\n        [\n            'class' =  ContentNegotiator::className(),\n            'formats' =  [\n                'application/json' =  Response::FORMAT_JSON,\n                'application/xml' =  Response::FORMAT_XML,\n            ],\n            'languages' =  [\n                'en-US',\n                'de',\n            ],\n        ],\n    ],\n];   Note  Nel caso in cui il tipo di contenuto e la lingua preferiti non possano essere determinati da una richiesta, verranno utilizzati il primo formato e la lingua elencati nei campi  formats  e  languages .",
            "title": "ContentNegotiator"
        },
        {
            "location": "/application-structure/sub-filters/#httpcache",
            "text": "HttpCache  implementa il caching sul lato client utilizzando le intestazioni HTTP  Last-Modified  e  Etag .\nPer esempio:  use yii\\filters\\HttpCache;\n\npublic function behaviors(){\n\n    return [\n        [\n            'class' =  HttpCache::className(),\n            'only' =  ['index'],\n            'lastModified' =  function ($action, $params) {\n                $q = new \\yii\\db\\Query();\n                return $q- from('user')- max('updated_at');\n            },\n        ],\n    ];\n}",
            "title": "HttpCache"
        },
        {
            "location": "/application-structure/sub-filters/#pagecache",
            "text": "PageCache  implementa il catching lato server di pagine intere. Nell'esempio seguente, PageCache viene applicato all'azione  index  per memorizzare nella cache l'intera pagina per un massimo di 60 secondi o finch\u00e8 il conteggio delle voci nella tabella  post  non cambia. Memorizza anche diverse versioni della pagina a seconda della lingua dell'applicazione scelta.  use yii\\filters\\PageCache;\nuse yii\\caching\\DbDependency;\n\npublic function behaviors(){\n\n    return [\n        'pageCache' =  [\n            'class' =  PageCache::className(),\n            'only' =  ['index'],\n            'duration' =  60,\n            'dependency' =  [\n                'class' =  DbDependency::className(),\n                'sql' =  'SELECT COUNT(*) FROM post',\n            ],\n            'variations' =  [\n                \\Yii::$app- language,\n            ]\n        ],\n    ];\n}",
            "title": "PageCache"
        },
        {
            "location": "/application-structure/sub-filters/#ratelimiter",
            "text": "RateLimiter  implementa un algoritmo di limitazione della velocit\u00e0 basato sull'algoritmo  leaky bucket . Viene principalmente utilizzato nell'implementazione di ApiRESTful.",
            "title": "RateLimiter"
        },
        {
            "location": "/application-structure/sub-filters/#verbfilter",
            "text": "VerbFilter  controlla se i metodi di richiesta HTTP sono consentiti dalle azioni richieste. Se non \u00e8 consentito, generer\u00e0 un'eccezione HTTP 405. Nell'esempio seguente, VerbFIlter viene dichiarato per specificare un set tipico di metodi di richiesta consentiti per le azioni CRUD.  use yii\\filters\\VerbFilter;\n\npublic function behaviors(){\n\n    return [\n        'verbs' =  [\n            'class' =  VerbFilter::className(),\n            'actions' =  [\n                'index'  =  ['get'],\n                'view'   =  ['get'],\n                'create' =  ['get', 'post'],\n                'update' =  ['get', 'put', 'post'],\n                'delete' =  ['post', 'delete'],\n            ],\n        ],\n    ];\n}",
            "title": "VerbFilter"
        },
        {
            "location": "/application-structure/sub-filters/#cors",
            "text": "Condivisione delle risorse tra origini  CORS  \u00e8 un meccanismo che consente a molte risorse (ad es. Caratters, JavaScript, ecc..). Su una pagina Web di essere richieste da un altro dominio al di fuori del dominio da cui proviene la risorsa. In particolare, le chiamate AJAX di JavaScript possono utilizzare il meccanismo XMLHttpRequest. Tali richieste \"interdominio\" sarebbero altrimenti vietate dai browser Web, secondo la stessa politica di sicurezza dell'origine. CORS definisce un modo in cui il browser e il server possono interagire per determinare se consentire o meno la richiesta di origine incrociata.  Il  filtro Cors  deve essere definito prima dei filtri di autenticazione / autorizzazione per assicurarsi che le intestazioni CORS vengano sempre inviate.  use yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n\n    return ArrayHelper::merge([\n        [\n            'class' =  Cors::className(),\n        ],\n    ], parent::behaviors());\n}  Controllare anche la sezione sui controller REST se si desidera aggiungere il filtro CORS a una classe  yii \\ rest \\ ActiveController  nella propria API.  Il filtraggio Cors pu\u00f2 essere ottimizzato usando la propriet\u00e0  $Cors .   cors['Origin'] : array utilizzato per definire le origini consentite. Pu\u00f2 essere  ['*'] (tutti) o  ['http://www.myserver.net', 'http://www.myotherserver.com'] . Predefinito a  ['*'] .  cors['Access-Control-Request-Method'] : rappresenta un array di verbi che sono consentiti da Yii come  ['GET', 'OPTIONS', 'HEAD'] . L'array predefinito \u00e8  ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'] .  cors['Access-Control-Request-Headers'] : matrice di intestazioni consentite da Yii. Possono essere  ['*']  tutte le intestazioni o specifiche  ['X-Request-With'] . Predefinito a  ['*'] .  cors['Access-Control-Allow-Credentials'] : questa regola controlla se la richiesta corrente pu\u00f2 essere fatta usando le credenziali. Pu\u00f2 essere  true ,  false  o  null (non impostato). Predefinito a  null .  cors['Access-Control-Max-Age'] : definisce la durata della richiesta pre-flight. Il valore predefinito \u00e8  86400 .   Ad esempio, consentendo CORS come URL di origine ( http://www.myserver.net ) con il metodo  GET ,  HEAD  e  OPTIONS :  use yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n    return ArrayHelper::merge([\n        [\n            'class' =  Cors::className(),\n            'cors' =  [\n                'Origin' =  ['http://www.myserver.net'],\n                'Access-Control-Request-Method' =  ['GET', 'HEAD', 'OPTIONS'],\n            ],\n        ],\n    ], parent::behaviors());\n}  E' possibile ottimizzare le intestazioni CORS sostituendo i parametri predefiniti in base all'azione. Ad esempio aggiungendo  Access-Control-Allow-Credentials  per l'azione di  login  potrebbe essere fatto in questo modo:  use yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n\n    return ArrayHelper::merge([\n        [\n            'class' =  Cors::className(),\n            'cors' =  [\n                'Origin' =  ['http://www.myserver.net'],\n                'Access-Control-Request-Method' =  ['GET', 'HEAD', 'OPTIONS'],\n            ],\n            'actions' =  [\n                'login' =  [\n                    'Access-Control-Allow-Credentials' =  true,\n                ]\n            ]\n        ],\n    ], parent::behaviors());\n}",
            "title": "Cors"
        },
        {
            "location": "/application-structure/sub-widget/",
            "text": "Widget\n\n\nI widget sono blocchi predefiniti riutilizzabili utilizzati nelle viste per creare elementi dell'interfaccia utente complessi e configurabili in modo orientato agli oggetti. Ad esempio, un widget di selezione della data pu\u00f2 generare una selezione data fantasia, che permette agli utenti di selezionare una data come input. Tutto quello che devi fare \u00e8 quello di inserire il codice seguente in una vista:\n\n\n?php\nuse yii\\jui\\DatePicker;\n?\n\n\n?= DatePicker::widget(['name' =\n 'date']) ?\n\n\n\n\nCi sono un buon numero di widget in bundle con Yii, come active form, JQuery UI, Twitter Bootrstrap Widget, ecc.. \nDi seguito, introdurremo le conoscenze di base sui widget. Si prega di far riferimento alla documentazione della classe API se si desidera conoscere l'utilizzo di un particolare widget.\n\n\nUtilizzo dei widget\n\n\nI widget vengono principalmente utilizzati nelle visualizzazioni. E' possibile chiamare il metodo \nyii \\ base \\Widget :: widget()\n per utilizzare un widget in una vista. Il metodo accetta un array di configurazione per inizializzare il widget e restituisce il risultato del rendering del widget. Ad esempio, il codice seguente inserisce un widget di selezione della data configurato per utilizzare la lingua russa e mantenere l'input \nfrom_date\n nell'attributo \n$model\n.\n\n\n?php\nuse yii\\jui\\DatePicker;\n?\n\n\n?= DatePicker::widget([\n    'model' =\n $model,\n    'attribute' =\n 'from_date',\n    'language' =\n 'ru',\n    'dateFormat' =\n 'php:Y-m-d',\n]) ?\n\n\n\n\nAlcuni widget possono prendere un blocco riguardante un contenuto, e lo racchiude tra l'invocazione di \nyii \\ base \\ Widget :: begin()\n e \nyii \\ base \\ Widget :: end()\n. Ad esempio, il seguente codice utilizza il widget \nyii \\ widgets \\ ActiveForm\n per generare un modulo di accesso. Il widget generer\u00e0 l'apertura e chiusura del tag \nform\n dove viene chiamato il metodo \nbegin()\n e il metodo \nend()\n. Qualunque cosa nel mezzo sar\u00e0 lasciata cos\u00ec com'\u00e8.\n\n\n?php\nuse yii\\widgets\\ActiveForm;\nuse yii\\helpers\\Html;\n?\n\n\n\n?php $form = ActiveForm::begin(['id' =\n 'login-form']); ?\n\n\n    \n?= $form-\nfield($model, 'username') ?\n\n\n    \n?= $form-\nfield($model, 'password')-\npasswordInput() ?\n\n\n    \ndiv class=\"form-group\"\n\n        \n?= Html::submitButton('Login') ?\n\n    \n/div\n\n\n\n?php ActiveForm::end(); ?\n\n\n\n\nSi noti che a differenza di \nyii \\ base \\ Widget :: widget()\n che restituisce il risultato di rendering di un widget, il metodo \nyii \\ base \\ Widget :: begin()\n restituisce un'istanza del widget che \u00e8 possibile utilizzare per creare il contenuto del widget stesso.\n\n\n\n\nWarning\n\n\nAlcuni widget utilizzeranno il buffering dell'output per regolare il contenuto incluso quando viene chiamato \nyii \\ base \\ Widget :: end()\n. Per questo motivo \u00e8 previsto che la chiamata di \nyii \\ base \\ Widget :: begin()\n e \nyii \\ base \\ Widget :: end()\n avvenga nello stesso file di visualizzazione. La mancata osservanza di questa regola pu\u00f2 comportare un risultato inaspettato.\n\n\n\n\nCreazione di widget\n\n\nPer creare un widget,dobbiamo estendere \nyii \\ base \\ Widget\n e dobbiamo sovrascrivere i metodi \nyii \\ base \\ Widget :: init()\n e / o \nyii \\ base \\ Widget :: run()\n. In genere, il metodo \ninit()\n deve contenere il codice che normalizza le propriet\u00e0 widget, mentre il metodo \nrun()\n deve contenere il codice che genera il risultato di rendering del widget. Il risultato del rendering pu\u00f2 essere restituito direttamente o restituito come stringa dal metodo \nrun()\n.\n\n\nNell'esempio seguente, il codice HTML all'interno della classe \nHelloWidget\n visualizza il contenuto assegnato alla sua propriet\u00e0 \nmessage\n. Se la propriet\u00e0 non \u00e8 impostata, visualizzer\u00e0 \"Hello World\" per impostazione predefinita.\n\n\nnamespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass HelloWidget extends Widget{\n\n    public $message;\n\n    public function init(){\n\n        parent::init();\n        if ($this-\nmessage === null) {\n            $this-\nmessage = 'Hello World';\n        }\n    }\n\n    public function run(){\n\n        return Html::encode($this-\nmessage);\n    }\n}\n\n\n\nPer utilizzare questo widget, \u00e8 sufficiente inserire il seguente codice in una vista:\n\n\n?php\nuse app\\components\\HelloWidget;\n?\n\n\n?= HelloWidget::widget(['message' =\n 'Good morning']) ?\n\n\n\n\nDi seguito vi mostro una variante della classe \nHelloWidget\n che prende il contenuto racchiuso tra le chiamate del metodo \nbegin()\n e \nend()\n, con HTML-encode() per visualizzarlo.\n\n\nnamespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass HelloWidget extends Widget{\n\n    public function init(){\n\n        parent::init();\n        ob_start();\n    }\n\n    public function run(){\n\n        $content = ob_get_clean();\n        return Html::encode($content);\n    }\n}\n\n\n\nCome puoi vedere, il buffer di output di PHP viene avviato all'interno del metodo \ninit()\n in modo che qualsiasi output tra le chiamate dei metodi \ninit()\n e \nrun()\n possa essere catturato, elaborato e restituito da \nrun()\n.\n\n\n\n\nNote\n\n\nQuando chiamate il metodo \nyii \\ base \\ Widget :: begin()\n, verr\u00e0 creata una nuova istanza del widget e il metodo \ninit()\n verr\u00e0 chiamato alla fine del costruttore del widget. Quando chiamate \nyii \\ base \\ Widget :: end()\n,\nrun()\n verr\u00e0 chiamato dal metodo di cui verr\u00e0 restituito il risultato del return().\n\n\n\n\nIl seguente codice mostra come utilizzare questa nuova variante della classe \nHelloWidget\n:\n\n\n?php\nuse app\\components\\HelloWidget;\n?\n\n\n?php HelloWidget::begin(); ?\n\n\n    content that may contain \ntag\n's\n\n\n?php HelloWidget::end(); ?\n\n\n\n\nA volte, un widget potrebbe dover restituire una grande quantit\u00e0 di contenuti. Mentre puoi incorporare il contenuto del metodo \nrun()\n, un approccio migliore \u00e8 quello di metterlo in una vista e chiamare \nyii \\ base \\ Widget :: render()\n per restituirlo. Per esempio:\n\n\npublic function run(){\n\n    return $this-\nrender('hello');\n\n}\n\n\n\nPer impostazione predefinita, le viste per un widget devono essere memorizzate in file nella directory \nWidgetPath(views\n, dove \nWidgetPath\n trova la directory contenente il file della classe relatio al widget. Pertanto, l'esempio soprastante, renderizza il file di visualizzazione \n@app/components/views/hello.php\n, assumendo che la classe del widget si trovi sotto \n@app/components\n. E' possibile sovrascrivere il metodo \nyii \\ base \\ Widget :: getViewPath()\n per personalizzare la directory contenente il file di visualizzazione del widget.",
            "title": "Widget"
        },
        {
            "location": "/application-structure/sub-widget/#widget",
            "text": "I widget sono blocchi predefiniti riutilizzabili utilizzati nelle viste per creare elementi dell'interfaccia utente complessi e configurabili in modo orientato agli oggetti. Ad esempio, un widget di selezione della data pu\u00f2 generare una selezione data fantasia, che permette agli utenti di selezionare una data come input. Tutto quello che devi fare \u00e8 quello di inserire il codice seguente in una vista:  ?php\nuse yii\\jui\\DatePicker;\n?  ?= DatePicker::widget(['name' =  'date']) ?   Ci sono un buon numero di widget in bundle con Yii, come active form, JQuery UI, Twitter Bootrstrap Widget, ecc.. \nDi seguito, introdurremo le conoscenze di base sui widget. Si prega di far riferimento alla documentazione della classe API se si desidera conoscere l'utilizzo di un particolare widget.",
            "title": "Widget"
        },
        {
            "location": "/application-structure/sub-widget/#utilizzo-dei-widget",
            "text": "I widget vengono principalmente utilizzati nelle visualizzazioni. E' possibile chiamare il metodo  yii \\ base \\Widget :: widget()  per utilizzare un widget in una vista. Il metodo accetta un array di configurazione per inizializzare il widget e restituisce il risultato del rendering del widget. Ad esempio, il codice seguente inserisce un widget di selezione della data configurato per utilizzare la lingua russa e mantenere l'input  from_date  nell'attributo  $model .  ?php\nuse yii\\jui\\DatePicker;\n?  ?= DatePicker::widget([\n    'model' =  $model,\n    'attribute' =  'from_date',\n    'language' =  'ru',\n    'dateFormat' =  'php:Y-m-d',\n]) ?   Alcuni widget possono prendere un blocco riguardante un contenuto, e lo racchiude tra l'invocazione di  yii \\ base \\ Widget :: begin()  e  yii \\ base \\ Widget :: end() . Ad esempio, il seguente codice utilizza il widget  yii \\ widgets \\ ActiveForm  per generare un modulo di accesso. Il widget generer\u00e0 l'apertura e chiusura del tag  form  dove viene chiamato il metodo  begin()  e il metodo  end() . Qualunque cosa nel mezzo sar\u00e0 lasciata cos\u00ec com'\u00e8.  ?php\nuse yii\\widgets\\ActiveForm;\nuse yii\\helpers\\Html;\n?  ?php $form = ActiveForm::begin(['id' =  'login-form']); ? \n\n     ?= $form- field($model, 'username') ? \n\n     ?= $form- field($model, 'password')- passwordInput() ? \n\n     div class=\"form-group\" \n         ?= Html::submitButton('Login') ? \n     /div  ?php ActiveForm::end(); ?   Si noti che a differenza di  yii \\ base \\ Widget :: widget()  che restituisce il risultato di rendering di un widget, il metodo  yii \\ base \\ Widget :: begin()  restituisce un'istanza del widget che \u00e8 possibile utilizzare per creare il contenuto del widget stesso.   Warning  Alcuni widget utilizzeranno il buffering dell'output per regolare il contenuto incluso quando viene chiamato  yii \\ base \\ Widget :: end() . Per questo motivo \u00e8 previsto che la chiamata di  yii \\ base \\ Widget :: begin()  e  yii \\ base \\ Widget :: end()  avvenga nello stesso file di visualizzazione. La mancata osservanza di questa regola pu\u00f2 comportare un risultato inaspettato.",
            "title": "Utilizzo dei widget"
        },
        {
            "location": "/application-structure/sub-widget/#creazione-di-widget",
            "text": "Per creare un widget,dobbiamo estendere  yii \\ base \\ Widget  e dobbiamo sovrascrivere i metodi  yii \\ base \\ Widget :: init()  e / o  yii \\ base \\ Widget :: run() . In genere, il metodo  init()  deve contenere il codice che normalizza le propriet\u00e0 widget, mentre il metodo  run()  deve contenere il codice che genera il risultato di rendering del widget. Il risultato del rendering pu\u00f2 essere restituito direttamente o restituito come stringa dal metodo  run() .  Nell'esempio seguente, il codice HTML all'interno della classe  HelloWidget  visualizza il contenuto assegnato alla sua propriet\u00e0  message . Se la propriet\u00e0 non \u00e8 impostata, visualizzer\u00e0 \"Hello World\" per impostazione predefinita.  namespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass HelloWidget extends Widget{\n\n    public $message;\n\n    public function init(){\n\n        parent::init();\n        if ($this- message === null) {\n            $this- message = 'Hello World';\n        }\n    }\n\n    public function run(){\n\n        return Html::encode($this- message);\n    }\n}  Per utilizzare questo widget, \u00e8 sufficiente inserire il seguente codice in una vista:  ?php\nuse app\\components\\HelloWidget;\n?  ?= HelloWidget::widget(['message' =  'Good morning']) ?   Di seguito vi mostro una variante della classe  HelloWidget  che prende il contenuto racchiuso tra le chiamate del metodo  begin()  e  end() , con HTML-encode() per visualizzarlo.  namespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass HelloWidget extends Widget{\n\n    public function init(){\n\n        parent::init();\n        ob_start();\n    }\n\n    public function run(){\n\n        $content = ob_get_clean();\n        return Html::encode($content);\n    }\n}  Come puoi vedere, il buffer di output di PHP viene avviato all'interno del metodo  init()  in modo che qualsiasi output tra le chiamate dei metodi  init()  e  run()  possa essere catturato, elaborato e restituito da  run() .   Note  Quando chiamate il metodo  yii \\ base \\ Widget :: begin() , verr\u00e0 creata una nuova istanza del widget e il metodo  init()  verr\u00e0 chiamato alla fine del costruttore del widget. Quando chiamate  yii \\ base \\ Widget :: end() , run()  verr\u00e0 chiamato dal metodo di cui verr\u00e0 restituito il risultato del return().   Il seguente codice mostra come utilizzare questa nuova variante della classe  HelloWidget :  ?php\nuse app\\components\\HelloWidget;\n?  ?php HelloWidget::begin(); ? \n\n    content that may contain  tag 's ?php HelloWidget::end(); ?   A volte, un widget potrebbe dover restituire una grande quantit\u00e0 di contenuti. Mentre puoi incorporare il contenuto del metodo  run() , un approccio migliore \u00e8 quello di metterlo in una vista e chiamare  yii \\ base \\ Widget :: render()  per restituirlo. Per esempio:  public function run(){\n\n    return $this- render('hello');\n\n}  Per impostazione predefinita, le viste per un widget devono essere memorizzate in file nella directory  WidgetPath(views , dove  WidgetPath  trova la directory contenente il file della classe relatio al widget. Pertanto, l'esempio soprastante, renderizza il file di visualizzazione  @app/components/views/hello.php , assumendo che la classe del widget si trovi sotto  @app/components . E' possibile sovrascrivere il metodo  yii \\ base \\ Widget :: getViewPath()  per personalizzare la directory contenente il file di visualizzazione del widget.",
            "title": "Creazione di widget"
        },
        {
            "location": "/application-structure/sub-assets/",
            "text": "Risorse (Assets)\n\n\nUna risorsa in Yii \u00e8 un file a cui \u00e8 possibile fare riferimento in una pagina Web. Pu\u00f2 essere un file CSS, un file JavaScript, un'immagine o un file video, ecc.. Le risorse si trovano in directory accessibili dal Web e sono servite direttamente dai server Web.\n\n\nSpesso \u00e8 preferibile gestire le risorse a livello di programmazione. Ad esempio, quando si utilizza il widget \nyii \\ jui \\ DatePicker\n in una pagina, verranno automaticamente inclusi i file CSS e JavaScript richiesti, invece di chiedere di trovare manualmente questi file e includerli. E quando si aggiorna il widget a una nuova versione, verr\u00e0 automaticamente utilizzata la nuova versione dei file di asset. In questo tutorial, descriveremo la potente capacit\u00e0 di gestione degli asset fornita da Yii.\n\n\nDefinizione dei pacchetti di asset\n\n\nI pacchetti di asset sono specificati come classi PHP che si estendono da \nyii \\ web \\ AssetBundle\n. Il nome di un bundle \u00e8 semplicemente il suo nome relativo alla classe PHP. una classe di asset bundle dovrebbe essere autoloadable. Solitamente specifica dove si trovano le risorse, quali file CSS e JavaScript, e ci dice anche quale pacchetto dipende da altri bundle.\n\n\nIl seguente codice definisce il pacchetto di asset principale utilizzato dal progetto del modello base:\n\n\n?php\n\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\n\nclass AppAsset extends AssetBundle{\n\n    public $basePath = '@webroot';\n    public $baseUrl = '@web';\n    public $css = [\n        'css/site.css',\n        ['css/print.css', 'media' =\n 'print'],\n    ];\n    public $js = [\n    ];\n    public $depends = [\n        'yii\\web\\YiiAsset',\n        'yii\\bootstrap\\BootstrapAsset',\n    ];\n}\n\n\n\nLa classe \nAppAsset\n specifica che il file di asset si trovano nella directory \n@webroot\n che corrisponde all'URL \n@web\n; il pacchetto contiene un singolo file CSS \ncss/site.css\n. e nessun file JavaScript. Il pacchetto dipende da altri due bundle: \nyii \\ base \\ YiiAsset\n e \nyii \\ bootstrap \\ BootstrapAsset\n. Una spiegazione pi\u00f9 dettagliata della propriet\u00e0 \nyii \\ web \\ AssetBundle\n pu\u00f2 essere trovata nel modo seguente:\n\n\n\n\nsourcePath\n: specifica la directory root che contiene i file di asset in questo pacchetto. Questa propriet\u00e0 deve essere impostata se la directory principale non \u00e8 accessibile dal Web. In caso contrario, \u00e8 necessario impostare la propriet\u00e0 \nbasePath\n e  la propriet\u00e0 \nbaseurl\n. Gli alias di percorso possono essere utilizzati.\n\n\nbasePath\n: specifica una directory accessibile dal Web che contiene i file di asset in questo pacchetto. Quando si specifica la propriet\u00e0 \nsourcePath\n, il gestore risorse pubblica le risorse di questo pacchetto in una directory accessibile dal Web, e sovrascrive di conseguenza questa propriet\u00e0. \u00c8 necessario impostarla se i file delle risorse sono gi\u00e0 in una directory accessibile dal Web e non \u00e8 necessario pubblicare gli asset. Gli alias di percorso possono essere utilizzati.\n\n\nbaseUrl\n: specifica l'URL corrispondente alla directory basePath. Come basePath , se si specifica la propriet\u00e0 sourcePath , il gestore risorse pubblicher\u00e0 le risorse e sovrascriver\u00e0 di conseguenza questa propriet\u00e0. Gli alias di percorso possono essere utilizzati.\n\n\ncss\n: specifica un array che elenca i file CSS contenuti in questo pacchetto. Si noti che solo la barra \"/\" deve essere utilizzata come separatore di directory. Ogni file pu\u00f2 essere specificato da solo come stringa o in un array insieme ai tag di attributo e ai relativi valori.\n\n\n\n\njs\n: specifica un array che elenca i file JavaScript contenuti in questo pacchetto. Il formato di questo array \u00e8 lo stesso di quello del css . Ogni file JavaScript pu\u00f2 essere specificato in uno dei seguenti due formati:\n\n\n\n\nun percorso relativo che rappresenta un file JavaScript locale (es js/main.js.). Il percorso effettivo del file pu\u00f2 essere determinato anteponendo \nyii \\ web \\ AssetManager :: $ basePath\n al percorso relativo e l'URL effettivo del file pu\u00f2 essere determinato anteponendo \nyii \\ web \\ AssetManager :: $ baseUrl\n al percorso relativo.\n\n\nun URL assoluto che rappresenta un file JavaScript esterno. Ad esempio \nhttp://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\n o \n//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js.\n.\n\n\n\n\n\n\n\n\ndepends\n: specifica un array che elenca i nomi dei bundle di asset da cui dipende questo bundle (sar\u00e0 spiegato nei prossimi paragrafi).\n\n\n\n\njsOptions\n: specifica le opzioni che verranno passate al metodo \nyii \\ web \\ View :: registerJsFile ()\n quando viene chiamato per registrare ogni file JavaScript in questo pacchetto.\n\n\ncssOptions\n: specifica le opzioni che verranno passate al metodo \nyii \\ web \\ View :: registerCssFile ()\n quando viene chiamato per registrare ogni file CSS in questo pacchetto.\n\n\npublishOptions\n: specifica le opzioni che verranno passate al metodo \nyii \\ web \\ AssetManager :: publish ()\n quando viene chiamato per pubblicare i file di risorse dall'origine in una directory Web. Viene utilizzato solo se si specifica la propriet\u00e0 \nsourcePath\n.\n\n\n\n\nPosizioni delle risorse\n\n\nLe risorse, in base alla loro posizione, possono essere classificate come:\n\n\n\n\nsource assets\n: i file delle risorse si trovano insieme al codice sorgente PHP che non pu\u00f2 essere direttamente accessibile via Web. Per utilizzare le source assets in una pagina, devono essere copiati in una directory Web e trasformati nelle cosiddette risorse pubbliche. Questo processo \u00e8 chiamato \nasset publishing\n che verr\u00e0 descritto nei paragrafi successivi.\n\n\nrisorse pubblicate\n: i file delle risorse si trovano in una directory Web e possono quindi essere accessibili direttamente via Web.\n\n\nrisorse esterne\n: i file delle risorse si trovano su un server Web diverso da quello che ospita la tua applicazione Web.\n\n\n\n\nQuando si definisce una classe bundle di asset, se si specifica la propriet\u00e0 \nsourcePath\n, significa che tutte le risorse elencate, stanno utilizzando percorsi relativi e saranno considerate come source assets. Se non si specifica questa propriet\u00e0, significa che tali risorse sono risorse pubblicate (public assets) (\u00e8 necessario specificare \nbasePath\n e \nbaseUrl\n per consentire a Yii di sapere dove si trovano).\n\n\nSi consiglia di posizionare le risorse appartenenti a un'applicazione in una directory Web, per evitare il processo di pubblicazione di asset non necessario e non voluto. Questo \u00e8 il motivo per cui \n`AppAssetper\n,nell'esempio precedente, gli viene specificato il \nbasePath\n, anzich\u00e9 il \nsourcePath\n.\n\n\nPer le estensioni, poich\u00e9 le loro risorse si trovano insieme al loro codice sorgente nelle directory che non sono accessibili dal Web, \u00e8 necessario specificare la propriet\u00e0 \nsourcePath\n quando si definiscono le classi di pacchetti di asset relativi ad essi.\n\n\n\n\nWarning\n\n\nNon utilizzare il percorso di origine \n@webroot/assetscome\n. Questa directory viene utilizzata come impostazione predefinita dal gestore risorse, per salvare i file di asset pubblicati dalla loro posizione di origine. Qualsiasi contenuto in questa directory, \u00e8 considerato temporaneamente e potrebbe essere soggetto a rimozione.\n\n\n\n\nDipendenze delle risorse\n\n\nQuando includi pi\u00f9 file CSS o JavaScript in una pagina Web, devono seguire un certo ordine per evitare problemi di sovrascrittura. Ad esempio, se si utilizza un widget dell'interfaccia utente jQuery in una pagina Web, \u00e8 necessario assicurarsi che il file jQuery JavaScript sia incluso prima del file JavaScript dell'interfaccia jQuery. Chiamiamo questi controlli \"dipendenze tra le risorse\".\n\n\nLe dipendenze delle risorse vengono principalmente specificate tramite la propriet\u00e0 \nyii \\ web \\ AssetBundle :: $ depends\n. Nell'esempio \nAppAsset\n, il fascio di asset dipende da altri due fasci di attivit\u00e0:\nYii \\ web \\ YiiAsset\n e \nYii \\ bootstrap \\ BootstrapAsset\n, il che significa che i file CSS e JavaScript in \nAppAsset\n saranno incluse dopo quei file nei due pacchetti dipendenti.\n\n\nLe dipendenze delle risorse sono transitive. Ci\u00f2 significa che se il pacchetto A dipende da B, che dipende da C, A dipender\u00e0 anche da C.\n\n\nOpzioni degli asset\n\n\n\u00c8 possibile specificare le propriet\u00e0 \ncssOptions\n e \njsOptions\n per personalizzare il modo in cui i file CSS e JavaScript sono inclusi in una pagina. I valori di queste propriet\u00e0 verranno passati ai metodi \nyii \\ web \\ View :: registerCssFile ()\n e \nyii \\ web \\ View :: registerJsFile ()\n, quando verranno chiamati dalla view per includere file CSS e JavaScript.\n\n\n\n\nNote\n\n\nLe opzioni impostate in una classe di bundle di asset, si applicano a ogni file CSS / JavaScript nel pacchetto. Se si desidera utilizzare diverse opzioni per file diversi, \u00e8 necessario utilizzare il formato indicato sopra o creare pacchetti di risorse separati e utilizzare un set di opzioni in ciascun pacchetto.\n\n\n\n\nAd esempio, per includere in modo condizionale un file CSS per i browser con IE9 (Internet Explorer 9) o inferiore, \u00e8 possibile utilizzare la seguente opzione:\n\n\npublic $cssOptions = ['condition' =\n 'lte IE9'];\n\n\n\nCi\u00f2 causer\u00e0 l'inclusione di un file CSS nel pacchetto utilizzando i seguenti tag HTML:\n\n\n!--[if lte IE9]\n\n\nlink rel=\"stylesheet\" href=\"path/to/foo.css\"\n\n\n![endif]--\n\n\n\n\nPer racchiudere i tag di collegamento CSS generati all'interno di \nnoscript\n, puoi configurare \ncssOptions\n come segue:\n\n\npublic $cssOptions = ['noscript' =\n true];\n\n\n\nPer includere un file JavaScript nella sezione head di una pagina, puoi utilizzare la seguente opzione:\n\n\npublic $jsOptions = ['position' =\n \\yii\\web\\View::POS_HEAD];\n\n\n\nPer impostazione predefinita, quando un pacchetto di risorse viene pubblicato, tutti i contenuti nella directory specificata da \nyii \\ web \\ AssetBundle :: $ sourcePath\n verranno pubblicati. \u00c8 possibile personalizzare questo comportamento configurando la propriet\u00e0 \npublishOptions\n. Ad esempio, per pubblicare solo una o alcune sottodirectory di \nyii \\ web \\ AssetBundle :: $ sourcePath\n, \u00e8 possibile effettuare quanto segue nella classe bundle degli asset:\n\n\n?php\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\n\nclass FontAwesomeAsset extends AssetBundle {\n\n    public $sourcePath = '@bower/font-awesome'; \n    public $css = [ \n        'css/font-awesome.min.css', \n    ];\n    public $publishOptions = [\n        'only' =\n [\n            'fonts/',\n            'css/',\n        ]\n    ];\n}\n\n\n\nL'esempio precedente definisce un pacchetto di risorse per il pacchetto \"fontawesome\" . Specificando l'opzione di pubblicazione \nonly\n, verranno pubblicate solo le sottodirectory \nfonts\ne \ncss\n.\n\n\nUtilizzo dei pacchetti di asset\n\n\nPer utilizzare un pacchetto di risorse, dobbiamo registrarlo con una vista chiamando il metodo \nyii \\ web \\ AssetBundle :: register ()\n. Ad esempio, in un modello di vista \u00e8 possibile registrare un pacchetto di asset come il seguente:  \n\n\nuse app\\assets\\AppAsset;\nAppAsset::register($this);  // $this represents the view object\n\n\n\n\n\nTip\n\n\nIl metodo \nyii \\ web \\ AssetBundle :: register()\n restituisce un oggetto bundle di asset contenente le informazioni sulle risorse pubblicate, come  \nbasePath\n e \nbaseUrl\n.\n\n\n\n\nSe si sta registrando un pacchetto di risorse in altri luoghi, \u00e8 necessario fornire l'oggetto di visualizzazione necessario. Ad esempio, per registrare un pacchetto di risorse in una classe widget , \u00e8 possibile ottenere l'oggetto vista per \n$this-\nview\n.\n\n\nQuando un bundle di asset \u00e8 registrato con una view, Yii registrer\u00e0 tutti i suoi bundle di asset dipendenti. Se un pacchetto di risorse si trova in una directory inaccessibile attraverso il Web, verr\u00e0 pubblicato in una directory Web. Successivamente, quando la vista esegue il rendering di una pagina, generer\u00e0 tag \nlink\ne  \nscript\n per i file CSS e JavaScript elencati nei pacchetti registrati. L'ordine di questi tag \u00e8 determinato dalle dipendenze tra i bundle registrati e dall'ordine delle risorse elencate nelle propriet\u00e0 \nyii \\ web \\ AssetBundle :: $ css\n e \nyii \\ web \\ AssetBundle :: $ js\n.\n\n\nBundle di asset dinamici\n\n\nEssendo un normale pacchetto di risorse di classe PHP, \u00e8 possibile avere alcune logiche aggiuntive ad esso correlate e pu\u00f2 modificare dinamicamente i parametri interni. Ad esempio: \u00e8 possibile utilizzare una sofisticata libreria JavaScript, che fornisce internazionalizzazione in file di origine separati: ciascuno per ciascuna lingua supportata. Quindi dovrai aggiungere un particolare file \".js\" alla tua pagina per far funzionare la traduzione della libreria. Questo pu\u00f2 essere ottenuto sovrascrivendo il metodo yii \\ web \\ AssetBundle :: init () :\n\n\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\nuse Yii;\n\nclass SophisticatedAssetBundle extends AssetBundle{\n\n    public $sourcePath = '/path/to/sophisticated/src';\n    public $js = [\n        'sophisticated.js' // file, which is always used\n    ];\n\n    public function init(){\n\n        parent::init();\n        $this-\njs[] = 'i18n/' . Yii::$app-\nlanguage . '.js'; // dynamic file added\n    }\n}\n\n\n\nL'asset bunlde pu\u00f2 anche essere regolato tramite la sua istanza restituita da \nyii \\ web \\ AssetBundle :: register()\n. Per esempio:\n\n\nuse app\\assets\\SophisticatedAssetBundle;\nuse Yii;\n\n$bundle = SophisticatedAssetBundle::register(Yii::$app-\nview);\n$bundle-\njs[] = 'i18n/' . Yii::$app-\nlanguage . '.js'; // dynamic file added\n\n\n\n\n\nWarning\n\n\nSebbene sia supportata la regolazione dinamica dei pacchetti di asset, non \u00e8 una buona pratica, perch\u00e8 pu\u00f2 portare a effetti collaterali imprevisti e, se possibile, dovrebbe essere evitata.\n\n\n\n\nPersonalizzazione dei pacchetti di risorse\n\n\nYii gestisce i bundle delle risorse tramite un componente dell'applicazione denominato \nassetManager\n che \u00e8 implementato da \nyii \\ web \\ AssetManager\n. Configurando la propriet\u00e0 \nyii \\ web \\ AssetManager :: $ bundles\n, \u00e8 possibile personalizzare il comportamento di un pacchetto di risorse. Ad esempio, il pacchetto asset predefinito \nyii \\ web \\ JqueryAsset\n utilizza il file \njquery.js\n dal pacchetto jquery Bower installato. Per migliorare la disponibilit\u00e0 e le prestazioni, potresti voler utilizzare una versione ospitata da Google. Questo lo possiamo ottenere configurando \nassetManager\n nella configurazione dell'applicazione come mostrato di seguito:\n\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'bundles' =\n [\n                'yii\\web\\JqueryAsset' =\n [\n                    'sourcePath' =\n null,   // do not publish the bundle\n                    'js' =\n [\n                        '//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js',\n                    ]\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\u00c8 possibile configurare pi\u00f9 bundle di asset in modo simile tramite \nyii \\ web \\ AssetManager :: $ bundles\n. Le chiavi dell'array dovrebbero essere i nomi delle classi  dei bundle di asset (senza la barra rovesciata iniziale) e i valori dell'array dovrebbero corrispondere agli array di configurazione corrispondenti.\n\n\n\n\nTip\n\n\nE' possibile scegliere condizionalmente quali risorse utilizzare in un pacchetto di risorse. L'esempio seguente mostra come utilizzare \njquery.js\n nell'ambiente di sviluppo e anche \njquery.min.js\n in altro modo:\n    'yii\\web\\JqueryAsset' =\n [\n        'js' =\n [\n        YII_ENV_DEV ? 'jquery.js' : 'jquery.min.js'\n        ]\n    ],\n\n\n\n\n\u00c8 possibile disabilitare uno o pi\u00f9 gruppi di risorse associandogli il valore \nfalse\n ai nomi dei pacchetti di asset che si desidera disabilitare. Quando si registra un pacchetto di asset disabilitato ad una vista, nessuno dei suoi bundle dipendenti verr\u00e0 registrato e la vista non includer\u00e0 alcuna delle risorse nel pacchetto nella pagina che esegue il rendering. Ad esempio, per disabilitare \nyii \\ web \\ JqueryAsset\n, \u00e8 possibile utilizzare la seguente configurazione:\n\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'bundles' =\n [\n                'yii\\web\\JqueryAsset' =\n false,\n            ],\n        ],\n    ],\n];\n\n\n\nPuoi anche disabilitare tutti i pacchetti delle risorse impostante \nyii \\ web \\ AssetManager :: $bundles\n a \nfalse\n.\n\n\nTieni presente che la personalizzazione effettuata tramite \nyii \\ web \\ AssetManager :: $ bundle\n viene applicata alla creazione del bundle di risorse, ad esempio durante la fase di costruzione di oggetti. Pertanto, qualsiasi aggiustamento apportato all'oggetto \nbundle\n,sostituir\u00e0 l'impostazione della mappatura al livello di \nyii \\ web \\ AssetManager :: $ bundles\n. In particolare: le regolazioni effettuate all'interno del metodo \nyii \\ web \\ AssetBundle :: init ()\n o sull'oggetto bundle registrato, avranno la precedenza sulla configurazione dell'\nAssetManager\n. Ecco alcuni esempi, in cui la mappatura impostata tramite \nyii \\ web \\ AssetManager :: $ bundles\n non ha alcun effetto:\n\n\n// Program source code:\n\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\nuse Yii;\n\nclass LanguageAssetBundle extends AssetBundle{\n\n    // ...\n\n    public function init(){\n\n        parent::init();\n        $this-\nbaseUrl = '@web/i18n/' . Yii::$app-\nlanguage; // can NOT be handled by `AssetManager`!\n    }\n}\n// ...\n\n$bundle = \\app\\assets\\LargeFileAssetBundle::register(Yii::$app-\nview);\n$bundle-\nbaseUrl = YII_DEBUG ? '@web/large-files': '@web/large-files/minified'; // can NOT be handled by `AssetManager`!\n\n\n// Application config :\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'bundles' =\n [\n                'app\\assets\\LanguageAssetBundle' =\n [\n                    'baseUrl' =\n 'http://some.cdn.com/files/i18n/en' // makes NO effect!\n                ],\n                'app\\assets\\LargeFileAssetBundle' =\n [\n                    'baseUrl' =\n 'http://some.cdn.com/files/large-files' // makes NO effect!\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nMapping degli asset\n\n\nA volte potresti voler \"correggere\" i percorsi dei file di asset errati / incompatibili usati in pi\u00f9 bundle. Ad esempio, il pacchetto A utilizza la versione 1.11.1 del file \njquery.min.js\n e il pacchetto B utilizza la versione 2.1.1 del file \njquery.js\n. Mentre \u00e8 possibile risolvere il problema personalizzando ogni fascio, un modo pi\u00f9 semplice \u00e8 quello di utilizzare funzione per mappare le attivit\u00e0 non corrette a agli oggetti desiderati. Per fare ci\u00f2, dobbiamo configurare la propriet\u00e0 \nyii \\ web \\ AssetManager :: $ assetMap\n come segue: \n\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'assetMap' =\n [\n                'jquery.js' =\n '//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js',\n            ],\n        ],\n    ],\n];\n\n\n\nLe chiavi di \nassetMap\n sono i nomi delle risorse che si desidera correggere e i valori sono i percorsi degli asset desiderati. Quando registri un pacchetto di asset con una vista, ogni file di asset relativo nei suoi array css e js sar\u00e0 esaminato rispetto a questa mappa. Se si trova che una delle chiavi \u00e8 l'ultima parte di un file di asset (che \u00e8 preceduta dal metodo\nyii \\ web \\ AssetBundle :: $ sourcePath\n, se disponibile), il valore corrispondente sostituir\u00e0 l'asset, e sar\u00e0 registrato nella vista. Ad esempio, il file di asset \nmy/path/to/jquery.js\ncorrisponde alla chiave \njquery.js\n.\n\n\n\n\nWarning\n\n\nSolo le risorse specificate utilizzando i percorsi relativi sono soggette alla mappatura delle risorse. I percorsi delle risorse devono essere URL assoluti o percorsi relativi a \nyii \\ web \\ AssetManager :: $basePath\n.\n\n\n\n\nPublishing degli asset\n\n\nCome sopra indicato, se un pacchetto di risorse si trova in una directory che non \u00e8 accessibile dal Web, le sue risorse verranno copiate in una directory Web quando il bundle viene registrato con una vista. Questo processo \u00e8 chiamato \nasset publishing\n e viene eseguito automaticamente dal gestore degli asset .\n\n\nPer impostazione predefinita, le risorse vengono pubblicate nella directory \n@webroot/assets\n che corrisponde all'URL \n@web/assets\n. \u00c8 possibile personalizzare questa posizione configurando le propriet\u00e0 \nbasePath\n e \nbaseUrl\n.\n\n\nInvece di pubblicare le risorse tramite la copia di file, \u00e8 possibile considerare l'utilizzo di collegamenti simbolici, sempre che sia il sistema operativo che il server lo permettano.Questa funzione pu\u00f2 essere abilitata impostando il valore di \nlinkAssets\n a \ntrue\n.\n\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'linkAssets' =\n true,\n        ],\n    ],\n];\n\n\n\nCon la configurazione sopra indicata, il gestore degli asset creer\u00e0 un collegamento simbolico al percorso di origine di un pacchetto di asset quando esso verr\u00e0 pubblicato. \u00c8 pi\u00f9 veloce della copia di file e pu\u00f2 anche garantire che le risorse pubblicate siano sempre aggiornate.\n\n\nCache busting\n\n\nPer l'applicazione Web eseguita in modalit\u00e0 di produzione, \u00e8 prassi abilitare la memorizzazione nella cache HTTP per le risorse. Uno svantaggio di questa pratica \u00e8 che ogni volta che si modifica una risorsa e la si distribuisce in produzione, un client utente pu\u00f2 ancora utilizzare la versione precedente a causa della memorizzazione nella cache HTTP. Per ovviare a questo inconveniente, \u00e8 possibile utilizzare la funzionalit\u00e0 \ncache busting\n, introdotta nella versione 2.0.3, configurando \nyii \\ web \\ AssetManager\n come segue:\n\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'appendTimestamp' =\n true,\n        ],\n    ],\n];\n\n\n\nIn questo modo, l'URL di ogni risorsa pubblicata verr\u00e0 aggiunto con il timestamp dell'ultima modifica. Ad esempio, l'URL \nyii.js\n potrebbe essere cos\u00ec fatto  \n/assets/5515a87c/yii.js?v=1423448645\"\n, in cui il parametro \nv\n rappresenta l'ultima data di modifica del file \nyii.js\n. Ora se modifichi una risorsa, anche il suo URL verr\u00e0 modificato, il che fa s\u00ec che il client recuperi la versione pi\u00f9 recente della risorsa.\n\n\nPacchetti di beni comunemente usati\n\n\nIl codice principale di Yii definisce molti pacchetti di risorse. Tra questi, i seguenti pacchetti sono comunemente usati e possono essere referenziati nell'applicazione o nel codice di estensione.\n\n\n\n\nyii \\ web \\ YiiAsset\n: include principalmente il file \nyii.js\n  che implementa un meccanismo di organizzazione del codice JavaScript nei moduli. Fornisce inoltre supporto speciale per gli attributi \ndata-method\n e \ndata-confirm\n e altre funzionalit\u00e0 utili.\n\n\nyii \\ web \\ JqueryAsset\n: include il file \njquery.js\n dal pacchetto \njQuery Bower\n.\n\n\nyii \\ bootstrap \\ BootstrapAsset\n: include il file CSS dal framework Bootstrap di Twitter.\n\n\n*yii \\ bootstrap \\ BootstrapPluginAsset\n: include il file JavaScript dal framework Bootstrap di Twitter per supportare i plug-in JavaScript di Bootstrap.\n\n\nyii \\ jui \\ JuiAsset\n: include i file CSS e JavaScript dalla libreria dell'interfaccia utente jQuery.\n\n\n\n\nSe il tuo codice dipende da jQuery, jQuery UI o Bootstrap, dovresti utilizzare questi bundle di asset predefiniti piuttosto che creare le tue versioni.\n\n\nConversione delle risorse\n\n\nInvece di scrivere direttamente codice CSS e / o JavaScript, gli sviluppatori spesso li scrivono in una sintassi estesa e usano strumenti speciali per convertirli in CSS / JavaScript. Ad esempio,per il codice CSS \u00e8 possibile utilizzare \nLESS\n o \nSCSS\n; e per JavaScript puoi usare \nTypeScript\n.\n\n\n\u00c8 possibile elencare i file di asset in sintassi estesa nelle propriet\u00e0 \ncss\n e \njs\n di un pacchetto di risorse. Per esempio,\n\n\nclass AppAsset extends AssetBundle{\n\n    public $basePath = '@webroot';\n    public $baseUrl = '@web';\n    public $css = [\n        'css/site.less',\n    ];\n    public $js = [\n        'js/site.ts',\n    ];\n    public $depends = [\n        'yii\\web\\YiiAsset',\n        'yii\\bootstrap\\BootstrapAsset',\n    ];\n}\n\n\n\nQuando si registra un pacchetto di asset con una vista, il gestore risorse eseguir\u00e0 automaticamente gli strumenti di pre-processore per convertire le risorse nella sintassi estesa riconosciuta in CSS / JavaScript. Quando alla fine, la vista esegue il rendering di una pagina, includer\u00e0 i file CSS / JavaScript nella pagina, anzich\u00e9 le risorse originali nella sintassi estesa.\n\n\nYii usa le estensioni dei nomi dei file per identificare la sintassi estesa in cui \u00e8 presente una risorsa. Per impostazione predefinita riconosce le seguenti estensioni di sintassi e nome file:\n\n\n\n\nLESS\n: \n.less\n\n\nSCSS\n: \n.scss\n\n\nStilo\n: \n.styl\n\n\nCoffeeScript\n: \n.coffee\n\n\nTypeScript\n: \n.ts\n\n\n\n\nYii fa affidamento sugli strumenti pre-processore installati per convertire le risorse. Ad esempio, per utilizzare \nLESS\n \u00e8 necessario installare il comando \nlessc\n pre-processore.\n\n\nE' possibile personalizzare i comandi del pre-processore e la sintassi estesa supportata, configurando il convertitore \nyii \\ web \\ AssetManager ::\n come il seguente:\n\n\nreturn [\n    'components' =\n [\n        'assetManager' =\n [\n            'converter' =\n [\n                'class' =\n 'yii\\web\\AssetConverter',\n                'commands' =\n [\n                    'less' =\n ['css', 'lessc {from} {to} --no-color'],\n                    'ts' =\n ['js', 'tsc --out {to} {from}'],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nCome riportato sopra, specifichiamo la sintassi estesa supportata tramite la propriet\u00e0 \nyii \\ web \\ AssetConverter :: $ commands\n. Le chiavi dell'array sono i nomi delle estensioni dei file (senza punto iniziale) e i valori dell'array sono i nomi delle estensioni dei file delle risorse risultanti e i comandi per eseguire la conversione degli asset. I token \n{from}\n e \n{to}\n verranno sostituiti con i percorsi dei file di asset di origine e i percorsi dei file di asset di destinazione.\n\n\n\n\nInfo\n\n\nEsistono altri modi di lavorare con le risorse nella sintassi estesa, oltre a quella descritta sopra. Ad esempio, \u00e8 possibile utilizzare strumenti di compilazione come \ngrunt\n per monitorare e convertire automaticamente le risorse in sintassi estesa. In questo caso, \u00e8 necessario elencare i file CSS / JavaScript risultanti in bundle di asset anzich\u00e9 nei file originali.\n\n\n\n\nCombinazione e compressione delle risorse\n\n\nUna pagina Web pu\u00f2 includere molti file CSS e / o JavaScript. Per ridurre il numero di richieste HTTP e la dimensione complessiva di download di questi file, \u00e8 prassi comune combinare e comprimere pi\u00f9 file CSS / JavaScript in uno o pochissimi file e quindi includere questi file compressi invece di quelli originali nel Web pagine.\n\n\n\n\nInfo\n\n\nLa combinazione e la compressione delle risorse sono in genere necessarie quando un'applicazione \u00e8 in modalit\u00e0 di produzione. Nella modalit\u00e0 di sviluppo, l'utilizzo dei file CSS / JavaScript originali \u00e8 spesso pi\u00f9 conveniente ai fini del debug.\n\n\n\n\nDi seguito, introduciamo un approccio per unire e comprimere i file delle risorse senza la necessit\u00e0 di modificare il codice dell'applicazione esistente.\n\n\n\n\nTrovare tutti i pacchetti delle risorse nella nostra applicazione che vogliamo unire e comprimere.\n\n\nDividi questi pacchetti in uno o pochi gruppi. Si noti che ogni pacchetto pu\u00f2 appartenere solo a un singolo gruppo.\n\n\nUnire / comprimere i file CSS in ogni gruppo in un singolo file. Fai lo stesso per i file JavaScript.\n\n\nDefinire un nuovo pacchetto di risorse per ogni gruppo:\n\n\nImpostare la propriet\u00e0 \ncss\n e \njs\n come file uniti rispettivamente di file CSS e file di JavaScript.\n\n\n\n\n\n\n\n\nUtilizzando questo approccio, quando si registra un pacchetto di asset in una vista, viene eseguita la registrazione automatica del nuovo bundle di asset per il gruppo a cui appartiene il bundle originale. Di conseguenza, i file di asset uniti / compressi sono inclusi nella pagina, anzich\u00e9 quelli originali.\n\n\nUn esempio\n\n\nFacciamo un esempio per spiegare ulteriormente l'approccio sopra.\n\n\nSupponiamo che la tua applicazione abbia due pagine, X e Y. Pagina X utilizza i bundle di asset A, B e C, mentre Page Y utilizza i bundle di asset B, C e D.\n\n\nHai due modi per dividere questi pacchetti di risorse. Uno consiste nell'utilizzare un singolo gruppo per includere tutti i pacchetti di risorse, l'altro \u00e8 mettere A nel Gruppo X, D nel Gruppo Y e (B, C) nel Gruppo S. Qual \u00e8 il migliore? Dipende. Il primo modo ha il vantaggio che entrambe le pagine condividono gli stessi file combinati ( CSS e JavaScript), il che rende pi\u00f9 efficace il caching HTTP. D'altra parte, poich\u00e9 il gruppo singolo contiene tutti i bundle, la dimensione dei file combinati CSS e JavaScript sar\u00e0 maggiore e quindi aumenter\u00e0 il tempo di trasmissione del file iniziale. Per semplicit\u00e0, in questo esempio, useremo il primo modo, utilizzare un singolo gruppo per contenere tutti i bundle.\n\n\n\n\nInfo\n\n\nDividere i raggruppamenti delle risorse in gruppi non \u00e8 un compito banale. Di solito richiede analisi sui dati di traffico del mondo reale di varie risorse su pagine diverse. All'inizio, puoi iniziare con un singolo gruppo per semplicit\u00e0.\n\n\n\n\nUtilizza gli strumenti esistenti (ad esempio Closure Compiler , YUI Compressor ) per unire e comprimere i file CSS e JavaScript in tutti i bundle. Si noti che i file devono essere combinati nell'ordine che soddisfa le dipendenze tra i pacchetti. Ad esempio, se Bundle A dipende da B che dipende da C e D, allora dovresti elencare i file di asset a partire da C e D, seguiti da B e infine A.\n\n\nDopo l'unione e la compressione, otteniamo un file CSS e un file JavaScript. Si supponga di nomiare i file \nall-xyz.css\n e \nall-xyz.js\n, dove \nxyz\nsta per un timestamp o un hash che viene utilizzato per rendere il nome del file univoco per evitare problemi di caching HTTP.\n\n\nSiamo all'ultimo passo ora. Configurare il gestore degli asset come segue nella configurazione dell'applicazione:\n\n\nreturn [\n    'components' =\n [\n        'assetManager' =\n [\n            'bundles' =\n [\n                'all' =\n [\n                    'class' =\n 'yii\\web\\AssetBundle',\n                    'basePath' =\n '@webroot/assets',\n                    'baseUrl' =\n '@web/assets',\n                    'css' =\n ['all-xyz.css'],\n                    'js' =\n ['all-xyz.js'],\n                ],\n                'A' =\n ['css' =\n [], 'js' =\n [], 'depends' =\n ['all']],\n                'B' =\n ['css' =\n [], 'js' =\n [], 'depends' =\n ['all']],\n                'C' =\n ['css' =\n [], 'js' =\n [], 'depends' =\n ['all']],\n                'D' =\n ['css' =\n [], 'js' =\n [], 'depends' =\n ['all']],\n            ],\n        ],\n    ],\n];\n\n\n\nLa suddetta configurazione modifica il comportamento predefinito di ciascun pacchetto. In particolare, i pacchetti A, B, C e D non hanno pi\u00f9 file di risorse. Ora dipendono tutti dal pacchetto \nall\n che contiene i file combinati \nall-xyz.css\n e \nall-xyz.js\n. Di conseguenza, per la Pagina X, invece di includere i file originali dal Bundle A, B e C, saranno inclusi solo questi due file combinati; la stessa cosa succede a Page Y.\n\n\nC'\u00e8 un trucco finale per rendere l'approccio spiegato in precedena pi\u00f9 agevole. Invece di modificare direttamente il file di configurazione dell'applicazione, \u00e8 possibile inserire l'array di personalizzazione del bundle in un file separato e includere condizionatamente questo file nella configurazione dell'applicazione. Per esempio,\n\n\nreturn [\n    'components' =\n [\n        'assetManager' =\n [\n            'bundles' =\n require __DIR__ . '/' . (YII_ENV_PROD ? 'assets-prod.php' : 'assets-dev.php'),  \n        ],\n    ],\n];\n\n\n\nIn altre parole, l'array di configurazione del bundle di asset viene salvato \nassets-prod.php\n per la modalit\u00e0 di produzione e \nassets-dev.php\nper la modalit\u00e0 non di produzione.\n\n\n\n\nWarning\n\n\nQuesto meccanismo di combinazione delle risorse si basa sulla capacit\u00e0 di poter sovrascrivere le propriet\u00e0 dei bundle di asse registrati tramite \nyii \\ web \\ AssetManager :: $ bundle\n. Tuttavia, come gi\u00e0 detto sopra, questa abilit\u00e0 non copre gli aggiustamenti del bundle degli asset, che vengono eseguiti nel metodo \nyii \\ web \\ AssetBundle :: init ()\n o dopo che il bundle \u00e8 stato registrato. Dovresti evitare l'uso di tali pacchetti dinamici durante la combinazione delle risorse.\n\n\n\n\nComando \nasset\n\n\nYii fornisce un comando console chiamato \nasset\n per automatizzare l'approccio che abbiamo appena descritto.\n\n\nPer utilizzare questo comando, \u00e8 necessario innanzitutto creare un file di configurazione per descrivere quali gruppi di risorse devono essere combinati e come devono essere raggruppati. \u00c8 possibile utilizzare il sottocomando \nasset/template\n per generare un modello e quindi modificarlo per adattarlo alle proprie esigenze.\n\n\nyii asset/template assets.php\n\n\n\nIl comando genera un file nominato \nassets.php\n nella directory corrente. Il contenuto di questo file \u00e8 simile al seguente:\n\n\n?php\n/**\n* Configuration file for the \"yii asset\" console command.\n* Note that in the console environment, some path aliases like '@webroot' and '@web' may not exist.\n* Please define these missing path aliases.\n*/\nreturn [\n    // Adjust command/callback for JavaScript files compressing:\n    'jsCompressor' =\n 'java -jar compiler.jar --js {from} --js_output_file {to}',\n    // Adjust command/callback for CSS files compressing:\n    'cssCompressor' =\n 'java -jar yuicompressor.jar --type css {from} -o {to}',\n    // Whether to delete asset source after compression:\n    'deleteSource' =\n false,\n    // The list of asset bundles to compress:\n    'bundles' =\n [\n        // 'yii\\web\\YiiAsset',\n        // 'yii\\web\\JqueryAsset',\n    ],\n    // Asset bundle for compression output:\n    'targets' =\n [\n        'all' =\n [\n            'class' =\n 'yii\\web\\AssetBundle',\n            'basePath' =\n '@webroot/assets',\n            'baseUrl' =\n '@web/assets',\n            'js' =\n 'js/all-{hash}.js',\n            'css' =\n 'css/all-{hash}.css',\n        ],\n    ],\n    // Asset manager configuration:\n    'assetManager' =\n [\n    ],\n];\n\n\n\n\u00c8 necessario modificare questo file e specificare i pacchetti che si intende combinare nell'opzione \nbundles\n. Nell'opzione \ntargets\n \u00e8 necessario specificare come i fasci debbano essere divisi in gruppi. \u00c8 possibile specificare uno o pi\u00f9 gruppi, come sopra menzionato.\n\n\n\n\nWarning\n\n\nPoich\u00e8 gli alia \n@webroot\n e \n@web\n non sono disponibili nella console, \u00e8 necessario definire in modo esplicito nella configurazione.\n\n\n\n\nI file JavaScript vengono uniti, compressi e scritti \njs/all-{hash}.js\n dove {hash} viene sostituito con l'hash del file risultante.\n\n\nLe opzioni \njsCompressor\n e \ncssCompressor\n specificano i comandi della console o i callback PHP per l'esecuzione di JavaScript e CSS. Per impostazione predefinita, Yii utilizza \nClosure Compiler\n per combinare i file JavaScript e YUI Compressor per combinare i file CSS. Dovresti installare questi strumenti manualmente o modificare queste opzioni per utilizzare i tuoi strumenti preferiti.\n\n\nCon il file di configurazione, \u00e8 possibile eseguire il comando \nasset\n per combinare e comprimere i file di asset e quindi generare un nuovo file di configurazione del bundle di asset \nassets-prod.php\n:\n\n\nyii asset assets.php config/assets-prod.php\n\n\n\nIl file di configurazione generato pu\u00f2 essere incluso nella configurazione dell'applicazione, come descritto nell'ultima sottosezione.\n\n\n\n\nWarning\n\n\nSe si personalizzano i bundle delle risorse per la propria applicazione tramite \nyii \\ web \\ AssetManager :: $ bundles\n o \nyii \\ web \\ AssetManager :: $ assetMap\n e si desidera applicare questa personalizzazione per i file di origine della compressione, \u00e8 necessario includere queste opzioni per la sezione \nassetManager\n all'interno del file di configurazione del comando asset.\n\n\n\n\n\n\nWarning\n\n\nMentre si specifica la sorgente di compressione, si dovrebbe evitare l'uso di bundle di asset i cui parametri possono essere regolati dinamicamente (ad esempio al metodo \ninit()\n o dopo la registrazione), poich\u00e9 potrebbero funzionare in modo non corretto dopo la compressione.\n\n\n\n\nRaggruppamento di pacchetti di asset\n\n\nNell'ultima sottosezione, abbiamo spiegato come combinare tutti i pacchetti di risorse in uno solo per minimizzare le richieste HTTP per i file di risorsa a cui si fa riferimento in un'applicazione. Questo non \u00e8 sempre auspicabile nella pratica. Ad esempio, immagina che la tua applicazione abbia un \"front-end\" e un \"back-end\", ognuno dei quali utilizza un set diverso di file JavaScript e CSS. In questo caso, la combinazione di tutti i bundle di asset non ha senso, perch\u00e9 i bundle di asset per il \"front-end\" non vengono utilizzati dal \"back-end\" e sarebbe uno spreco di larghezza di banda della rete da inviare le risorse \"back-end\" quando viene richiesta una pagina \"front-end\".\n\n\nPer risolvere il problema precedente, \u00e8 possibile dividere gruppi di risorse in gruppi e combinare raggruppamenti di risorse per ciascun gruppo. La seguente configurazione mostra come raggruppare i pacchetti di asset:\n\n\nreturn [\n    ...\n    // Specify output bundles with groups:\n    'targets' =\n [\n        'allShared' =\n [\n            'js' =\n 'js/all-shared-{hash}.js',\n            'css' =\n 'css/all-shared-{hash}.css',\n            'depends' =\n [\n                // Include all assets shared between 'backend' and 'frontend'\n                'yii\\web\\YiiAsset',\n                'app\\assets\\SharedAsset',\n            ],\n        ],\n        'allBackEnd' =\n [\n            'js' =\n 'js/all-{hash}.js',\n            'css' =\n 'css/all-{hash}.css',\n            'depends' =\n [\n                // Include only 'backend' assets:\n                'app\\assets\\AdminAsset'\n            ],\n        ],\n        'allFrontEnd' =\n [\n            'js' =\n 'js/all-{hash}.js',\n            'css' =\n 'css/all-{hash}.css',\n            'depends' =\n [], // Include all remaining assets\n        ],\n    ],\n    ...\n];\n\n\n\nCome si pu\u00f2 vedere, i fasci di attivit\u00e0 si dividono in tre gruppi: \nallShared\n, \nallBackEnd\n e \nallFrontEnd\n. Ognuno di essi dipende da un insieme appropriato di pacchetti di risorse. Ad esempio, \nallBackEnd\n dipende da \napp\\assets\\AdminAsset\n. Quando si esegue il comando \nasset\n con questa configurazione, unir\u00e0 i bundle di asset in base alle specifiche precedenti.\n\n\n\n\nInfo\n\n\nPuoi lasciare la configurazione \ndepends\n vuota per uno dei pacchetti di destinazione. In questo modo, quel particolare bundle di asset dipender\u00e0 da tutti i bundle di asset rimanenti su cui altri bundle target non dipendono.",
            "title": "Assets"
        },
        {
            "location": "/application-structure/sub-assets/#risorse-assets",
            "text": "Una risorsa in Yii \u00e8 un file a cui \u00e8 possibile fare riferimento in una pagina Web. Pu\u00f2 essere un file CSS, un file JavaScript, un'immagine o un file video, ecc.. Le risorse si trovano in directory accessibili dal Web e sono servite direttamente dai server Web.  Spesso \u00e8 preferibile gestire le risorse a livello di programmazione. Ad esempio, quando si utilizza il widget  yii \\ jui \\ DatePicker  in una pagina, verranno automaticamente inclusi i file CSS e JavaScript richiesti, invece di chiedere di trovare manualmente questi file e includerli. E quando si aggiorna il widget a una nuova versione, verr\u00e0 automaticamente utilizzata la nuova versione dei file di asset. In questo tutorial, descriveremo la potente capacit\u00e0 di gestione degli asset fornita da Yii.",
            "title": "Risorse (Assets)"
        },
        {
            "location": "/application-structure/sub-assets/#definizione-dei-pacchetti-di-asset",
            "text": "I pacchetti di asset sono specificati come classi PHP che si estendono da  yii \\ web \\ AssetBundle . Il nome di un bundle \u00e8 semplicemente il suo nome relativo alla classe PHP. una classe di asset bundle dovrebbe essere autoloadable. Solitamente specifica dove si trovano le risorse, quali file CSS e JavaScript, e ci dice anche quale pacchetto dipende da altri bundle.  Il seguente codice definisce il pacchetto di asset principale utilizzato dal progetto del modello base:  ?php\n\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\n\nclass AppAsset extends AssetBundle{\n\n    public $basePath = '@webroot';\n    public $baseUrl = '@web';\n    public $css = [\n        'css/site.css',\n        ['css/print.css', 'media' =  'print'],\n    ];\n    public $js = [\n    ];\n    public $depends = [\n        'yii\\web\\YiiAsset',\n        'yii\\bootstrap\\BootstrapAsset',\n    ];\n}  La classe  AppAsset  specifica che il file di asset si trovano nella directory  @webroot  che corrisponde all'URL  @web ; il pacchetto contiene un singolo file CSS  css/site.css . e nessun file JavaScript. Il pacchetto dipende da altri due bundle:  yii \\ base \\ YiiAsset  e  yii \\ bootstrap \\ BootstrapAsset . Una spiegazione pi\u00f9 dettagliata della propriet\u00e0  yii \\ web \\ AssetBundle  pu\u00f2 essere trovata nel modo seguente:   sourcePath : specifica la directory root che contiene i file di asset in questo pacchetto. Questa propriet\u00e0 deve essere impostata se la directory principale non \u00e8 accessibile dal Web. In caso contrario, \u00e8 necessario impostare la propriet\u00e0  basePath  e  la propriet\u00e0  baseurl . Gli alias di percorso possono essere utilizzati.  basePath : specifica una directory accessibile dal Web che contiene i file di asset in questo pacchetto. Quando si specifica la propriet\u00e0  sourcePath , il gestore risorse pubblica le risorse di questo pacchetto in una directory accessibile dal Web, e sovrascrive di conseguenza questa propriet\u00e0. \u00c8 necessario impostarla se i file delle risorse sono gi\u00e0 in una directory accessibile dal Web e non \u00e8 necessario pubblicare gli asset. Gli alias di percorso possono essere utilizzati.  baseUrl : specifica l'URL corrispondente alla directory basePath. Come basePath , se si specifica la propriet\u00e0 sourcePath , il gestore risorse pubblicher\u00e0 le risorse e sovrascriver\u00e0 di conseguenza questa propriet\u00e0. Gli alias di percorso possono essere utilizzati.  css : specifica un array che elenca i file CSS contenuti in questo pacchetto. Si noti che solo la barra \"/\" deve essere utilizzata come separatore di directory. Ogni file pu\u00f2 essere specificato da solo come stringa o in un array insieme ai tag di attributo e ai relativi valori.   js : specifica un array che elenca i file JavaScript contenuti in questo pacchetto. Il formato di questo array \u00e8 lo stesso di quello del css . Ogni file JavaScript pu\u00f2 essere specificato in uno dei seguenti due formati:   un percorso relativo che rappresenta un file JavaScript locale (es js/main.js.). Il percorso effettivo del file pu\u00f2 essere determinato anteponendo  yii \\ web \\ AssetManager :: $ basePath  al percorso relativo e l'URL effettivo del file pu\u00f2 essere determinato anteponendo  yii \\ web \\ AssetManager :: $ baseUrl  al percorso relativo.  un URL assoluto che rappresenta un file JavaScript esterno. Ad esempio  http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js  o  //ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js. .     depends : specifica un array che elenca i nomi dei bundle di asset da cui dipende questo bundle (sar\u00e0 spiegato nei prossimi paragrafi).   jsOptions : specifica le opzioni che verranno passate al metodo  yii \\ web \\ View :: registerJsFile ()  quando viene chiamato per registrare ogni file JavaScript in questo pacchetto.  cssOptions : specifica le opzioni che verranno passate al metodo  yii \\ web \\ View :: registerCssFile ()  quando viene chiamato per registrare ogni file CSS in questo pacchetto.  publishOptions : specifica le opzioni che verranno passate al metodo  yii \\ web \\ AssetManager :: publish ()  quando viene chiamato per pubblicare i file di risorse dall'origine in una directory Web. Viene utilizzato solo se si specifica la propriet\u00e0  sourcePath .",
            "title": "Definizione dei pacchetti di asset"
        },
        {
            "location": "/application-structure/sub-assets/#posizioni-delle-risorse",
            "text": "Le risorse, in base alla loro posizione, possono essere classificate come:   source assets : i file delle risorse si trovano insieme al codice sorgente PHP che non pu\u00f2 essere direttamente accessibile via Web. Per utilizzare le source assets in una pagina, devono essere copiati in una directory Web e trasformati nelle cosiddette risorse pubbliche. Questo processo \u00e8 chiamato  asset publishing  che verr\u00e0 descritto nei paragrafi successivi.  risorse pubblicate : i file delle risorse si trovano in una directory Web e possono quindi essere accessibili direttamente via Web.  risorse esterne : i file delle risorse si trovano su un server Web diverso da quello che ospita la tua applicazione Web.   Quando si definisce una classe bundle di asset, se si specifica la propriet\u00e0  sourcePath , significa che tutte le risorse elencate, stanno utilizzando percorsi relativi e saranno considerate come source assets. Se non si specifica questa propriet\u00e0, significa che tali risorse sono risorse pubblicate (public assets) (\u00e8 necessario specificare  basePath  e  baseUrl  per consentire a Yii di sapere dove si trovano).  Si consiglia di posizionare le risorse appartenenti a un'applicazione in una directory Web, per evitare il processo di pubblicazione di asset non necessario e non voluto. Questo \u00e8 il motivo per cui  `AppAssetper ,nell'esempio precedente, gli viene specificato il  basePath , anzich\u00e9 il  sourcePath .  Per le estensioni, poich\u00e9 le loro risorse si trovano insieme al loro codice sorgente nelle directory che non sono accessibili dal Web, \u00e8 necessario specificare la propriet\u00e0  sourcePath  quando si definiscono le classi di pacchetti di asset relativi ad essi.   Warning  Non utilizzare il percorso di origine  @webroot/assetscome . Questa directory viene utilizzata come impostazione predefinita dal gestore risorse, per salvare i file di asset pubblicati dalla loro posizione di origine. Qualsiasi contenuto in questa directory, \u00e8 considerato temporaneamente e potrebbe essere soggetto a rimozione.",
            "title": "Posizioni delle risorse"
        },
        {
            "location": "/application-structure/sub-assets/#dipendenze-delle-risorse",
            "text": "Quando includi pi\u00f9 file CSS o JavaScript in una pagina Web, devono seguire un certo ordine per evitare problemi di sovrascrittura. Ad esempio, se si utilizza un widget dell'interfaccia utente jQuery in una pagina Web, \u00e8 necessario assicurarsi che il file jQuery JavaScript sia incluso prima del file JavaScript dell'interfaccia jQuery. Chiamiamo questi controlli \"dipendenze tra le risorse\".  Le dipendenze delle risorse vengono principalmente specificate tramite la propriet\u00e0  yii \\ web \\ AssetBundle :: $ depends . Nell'esempio  AppAsset , il fascio di asset dipende da altri due fasci di attivit\u00e0: Yii \\ web \\ YiiAsset  e  Yii \\ bootstrap \\ BootstrapAsset , il che significa che i file CSS e JavaScript in  AppAsset  saranno incluse dopo quei file nei due pacchetti dipendenti.  Le dipendenze delle risorse sono transitive. Ci\u00f2 significa che se il pacchetto A dipende da B, che dipende da C, A dipender\u00e0 anche da C.",
            "title": "Dipendenze delle risorse"
        },
        {
            "location": "/application-structure/sub-assets/#opzioni-degli-asset",
            "text": "\u00c8 possibile specificare le propriet\u00e0  cssOptions  e  jsOptions  per personalizzare il modo in cui i file CSS e JavaScript sono inclusi in una pagina. I valori di queste propriet\u00e0 verranno passati ai metodi  yii \\ web \\ View :: registerCssFile ()  e  yii \\ web \\ View :: registerJsFile () , quando verranno chiamati dalla view per includere file CSS e JavaScript.   Note  Le opzioni impostate in una classe di bundle di asset, si applicano a ogni file CSS / JavaScript nel pacchetto. Se si desidera utilizzare diverse opzioni per file diversi, \u00e8 necessario utilizzare il formato indicato sopra o creare pacchetti di risorse separati e utilizzare un set di opzioni in ciascun pacchetto.   Ad esempio, per includere in modo condizionale un file CSS per i browser con IE9 (Internet Explorer 9) o inferiore, \u00e8 possibile utilizzare la seguente opzione:  public $cssOptions = ['condition' =  'lte IE9'];  Ci\u00f2 causer\u00e0 l'inclusione di un file CSS nel pacchetto utilizzando i seguenti tag HTML:  !--[if lte IE9]  link rel=\"stylesheet\" href=\"path/to/foo.css\"  ![endif]--   Per racchiudere i tag di collegamento CSS generati all'interno di  noscript , puoi configurare  cssOptions  come segue:  public $cssOptions = ['noscript' =  true];  Per includere un file JavaScript nella sezione head di una pagina, puoi utilizzare la seguente opzione:  public $jsOptions = ['position' =  \\yii\\web\\View::POS_HEAD];  Per impostazione predefinita, quando un pacchetto di risorse viene pubblicato, tutti i contenuti nella directory specificata da  yii \\ web \\ AssetBundle :: $ sourcePath  verranno pubblicati. \u00c8 possibile personalizzare questo comportamento configurando la propriet\u00e0  publishOptions . Ad esempio, per pubblicare solo una o alcune sottodirectory di  yii \\ web \\ AssetBundle :: $ sourcePath , \u00e8 possibile effettuare quanto segue nella classe bundle degli asset:  ?php\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\n\nclass FontAwesomeAsset extends AssetBundle {\n\n    public $sourcePath = '@bower/font-awesome'; \n    public $css = [ \n        'css/font-awesome.min.css', \n    ];\n    public $publishOptions = [\n        'only' =  [\n            'fonts/',\n            'css/',\n        ]\n    ];\n}  L'esempio precedente definisce un pacchetto di risorse per il pacchetto \"fontawesome\" . Specificando l'opzione di pubblicazione  only , verranno pubblicate solo le sottodirectory  fonts e  css .",
            "title": "Opzioni degli asset"
        },
        {
            "location": "/application-structure/sub-assets/#utilizzo-dei-pacchetti-di-asset",
            "text": "Per utilizzare un pacchetto di risorse, dobbiamo registrarlo con una vista chiamando il metodo  yii \\ web \\ AssetBundle :: register () . Ad esempio, in un modello di vista \u00e8 possibile registrare un pacchetto di asset come il seguente:    use app\\assets\\AppAsset;\nAppAsset::register($this);  // $this represents the view object   Tip  Il metodo  yii \\ web \\ AssetBundle :: register()  restituisce un oggetto bundle di asset contenente le informazioni sulle risorse pubblicate, come   basePath  e  baseUrl .   Se si sta registrando un pacchetto di risorse in altri luoghi, \u00e8 necessario fornire l'oggetto di visualizzazione necessario. Ad esempio, per registrare un pacchetto di risorse in una classe widget , \u00e8 possibile ottenere l'oggetto vista per  $this- view .  Quando un bundle di asset \u00e8 registrato con una view, Yii registrer\u00e0 tutti i suoi bundle di asset dipendenti. Se un pacchetto di risorse si trova in una directory inaccessibile attraverso il Web, verr\u00e0 pubblicato in una directory Web. Successivamente, quando la vista esegue il rendering di una pagina, generer\u00e0 tag  link e   script  per i file CSS e JavaScript elencati nei pacchetti registrati. L'ordine di questi tag \u00e8 determinato dalle dipendenze tra i bundle registrati e dall'ordine delle risorse elencate nelle propriet\u00e0  yii \\ web \\ AssetBundle :: $ css  e  yii \\ web \\ AssetBundle :: $ js .",
            "title": "Utilizzo dei pacchetti di asset"
        },
        {
            "location": "/application-structure/sub-assets/#bundle-di-asset-dinamici",
            "text": "Essendo un normale pacchetto di risorse di classe PHP, \u00e8 possibile avere alcune logiche aggiuntive ad esso correlate e pu\u00f2 modificare dinamicamente i parametri interni. Ad esempio: \u00e8 possibile utilizzare una sofisticata libreria JavaScript, che fornisce internazionalizzazione in file di origine separati: ciascuno per ciascuna lingua supportata. Quindi dovrai aggiungere un particolare file \".js\" alla tua pagina per far funzionare la traduzione della libreria. Questo pu\u00f2 essere ottenuto sovrascrivendo il metodo yii \\ web \\ AssetBundle :: init () :  namespace app\\assets;\n\nuse yii\\web\\AssetBundle;\nuse Yii;\n\nclass SophisticatedAssetBundle extends AssetBundle{\n\n    public $sourcePath = '/path/to/sophisticated/src';\n    public $js = [\n        'sophisticated.js' // file, which is always used\n    ];\n\n    public function init(){\n\n        parent::init();\n        $this- js[] = 'i18n/' . Yii::$app- language . '.js'; // dynamic file added\n    }\n}  L'asset bunlde pu\u00f2 anche essere regolato tramite la sua istanza restituita da  yii \\ web \\ AssetBundle :: register() . Per esempio:  use app\\assets\\SophisticatedAssetBundle;\nuse Yii;\n\n$bundle = SophisticatedAssetBundle::register(Yii::$app- view);\n$bundle- js[] = 'i18n/' . Yii::$app- language . '.js'; // dynamic file added   Warning  Sebbene sia supportata la regolazione dinamica dei pacchetti di asset, non \u00e8 una buona pratica, perch\u00e8 pu\u00f2 portare a effetti collaterali imprevisti e, se possibile, dovrebbe essere evitata.",
            "title": "Bundle di asset dinamici"
        },
        {
            "location": "/application-structure/sub-assets/#personalizzazione-dei-pacchetti-di-risorse",
            "text": "Yii gestisce i bundle delle risorse tramite un componente dell'applicazione denominato  assetManager  che \u00e8 implementato da  yii \\ web \\ AssetManager . Configurando la propriet\u00e0  yii \\ web \\ AssetManager :: $ bundles , \u00e8 possibile personalizzare il comportamento di un pacchetto di risorse. Ad esempio, il pacchetto asset predefinito  yii \\ web \\ JqueryAsset  utilizza il file  jquery.js  dal pacchetto jquery Bower installato. Per migliorare la disponibilit\u00e0 e le prestazioni, potresti voler utilizzare una versione ospitata da Google. Questo lo possiamo ottenere configurando  assetManager  nella configurazione dell'applicazione come mostrato di seguito:  return [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'bundles' =  [\n                'yii\\web\\JqueryAsset' =  [\n                    'sourcePath' =  null,   // do not publish the bundle\n                    'js' =  [\n                        '//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js',\n                    ]\n                ],\n            ],\n        ],\n    ],\n];  \u00c8 possibile configurare pi\u00f9 bundle di asset in modo simile tramite  yii \\ web \\ AssetManager :: $ bundles . Le chiavi dell'array dovrebbero essere i nomi delle classi  dei bundle di asset (senza la barra rovesciata iniziale) e i valori dell'array dovrebbero corrispondere agli array di configurazione corrispondenti.   Tip  E' possibile scegliere condizionalmente quali risorse utilizzare in un pacchetto di risorse. L'esempio seguente mostra come utilizzare  jquery.js  nell'ambiente di sviluppo e anche  jquery.min.js  in altro modo:\n    'yii\\web\\JqueryAsset' =  [\n        'js' =  [\n        YII_ENV_DEV ? 'jquery.js' : 'jquery.min.js'\n        ]\n    ],   \u00c8 possibile disabilitare uno o pi\u00f9 gruppi di risorse associandogli il valore  false  ai nomi dei pacchetti di asset che si desidera disabilitare. Quando si registra un pacchetto di asset disabilitato ad una vista, nessuno dei suoi bundle dipendenti verr\u00e0 registrato e la vista non includer\u00e0 alcuna delle risorse nel pacchetto nella pagina che esegue il rendering. Ad esempio, per disabilitare  yii \\ web \\ JqueryAsset , \u00e8 possibile utilizzare la seguente configurazione:  return [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'bundles' =  [\n                'yii\\web\\JqueryAsset' =  false,\n            ],\n        ],\n    ],\n];  Puoi anche disabilitare tutti i pacchetti delle risorse impostante  yii \\ web \\ AssetManager :: $bundles  a  false .  Tieni presente che la personalizzazione effettuata tramite  yii \\ web \\ AssetManager :: $ bundle  viene applicata alla creazione del bundle di risorse, ad esempio durante la fase di costruzione di oggetti. Pertanto, qualsiasi aggiustamento apportato all'oggetto  bundle ,sostituir\u00e0 l'impostazione della mappatura al livello di  yii \\ web \\ AssetManager :: $ bundles . In particolare: le regolazioni effettuate all'interno del metodo  yii \\ web \\ AssetBundle :: init ()  o sull'oggetto bundle registrato, avranno la precedenza sulla configurazione dell' AssetManager . Ecco alcuni esempi, in cui la mappatura impostata tramite  yii \\ web \\ AssetManager :: $ bundles  non ha alcun effetto:  // Program source code:\n\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\nuse Yii;\n\nclass LanguageAssetBundle extends AssetBundle{\n\n    // ...\n\n    public function init(){\n\n        parent::init();\n        $this- baseUrl = '@web/i18n/' . Yii::$app- language; // can NOT be handled by `AssetManager`!\n    }\n}\n// ...\n\n$bundle = \\app\\assets\\LargeFileAssetBundle::register(Yii::$app- view);\n$bundle- baseUrl = YII_DEBUG ? '@web/large-files': '@web/large-files/minified'; // can NOT be handled by `AssetManager`!\n\n\n// Application config :\n\nreturn [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'bundles' =  [\n                'app\\assets\\LanguageAssetBundle' =  [\n                    'baseUrl' =  'http://some.cdn.com/files/i18n/en' // makes NO effect!\n                ],\n                'app\\assets\\LargeFileAssetBundle' =  [\n                    'baseUrl' =  'http://some.cdn.com/files/large-files' // makes NO effect!\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Personalizzazione dei pacchetti di risorse"
        },
        {
            "location": "/application-structure/sub-assets/#mapping-degli-asset",
            "text": "A volte potresti voler \"correggere\" i percorsi dei file di asset errati / incompatibili usati in pi\u00f9 bundle. Ad esempio, il pacchetto A utilizza la versione 1.11.1 del file  jquery.min.js  e il pacchetto B utilizza la versione 2.1.1 del file  jquery.js . Mentre \u00e8 possibile risolvere il problema personalizzando ogni fascio, un modo pi\u00f9 semplice \u00e8 quello di utilizzare funzione per mappare le attivit\u00e0 non corrette a agli oggetti desiderati. Per fare ci\u00f2, dobbiamo configurare la propriet\u00e0  yii \\ web \\ AssetManager :: $ assetMap  come segue:   return [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'assetMap' =  [\n                'jquery.js' =  '//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js',\n            ],\n        ],\n    ],\n];  Le chiavi di  assetMap  sono i nomi delle risorse che si desidera correggere e i valori sono i percorsi degli asset desiderati. Quando registri un pacchetto di asset con una vista, ogni file di asset relativo nei suoi array css e js sar\u00e0 esaminato rispetto a questa mappa. Se si trova che una delle chiavi \u00e8 l'ultima parte di un file di asset (che \u00e8 preceduta dal metodo yii \\ web \\ AssetBundle :: $ sourcePath , se disponibile), il valore corrispondente sostituir\u00e0 l'asset, e sar\u00e0 registrato nella vista. Ad esempio, il file di asset  my/path/to/jquery.js corrisponde alla chiave  jquery.js .   Warning  Solo le risorse specificate utilizzando i percorsi relativi sono soggette alla mappatura delle risorse. I percorsi delle risorse devono essere URL assoluti o percorsi relativi a  yii \\ web \\ AssetManager :: $basePath .",
            "title": "Mapping degli asset"
        },
        {
            "location": "/application-structure/sub-assets/#publishing-degli-asset",
            "text": "Come sopra indicato, se un pacchetto di risorse si trova in una directory che non \u00e8 accessibile dal Web, le sue risorse verranno copiate in una directory Web quando il bundle viene registrato con una vista. Questo processo \u00e8 chiamato  asset publishing  e viene eseguito automaticamente dal gestore degli asset .  Per impostazione predefinita, le risorse vengono pubblicate nella directory  @webroot/assets  che corrisponde all'URL  @web/assets . \u00c8 possibile personalizzare questa posizione configurando le propriet\u00e0  basePath  e  baseUrl .  Invece di pubblicare le risorse tramite la copia di file, \u00e8 possibile considerare l'utilizzo di collegamenti simbolici, sempre che sia il sistema operativo che il server lo permettano.Questa funzione pu\u00f2 essere abilitata impostando il valore di  linkAssets  a  true .  return [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'linkAssets' =  true,\n        ],\n    ],\n];  Con la configurazione sopra indicata, il gestore degli asset creer\u00e0 un collegamento simbolico al percorso di origine di un pacchetto di asset quando esso verr\u00e0 pubblicato. \u00c8 pi\u00f9 veloce della copia di file e pu\u00f2 anche garantire che le risorse pubblicate siano sempre aggiornate.",
            "title": "Publishing degli asset"
        },
        {
            "location": "/application-structure/sub-assets/#cache-busting",
            "text": "Per l'applicazione Web eseguita in modalit\u00e0 di produzione, \u00e8 prassi abilitare la memorizzazione nella cache HTTP per le risorse. Uno svantaggio di questa pratica \u00e8 che ogni volta che si modifica una risorsa e la si distribuisce in produzione, un client utente pu\u00f2 ancora utilizzare la versione precedente a causa della memorizzazione nella cache HTTP. Per ovviare a questo inconveniente, \u00e8 possibile utilizzare la funzionalit\u00e0  cache busting , introdotta nella versione 2.0.3, configurando  yii \\ web \\ AssetManager  come segue:  return [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'appendTimestamp' =  true,\n        ],\n    ],\n];  In questo modo, l'URL di ogni risorsa pubblicata verr\u00e0 aggiunto con il timestamp dell'ultima modifica. Ad esempio, l'URL  yii.js  potrebbe essere cos\u00ec fatto   /assets/5515a87c/yii.js?v=1423448645\" , in cui il parametro  v  rappresenta l'ultima data di modifica del file  yii.js . Ora se modifichi una risorsa, anche il suo URL verr\u00e0 modificato, il che fa s\u00ec che il client recuperi la versione pi\u00f9 recente della risorsa.",
            "title": "Cache busting"
        },
        {
            "location": "/application-structure/sub-assets/#pacchetti-di-beni-comunemente-usati",
            "text": "Il codice principale di Yii definisce molti pacchetti di risorse. Tra questi, i seguenti pacchetti sono comunemente usati e possono essere referenziati nell'applicazione o nel codice di estensione.   yii \\ web \\ YiiAsset : include principalmente il file  yii.js   che implementa un meccanismo di organizzazione del codice JavaScript nei moduli. Fornisce inoltre supporto speciale per gli attributi  data-method  e  data-confirm  e altre funzionalit\u00e0 utili.  yii \\ web \\ JqueryAsset : include il file  jquery.js  dal pacchetto  jQuery Bower .  yii \\ bootstrap \\ BootstrapAsset : include il file CSS dal framework Bootstrap di Twitter.  *yii \\ bootstrap \\ BootstrapPluginAsset : include il file JavaScript dal framework Bootstrap di Twitter per supportare i plug-in JavaScript di Bootstrap.  yii \\ jui \\ JuiAsset : include i file CSS e JavaScript dalla libreria dell'interfaccia utente jQuery.   Se il tuo codice dipende da jQuery, jQuery UI o Bootstrap, dovresti utilizzare questi bundle di asset predefiniti piuttosto che creare le tue versioni.",
            "title": "Pacchetti di beni comunemente usati"
        },
        {
            "location": "/application-structure/sub-assets/#conversione-delle-risorse",
            "text": "Invece di scrivere direttamente codice CSS e / o JavaScript, gli sviluppatori spesso li scrivono in una sintassi estesa e usano strumenti speciali per convertirli in CSS / JavaScript. Ad esempio,per il codice CSS \u00e8 possibile utilizzare  LESS  o  SCSS ; e per JavaScript puoi usare  TypeScript .  \u00c8 possibile elencare i file di asset in sintassi estesa nelle propriet\u00e0  css  e  js  di un pacchetto di risorse. Per esempio,  class AppAsset extends AssetBundle{\n\n    public $basePath = '@webroot';\n    public $baseUrl = '@web';\n    public $css = [\n        'css/site.less',\n    ];\n    public $js = [\n        'js/site.ts',\n    ];\n    public $depends = [\n        'yii\\web\\YiiAsset',\n        'yii\\bootstrap\\BootstrapAsset',\n    ];\n}  Quando si registra un pacchetto di asset con una vista, il gestore risorse eseguir\u00e0 automaticamente gli strumenti di pre-processore per convertire le risorse nella sintassi estesa riconosciuta in CSS / JavaScript. Quando alla fine, la vista esegue il rendering di una pagina, includer\u00e0 i file CSS / JavaScript nella pagina, anzich\u00e9 le risorse originali nella sintassi estesa.  Yii usa le estensioni dei nomi dei file per identificare la sintassi estesa in cui \u00e8 presente una risorsa. Per impostazione predefinita riconosce le seguenti estensioni di sintassi e nome file:   LESS :  .less  SCSS :  .scss  Stilo :  .styl  CoffeeScript :  .coffee  TypeScript :  .ts   Yii fa affidamento sugli strumenti pre-processore installati per convertire le risorse. Ad esempio, per utilizzare  LESS  \u00e8 necessario installare il comando  lessc  pre-processore.  E' possibile personalizzare i comandi del pre-processore e la sintassi estesa supportata, configurando il convertitore  yii \\ web \\ AssetManager ::  come il seguente:  return [\n    'components' =  [\n        'assetManager' =  [\n            'converter' =  [\n                'class' =  'yii\\web\\AssetConverter',\n                'commands' =  [\n                    'less' =  ['css', 'lessc {from} {to} --no-color'],\n                    'ts' =  ['js', 'tsc --out {to} {from}'],\n                ],\n            ],\n        ],\n    ],\n];  Come riportato sopra, specifichiamo la sintassi estesa supportata tramite la propriet\u00e0  yii \\ web \\ AssetConverter :: $ commands . Le chiavi dell'array sono i nomi delle estensioni dei file (senza punto iniziale) e i valori dell'array sono i nomi delle estensioni dei file delle risorse risultanti e i comandi per eseguire la conversione degli asset. I token  {from}  e  {to}  verranno sostituiti con i percorsi dei file di asset di origine e i percorsi dei file di asset di destinazione.   Info  Esistono altri modi di lavorare con le risorse nella sintassi estesa, oltre a quella descritta sopra. Ad esempio, \u00e8 possibile utilizzare strumenti di compilazione come  grunt  per monitorare e convertire automaticamente le risorse in sintassi estesa. In questo caso, \u00e8 necessario elencare i file CSS / JavaScript risultanti in bundle di asset anzich\u00e9 nei file originali.",
            "title": "Conversione delle risorse"
        },
        {
            "location": "/application-structure/sub-assets/#combinazione-e-compressione-delle-risorse",
            "text": "Una pagina Web pu\u00f2 includere molti file CSS e / o JavaScript. Per ridurre il numero di richieste HTTP e la dimensione complessiva di download di questi file, \u00e8 prassi comune combinare e comprimere pi\u00f9 file CSS / JavaScript in uno o pochissimi file e quindi includere questi file compressi invece di quelli originali nel Web pagine.   Info  La combinazione e la compressione delle risorse sono in genere necessarie quando un'applicazione \u00e8 in modalit\u00e0 di produzione. Nella modalit\u00e0 di sviluppo, l'utilizzo dei file CSS / JavaScript originali \u00e8 spesso pi\u00f9 conveniente ai fini del debug.   Di seguito, introduciamo un approccio per unire e comprimere i file delle risorse senza la necessit\u00e0 di modificare il codice dell'applicazione esistente.   Trovare tutti i pacchetti delle risorse nella nostra applicazione che vogliamo unire e comprimere.  Dividi questi pacchetti in uno o pochi gruppi. Si noti che ogni pacchetto pu\u00f2 appartenere solo a un singolo gruppo.  Unire / comprimere i file CSS in ogni gruppo in un singolo file. Fai lo stesso per i file JavaScript.  Definire un nuovo pacchetto di risorse per ogni gruppo:  Impostare la propriet\u00e0  css  e  js  come file uniti rispettivamente di file CSS e file di JavaScript.     Utilizzando questo approccio, quando si registra un pacchetto di asset in una vista, viene eseguita la registrazione automatica del nuovo bundle di asset per il gruppo a cui appartiene il bundle originale. Di conseguenza, i file di asset uniti / compressi sono inclusi nella pagina, anzich\u00e9 quelli originali.",
            "title": "Combinazione e compressione delle risorse"
        },
        {
            "location": "/application-structure/sub-assets/#un-esempio",
            "text": "Facciamo un esempio per spiegare ulteriormente l'approccio sopra.  Supponiamo che la tua applicazione abbia due pagine, X e Y. Pagina X utilizza i bundle di asset A, B e C, mentre Page Y utilizza i bundle di asset B, C e D.  Hai due modi per dividere questi pacchetti di risorse. Uno consiste nell'utilizzare un singolo gruppo per includere tutti i pacchetti di risorse, l'altro \u00e8 mettere A nel Gruppo X, D nel Gruppo Y e (B, C) nel Gruppo S. Qual \u00e8 il migliore? Dipende. Il primo modo ha il vantaggio che entrambe le pagine condividono gli stessi file combinati ( CSS e JavaScript), il che rende pi\u00f9 efficace il caching HTTP. D'altra parte, poich\u00e9 il gruppo singolo contiene tutti i bundle, la dimensione dei file combinati CSS e JavaScript sar\u00e0 maggiore e quindi aumenter\u00e0 il tempo di trasmissione del file iniziale. Per semplicit\u00e0, in questo esempio, useremo il primo modo, utilizzare un singolo gruppo per contenere tutti i bundle.   Info  Dividere i raggruppamenti delle risorse in gruppi non \u00e8 un compito banale. Di solito richiede analisi sui dati di traffico del mondo reale di varie risorse su pagine diverse. All'inizio, puoi iniziare con un singolo gruppo per semplicit\u00e0.   Utilizza gli strumenti esistenti (ad esempio Closure Compiler , YUI Compressor ) per unire e comprimere i file CSS e JavaScript in tutti i bundle. Si noti che i file devono essere combinati nell'ordine che soddisfa le dipendenze tra i pacchetti. Ad esempio, se Bundle A dipende da B che dipende da C e D, allora dovresti elencare i file di asset a partire da C e D, seguiti da B e infine A.  Dopo l'unione e la compressione, otteniamo un file CSS e un file JavaScript. Si supponga di nomiare i file  all-xyz.css  e  all-xyz.js , dove  xyz sta per un timestamp o un hash che viene utilizzato per rendere il nome del file univoco per evitare problemi di caching HTTP.  Siamo all'ultimo passo ora. Configurare il gestore degli asset come segue nella configurazione dell'applicazione:  return [\n    'components' =  [\n        'assetManager' =  [\n            'bundles' =  [\n                'all' =  [\n                    'class' =  'yii\\web\\AssetBundle',\n                    'basePath' =  '@webroot/assets',\n                    'baseUrl' =  '@web/assets',\n                    'css' =  ['all-xyz.css'],\n                    'js' =  ['all-xyz.js'],\n                ],\n                'A' =  ['css' =  [], 'js' =  [], 'depends' =  ['all']],\n                'B' =  ['css' =  [], 'js' =  [], 'depends' =  ['all']],\n                'C' =  ['css' =  [], 'js' =  [], 'depends' =  ['all']],\n                'D' =  ['css' =  [], 'js' =  [], 'depends' =  ['all']],\n            ],\n        ],\n    ],\n];  La suddetta configurazione modifica il comportamento predefinito di ciascun pacchetto. In particolare, i pacchetti A, B, C e D non hanno pi\u00f9 file di risorse. Ora dipendono tutti dal pacchetto  all  che contiene i file combinati  all-xyz.css  e  all-xyz.js . Di conseguenza, per la Pagina X, invece di includere i file originali dal Bundle A, B e C, saranno inclusi solo questi due file combinati; la stessa cosa succede a Page Y.  C'\u00e8 un trucco finale per rendere l'approccio spiegato in precedena pi\u00f9 agevole. Invece di modificare direttamente il file di configurazione dell'applicazione, \u00e8 possibile inserire l'array di personalizzazione del bundle in un file separato e includere condizionatamente questo file nella configurazione dell'applicazione. Per esempio,  return [\n    'components' =  [\n        'assetManager' =  [\n            'bundles' =  require __DIR__ . '/' . (YII_ENV_PROD ? 'assets-prod.php' : 'assets-dev.php'),  \n        ],\n    ],\n];  In altre parole, l'array di configurazione del bundle di asset viene salvato  assets-prod.php  per la modalit\u00e0 di produzione e  assets-dev.php per la modalit\u00e0 non di produzione.   Warning  Questo meccanismo di combinazione delle risorse si basa sulla capacit\u00e0 di poter sovrascrivere le propriet\u00e0 dei bundle di asse registrati tramite  yii \\ web \\ AssetManager :: $ bundle . Tuttavia, come gi\u00e0 detto sopra, questa abilit\u00e0 non copre gli aggiustamenti del bundle degli asset, che vengono eseguiti nel metodo  yii \\ web \\ AssetBundle :: init ()  o dopo che il bundle \u00e8 stato registrato. Dovresti evitare l'uso di tali pacchetti dinamici durante la combinazione delle risorse.",
            "title": "Un esempio"
        },
        {
            "location": "/application-structure/sub-assets/#comando-asset",
            "text": "Yii fornisce un comando console chiamato  asset  per automatizzare l'approccio che abbiamo appena descritto.  Per utilizzare questo comando, \u00e8 necessario innanzitutto creare un file di configurazione per descrivere quali gruppi di risorse devono essere combinati e come devono essere raggruppati. \u00c8 possibile utilizzare il sottocomando  asset/template  per generare un modello e quindi modificarlo per adattarlo alle proprie esigenze.  yii asset/template assets.php  Il comando genera un file nominato  assets.php  nella directory corrente. Il contenuto di questo file \u00e8 simile al seguente:  ?php\n/**\n* Configuration file for the \"yii asset\" console command.\n* Note that in the console environment, some path aliases like '@webroot' and '@web' may not exist.\n* Please define these missing path aliases.\n*/\nreturn [\n    // Adjust command/callback for JavaScript files compressing:\n    'jsCompressor' =  'java -jar compiler.jar --js {from} --js_output_file {to}',\n    // Adjust command/callback for CSS files compressing:\n    'cssCompressor' =  'java -jar yuicompressor.jar --type css {from} -o {to}',\n    // Whether to delete asset source after compression:\n    'deleteSource' =  false,\n    // The list of asset bundles to compress:\n    'bundles' =  [\n        // 'yii\\web\\YiiAsset',\n        // 'yii\\web\\JqueryAsset',\n    ],\n    // Asset bundle for compression output:\n    'targets' =  [\n        'all' =  [\n            'class' =  'yii\\web\\AssetBundle',\n            'basePath' =  '@webroot/assets',\n            'baseUrl' =  '@web/assets',\n            'js' =  'js/all-{hash}.js',\n            'css' =  'css/all-{hash}.css',\n        ],\n    ],\n    // Asset manager configuration:\n    'assetManager' =  [\n    ],\n];  \u00c8 necessario modificare questo file e specificare i pacchetti che si intende combinare nell'opzione  bundles . Nell'opzione  targets  \u00e8 necessario specificare come i fasci debbano essere divisi in gruppi. \u00c8 possibile specificare uno o pi\u00f9 gruppi, come sopra menzionato.   Warning  Poich\u00e8 gli alia  @webroot  e  @web  non sono disponibili nella console, \u00e8 necessario definire in modo esplicito nella configurazione.   I file JavaScript vengono uniti, compressi e scritti  js/all-{hash}.js  dove {hash} viene sostituito con l'hash del file risultante.  Le opzioni  jsCompressor  e  cssCompressor  specificano i comandi della console o i callback PHP per l'esecuzione di JavaScript e CSS. Per impostazione predefinita, Yii utilizza  Closure Compiler  per combinare i file JavaScript e YUI Compressor per combinare i file CSS. Dovresti installare questi strumenti manualmente o modificare queste opzioni per utilizzare i tuoi strumenti preferiti.  Con il file di configurazione, \u00e8 possibile eseguire il comando  asset  per combinare e comprimere i file di asset e quindi generare un nuovo file di configurazione del bundle di asset  assets-prod.php :  yii asset assets.php config/assets-prod.php  Il file di configurazione generato pu\u00f2 essere incluso nella configurazione dell'applicazione, come descritto nell'ultima sottosezione.   Warning  Se si personalizzano i bundle delle risorse per la propria applicazione tramite  yii \\ web \\ AssetManager :: $ bundles  o  yii \\ web \\ AssetManager :: $ assetMap  e si desidera applicare questa personalizzazione per i file di origine della compressione, \u00e8 necessario includere queste opzioni per la sezione  assetManager  all'interno del file di configurazione del comando asset.    Warning  Mentre si specifica la sorgente di compressione, si dovrebbe evitare l'uso di bundle di asset i cui parametri possono essere regolati dinamicamente (ad esempio al metodo  init()  o dopo la registrazione), poich\u00e9 potrebbero funzionare in modo non corretto dopo la compressione.",
            "title": "Comando asset"
        },
        {
            "location": "/application-structure/sub-assets/#raggruppamento-di-pacchetti-di-asset",
            "text": "Nell'ultima sottosezione, abbiamo spiegato come combinare tutti i pacchetti di risorse in uno solo per minimizzare le richieste HTTP per i file di risorsa a cui si fa riferimento in un'applicazione. Questo non \u00e8 sempre auspicabile nella pratica. Ad esempio, immagina che la tua applicazione abbia un \"front-end\" e un \"back-end\", ognuno dei quali utilizza un set diverso di file JavaScript e CSS. In questo caso, la combinazione di tutti i bundle di asset non ha senso, perch\u00e9 i bundle di asset per il \"front-end\" non vengono utilizzati dal \"back-end\" e sarebbe uno spreco di larghezza di banda della rete da inviare le risorse \"back-end\" quando viene richiesta una pagina \"front-end\".  Per risolvere il problema precedente, \u00e8 possibile dividere gruppi di risorse in gruppi e combinare raggruppamenti di risorse per ciascun gruppo. La seguente configurazione mostra come raggruppare i pacchetti di asset:  return [\n    ...\n    // Specify output bundles with groups:\n    'targets' =  [\n        'allShared' =  [\n            'js' =  'js/all-shared-{hash}.js',\n            'css' =  'css/all-shared-{hash}.css',\n            'depends' =  [\n                // Include all assets shared between 'backend' and 'frontend'\n                'yii\\web\\YiiAsset',\n                'app\\assets\\SharedAsset',\n            ],\n        ],\n        'allBackEnd' =  [\n            'js' =  'js/all-{hash}.js',\n            'css' =  'css/all-{hash}.css',\n            'depends' =  [\n                // Include only 'backend' assets:\n                'app\\assets\\AdminAsset'\n            ],\n        ],\n        'allFrontEnd' =  [\n            'js' =  'js/all-{hash}.js',\n            'css' =  'css/all-{hash}.css',\n            'depends' =  [], // Include all remaining assets\n        ],\n    ],\n    ...\n];  Come si pu\u00f2 vedere, i fasci di attivit\u00e0 si dividono in tre gruppi:  allShared ,  allBackEnd  e  allFrontEnd . Ognuno di essi dipende da un insieme appropriato di pacchetti di risorse. Ad esempio,  allBackEnd  dipende da  app\\assets\\AdminAsset . Quando si esegue il comando  asset  con questa configurazione, unir\u00e0 i bundle di asset in base alle specifiche precedenti.   Info  Puoi lasciare la configurazione  depends  vuota per uno dei pacchetti di destinazione. In questo modo, quel particolare bundle di asset dipender\u00e0 da tutti i bundle di asset rimanenti su cui altri bundle target non dipendono.",
            "title": "Raggruppamento di pacchetti di asset"
        },
        {
            "location": "/application-structure/sub-extensions/",
            "text": "Estensioni\n\n\nLe estensioni sono pacchetti software ridistribuibili progettati specificamente per essere utilizzati nella applicazioni Yii e offrono funzionalit\u00e0 pronte all'uso. Ad esempio, l'estensione \nyiisoft / yii2-debug\n aggiunge una comoda barra di debug nella parte inferiore di ogni pagina dell'applicazione per aiutarti a comprendere pi\u00f9 facilmente come vengono generate le pagine. Puoi usare le estensioni per accellerare il tuo processo di sviluppo. Puoi anche impacchettare il tuo codice come estensione per condividere con altre persone il tuo grande lavoro.\n\n\n\n\nNote\n\n\nUtiliziamo il termine \"estensione\" per fare riferimento ai pacchetti software specifici di Yii. Per pacchetti software generici che possono essere utilizzati senza Yii, faremo riferimento a loro usando il termine di \"pacchetto\" o \"libreria\".\n\n\n\n\nUtilizzando le estensioni\n\n\nPer utilizzare un'estensione, \u00e8 necessario prima installarla. La maggior parte delle estensioni sono distribuite come pacchetti di \nComposer\n che possono essere installati seguendo due semplici passaggi:\n1. modificare il file \ncomposer.json\n dell'applicazione e specificare quali estensioni (pacchetti di Composer) si desidera installare.\n2. eseguire \ncomposer install\n per installare le estensioni specificate.\n\n\nSi noti che potrebbe essere necessario installare il Composer se non lo si possiede.\n\n\nPer impostazione predefinita, il Composer installa i pacchetti registrati su \nPackagist\n, il pi\u00f9 grande repository per i pacchetti Composer open source. Puoi cercare estensioni su Packagist. Puoi anche creare il tuo repository e configurare il Composer per usarlo. Questo \u00e8 utile se stai sviluppando estensioni private che vuoi condividere solo nei tuoi progetti.\n\n\nLe estensioni installate da Composer sono memorizzate nella directory \nBasePath/vendor\n, dove \nBasePath\n fa riferimento al percorso base dell'applicazione.\nPoich\u00e8 il Composer \u00e8 un gestore delle dipendenze, quando installa un pacchetto, installa anche tutti i suoi pacchetti dipendenti.\n\n\nAd esempio, per installare l'estensione \nyiisoft/yii2-imagine\n, dobbiamo modificare il nostro \ncomposer.json\n, simile al seguente:\n\n\n{\n    // ...\n\n    \"require\": {\n        // ... other dependencies\n\n        \"yiisoft/yii2-imagine\": \"*\"\n    }\n}\n\n\n\nDopo l'installazione, dovresti vedere la directory \nyiisoft/yii2-imagine\n sotto \nBasePath/vendor\n. Dovresti anche vedere un'altra directory \nimagine/imagine\n che contiene il pacchetto dipendente installato.\n\n\n\n\nTip\n\n\nIl \nyiisoft/yii2-imagine\n \u00e8 un'estensione nucleo sviluppato e mantenuto dal team di sviluppo di Yii. Tutte le estensioni base sono ospitate su \nPackagist\n e sono denominate come \nyiisoft/yii2-xyz\n, dove \nxyz\n stanno per le diverse versioni.\n\n\n\n\nOra puoi usare le estensioni installate che faranno parte della tua applicazione. L'esempio seguente mostra come utilizzare la classe \nyii\\imagine\\Image\n fornita dall'estensione \nyiisoft/yii2-imagine\n:\n\n\nuse Yii;\nuse yii\\imagine\\Image;\n\n// generate a thumbnail image\nImage::thumbnail('@webroot/img/test-image.jpg', 120, 120)\n    -\nsave(Yii::getAlias('@runtime/thumb-test-image.jpg'), ['quality' =\n 50]);\n\n\n\n\n\nTip\n\n\nLe classi delle estensioni vengono caricate automaticamente dal caricatore automatico della classe Yii.\n\n\n\n\nInstallare manualmente le estensioni\n\n\nIn alcune rare occasioni, potresti voler installare alcune o tutte le estensioni manualmente, piuttosto che affidarti al Composer. Per fare ci\u00f2, dovresti:\n\n\n\n\nscaricare i file dell'archivio dell'estensione e decomprimerli nella directory \nvendor\n.\n\n\ninstallare i caricatori automatici della classe forniti dalle estensioni, se presenti.\n\n\nscaricare e installare le estensioni dipendenti come da istruzioni.\n\n\n\n\nSe un'estensione non ha un autoloader di classe ma segue lo standard \nPSR-4\n, \u00e8 possibile utilizzare il caricatore automatico di classe fornito da Yii per caricare automaticamente le classe di estensione. Tutto quello che devi fare \u00e8 solo dichiarare un alias di root per la directory dell'estensione. Ad esempio, supponendo di aver installato un'estensione nella directory \nvendor/mycompany/myext\n e le classi di estensione si trovano nel namespace \nmyext\n, \u00e8 possibile includere il seguente codice nella configurazione dell'applicazione:\n\n\n[\n    'aliases' =\n [\n        '@myext' =\n '@vendor/mycompany/myext',\n    ],\n]\n\n\n\nCreazione di un'estensione\n\n\nPotresti considerare di creare un'estensione quando senti la necessit\u00e0 di condividere con altre persone il tuo codice. Un'estensione pu\u00f2 contenere qualsiasi codice che preferisci, come una classe helper, un widget, un modulo, ecc..\n\n\nSi consiglia di creare un'estensione in termini di un pacchetto Composer in modo che possa essere installato in modo pi\u00f9 semplice e che possa essere anche utilizzato da altri utenti.\n\n\nDi seguito sono riportati i passaggi di base che \u00e8 possibile seguire per creare un'estensione come pacchetto di Composer.\n\n\n\n\nCrea un progetto per la tua estensione e ospitalo si una repository VCS, come per esempio \ngithub.com\n. Il lavoro di sviluppo e manutensione per l'estensione dovrebbe essere fatto su questa directory.\n\n\nSotto la directory root del progetto, crea un file chiamato \ncomposer.json\n come richiesto dal Composer.\n\n\nRegistra la tua estensione come una repository Composer, come Packagist, in modo che altri utenti possano trovare e installare la tua estensione usando il Composer.\n\n\n\n\nComposer.json\n\n\nOgni pacchetto di Composer deve avere un file \ncomposer.json\n nella sua directory principale. Il file contiene i metadati relativi al pacchetto. L'esempio seguente mostra il file \ncomposer.json\n per l'estensione \nyiisoft/yii2-imagine\n:\n\n\n{\n    // package name\n    \"name\": \"yiisoft/yii2-imagine\",\n\n    // package type\n    \"type\": \"yii2-extension\",\n\n    \"description\": \"The Imagine integration for the Yii framework\",\n    \"keywords\": [\"yii2\", \"imagine\", \"image\", \"helper\"],\n    \"license\": \"BSD-3-Clause\",\n    \"support\": {\n        \"issues\": \"https://github.com/yiisoft/yii2/issues?labels=ext%3Aimagine\",\n        \"forum\": \"http://www.yiiframework.com/forum/\",\n        \"wiki\": \"http://www.yiiframework.com/wiki/\",\n        \"irc\": \"irc://irc.freenode.net/yii\",\n        \"source\": \"https://github.com/yiisoft/yii2\"\n    },\n    \"authors\": [\n        {\n            \"name\": \"Lorenzo Milicia\",\n            \"email\": \"lorenzo.milicia4@gmail.com\"\n        }\n    ],\n\n    // package dependencies\n    \"require\": {\n        \"yiisoft/yii2\": \"~2.0.0\",\n        \"imagine/imagine\": \"v0.5.0\"\n    },\n\n    // class autoloading specs\n    \"autoload\": {\n        \"psr-4\": {\n            \"yii\\\\imagine\\\\\": \"\"\n        }\n    }\n}\n\n\n\nEstensioni principali\n\n\nYii fornisce le seguenti estensioni principali sviluppate e gestite dal team di sviluppatori di Yii. Sono tutti registrati su Packagist. Ecco un elenco delle principali estensioni:\n\n\n\n\nyiisoft / yii2-apidoc\n: fornisce un generatore di documentazione API estensibile e ad alte prestazioni. Viene anche utilizzato per generare la documentazione dell'API del framework principale.\n\n\nyiisoft / yii2-authclient\n: fornisce un insieme di client di autenticazione comunemente utilizzati, come il client OAuth2 di Facebook, il client GitHub OAuth2.\n\n\nyiisoft / yii2-bootstrap\n: fornisce un set di widget che incapsulano i componenti e i plugin Bootstrap .\n\n\nyiisoft / yii2-codeception\n: fornisce supporto di test basato su Codeception .\n\n\nyiisoft / yii2-debug\n: fornisce il supporto per il debug per le applicazioni Yii. Quando viene utilizzata questa estensione, nella parte inferiore di ogni pagina viene visualizzata una barra degli strumenti del debugger. L'estensione fornisce anche una serie di pagine autonome per visualizzare informazioni di debug pi\u00f9 dettagliate.\n\n\nyiisoft / yii2-elasticsearch\n: fornisce il supporto per l'utilizzo di Elasticsearch . Comprende il supporto di query / ricerca di base e implementa anche il pattern Active Record che consente di archiviare i record attivi in \u200b\u200bElasticsearch.\n\n\nyiisoft / yii2-faker\n: fornisce il supporto per l'utilizzo di Faker per generare dati falsi per te.\n\n\nyiisoft / yii2-gii\n: fornisce un generatore di codice basato sul Web che \u00e8 altamente estensibile e pu\u00f2 essere utilizzato per generare rapidamente modelli, moduli, moduli, CRUD, ecc.\n\n\nyiisoft / yii2-httpclient\n: fornisce un client HTTP.\n\n\nyiisoft / yii2-imagine\n: fornisce funzioni di manipolazione delle immagini di uso comune basate su Imagine .\n\n\nyiisoft / yii2-jui\n: fornisce un insieme di widget che incapsulano le interazioni e i widget dell'interfaccia utente JQuery .\n\n\nyiisoft / yii2-mongodb\n: fornisce il supporto per l'utilizzo di MongoDB . Include funzionalit\u00e0 come query di base, record attivi, migrazioni, memorizzazione nella cache, generazione di codice, ecc.\n\n\nyiisoft / yii2-redis\n: fornisce il supporto per l'utilizzo di redis . Include funzionalit\u00e0 come query di base, record attivi, memorizzazione nella cache, ecc.\n\n\nyiisoft / yii2-smarty\n: fornisce un motore di template basato su Smarty .\n\n\nyiisoft / yii2-sfinge\n: fornisce il supporto per l'uso di Sfinge . Include funzionalit\u00e0 come query di base, Active Record, generazione di codice, ecc.\n\n\nyiisoft / yii2-swiftmailer\n: fornisce funzioni di invio e-mail basate su swiftmailer .\n\n\nyiisoft / yii2-twig\n: fornisce un motore di template basato su Twig .",
            "title": "Estensioni"
        },
        {
            "location": "/application-structure/sub-extensions/#estensioni",
            "text": "Le estensioni sono pacchetti software ridistribuibili progettati specificamente per essere utilizzati nella applicazioni Yii e offrono funzionalit\u00e0 pronte all'uso. Ad esempio, l'estensione  yiisoft / yii2-debug  aggiunge una comoda barra di debug nella parte inferiore di ogni pagina dell'applicazione per aiutarti a comprendere pi\u00f9 facilmente come vengono generate le pagine. Puoi usare le estensioni per accellerare il tuo processo di sviluppo. Puoi anche impacchettare il tuo codice come estensione per condividere con altre persone il tuo grande lavoro.   Note  Utiliziamo il termine \"estensione\" per fare riferimento ai pacchetti software specifici di Yii. Per pacchetti software generici che possono essere utilizzati senza Yii, faremo riferimento a loro usando il termine di \"pacchetto\" o \"libreria\".",
            "title": "Estensioni"
        },
        {
            "location": "/application-structure/sub-extensions/#utilizzando-le-estensioni",
            "text": "Per utilizzare un'estensione, \u00e8 necessario prima installarla. La maggior parte delle estensioni sono distribuite come pacchetti di  Composer  che possono essere installati seguendo due semplici passaggi:\n1. modificare il file  composer.json  dell'applicazione e specificare quali estensioni (pacchetti di Composer) si desidera installare.\n2. eseguire  composer install  per installare le estensioni specificate.  Si noti che potrebbe essere necessario installare il Composer se non lo si possiede.  Per impostazione predefinita, il Composer installa i pacchetti registrati su  Packagist , il pi\u00f9 grande repository per i pacchetti Composer open source. Puoi cercare estensioni su Packagist. Puoi anche creare il tuo repository e configurare il Composer per usarlo. Questo \u00e8 utile se stai sviluppando estensioni private che vuoi condividere solo nei tuoi progetti.  Le estensioni installate da Composer sono memorizzate nella directory  BasePath/vendor , dove  BasePath  fa riferimento al percorso base dell'applicazione.\nPoich\u00e8 il Composer \u00e8 un gestore delle dipendenze, quando installa un pacchetto, installa anche tutti i suoi pacchetti dipendenti.  Ad esempio, per installare l'estensione  yiisoft/yii2-imagine , dobbiamo modificare il nostro  composer.json , simile al seguente:  {\n    // ...\n\n    \"require\": {\n        // ... other dependencies\n\n        \"yiisoft/yii2-imagine\": \"*\"\n    }\n}  Dopo l'installazione, dovresti vedere la directory  yiisoft/yii2-imagine  sotto  BasePath/vendor . Dovresti anche vedere un'altra directory  imagine/imagine  che contiene il pacchetto dipendente installato.   Tip  Il  yiisoft/yii2-imagine  \u00e8 un'estensione nucleo sviluppato e mantenuto dal team di sviluppo di Yii. Tutte le estensioni base sono ospitate su  Packagist  e sono denominate come  yiisoft/yii2-xyz , dove  xyz  stanno per le diverse versioni.   Ora puoi usare le estensioni installate che faranno parte della tua applicazione. L'esempio seguente mostra come utilizzare la classe  yii\\imagine\\Image  fornita dall'estensione  yiisoft/yii2-imagine :  use Yii;\nuse yii\\imagine\\Image;\n\n// generate a thumbnail image\nImage::thumbnail('@webroot/img/test-image.jpg', 120, 120)\n    - save(Yii::getAlias('@runtime/thumb-test-image.jpg'), ['quality' =  50]);   Tip  Le classi delle estensioni vengono caricate automaticamente dal caricatore automatico della classe Yii.",
            "title": "Utilizzando le estensioni"
        },
        {
            "location": "/application-structure/sub-extensions/#installare-manualmente-le-estensioni",
            "text": "In alcune rare occasioni, potresti voler installare alcune o tutte le estensioni manualmente, piuttosto che affidarti al Composer. Per fare ci\u00f2, dovresti:   scaricare i file dell'archivio dell'estensione e decomprimerli nella directory  vendor .  installare i caricatori automatici della classe forniti dalle estensioni, se presenti.  scaricare e installare le estensioni dipendenti come da istruzioni.   Se un'estensione non ha un autoloader di classe ma segue lo standard  PSR-4 , \u00e8 possibile utilizzare il caricatore automatico di classe fornito da Yii per caricare automaticamente le classe di estensione. Tutto quello che devi fare \u00e8 solo dichiarare un alias di root per la directory dell'estensione. Ad esempio, supponendo di aver installato un'estensione nella directory  vendor/mycompany/myext  e le classi di estensione si trovano nel namespace  myext , \u00e8 possibile includere il seguente codice nella configurazione dell'applicazione:  [\n    'aliases' =  [\n        '@myext' =  '@vendor/mycompany/myext',\n    ],\n]",
            "title": "Installare manualmente le estensioni"
        },
        {
            "location": "/application-structure/sub-extensions/#creazione-di-unestensione",
            "text": "Potresti considerare di creare un'estensione quando senti la necessit\u00e0 di condividere con altre persone il tuo codice. Un'estensione pu\u00f2 contenere qualsiasi codice che preferisci, come una classe helper, un widget, un modulo, ecc..  Si consiglia di creare un'estensione in termini di un pacchetto Composer in modo che possa essere installato in modo pi\u00f9 semplice e che possa essere anche utilizzato da altri utenti.  Di seguito sono riportati i passaggi di base che \u00e8 possibile seguire per creare un'estensione come pacchetto di Composer.   Crea un progetto per la tua estensione e ospitalo si una repository VCS, come per esempio  github.com . Il lavoro di sviluppo e manutensione per l'estensione dovrebbe essere fatto su questa directory.  Sotto la directory root del progetto, crea un file chiamato  composer.json  come richiesto dal Composer.  Registra la tua estensione come una repository Composer, come Packagist, in modo che altri utenti possano trovare e installare la tua estensione usando il Composer.",
            "title": "Creazione di un'estensione"
        },
        {
            "location": "/application-structure/sub-extensions/#composerjson",
            "text": "Ogni pacchetto di Composer deve avere un file  composer.json  nella sua directory principale. Il file contiene i metadati relativi al pacchetto. L'esempio seguente mostra il file  composer.json  per l'estensione  yiisoft/yii2-imagine :  {\n    // package name\n    \"name\": \"yiisoft/yii2-imagine\",\n\n    // package type\n    \"type\": \"yii2-extension\",\n\n    \"description\": \"The Imagine integration for the Yii framework\",\n    \"keywords\": [\"yii2\", \"imagine\", \"image\", \"helper\"],\n    \"license\": \"BSD-3-Clause\",\n    \"support\": {\n        \"issues\": \"https://github.com/yiisoft/yii2/issues?labels=ext%3Aimagine\",\n        \"forum\": \"http://www.yiiframework.com/forum/\",\n        \"wiki\": \"http://www.yiiframework.com/wiki/\",\n        \"irc\": \"irc://irc.freenode.net/yii\",\n        \"source\": \"https://github.com/yiisoft/yii2\"\n    },\n    \"authors\": [\n        {\n            \"name\": \"Lorenzo Milicia\",\n            \"email\": \"lorenzo.milicia4@gmail.com\"\n        }\n    ],\n\n    // package dependencies\n    \"require\": {\n        \"yiisoft/yii2\": \"~2.0.0\",\n        \"imagine/imagine\": \"v0.5.0\"\n    },\n\n    // class autoloading specs\n    \"autoload\": {\n        \"psr-4\": {\n            \"yii\\\\imagine\\\\\": \"\"\n        }\n    }\n}",
            "title": "Composer.json"
        },
        {
            "location": "/application-structure/sub-extensions/#estensioni-principali",
            "text": "Yii fornisce le seguenti estensioni principali sviluppate e gestite dal team di sviluppatori di Yii. Sono tutti registrati su Packagist. Ecco un elenco delle principali estensioni:   yiisoft / yii2-apidoc : fornisce un generatore di documentazione API estensibile e ad alte prestazioni. Viene anche utilizzato per generare la documentazione dell'API del framework principale.  yiisoft / yii2-authclient : fornisce un insieme di client di autenticazione comunemente utilizzati, come il client OAuth2 di Facebook, il client GitHub OAuth2.  yiisoft / yii2-bootstrap : fornisce un set di widget che incapsulano i componenti e i plugin Bootstrap .  yiisoft / yii2-codeception : fornisce supporto di test basato su Codeception .  yiisoft / yii2-debug : fornisce il supporto per il debug per le applicazioni Yii. Quando viene utilizzata questa estensione, nella parte inferiore di ogni pagina viene visualizzata una barra degli strumenti del debugger. L'estensione fornisce anche una serie di pagine autonome per visualizzare informazioni di debug pi\u00f9 dettagliate.  yiisoft / yii2-elasticsearch : fornisce il supporto per l'utilizzo di Elasticsearch . Comprende il supporto di query / ricerca di base e implementa anche il pattern Active Record che consente di archiviare i record attivi in \u200b\u200bElasticsearch.  yiisoft / yii2-faker : fornisce il supporto per l'utilizzo di Faker per generare dati falsi per te.  yiisoft / yii2-gii : fornisce un generatore di codice basato sul Web che \u00e8 altamente estensibile e pu\u00f2 essere utilizzato per generare rapidamente modelli, moduli, moduli, CRUD, ecc.  yiisoft / yii2-httpclient : fornisce un client HTTP.  yiisoft / yii2-imagine : fornisce funzioni di manipolazione delle immagini di uso comune basate su Imagine .  yiisoft / yii2-jui : fornisce un insieme di widget che incapsulano le interazioni e i widget dell'interfaccia utente JQuery .  yiisoft / yii2-mongodb : fornisce il supporto per l'utilizzo di MongoDB . Include funzionalit\u00e0 come query di base, record attivi, migrazioni, memorizzazione nella cache, generazione di codice, ecc.  yiisoft / yii2-redis : fornisce il supporto per l'utilizzo di redis . Include funzionalit\u00e0 come query di base, record attivi, memorizzazione nella cache, ecc.  yiisoft / yii2-smarty : fornisce un motore di template basato su Smarty .  yiisoft / yii2-sfinge : fornisce il supporto per l'uso di Sfinge . Include funzionalit\u00e0 come query di base, Active Record, generazione di codice, ecc.  yiisoft / yii2-swiftmailer : fornisce funzioni di invio e-mail basate su swiftmailer .  yiisoft / yii2-twig : fornisce un motore di template basato su Twig .",
            "title": "Estensioni principali"
        },
        {
            "location": "/handling-requests/sub-request-overview/",
            "text": "Panoramica\n\n\nOgni volta che un'applicazione Yii gestisce una richiesta, subisce un flusso di richieste come segue:\n\n\n\n\nUn utente fa una richiesta allo script di entrata \nweb/index.php\n.\n\n\nLo script di entrata carica la configurazione dell'applicazione e crea un'istanza dell'applicazione per gestire la richiesta.\n\n\nL'applicazione converte il percorso richiesto con l'aiuto del componente dell'applicazione richiesta.\n\n\nL'applicazione crea un'istanza del controller per gestire la richiesta.\n\n\nIl controller crea un'istanza di azione ed esegue i filtri per l'azione.\n\n\nSe un filtro fallisce, l'azione viene annullata.\n\n\nSe tutti i filtri passano, l'azione viene eseguita.\n\n\nL'azione carica un modello di dati , possibilmente da un database.\n\n\nL'azione rende una vista , fornendola con il modello di dati.\n\n\nIl risultato del rendering viene restituito al componente dell'applicazione di risposta .\n\n\nIl componente di risposta invia il risultato visualizzato al browser dell'utente.\n\n\n\n\nIl seguente diagramma mostra come un'applicazione gestisce una richiesta.\n\n\n\n\nIn questa sezione, descriveremo in dettaglio come funzionano alcuni di questi passaggi.",
            "title": "Panoramica sulla gestione delle richieste"
        },
        {
            "location": "/handling-requests/sub-request-overview/#panoramica",
            "text": "Ogni volta che un'applicazione Yii gestisce una richiesta, subisce un flusso di richieste come segue:   Un utente fa una richiesta allo script di entrata  web/index.php .  Lo script di entrata carica la configurazione dell'applicazione e crea un'istanza dell'applicazione per gestire la richiesta.  L'applicazione converte il percorso richiesto con l'aiuto del componente dell'applicazione richiesta.  L'applicazione crea un'istanza del controller per gestire la richiesta.  Il controller crea un'istanza di azione ed esegue i filtri per l'azione.  Se un filtro fallisce, l'azione viene annullata.  Se tutti i filtri passano, l'azione viene eseguita.  L'azione carica un modello di dati , possibilmente da un database.  L'azione rende una vista , fornendola con il modello di dati.  Il risultato del rendering viene restituito al componente dell'applicazione di risposta .  Il componente di risposta invia il risultato visualizzato al browser dell'utente.   Il seguente diagramma mostra come un'applicazione gestisce una richiesta.   In questa sezione, descriveremo in dettaglio come funzionano alcuni di questi passaggi.",
            "title": "Panoramica"
        },
        {
            "location": "/handling-requests/sub-bootstrapping/",
            "text": "Bootstrapping\n\n\nIl bootstrap fa riferimento al processo di preparazione dell'ambiente prima che un'applicazione inizi a risolvere e ad elaborare una richiesta in entrata. Il bootstrap viene eseguito in due punti: lo script di immissione (entry scrpit) e nell' applicazione.\n\n\nNell'entry script, vengono registrati i caricatori automatici di classi per diverse librerie. Ci\u00f2 include il caricatore automatico \nComposer\n tramite il relativo file \nautoload.php\n e il caricatore automatico Yii, attraverso il relativo file della classe \nYii\n. L'entry script carica quindi la configurazione dell'applicazione e crea un'istanza dell'applicazione.\n\n\nNel costruttore dell'applicazione, viene eseguito il seguente lavoro di bootstrap:\n\n\n\n\nviene chiamato il metodo \npreInit()\n, che configura alcune propriet\u00e0 dell'applicazione ad alta priorit\u00e0, come \nyii \\ base \\ Application :: basePath\n.\n\n\nRegistrare \nyii \\ base \\ Application :: errorHandler\n.\n\n\nInizializza le propriet\u00e0 dell'applicazione utilizzando la configurazione dell'applicazione specificata.\n\n\nViene chiamato il metodo \ninit()\n che a sua volta chiama il metodo \nbootstrap()\n per eseguire componenti bootstrap.\n\n\nIncludi il file manifest dell'estensione \nvendor/yiisoft/extensions.php\n.\n\n\nCrea ed esegui i componenti bootstrap dichiarati dalle estensioni.\n\n\nDobbiamo creare ed eseguire componenti e / o moduli dell'applicazione dichiarati nella propriet\u00e0 bootstrap dell'applicazione .\n\n\n\n\n\n\n\n\nPoich\u00e9 bootstrap deve essere eseguito prima di gestire ogni richiesta, \u00e8 molto importante mantenere questo processo leggero e ottimizzarlo il pi\u00f9 possibile.\n\n\nAdesso dobbiamo cercare di non registrare troppi componenti bootstrap. Un componente bootstrap \u00e8 necessario solo se vuole partecipare all'intero ciclo di vita della gestione richiesta. Ad esempio,se un modulo deve registrare regole di analisi URL aggiuntive, dovrebbe essere elencato nella propriet\u00e0 bootstrap in modo che le nuove regole URL possano avere effetto prima che vengano utilizzate per risolvere le richieste.\n\n\nIn modalit\u00e0 di produzione dell'applicazione, possiamo abilitare una cache bytecode, come \nOPcache\n o \nAPC\n, per ridurre al minimo il tempo necessario per includere e analizzare i file PHP.\n\n\nAlcune applicazioni di grandi dimensioni hanno configurazioni molto complesse e suddivise in molti file di configurazione pi\u00f9 piccoli. In tal caso, ci conviene prendere in considerazione la memorizzazione nella cache di un intero array di configurazione.",
            "title": "Bootstrapping"
        },
        {
            "location": "/handling-requests/sub-bootstrapping/#bootstrapping",
            "text": "Il bootstrap fa riferimento al processo di preparazione dell'ambiente prima che un'applicazione inizi a risolvere e ad elaborare una richiesta in entrata. Il bootstrap viene eseguito in due punti: lo script di immissione (entry scrpit) e nell' applicazione.  Nell'entry script, vengono registrati i caricatori automatici di classi per diverse librerie. Ci\u00f2 include il caricatore automatico  Composer  tramite il relativo file  autoload.php  e il caricatore automatico Yii, attraverso il relativo file della classe  Yii . L'entry script carica quindi la configurazione dell'applicazione e crea un'istanza dell'applicazione.  Nel costruttore dell'applicazione, viene eseguito il seguente lavoro di bootstrap:   viene chiamato il metodo  preInit() , che configura alcune propriet\u00e0 dell'applicazione ad alta priorit\u00e0, come  yii \\ base \\ Application :: basePath .  Registrare  yii \\ base \\ Application :: errorHandler .  Inizializza le propriet\u00e0 dell'applicazione utilizzando la configurazione dell'applicazione specificata.  Viene chiamato il metodo  init()  che a sua volta chiama il metodo  bootstrap()  per eseguire componenti bootstrap.  Includi il file manifest dell'estensione  vendor/yiisoft/extensions.php .  Crea ed esegui i componenti bootstrap dichiarati dalle estensioni.  Dobbiamo creare ed eseguire componenti e / o moduli dell'applicazione dichiarati nella propriet\u00e0 bootstrap dell'applicazione .     Poich\u00e9 bootstrap deve essere eseguito prima di gestire ogni richiesta, \u00e8 molto importante mantenere questo processo leggero e ottimizzarlo il pi\u00f9 possibile.  Adesso dobbiamo cercare di non registrare troppi componenti bootstrap. Un componente bootstrap \u00e8 necessario solo se vuole partecipare all'intero ciclo di vita della gestione richiesta. Ad esempio,se un modulo deve registrare regole di analisi URL aggiuntive, dovrebbe essere elencato nella propriet\u00e0 bootstrap in modo che le nuove regole URL possano avere effetto prima che vengano utilizzate per risolvere le richieste.  In modalit\u00e0 di produzione dell'applicazione, possiamo abilitare una cache bytecode, come  OPcache  o  APC , per ridurre al minimo il tempo necessario per includere e analizzare i file PHP.  Alcune applicazioni di grandi dimensioni hanno configurazioni molto complesse e suddivise in molti file di configurazione pi\u00f9 piccoli. In tal caso, ci conviene prendere in considerazione la memorizzazione nella cache di un intero array di configurazione.",
            "title": "Bootstrapping"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/",
            "text": "Routing e creazione degli URL\n\n\nQuando un'applicazione Yii avvia l'elaborazione di una richiesta di URL, il primo passo necessario \u00e8 analizzare l'URL in una \nroute\n. Il percorso viene quindi utilizzato per istanziare l' azione del controller corrispondente per gestire la richiesta. L'intero processo \u00e8 chiamato \nrouting\n.\n\n\nIl processo inverso di routing si chiama creazione di URL , che crea un URL da una determinata route e i parametri di query associati. Successivamente, quando viene richiesto l'URL creato, il processo di routing pu\u00f2 risolverlo nel percorso originale e nei parametri della query associata.\n\n\nIl pezzo centrale responsabile per il routing e la creazione di URL \u00e8 il gestore degli URL , che \u00e8 registrato come componente dell'applicazione \nurlManager\n. Il gestore URL fornisce il metodo \nparseRequest()\n per analizzare una richiesta in entrata in una route e i parametri di query associati ad esso, e fornisce anche il metodo \ncreateUrl()\n per creare un URL da una determinata route e i relativi parametri di query associati.\n\n\nConfigurando il componente \nurlManager\n nella configurazione dell'applicazione, \u00e8 possibile consentire all'applicazione di riconoscere i formati di URL arbitrari senza modificare il codice dell'applicazione esistente. Ad esempio, \u00e8 possibile utilizzare il seguente codice per creare un URL per l'azione \npost/view\n:\n\n\nuse yii\\helpers\\Url;\n\n// Url::to() calls UrlManager::createUrl() to create a URL\n$url = Url::to(['post/view', 'id' =\n 100]);\n\n\n\nA seconda della configurazione dell'\nurlManager\n, l'URL creato pu\u00f2 apparire come uno degli esempi sottostanti. E se l'URL creato viene richiesto in seguito, verr\u00e0 comunque analizzato nella route originale e nel valore del parametro di query.\n\n\n/index.php?r=post%2Fview\nid=100\n/index.php/post/100\n/posts/100\n\n\n\nFormati degli URL\n\n\nIl gestore degli URL supporta due formati:\n\n\n\n\nIl formato URL predefinito.\n\n\nIl formato URL pi\u00f9 \"grazioso\".\n\n\n\n\nIl formato URL predefinito utilizza un parametro di query denominato \nr\n per rappresentare la route e i normali parametri di query. Ad esempio, l'URL \n/index.php?r=post/view\nid=100\n rappresenta il percorso \npost/view\n e il parametro \nid\n ha un valore di \n100\n. Il formato URL predefinito non richiede alcuna configurazione del gestore URL e funziona in qualsiasi configurazione del server Web.\n\n\nIl formato URL \u201cgrazioso\u201c utilizza il percorso aggiuntivo che segue il nome dello script della voce per rappresentare la route e i parametri di query associati. Ad esempio, il percorso aggiuntivo nell'URL \n/index.php/post/100\n \u00e8 \n/post/100\n che pu\u00f2 rappresentare il percorso \npost/view\ne il parametro \nid\n che ha come valore della query \n100\ncon una regola URL appropriata . Per utilizzare il formato URL pi\u00f9 grazioso, \u00e8 necessario progettare un set di regole URL in base ai requisiti effettivi su come dovrebbe apparire l'URL.\n\n\n\u00c8 possibile passare tra i due formati di URL attivando la propriet\u00e0 \nenablePrettyUrl\n del gestore URL senza modificare nessun codice nell'applicazione.\n\n\nRouting\n\n\nIl routing prevede due passaggi:\n\n\n\n\nla richiesta in entrata viene analizzata in una route e i parametri di query associati;\n\n\nviene creata un'azione di controllo corrispondente al percorso analizzato per gestire la richiesta.\n\n\n\n\nQuando si utilizza il formato URL predefinito, l'analisi di una richiesta in una route \u00e8 semplice come ottenere il valore di un parametro GET di una query denominata \nr\n.\n\n\nQuando si utilizza il formato URL \"grazioso\", il gestore URL esaminer\u00e0 le regole URL registrate per trovare quella corrispondente che possa risolvere la richiesta in una route. Se tale regola non pu\u00f2 essere trovata, verr\u00e0 generata un'eccezione \nyii \\ web \\ NotFoundHttpException\n.\n\n\nUna volta che la richiesta viene analizzata in una route, \u00e8 il momento di creare l'azione del controller identificata dalla route stessa. Il percorso \u00e8 suddiviso in pi\u00f9 parti con le barre in esso contenute. Ad esempio, \nsite/index\n sar\u00e0 suddiviso in \nsite\ne \nindex\n. Ogni parte \u00e8 un ID che pu\u00f2 riferirsi a un modulo, a un controllore o a un'azione. A partire dalla prima parte del percorso, l'applicazione effettua le seguenti operazioni per creare i moduli (se presenti), il controller e l'azione:\n\n\n\n\nImposta l'applicazione come modulo corrente\n\n\nVerificare se il \"controller map\" del modulo corrente contiene l'ID giusto. In tal caso, verr\u00e0 creato un oggetto controller in base alla configurazione trovata nella mappa e verr\u00e0 eseguito il passaggio \"5\" per gestire la parte restante del percorso.\n\n\nVerifica se l'ID fa riferimento a un modulo elencato nella propriet\u00e0 \nyii \\ base \\ Module :: modules\n del modulo corrente. In tal caso, viene creato un modulo in base alla configurazione trovata nell'elenco dei moduli e il passaggio \"2\" verr\u00e0 utilizzato per gestire la parte successiva del percorso nel contesto del modulo appena creato.\n\n\nTratta l'ID come un' \"ID controller\" e crea un oggetto controller. Fai il prossimo passo con la parte restante del percorso.\n\n\nIl controller cerca l'ID corrente nella sua mappa d'azione. Se trovato, crea un'azione in base alla configurazione trovata nella mappa. In caso contrario, il controller tenter\u00e0 di creare un'azione in linea definita da un metodo di azione corrispondente all'ID azione corrente.\n\n\n\n\nTra i passaggi precedenti, se si verifica un errore, verr\u00e0 generata un'eccezione \nyii \\ web \\ NotFoundHttpException\n, che indica l'errore del processo di routing.\n\n\nPercorso predefinito\n\n\nQuando una richiesta viene analizzata in una route vuota, verr\u00e0 utilizzata la cosiddetta \"route predefinita\". Per impostazione predefinita, la route predefinita \u00e8 \nsite/index\n, che si riferisce all'azione \nindex\n del \nsitecontroller\n. \u00c8 possibile personalizzarlo configurando la propriet\u00e0 \ndefaultRoute\n dell'applicazione nella configurazione dell'app come la seguente:\n\n\n[\n    // ...\n    'defaultRoute' =\n 'main/index',\n];\n\n\n\nSimile al percorso predefinito dell'applicazione, vi \u00e8 anche un percorso predefinito per i moduli, cos\u00ec per esempio se vi \u00e8 un modulo \nuser\n e la richiesta viene analizzata nella route \nuser\n del modulo \ndefaultroute\n \u00e8 utilizzato per determinare il controller. Per impostazione predefinita, il nome del controller \u00e8 \ndefault\n. Se non si specifica un'azione \ndefaultroute\n, la propriet\u00e0 \nDefaultAction\n del controller verr\u00e0 utilizzata per determinare l'azione. In questo esempio, il percorso completo sar\u00e0 \nuser/default/index\n.\n\n\nItinerario \nCatchAll\n\n\nA volte, potresti voler mettere temporaneamente in pausa la tua applicazione Web e visualizzare la stessa pagina informativa per tutte le richieste. Ci sono molti modi per raggiungere questo obiettivo. Ma uno dei modi pi\u00f9 semplici \u00e8 configurare la propriet\u00e0 \nyii \\ web \\ Application :: $ catchAll\n come segue nella configurazione dell'applicazione:\n\n\n[\n    // ...\n    'catchAll' =\n ['site/offline'],\n];\n\n\n\nCon la configurazione sopra indicata, l'azione \nsite/offline\n verr\u00e0 utilizzata per gestire tutte le richieste in arrivo.\n\n\nLa propriet\u00e0 \ncatchAll\n dovrebbe prendere una matrice,il cui primo elemento specifica una rotta, e il resto degli elementi (coppie nome-valore) specificano i parametri da associare all'azione stessa.\n\n\n\n\nInfo\n\n\nLa barra degli strumenti di debug nell'ambiente di sviluppo non funzioner\u00e0 quando questa propriet\u00e0 \u00e8 abilitata.\n\n\n\n\nCreazione di URL\n\n\nYii fornisce un metodo di supporto \nyii \\ helpers \\ Url :: to()\n per creare vari tipi di URL dai percorsi specificati e i relativi parametri di query associati. Per esempio,\n\n\nuse yii\\helpers\\Url;\n\n// creates a URL to a route: /index.php?r=post%2Findex\necho Url::to(['post/index']);\n\n// creates a URL to a route with parameters: /index.php?r=post%2Fview\nid=100\necho Url::to(['post/view', 'id' =\n 100]);\n\n// creates an anchored URL: /index.php?r=post%2Fview\nid=100#content\necho Url::to(['post/view', 'id' =\n 100, '#' =\n 'content']);\n\n// creates an absolute URL: http://www.example.com/index.php?r=post%2Findex\necho Url::to(['post/index'], true);\n\n// creates an absolute URL using the https scheme: https://www.example.com/index.php?r=post%2Findex\necho Url::to(['post/index'], 'https');\n\n\n\nNota che nell'esempio indicato sopra, assumiamo per esempio, che venga utilizzato il formato URL predefinito. Se il formato URL \"pretty\"(grazioso) \u00e8 abilitato, gli URL creati saranno diversi, in base alle regole URL in uso.\n\n\nIl percorso passato al metodo \nyii \\ helpers \\ Url :: to ()\n \u00e8 sensibile al contesto. Pu\u00f2 essere una route relativa o una route assoluta, che sar\u00e0 normalizzata secondo le seguenti regole:\n\n\n\n\nSe la route \u00e8 una stringa vuota, verr\u00e0 utilizzata la route \n yii \\ web \\ Controller :: \n attualmente richiesta;\n\n\nSe il percorso non contiene alcuna barra, viene considerato un ID d'azione del controller corrente e verr\u00e0 anteposto al valore \nyii \\ web \\ Controller :: uniqueId\n del controller corrente;\n\n\nSe la route non ha una barra iniziale, viene considerata una route relativa al modulo corrente e verr\u00e0 anteposta al valore \nyii \\ base \\ Module :: uniqueId\n del modulo corrente.\n\n\n\n\nA partire dalla versione 2.0.2, \u00e8 possibile specificare un percorso in termini di \nalias\n. In questo caso, l'alias verr\u00e0 convertito nel percorso effettivo trasformandolo in un percorso assoluto in base alle regole precedenti.\n\n\nAd esempio, supponiamo che il modulo corrente sia \nadmin\n e il controller corrente sia \npost\n,\n\n\nuse yii\\helpers\\Url;\n\n// currently requested route: /index.php?r=admin%2Fpost%2Findex\necho Url::to(['']);\n\n// a relative route with action ID only: /index.php?r=admin%2Fpost%2Findex\necho Url::to(['index']);\n\n// a relative route: /index.php?r=admin%2Fpost%2Findex\necho Url::to(['post/index']);\n\n// an absolute route: /index.php?r=post%2Findex\necho Url::to(['/post/index']);\n\n// using an alias \"@posts\", which is defined as \"/post/index\": /index.php?r=post%2Findex\necho Url::to(['@posts']);\n\n\n\nIl metodo \nyii \\ helpers \\ Url :: to ()\n viene implementato chiamando i metodi \ncreateUrl()\n e \ncreateAbsoluteUrl()\n del gestore URL. Nelle prossime sottosezioni, spiegheremo come configurare il gestore URL per personalizzare il formato degli URL creati.\n\n\nIl metodo \nyii \\ helpers \\ Url :: to ()\n supporta anche la creazione di URL che non sono correlati a percorsi particolari. Invece di passare un array come primo parametro, dovresti passare una stringa in questo caso. Per esempio,\n\n\nuse yii\\helpers\\Url;\n\n// currently requested URL: /index.php?r=admin%2Fpost%2Findex\necho Url::to();\n\n// an aliased URL: http://example.com\nYii::setAlias('@example', 'http://example.com/');\necho Url::to('@example');\n\n// an absolute URL: http://example.com/images/logo.gif\necho Url::to('/images/logo.gif', true);\n\n\n\nOltre al metodo \nto()\n, la classe \nhelper\n \nyii \\ helpers \\ Url\n fornisce anche altri metodi di creazione di URL convenienti. Per esempio,\n\n\nuse yii\\helpers\\Url;\n\n// home page URL: /index.php?r=site%2Findex\necho Url::home();\n\n// the base URL, useful if the application is deployed in a sub-folder of the Web root\necho Url::base();\n\n// the canonical URL of the currently requested URL\n// see https://en.wikipedia.org/wiki/Canonical_link_element\necho Url::canonical();\n\n// remember the currently requested URL and retrieve it back in later requests\nUrl::remember();\necho Url::previous();\n\n\n\nUtilizziamo gli URL \"graziosi\" (pretty)\n\n\nPer utilizzare gli URL \"graziosi\", dobbiamo configurare il componente \nurlManager\n nella configurazione dell'applicazione come segue:\n\n\n[\n    'components' =\n [\n        'urlManager' =\n [\n            'enablePrettyUrl' =\n true,\n            'showScriptName' =\n false,\n            'enableStrictParsing' =\n false,\n            'rules' =\n [\n                // ...\n            ],\n        ],\n    ],\n]\n\n\n\nLa propriet\u00e0 \nenablePrettyUrl\n \u00e8 obbligatoria in quanto attiva il formato URL grazioso. Il resto della propriet\u00e0 \u00e8 facoltativo. Tuttavia, la loro configurazione indicata di sopra \u00e8 la pi\u00f9 usata.\n\n\n\n\nshowScriptName\n: questa propriet\u00e0 determina se lo script in entrata deve essere incluso negli URL creati. Ad esempio, invece di creare un URL \n/index.php/post/100\n, impostando questa propriet\u00e0 a \nfalse\n, verr\u00e0 generato un URL \n/post/100\n.\n\n\nenableStrictParsing\n: questa propriet\u00e0 determina se abilitare l'analisi rigorosa delle richieste. Se l'analisi rigorosa \u00e8 abilitata, l'URL richiesto in entrata deve corrispondere ad almeno una delle regole per essere trattato come una richiesta valida, altrimenti verr\u00e0 generata una eccezione \nyii \\ web \\ NotFoundHttpException\n. Se l'analisi rigorosa \u00e8 disabilitata, quando nessuna delle regole corrisponde all'URL richiesto, la parte di informazioni sul percorso dell'URL verr\u00e0 considerata come la route richiesta.\n\n\nrules\n: questa propriet\u00e0 contiene un elenco di regole che specificano come analizzare e creare URL. \u00c8 la propriet\u00e0 principale con cui dovresti lavorare per creare URL il cui formato soddisfa i tuoi particolari requisiti applicativi.\n\n\n\n\n\n\nNote\n\n\nAl fine di nascondere il nome dello script di entrata negli URL creati, oltre al valore \nfalse\n di \nshowScriptName\n, potrebbe anche essere necessario configurare il server Web in modo che possa identificare correttamente quale script PHP dovrebbe essere eseguito quando un URL richiesto non viene specificato.\n\n\n\n\nRegole dell'URL\n\n\nUna regola associata all'URL \u00e8 una classe che implementa \nyii \\ web \\ UrlRuleInterface\n, in genere \nyii \\ web \\ UrlRule\n. Ogni regola URL consiste in un modello utilizzato per la corrispondenza della parte di informazioni sul percorso degli URL, una route e alcuni parametri di query. Una regola URL pu\u00f2 essere utilizzata per analizzare una richiesta,se il suo modello corrisponde all'URL richiesto. \u00c8 possibile utilizzare una regola URL per creare un URL se i relativi nomi dei parametri di route e query corrispondono a quelli forniti.\n\n\nQuando il formato URL pretty(grazioso) \u00e8 abilitato, il gestore URL utilizza le regole dichiarate nella sua propriet\u00e0 \nrules\n per analizzare le richieste in arrivo e creare l'URL. In particolare, per analizzare una richiesta in arrivo, il gestore URL esamina le regole nell'ordine dichiarate in precedenza e cerca la prima regola che corrisponde all'URL richiesto. La regola di corrispondenza viene quindi utilizzata per analizzare l'URL in una route e i relativi parametri associati. Allo stesso modo, per creare un URL, il gestore URL cerca la prima regola che corrisponde al percorso e ai parametri specificati e la utilizza per creare un URL.\n\n\n\u00c8 possibile configurare le regole \nyii \\ web \\ UrlManager :: $\n come una matrice, composta con le chiavi come modelli e i relativi percorsi. Ogni coppia \"percorso-itinerario\" costruisce una regola URL. Ad esempio, la seguente configurazione dichiara due regole URL. La prima regola corrisponde a un URL \npost\n se lo mappa nella route \npost/index\n. La seconda regola corrisponde a un URL indicato dall'espressione \npost/(\\d+)\n e lo mappa nella route \npost/view\n e nello stesso momento definisce un parametro associato all'\nid\n.\n\n\n'rules' =\n [\n    'posts' =\n 'post/index',\n    'post/\nid:\\d+\n' =\n 'post/view',\n]\n\n\n\nOltre a dichiarare le regole dell'URL come coppie di \"pattern-route\", puoi anche dichiararle come array di configurazione. Ogni array di configurazione viene utilizzato per configurare un singolo oggetto per la regola dell'URL. Questo \u00e8 spesso necessario quando si desidera configurare altre propriet\u00e0 di una regola URL. Per esempio,\n\n\n'rules' =\n [\n    // ...other url rules...\n    [\n        'pattern' =\n 'posts',\n        'route' =\n 'post/index',\n        'suffix' =\n '.json',\n    ],\n]\n\n\n\nPer impostazione predefinita, se non si specifica l'opzione \nclass\n per una configurazione di regole, verr\u00e0 utilizzata la classe predefinita \nyii \\ web \\ UrlRule\n, che \u00e8 il valore predefinito definito in \nyii \\ web \\ UrlManager :: $ ruleConfig\n.\n\n\nParametri nominati\n\n\nUna regola URL pu\u00f2 essere associata ai parametri di query denominati che sono specificati nel modello del formato di \nParamName:RegExp\n, dove \nParamName\n specifica il nome del parametro e \nRegExp\n \u00e8 un'espressione regolare facoltativa utilizzata per abbinare i valori dei parametri. Se \nRegExp\n non \u00e8 specificato, significa che il valore del parametro dovr\u00e0 essere una stringa senza alcuna barra.\n\n\nQuando una regola viene utilizzata per analizzare un URL, riempir\u00e0 i parametri associati con valori corrispondenti ai componenti che formano l'URL e questi parametri saranno resi disponibili in seguito ad un componente \nrequest\n che effettuer\u00e0 una chiamata in \n$_GET\n. Quando la regola viene utilizzata per creare un URL, prender\u00e0 i valori dei parametri forniti e li inserir\u00e0 nei punti in cui sono stati dichiarati i parametri.\n\n\nIllustriamo alcuni esempi per vedere come funzionano i parametri denominati. Supponiamo di aver dichiarato le seguenti tre regole URL:\n\n\n'rules' =\n [\n    'posts/\nyear:\\d{4}\n/\ncategory\n' =\n 'post/index',\n    'posts' =\n 'post/index',\n    'post/\nid:\\d+\n' =\n 'post/view',\n]\n\n\n\nQuando le regole vengono utilizzate per analizzare gli URL:\n\n\n\n\n/index.php/posts\n viene analizzato nel percorso \npost/index\nusando la seconda regola;\n\n\n/index.php/posts/2014/php\n viene analizzato nel percorso \npost/index\n, il parametro \nyear\n (il cui valore \u00e8 2014) e il parametro \ncategory\n (il cui valore \u00e8 php) utilizzano la prima regola;\n\n\n/index.php/post/100\n viene analizzato nel percorso \npost/view\n e il parametro \nid\n (il cui valore \u00e8 100) utilizza la terza regola;\n\n\n\n\n/index.php/posts/php\n causer\u00e0 un'eccezione \nyii \\ web \\ NotFoundHttpException\n quando \nyii \\ web \\ UrlManager :: $ enableStrictParsing\n \u00e8 \ntrue\n, perch\u00e9 non corrisponde a nessuno dei pattern. Se \nyii \\ web \\ UrlManager :: $ enableStrictParsing\n \u00e8 \nfalse\n(il valore predefinito), la parte di informazioni sul percorso \nposts/php\n verr\u00e0 restituita come route. Ci\u00f2 eseguir\u00e0 l'azione corrispondente se esiste o non genera un'eccezione \nyii \\ web \\ NotFoundHttpException\n in un'altro modo.\n\n\n\n\n\n\nUrl::to(['post/index'])\ncrea \n/index.php/posts\n usando la seconda regola;\n\n\n\n\nUrl::to(['post/index', 'year' =\n 2014, 'category' =\n 'php'])\n crea \n/index.php/posts/2014/php\n usando la prima regola;\n\n\nUrl::to(['post/view', 'id' =\n 100])\ncrea \n/index.php/post/100\n usando la terza regola;\n\n\nUrl::to(['post/view', 'id' =\n 100, 'source' =\n 'ad'])\n crea \n/index.php/post/100?source=ad\n usando la terza regola. Poich\u00e9 il parametro \nsource\n non \u00e8 specificato nella regola, viene aggiunto come parametro di query nell'URL creato.\n\n\nUrl::to(['post/index', 'category' =\n 'php'])\ncrea \n/index.php/post/index?category=php\n non usando nessuna delle regole. Si noti che poich\u00e9 non si applica nessuna regola, l'URL viene creato aggiungendo semplicemente il percorso come informazione sul percorso e tutti i parametri come parte della stringa di query.\n\n\n\n\nPercorsi di parametrizzazione\n\n\n\u00c8 possibile incorporare i nomi dei parametri nel percorso di un'URL. Ci\u00f2 consente di utilizzare una regola URL per la corrispondenza di pi\u00f9 percorsi. Ad esempio, le seguenti regole incorporano \ncontroller\n e  il parametro \naction\nall'interno delle route.\n\n\n'rules' =\n [\n    '\ncontroller:(post|comment)\n/create' =\n '\ncontroller\n/create',\n    '\ncontroller:(post|comment)\n/\nid:\\d+\n/\naction:(update|delete)\n' =\n '\ncontroller\n/\naction\n',\n    '\ncontroller:(post|comment)\n/\nid:\\d+\n' =\n '\ncontroller\n/view',\n    '\ncontroller:(post|comment)\ns' =\n '\ncontroller\n/index',\n]\n\n\n\nValori dei parametri predefiniti\n\n\nPer impostazione predefinita, sono richiesti tutti i parametri dichiarati in una regola. Se un URL richiesto non contiene un particolare parametro, o se un URL viene creato senza un particolare parametro, la regola non verr\u00e0 applicata. Per rendere facoltativi alcuni parametri, \u00e8 possibile configurare le propriet\u00e0 dei valori predefiniti di una regola. I parametri elencati in questa propriet\u00e0 sono facoltativi e prenderanno i valori specificati quando non vengono forniti.\n\n\nNella seguente dichiarazione di regole, i parametri \npage\n e \ntag\n sono entrambi opzionali e assumeranno il valore 1 e la stringa vuota, rispettivamente, quando non vengono forniti.\n\n\n'rules' =\n [\n    // ...other rules...\n    [\n        'pattern' =\n 'posts/\npage:\\d+\n/\ntag\n',\n        'route' =\n 'post/index',\n        'defaults' =\n ['page' =\n 1, 'tag' =\n ''],\n    ],\n]\n\n\n\nLa regola precedente pu\u00f2 essere utilizzata per analizzare o creare uno dei seguenti URL:\n\n\n\n\n/index.php/posts: page\n: il valore \u00e8 1, e tag \u00e8 ''.\n\n\n/index.php/posts/2\n: il valore di page \u00e8 2, e tag \u00e8 ''.\n\n\n/index.php/posts/2/news\n: il valore di page \u00e8 2, e tag \u00e8 'news'.\n\n\n/index.php/posts/news\n: il valore di page \u00e8 1, e tag \u00e8 'news'.\n\n\n\n\nSenza usare parametri opzionali, dovresti creare 4 regole per ottenere lo stesso risultato.\n\n\n\n\nWarning\n\n\nSe pattern contiene solo parametri e barre opzionali, il primo parametro pu\u00f2 essere omesso solo se tutti gli altri parametri vengono omessi.\n\n\n\n\nRegole con nomi dei server\n\n\n\u00c8 possibile includere i nomi dei server Web negli schemi delle regole URL. Ci\u00f2 \u00e8 utile soprattutto quando l'applicazione deve comportarsi diversamente per i diversi nomi di server Web. Ad esempio, le seguenti regole analizzeranno l'URL \nhttp://admin.example.com/login\n nel percorso \nadmin/user/login\ne \nhttp://www.example.com/login\n in \nsite/login\n.\n\n\n'rules' =\n [\n    'http://admin.example.com/login' =\n 'admin/user/login',\n    'http://www.example.com/login' =\n 'site/login',\n]\n\n\n\n\u00c8 inoltre possibile incorporare parametri nei nomi dei server per estrarre informazioni dinamiche da essi. Ad esempio, la seguente regola analizzer\u00e0 l'URL \nhttp://en.example.com/posts\n nel percorso \npost/index\n e nel parametro \nlanguage=en\n.\n\n\n'rules' =\n [\n    'http://\nlanguage:\\w+\n.example.com/posts' =\n 'post/index',\n]\n\n\n\nDalla versione 2.0.11, \u00e8 possibile utilizzare anche modelli relativi al protocollo che funzionano per entrambi \nhttp\n e \nhttps\n. La sintassi \u00e8 lo stesso, ma saltando la parte \nhttp:\n, ad esempio: \n'//www.example.com/login' =\n 'site/login'\n.\n\n\nSuffissi degli URL\n\n\nSi consiglia di aggiungere suffissi agli URL per vari scopi. Ad esempio, puoi aggiungere \n.html\n agli URL in modo che sembrino URL per pagine HTML statiche; puoi anche aggiungere \n.json\nagli URL per indicare il tipo di contenuto previsto della risposta. \u00c8 possibile raggiungere questo obiettivo configurando la propriet\u00e0 \nyii \\ web \\ UrlManager :: $\n come segue nella configurazione dell'applicazione:\n\n\n[\n    // ...\n    'components' =\n [\n        'urlManager' =\n [\n            'enablePrettyUrl' =\n true,\n            // ...\n            'suffix' =\n '.html',\n            'rules' =\n [\n                // ...\n            ],\n        ],\n    ],\n]\n\n\n\nLa configurazione sopra descritta consentir\u00e0 al gestore URL di riconoscere gli URL richiesti e anche di creare URL con il suffisso di \n.html\n.\n\n\n\n\nTip\n\n\nPuoi impostare \n/\n come suffisso URL in modo che gli URL finiscano tutti con una barra.\n\n\n\n\nA volte potresti voler utilizzare diversi suffissi per URL diversi. Questo pu\u00f2 essere ottenuto configurando la propriet\u00e0 suffisso delle singole regole URL. Quando una regola URL ha questa propriet\u00e0 impostata, sovrascriver\u00e0 l'impostazione del suffisso a livello di gestore URL. Ad esempio, la seguente configurazione contiene una regola URL personalizzata che utilizza l'estensione \n.json\n come suffisso invece del suffisso \n.html\n.\n\n\n[\n    'components' =\n [\n        'urlManager' =\n [\n            'enablePrettyUrl' =\n true,\n            // ...\n            'suffix' =\n '.html',\n            'rules' =\n [\n                // ...\n                [\n                    'pattern' =\n 'posts',\n                    'route' =\n 'post/index',\n                    'suffix' =\n '.json',\n                ],\n            ],\n        ],\n    ],\n]\n\n\n\nMetodi HTTP\n\n\nQuando si implementano le API RESTful, \u00e8 comunemente necessario analizzare lo stesso URL in percorsi diversi in base ai metodi HTTP utilizzati. Questo pu\u00f2 essere facilmente ottenuto anteponendo i metodi HTTP supportati ai pattern delle regole. Se una regola supporta pi\u00f9 metodi HTTP, conviene separare i nomi dei metodi con virgole. Ad esempio, le seguenti regole hanno lo stesso modello \npost/\nid:\\d+\n con supporto del metodo HTTP diverso. Una richiesta di \nPUT post/100\n sar\u00e0 analizzato in \npost/update\n, mentre la richiesta di \nGET post/100\n verr\u00e0 analizzato in \npost/view\n.\n\n\n'rules' =\n [\n    'PUT,POST post/\nid:\\d+\n' =\n 'post/update',\n    'DELETE post/\nid:\\d+\n' =\n 'post/delete',\n    'post/\nid:\\d+\n' =\n 'post/view',\n]\n\n\n\n\n\nNote\n\n\nSe una regola URL contiene metodi HTTP nel suo pattern, la regola verr\u00e0 utilizzata solo per scopi di analisi a meno che \nGET\n sia tra i verbi specificati. Verr\u00e0 saltato quando viene chiamato il gestore URL per creare URL.\n\n\n\n\n\n\nTip\n\n\nPer semplificare il routing delle API RESTful, Yii fornisce una classe di regole URL speciale \nyii \\ rest \\ UrlRule\n che \u00e8 molto efficiente e supporta alcune funzioni di fantasia come la pluralizzazione automatica degli ID controller. Per maggiori dettagli, fai riferimento alla sezione Routing nel capitolo API RESTful.\n\n\n\n\nAgigunta di regole in modo dinamico\n\n\nLe regole URL possono essere aggiunte dinamicamente al gestore URL. Questo \u00e8 spesso necessario per i moduli ridistribuibili che vogliono gestire le proprie regole URL. Affinch\u00e9 le regole aggiunte dinamicamente abbiano effetto durante il processo di routing, \u00e8 necessario aggiungerle durante la fase di avvio dell'applicazione. Ci\u00f2 significa che i moduli devono implementare \nyii \\ base \\ BootstrapInterface\n e aggiungere le regole nel metodo \nbootstrap()\n come segue:\n\n\npublic function bootstrap($app){\n\n    $app-\ngetUrlManager()-\naddRules([\n        // rule declarations here\n    ], false);\n}\n\n\n\nNota che dovresti anche elencare questi moduli in \nyii \\ web \\ Application :: bootstrap()\n in modo che possano partecipare al processo di bootstrap.\n\n\nCreazione regole associate alle classi\n\n\nNonostante la classe di default \nyii \\ web \\ UrlRule\n sia abbastanza flessibile per la maggior parte dei progetti, ci sono situazioni in cui devi creare le tue classi di regole. Ad esempio, in un sito Web di un rivenditore di automobili, \u00e8 possibile che si desideri supportare il formato dell'URL come \n/Manufacturer/Model\n, dove entrambi \nManufacturer\n e \nModel\n devono abbinare alcuni dati memorizzati in una tabella di database. La classe di regole predefinita non funzioner\u00e0 qui perch\u00e9 si basa su pattern dichiarati staticamente.\n\n\nPossiamo creare la seguente classe di regole URL per risolvere questo problema.\n\n\n?php\n\nnamespace app\\components;\n\nuse yii\\web\\UrlRuleInterface;\nuse yii\\base\\BaseObject;\n\nclass CarUrlRule extends BaseObject implements UrlRuleInterface{\n\n    public function createUrl($manager, $route, $params){\n\n        if ($route === 'car/index') {\n            if (isset($params['manufacturer'], $params['model'])) {\n                return $params['manufacturer'] . '/' . $params['model'];\n            } elseif (isset($params['manufacturer'])) {\n                return $params['manufacturer'];\n            }\n        }\n        return false; // this rule does not apply\n    }\n\n    public function parseRequest($manager, $request){\n\n        $pathInfo = $request-\ngetPathInfo();\n        if (preg_match('%^(\\w+)(/(\\w+))?$%', $pathInfo, $matches)) {\n            // check $matches[1] and $matches[3] to see\n            // if they match a manufacturer and a model in the database.\n            // If so, set $params['manufacturer'] and/or $params['model']\n            // and return ['car/index', $params]\n        }\n        return false; // this rule does not apply\n    }\n}\n\n\n\nE usa la nuova classe di regole nella configurazione delle regole sia \nyii \\ web \\ UrlManager :: $\n:\n\n\n'rules' =\n [\n    // ...other rules...\n    [\n        'class' =\n 'app\\components\\CarUrlRule',\n        // ...configure other properties...\n    ],\n]\n\n\n\nNormalizzazione dell'URL\n\n\nDalla versione 2.0.10 l'UrlManager pu\u00f2 essere configurato per utilizzare \nUrlNormalizer\n per gestire le variazioni dello stesso URL, ad esempio con e senza una barra finale. Perch\u00e9 tecnicamente \nhttp://example.com/path\n e \nhttp://example.com/path/\n sono URL diversi, offrire lo stesso contenuto per entrambi pu\u00f2 degradare il ranking SEO. Normalmente il normalizzatore comprime le barre consecutive, aggiunge o rimuove le barre finali a seconda che il suffisso abbia o meno una barra finale e reindirizza alla versione normalizzata dell'URL utilizzando il reindirizzamento permanente . Il normalizzatore pu\u00f2 essere configurato globalmente per il gestore URL o singolarmente per ogni regola: per impostazione predefinita ogni regola utilizzer\u00e0 il normalizzatore dal gestore URL. \u00c8 possibile impostare \nUrlRule :: $ normalizer\n su \nfalse\n per disabilitare la normalizzazione per una regola URL specifica.\n\n\nIl codice sotto stante mostra una configurazione di esempio per l'UrlNormalizer:\n\n\n'urlManager' =\n [\n    'enablePrettyUrl' =\n true,\n    'showScriptName' =\n false,\n    'enableStrictParsing' =\n true,\n    'suffix' =\n '.html',\n    'normalizer' =\n [\n        'class' =\n 'yii\\web\\UrlNormalizer',\n        // use temporary redirection instead of permanent for debugging\n        'action' =\n UrlNormalizer::ACTION_REDIRECT_TEMPORARY,\n    ],\n    'rules' =\n [\n        // ...other rules...\n        [\n            'pattern' =\n 'posts',\n            'route' =\n 'post/index',\n            'suffix' =\n '/',\n            'normalizer' =\n false, // disable normalizer for this rule\n        ],\n        [\n            'pattern' =\n 'tags',\n            'route' =\n 'tag/index',\n            'normalizer' =\n [\n                // do not collapse consecutive slashes for this rule\n                'collapseSlashes' =\n false,\n            ],\n        ],\n    ],\n]\n\n\n\n\n\nNote\n\n\nPer impostazione predefinita \nUrlManager :: $ normalizer\n \u00e8 disabilitato. \u00c8 necessario configurarlo in modo esplicito per abilitare la normalizzazione degli URL.\n\n\n\n\nConsiderazioni sulle prestazioni\n\n\nDurante lo sviluppo di un'applicazione Web complessa, \u00e8 importante ottimizzare le regole degli URL in modo che sia necessario meno tempo per analizzare le richieste e creare URL.\n\n\nUtilizzando route parametrizzate, \u00e8 possibile ridurre il numero di regole URL, che possono migliorare significativamente le prestazioni.\n\n\nDurante l'analisi o la creazione di URL, il gestore URL esamina le regole URL nell'ordine in cui sono dichiarate. Pertanto, si pu\u00f2 prendere in considerazione la possibilit\u00e0 di modificare l'ordine delle regole dell'URL in modo che le regole pi\u00f9 specifiche e / o pi\u00f9 comunemente usate siano poste prima di quelle meno utilizzate.\n\n\nSe alcune regole URL condividono lo stesso prefisso nei propri pattern o percorsi, \u00e8 possibile considerare l'utilizzo di \nyii \\ web \\ GroupUrlRule\n in modo che possano essere esaminati in modo pi\u00f9 efficiente dal gestore URL come gruppo. Questo \u00e8 spesso il caso in cui l'applicazione \u00e8 composta da moduli, ciascuno con il proprio set di regole URL con l'ID del modulo come prefisso comune.",
            "title": "Routing e creazione degli URL"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#routing-e-creazione-degli-url",
            "text": "Quando un'applicazione Yii avvia l'elaborazione di una richiesta di URL, il primo passo necessario \u00e8 analizzare l'URL in una  route . Il percorso viene quindi utilizzato per istanziare l' azione del controller corrispondente per gestire la richiesta. L'intero processo \u00e8 chiamato  routing .  Il processo inverso di routing si chiama creazione di URL , che crea un URL da una determinata route e i parametri di query associati. Successivamente, quando viene richiesto l'URL creato, il processo di routing pu\u00f2 risolverlo nel percorso originale e nei parametri della query associata.  Il pezzo centrale responsabile per il routing e la creazione di URL \u00e8 il gestore degli URL , che \u00e8 registrato come componente dell'applicazione  urlManager . Il gestore URL fornisce il metodo  parseRequest()  per analizzare una richiesta in entrata in una route e i parametri di query associati ad esso, e fornisce anche il metodo  createUrl()  per creare un URL da una determinata route e i relativi parametri di query associati.  Configurando il componente  urlManager  nella configurazione dell'applicazione, \u00e8 possibile consentire all'applicazione di riconoscere i formati di URL arbitrari senza modificare il codice dell'applicazione esistente. Ad esempio, \u00e8 possibile utilizzare il seguente codice per creare un URL per l'azione  post/view :  use yii\\helpers\\Url;\n\n// Url::to() calls UrlManager::createUrl() to create a URL\n$url = Url::to(['post/view', 'id' =  100]);  A seconda della configurazione dell' urlManager , l'URL creato pu\u00f2 apparire come uno degli esempi sottostanti. E se l'URL creato viene richiesto in seguito, verr\u00e0 comunque analizzato nella route originale e nel valore del parametro di query.  /index.php?r=post%2Fview id=100\n/index.php/post/100\n/posts/100",
            "title": "Routing e creazione degli URL"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#formati-degli-url",
            "text": "Il gestore degli URL supporta due formati:   Il formato URL predefinito.  Il formato URL pi\u00f9 \"grazioso\".   Il formato URL predefinito utilizza un parametro di query denominato  r  per rappresentare la route e i normali parametri di query. Ad esempio, l'URL  /index.php?r=post/view id=100  rappresenta il percorso  post/view  e il parametro  id  ha un valore di  100 . Il formato URL predefinito non richiede alcuna configurazione del gestore URL e funziona in qualsiasi configurazione del server Web.  Il formato URL \u201cgrazioso\u201c utilizza il percorso aggiuntivo che segue il nome dello script della voce per rappresentare la route e i parametri di query associati. Ad esempio, il percorso aggiuntivo nell'URL  /index.php/post/100  \u00e8  /post/100  che pu\u00f2 rappresentare il percorso  post/view e il parametro  id  che ha come valore della query  100 con una regola URL appropriata . Per utilizzare il formato URL pi\u00f9 grazioso, \u00e8 necessario progettare un set di regole URL in base ai requisiti effettivi su come dovrebbe apparire l'URL.  \u00c8 possibile passare tra i due formati di URL attivando la propriet\u00e0  enablePrettyUrl  del gestore URL senza modificare nessun codice nell'applicazione.",
            "title": "Formati degli URL"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#routing",
            "text": "Il routing prevede due passaggi:   la richiesta in entrata viene analizzata in una route e i parametri di query associati;  viene creata un'azione di controllo corrispondente al percorso analizzato per gestire la richiesta.   Quando si utilizza il formato URL predefinito, l'analisi di una richiesta in una route \u00e8 semplice come ottenere il valore di un parametro GET di una query denominata  r .  Quando si utilizza il formato URL \"grazioso\", il gestore URL esaminer\u00e0 le regole URL registrate per trovare quella corrispondente che possa risolvere la richiesta in una route. Se tale regola non pu\u00f2 essere trovata, verr\u00e0 generata un'eccezione  yii \\ web \\ NotFoundHttpException .  Una volta che la richiesta viene analizzata in una route, \u00e8 il momento di creare l'azione del controller identificata dalla route stessa. Il percorso \u00e8 suddiviso in pi\u00f9 parti con le barre in esso contenute. Ad esempio,  site/index  sar\u00e0 suddiviso in  site e  index . Ogni parte \u00e8 un ID che pu\u00f2 riferirsi a un modulo, a un controllore o a un'azione. A partire dalla prima parte del percorso, l'applicazione effettua le seguenti operazioni per creare i moduli (se presenti), il controller e l'azione:   Imposta l'applicazione come modulo corrente  Verificare se il \"controller map\" del modulo corrente contiene l'ID giusto. In tal caso, verr\u00e0 creato un oggetto controller in base alla configurazione trovata nella mappa e verr\u00e0 eseguito il passaggio \"5\" per gestire la parte restante del percorso.  Verifica se l'ID fa riferimento a un modulo elencato nella propriet\u00e0  yii \\ base \\ Module :: modules  del modulo corrente. In tal caso, viene creato un modulo in base alla configurazione trovata nell'elenco dei moduli e il passaggio \"2\" verr\u00e0 utilizzato per gestire la parte successiva del percorso nel contesto del modulo appena creato.  Tratta l'ID come un' \"ID controller\" e crea un oggetto controller. Fai il prossimo passo con la parte restante del percorso.  Il controller cerca l'ID corrente nella sua mappa d'azione. Se trovato, crea un'azione in base alla configurazione trovata nella mappa. In caso contrario, il controller tenter\u00e0 di creare un'azione in linea definita da un metodo di azione corrispondente all'ID azione corrente.   Tra i passaggi precedenti, se si verifica un errore, verr\u00e0 generata un'eccezione  yii \\ web \\ NotFoundHttpException , che indica l'errore del processo di routing.",
            "title": "Routing"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#percorso-predefinito",
            "text": "Quando una richiesta viene analizzata in una route vuota, verr\u00e0 utilizzata la cosiddetta \"route predefinita\". Per impostazione predefinita, la route predefinita \u00e8  site/index , che si riferisce all'azione  index  del  sitecontroller . \u00c8 possibile personalizzarlo configurando la propriet\u00e0  defaultRoute  dell'applicazione nella configurazione dell'app come la seguente:  [\n    // ...\n    'defaultRoute' =  'main/index',\n];  Simile al percorso predefinito dell'applicazione, vi \u00e8 anche un percorso predefinito per i moduli, cos\u00ec per esempio se vi \u00e8 un modulo  user  e la richiesta viene analizzata nella route  user  del modulo  defaultroute  \u00e8 utilizzato per determinare il controller. Per impostazione predefinita, il nome del controller \u00e8  default . Se non si specifica un'azione  defaultroute , la propriet\u00e0  DefaultAction  del controller verr\u00e0 utilizzata per determinare l'azione. In questo esempio, il percorso completo sar\u00e0  user/default/index .",
            "title": "Percorso predefinito"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#itinerario-catchall",
            "text": "A volte, potresti voler mettere temporaneamente in pausa la tua applicazione Web e visualizzare la stessa pagina informativa per tutte le richieste. Ci sono molti modi per raggiungere questo obiettivo. Ma uno dei modi pi\u00f9 semplici \u00e8 configurare la propriet\u00e0  yii \\ web \\ Application :: $ catchAll  come segue nella configurazione dell'applicazione:  [\n    // ...\n    'catchAll' =  ['site/offline'],\n];  Con la configurazione sopra indicata, l'azione  site/offline  verr\u00e0 utilizzata per gestire tutte le richieste in arrivo.  La propriet\u00e0  catchAll  dovrebbe prendere una matrice,il cui primo elemento specifica una rotta, e il resto degli elementi (coppie nome-valore) specificano i parametri da associare all'azione stessa.   Info  La barra degli strumenti di debug nell'ambiente di sviluppo non funzioner\u00e0 quando questa propriet\u00e0 \u00e8 abilitata.",
            "title": "Itinerario CatchAll"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#creazione-di-url",
            "text": "Yii fornisce un metodo di supporto  yii \\ helpers \\ Url :: to()  per creare vari tipi di URL dai percorsi specificati e i relativi parametri di query associati. Per esempio,  use yii\\helpers\\Url;\n\n// creates a URL to a route: /index.php?r=post%2Findex\necho Url::to(['post/index']);\n\n// creates a URL to a route with parameters: /index.php?r=post%2Fview id=100\necho Url::to(['post/view', 'id' =  100]);\n\n// creates an anchored URL: /index.php?r=post%2Fview id=100#content\necho Url::to(['post/view', 'id' =  100, '#' =  'content']);\n\n// creates an absolute URL: http://www.example.com/index.php?r=post%2Findex\necho Url::to(['post/index'], true);\n\n// creates an absolute URL using the https scheme: https://www.example.com/index.php?r=post%2Findex\necho Url::to(['post/index'], 'https');  Nota che nell'esempio indicato sopra, assumiamo per esempio, che venga utilizzato il formato URL predefinito. Se il formato URL \"pretty\"(grazioso) \u00e8 abilitato, gli URL creati saranno diversi, in base alle regole URL in uso.  Il percorso passato al metodo  yii \\ helpers \\ Url :: to ()  \u00e8 sensibile al contesto. Pu\u00f2 essere una route relativa o una route assoluta, che sar\u00e0 normalizzata secondo le seguenti regole:   Se la route \u00e8 una stringa vuota, verr\u00e0 utilizzata la route   yii \\ web \\ Controller ::   attualmente richiesta;  Se il percorso non contiene alcuna barra, viene considerato un ID d'azione del controller corrente e verr\u00e0 anteposto al valore  yii \\ web \\ Controller :: uniqueId  del controller corrente;  Se la route non ha una barra iniziale, viene considerata una route relativa al modulo corrente e verr\u00e0 anteposta al valore  yii \\ base \\ Module :: uniqueId  del modulo corrente.   A partire dalla versione 2.0.2, \u00e8 possibile specificare un percorso in termini di  alias . In questo caso, l'alias verr\u00e0 convertito nel percorso effettivo trasformandolo in un percorso assoluto in base alle regole precedenti.  Ad esempio, supponiamo che il modulo corrente sia  admin  e il controller corrente sia  post ,  use yii\\helpers\\Url;\n\n// currently requested route: /index.php?r=admin%2Fpost%2Findex\necho Url::to(['']);\n\n// a relative route with action ID only: /index.php?r=admin%2Fpost%2Findex\necho Url::to(['index']);\n\n// a relative route: /index.php?r=admin%2Fpost%2Findex\necho Url::to(['post/index']);\n\n// an absolute route: /index.php?r=post%2Findex\necho Url::to(['/post/index']);\n\n// using an alias \"@posts\", which is defined as \"/post/index\": /index.php?r=post%2Findex\necho Url::to(['@posts']);  Il metodo  yii \\ helpers \\ Url :: to ()  viene implementato chiamando i metodi  createUrl()  e  createAbsoluteUrl()  del gestore URL. Nelle prossime sottosezioni, spiegheremo come configurare il gestore URL per personalizzare il formato degli URL creati.  Il metodo  yii \\ helpers \\ Url :: to ()  supporta anche la creazione di URL che non sono correlati a percorsi particolari. Invece di passare un array come primo parametro, dovresti passare una stringa in questo caso. Per esempio,  use yii\\helpers\\Url;\n\n// currently requested URL: /index.php?r=admin%2Fpost%2Findex\necho Url::to();\n\n// an aliased URL: http://example.com\nYii::setAlias('@example', 'http://example.com/');\necho Url::to('@example');\n\n// an absolute URL: http://example.com/images/logo.gif\necho Url::to('/images/logo.gif', true);  Oltre al metodo  to() , la classe  helper   yii \\ helpers \\ Url  fornisce anche altri metodi di creazione di URL convenienti. Per esempio,  use yii\\helpers\\Url;\n\n// home page URL: /index.php?r=site%2Findex\necho Url::home();\n\n// the base URL, useful if the application is deployed in a sub-folder of the Web root\necho Url::base();\n\n// the canonical URL of the currently requested URL\n// see https://en.wikipedia.org/wiki/Canonical_link_element\necho Url::canonical();\n\n// remember the currently requested URL and retrieve it back in later requests\nUrl::remember();\necho Url::previous();",
            "title": "Creazione di URL"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#utilizziamo-gli-url-graziosi-pretty",
            "text": "Per utilizzare gli URL \"graziosi\", dobbiamo configurare il componente  urlManager  nella configurazione dell'applicazione come segue:  [\n    'components' =  [\n        'urlManager' =  [\n            'enablePrettyUrl' =  true,\n            'showScriptName' =  false,\n            'enableStrictParsing' =  false,\n            'rules' =  [\n                // ...\n            ],\n        ],\n    ],\n]  La propriet\u00e0  enablePrettyUrl  \u00e8 obbligatoria in quanto attiva il formato URL grazioso. Il resto della propriet\u00e0 \u00e8 facoltativo. Tuttavia, la loro configurazione indicata di sopra \u00e8 la pi\u00f9 usata.   showScriptName : questa propriet\u00e0 determina se lo script in entrata deve essere incluso negli URL creati. Ad esempio, invece di creare un URL  /index.php/post/100 , impostando questa propriet\u00e0 a  false , verr\u00e0 generato un URL  /post/100 .  enableStrictParsing : questa propriet\u00e0 determina se abilitare l'analisi rigorosa delle richieste. Se l'analisi rigorosa \u00e8 abilitata, l'URL richiesto in entrata deve corrispondere ad almeno una delle regole per essere trattato come una richiesta valida, altrimenti verr\u00e0 generata una eccezione  yii \\ web \\ NotFoundHttpException . Se l'analisi rigorosa \u00e8 disabilitata, quando nessuna delle regole corrisponde all'URL richiesto, la parte di informazioni sul percorso dell'URL verr\u00e0 considerata come la route richiesta.  rules : questa propriet\u00e0 contiene un elenco di regole che specificano come analizzare e creare URL. \u00c8 la propriet\u00e0 principale con cui dovresti lavorare per creare URL il cui formato soddisfa i tuoi particolari requisiti applicativi.    Note  Al fine di nascondere il nome dello script di entrata negli URL creati, oltre al valore  false  di  showScriptName , potrebbe anche essere necessario configurare il server Web in modo che possa identificare correttamente quale script PHP dovrebbe essere eseguito quando un URL richiesto non viene specificato.",
            "title": "Utilizziamo gli URL \"graziosi\" (pretty)"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#regole-dellurl",
            "text": "Una regola associata all'URL \u00e8 una classe che implementa  yii \\ web \\ UrlRuleInterface , in genere  yii \\ web \\ UrlRule . Ogni regola URL consiste in un modello utilizzato per la corrispondenza della parte di informazioni sul percorso degli URL, una route e alcuni parametri di query. Una regola URL pu\u00f2 essere utilizzata per analizzare una richiesta,se il suo modello corrisponde all'URL richiesto. \u00c8 possibile utilizzare una regola URL per creare un URL se i relativi nomi dei parametri di route e query corrispondono a quelli forniti.  Quando il formato URL pretty(grazioso) \u00e8 abilitato, il gestore URL utilizza le regole dichiarate nella sua propriet\u00e0  rules  per analizzare le richieste in arrivo e creare l'URL. In particolare, per analizzare una richiesta in arrivo, il gestore URL esamina le regole nell'ordine dichiarate in precedenza e cerca la prima regola che corrisponde all'URL richiesto. La regola di corrispondenza viene quindi utilizzata per analizzare l'URL in una route e i relativi parametri associati. Allo stesso modo, per creare un URL, il gestore URL cerca la prima regola che corrisponde al percorso e ai parametri specificati e la utilizza per creare un URL.  \u00c8 possibile configurare le regole  yii \\ web \\ UrlManager :: $  come una matrice, composta con le chiavi come modelli e i relativi percorsi. Ogni coppia \"percorso-itinerario\" costruisce una regola URL. Ad esempio, la seguente configurazione dichiara due regole URL. La prima regola corrisponde a un URL  post  se lo mappa nella route  post/index . La seconda regola corrisponde a un URL indicato dall'espressione  post/(\\d+)  e lo mappa nella route  post/view  e nello stesso momento definisce un parametro associato all' id .  'rules' =  [\n    'posts' =  'post/index',\n    'post/ id:\\d+ ' =  'post/view',\n]  Oltre a dichiarare le regole dell'URL come coppie di \"pattern-route\", puoi anche dichiararle come array di configurazione. Ogni array di configurazione viene utilizzato per configurare un singolo oggetto per la regola dell'URL. Questo \u00e8 spesso necessario quando si desidera configurare altre propriet\u00e0 di una regola URL. Per esempio,  'rules' =  [\n    // ...other url rules...\n    [\n        'pattern' =  'posts',\n        'route' =  'post/index',\n        'suffix' =  '.json',\n    ],\n]  Per impostazione predefinita, se non si specifica l'opzione  class  per una configurazione di regole, verr\u00e0 utilizzata la classe predefinita  yii \\ web \\ UrlRule , che \u00e8 il valore predefinito definito in  yii \\ web \\ UrlManager :: $ ruleConfig .",
            "title": "Regole dell'URL"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#parametri-nominati",
            "text": "Una regola URL pu\u00f2 essere associata ai parametri di query denominati che sono specificati nel modello del formato di  ParamName:RegExp , dove  ParamName  specifica il nome del parametro e  RegExp  \u00e8 un'espressione regolare facoltativa utilizzata per abbinare i valori dei parametri. Se  RegExp  non \u00e8 specificato, significa che il valore del parametro dovr\u00e0 essere una stringa senza alcuna barra.  Quando una regola viene utilizzata per analizzare un URL, riempir\u00e0 i parametri associati con valori corrispondenti ai componenti che formano l'URL e questi parametri saranno resi disponibili in seguito ad un componente  request  che effettuer\u00e0 una chiamata in  $_GET . Quando la regola viene utilizzata per creare un URL, prender\u00e0 i valori dei parametri forniti e li inserir\u00e0 nei punti in cui sono stati dichiarati i parametri.  Illustriamo alcuni esempi per vedere come funzionano i parametri denominati. Supponiamo di aver dichiarato le seguenti tre regole URL:  'rules' =  [\n    'posts/ year:\\d{4} / category ' =  'post/index',\n    'posts' =  'post/index',\n    'post/ id:\\d+ ' =  'post/view',\n]  Quando le regole vengono utilizzate per analizzare gli URL:   /index.php/posts  viene analizzato nel percorso  post/index usando la seconda regola;  /index.php/posts/2014/php  viene analizzato nel percorso  post/index , il parametro  year  (il cui valore \u00e8 2014) e il parametro  category  (il cui valore \u00e8 php) utilizzano la prima regola;  /index.php/post/100  viene analizzato nel percorso  post/view  e il parametro  id  (il cui valore \u00e8 100) utilizza la terza regola;   /index.php/posts/php  causer\u00e0 un'eccezione  yii \\ web \\ NotFoundHttpException  quando  yii \\ web \\ UrlManager :: $ enableStrictParsing  \u00e8  true , perch\u00e9 non corrisponde a nessuno dei pattern. Se  yii \\ web \\ UrlManager :: $ enableStrictParsing  \u00e8  false (il valore predefinito), la parte di informazioni sul percorso  posts/php  verr\u00e0 restituita come route. Ci\u00f2 eseguir\u00e0 l'azione corrispondente se esiste o non genera un'eccezione  yii \\ web \\ NotFoundHttpException  in un'altro modo.    Url::to(['post/index']) crea  /index.php/posts  usando la seconda regola;   Url::to(['post/index', 'year' =  2014, 'category' =  'php'])  crea  /index.php/posts/2014/php  usando la prima regola;  Url::to(['post/view', 'id' =  100]) crea  /index.php/post/100  usando la terza regola;  Url::to(['post/view', 'id' =  100, 'source' =  'ad'])  crea  /index.php/post/100?source=ad  usando la terza regola. Poich\u00e9 il parametro  source  non \u00e8 specificato nella regola, viene aggiunto come parametro di query nell'URL creato.  Url::to(['post/index', 'category' =  'php']) crea  /index.php/post/index?category=php  non usando nessuna delle regole. Si noti che poich\u00e9 non si applica nessuna regola, l'URL viene creato aggiungendo semplicemente il percorso come informazione sul percorso e tutti i parametri come parte della stringa di query.",
            "title": "Parametri nominati"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#percorsi-di-parametrizzazione",
            "text": "\u00c8 possibile incorporare i nomi dei parametri nel percorso di un'URL. Ci\u00f2 consente di utilizzare una regola URL per la corrispondenza di pi\u00f9 percorsi. Ad esempio, le seguenti regole incorporano  controller  e  il parametro  action all'interno delle route.  'rules' =  [\n    ' controller:(post|comment) /create' =  ' controller /create',\n    ' controller:(post|comment) / id:\\d+ / action:(update|delete) ' =  ' controller / action ',\n    ' controller:(post|comment) / id:\\d+ ' =  ' controller /view',\n    ' controller:(post|comment) s' =  ' controller /index',\n]",
            "title": "Percorsi di parametrizzazione"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#valori-dei-parametri-predefiniti",
            "text": "Per impostazione predefinita, sono richiesti tutti i parametri dichiarati in una regola. Se un URL richiesto non contiene un particolare parametro, o se un URL viene creato senza un particolare parametro, la regola non verr\u00e0 applicata. Per rendere facoltativi alcuni parametri, \u00e8 possibile configurare le propriet\u00e0 dei valori predefiniti di una regola. I parametri elencati in questa propriet\u00e0 sono facoltativi e prenderanno i valori specificati quando non vengono forniti.  Nella seguente dichiarazione di regole, i parametri  page  e  tag  sono entrambi opzionali e assumeranno il valore 1 e la stringa vuota, rispettivamente, quando non vengono forniti.  'rules' =  [\n    // ...other rules...\n    [\n        'pattern' =  'posts/ page:\\d+ / tag ',\n        'route' =  'post/index',\n        'defaults' =  ['page' =  1, 'tag' =  ''],\n    ],\n]  La regola precedente pu\u00f2 essere utilizzata per analizzare o creare uno dei seguenti URL:   /index.php/posts: page : il valore \u00e8 1, e tag \u00e8 ''.  /index.php/posts/2 : il valore di page \u00e8 2, e tag \u00e8 ''.  /index.php/posts/2/news : il valore di page \u00e8 2, e tag \u00e8 'news'.  /index.php/posts/news : il valore di page \u00e8 1, e tag \u00e8 'news'.   Senza usare parametri opzionali, dovresti creare 4 regole per ottenere lo stesso risultato.   Warning  Se pattern contiene solo parametri e barre opzionali, il primo parametro pu\u00f2 essere omesso solo se tutti gli altri parametri vengono omessi.",
            "title": "Valori dei parametri predefiniti"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#regole-con-nomi-dei-server",
            "text": "\u00c8 possibile includere i nomi dei server Web negli schemi delle regole URL. Ci\u00f2 \u00e8 utile soprattutto quando l'applicazione deve comportarsi diversamente per i diversi nomi di server Web. Ad esempio, le seguenti regole analizzeranno l'URL  http://admin.example.com/login  nel percorso  admin/user/login e  http://www.example.com/login  in  site/login .  'rules' =  [\n    'http://admin.example.com/login' =  'admin/user/login',\n    'http://www.example.com/login' =  'site/login',\n]  \u00c8 inoltre possibile incorporare parametri nei nomi dei server per estrarre informazioni dinamiche da essi. Ad esempio, la seguente regola analizzer\u00e0 l'URL  http://en.example.com/posts  nel percorso  post/index  e nel parametro  language=en .  'rules' =  [\n    'http:// language:\\w+ .example.com/posts' =  'post/index',\n]  Dalla versione 2.0.11, \u00e8 possibile utilizzare anche modelli relativi al protocollo che funzionano per entrambi  http  e  https . La sintassi \u00e8 lo stesso, ma saltando la parte  http: , ad esempio:  '//www.example.com/login' =  'site/login' .",
            "title": "Regole con nomi dei server"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#suffissi-degli-url",
            "text": "Si consiglia di aggiungere suffissi agli URL per vari scopi. Ad esempio, puoi aggiungere  .html  agli URL in modo che sembrino URL per pagine HTML statiche; puoi anche aggiungere  .json agli URL per indicare il tipo di contenuto previsto della risposta. \u00c8 possibile raggiungere questo obiettivo configurando la propriet\u00e0  yii \\ web \\ UrlManager :: $  come segue nella configurazione dell'applicazione:  [\n    // ...\n    'components' =  [\n        'urlManager' =  [\n            'enablePrettyUrl' =  true,\n            // ...\n            'suffix' =  '.html',\n            'rules' =  [\n                // ...\n            ],\n        ],\n    ],\n]  La configurazione sopra descritta consentir\u00e0 al gestore URL di riconoscere gli URL richiesti e anche di creare URL con il suffisso di  .html .   Tip  Puoi impostare  /  come suffisso URL in modo che gli URL finiscano tutti con una barra.   A volte potresti voler utilizzare diversi suffissi per URL diversi. Questo pu\u00f2 essere ottenuto configurando la propriet\u00e0 suffisso delle singole regole URL. Quando una regola URL ha questa propriet\u00e0 impostata, sovrascriver\u00e0 l'impostazione del suffisso a livello di gestore URL. Ad esempio, la seguente configurazione contiene una regola URL personalizzata che utilizza l'estensione  .json  come suffisso invece del suffisso  .html .  [\n    'components' =  [\n        'urlManager' =  [\n            'enablePrettyUrl' =  true,\n            // ...\n            'suffix' =  '.html',\n            'rules' =  [\n                // ...\n                [\n                    'pattern' =  'posts',\n                    'route' =  'post/index',\n                    'suffix' =  '.json',\n                ],\n            ],\n        ],\n    ],\n]",
            "title": "Suffissi degli URL"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#metodi-http",
            "text": "Quando si implementano le API RESTful, \u00e8 comunemente necessario analizzare lo stesso URL in percorsi diversi in base ai metodi HTTP utilizzati. Questo pu\u00f2 essere facilmente ottenuto anteponendo i metodi HTTP supportati ai pattern delle regole. Se una regola supporta pi\u00f9 metodi HTTP, conviene separare i nomi dei metodi con virgole. Ad esempio, le seguenti regole hanno lo stesso modello  post/ id:\\d+  con supporto del metodo HTTP diverso. Una richiesta di  PUT post/100  sar\u00e0 analizzato in  post/update , mentre la richiesta di  GET post/100  verr\u00e0 analizzato in  post/view .  'rules' =  [\n    'PUT,POST post/ id:\\d+ ' =  'post/update',\n    'DELETE post/ id:\\d+ ' =  'post/delete',\n    'post/ id:\\d+ ' =  'post/view',\n]   Note  Se una regola URL contiene metodi HTTP nel suo pattern, la regola verr\u00e0 utilizzata solo per scopi di analisi a meno che  GET  sia tra i verbi specificati. Verr\u00e0 saltato quando viene chiamato il gestore URL per creare URL.    Tip  Per semplificare il routing delle API RESTful, Yii fornisce una classe di regole URL speciale  yii \\ rest \\ UrlRule  che \u00e8 molto efficiente e supporta alcune funzioni di fantasia come la pluralizzazione automatica degli ID controller. Per maggiori dettagli, fai riferimento alla sezione Routing nel capitolo API RESTful.",
            "title": "Metodi HTTP"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#agigunta-di-regole-in-modo-dinamico",
            "text": "Le regole URL possono essere aggiunte dinamicamente al gestore URL. Questo \u00e8 spesso necessario per i moduli ridistribuibili che vogliono gestire le proprie regole URL. Affinch\u00e9 le regole aggiunte dinamicamente abbiano effetto durante il processo di routing, \u00e8 necessario aggiungerle durante la fase di avvio dell'applicazione. Ci\u00f2 significa che i moduli devono implementare  yii \\ base \\ BootstrapInterface  e aggiungere le regole nel metodo  bootstrap()  come segue:  public function bootstrap($app){\n\n    $app- getUrlManager()- addRules([\n        // rule declarations here\n    ], false);\n}  Nota che dovresti anche elencare questi moduli in  yii \\ web \\ Application :: bootstrap()  in modo che possano partecipare al processo di bootstrap.",
            "title": "Agigunta di regole in modo dinamico"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#creazione-regole-associate-alle-classi",
            "text": "Nonostante la classe di default  yii \\ web \\ UrlRule  sia abbastanza flessibile per la maggior parte dei progetti, ci sono situazioni in cui devi creare le tue classi di regole. Ad esempio, in un sito Web di un rivenditore di automobili, \u00e8 possibile che si desideri supportare il formato dell'URL come  /Manufacturer/Model , dove entrambi  Manufacturer  e  Model  devono abbinare alcuni dati memorizzati in una tabella di database. La classe di regole predefinita non funzioner\u00e0 qui perch\u00e9 si basa su pattern dichiarati staticamente.  Possiamo creare la seguente classe di regole URL per risolvere questo problema.  ?php\n\nnamespace app\\components;\n\nuse yii\\web\\UrlRuleInterface;\nuse yii\\base\\BaseObject;\n\nclass CarUrlRule extends BaseObject implements UrlRuleInterface{\n\n    public function createUrl($manager, $route, $params){\n\n        if ($route === 'car/index') {\n            if (isset($params['manufacturer'], $params['model'])) {\n                return $params['manufacturer'] . '/' . $params['model'];\n            } elseif (isset($params['manufacturer'])) {\n                return $params['manufacturer'];\n            }\n        }\n        return false; // this rule does not apply\n    }\n\n    public function parseRequest($manager, $request){\n\n        $pathInfo = $request- getPathInfo();\n        if (preg_match('%^(\\w+)(/(\\w+))?$%', $pathInfo, $matches)) {\n            // check $matches[1] and $matches[3] to see\n            // if they match a manufacturer and a model in the database.\n            // If so, set $params['manufacturer'] and/or $params['model']\n            // and return ['car/index', $params]\n        }\n        return false; // this rule does not apply\n    }\n}  E usa la nuova classe di regole nella configurazione delle regole sia  yii \\ web \\ UrlManager :: $ :  'rules' =  [\n    // ...other rules...\n    [\n        'class' =  'app\\components\\CarUrlRule',\n        // ...configure other properties...\n    ],\n]",
            "title": "Creazione regole associate alle classi"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#normalizzazione-dellurl",
            "text": "Dalla versione 2.0.10 l'UrlManager pu\u00f2 essere configurato per utilizzare  UrlNormalizer  per gestire le variazioni dello stesso URL, ad esempio con e senza una barra finale. Perch\u00e9 tecnicamente  http://example.com/path  e  http://example.com/path/  sono URL diversi, offrire lo stesso contenuto per entrambi pu\u00f2 degradare il ranking SEO. Normalmente il normalizzatore comprime le barre consecutive, aggiunge o rimuove le barre finali a seconda che il suffisso abbia o meno una barra finale e reindirizza alla versione normalizzata dell'URL utilizzando il reindirizzamento permanente . Il normalizzatore pu\u00f2 essere configurato globalmente per il gestore URL o singolarmente per ogni regola: per impostazione predefinita ogni regola utilizzer\u00e0 il normalizzatore dal gestore URL. \u00c8 possibile impostare  UrlRule :: $ normalizer  su  false  per disabilitare la normalizzazione per una regola URL specifica.  Il codice sotto stante mostra una configurazione di esempio per l'UrlNormalizer:  'urlManager' =  [\n    'enablePrettyUrl' =  true,\n    'showScriptName' =  false,\n    'enableStrictParsing' =  true,\n    'suffix' =  '.html',\n    'normalizer' =  [\n        'class' =  'yii\\web\\UrlNormalizer',\n        // use temporary redirection instead of permanent for debugging\n        'action' =  UrlNormalizer::ACTION_REDIRECT_TEMPORARY,\n    ],\n    'rules' =  [\n        // ...other rules...\n        [\n            'pattern' =  'posts',\n            'route' =  'post/index',\n            'suffix' =  '/',\n            'normalizer' =  false, // disable normalizer for this rule\n        ],\n        [\n            'pattern' =  'tags',\n            'route' =  'tag/index',\n            'normalizer' =  [\n                // do not collapse consecutive slashes for this rule\n                'collapseSlashes' =  false,\n            ],\n        ],\n    ],\n]   Note  Per impostazione predefinita  UrlManager :: $ normalizer  \u00e8 disabilitato. \u00c8 necessario configurarlo in modo esplicito per abilitare la normalizzazione degli URL.",
            "title": "Normalizzazione dell'URL"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#considerazioni-sulle-prestazioni",
            "text": "Durante lo sviluppo di un'applicazione Web complessa, \u00e8 importante ottimizzare le regole degli URL in modo che sia necessario meno tempo per analizzare le richieste e creare URL.  Utilizzando route parametrizzate, \u00e8 possibile ridurre il numero di regole URL, che possono migliorare significativamente le prestazioni.  Durante l'analisi o la creazione di URL, il gestore URL esamina le regole URL nell'ordine in cui sono dichiarate. Pertanto, si pu\u00f2 prendere in considerazione la possibilit\u00e0 di modificare l'ordine delle regole dell'URL in modo che le regole pi\u00f9 specifiche e / o pi\u00f9 comunemente usate siano poste prima di quelle meno utilizzate.  Se alcune regole URL condividono lo stesso prefisso nei propri pattern o percorsi, \u00e8 possibile considerare l'utilizzo di  yii \\ web \\ GroupUrlRule  in modo che possano essere esaminati in modo pi\u00f9 efficiente dal gestore URL come gruppo. Questo \u00e8 spesso il caso in cui l'applicazione \u00e8 composta da moduli, ciascuno con il proprio set di regole URL con l'ID del modulo come prefisso comune.",
            "title": "Considerazioni sulle prestazioni"
        },
        {
            "location": "/handling-requests/sub-requests/",
            "text": "Requests\n\n\nLe richieste fatte ad un'applicazione sono rappresentate in termini di oggetti \nyii \\ web \\ Request\n che forniscono informazioni come parametri di richiesta, intestazioni HTTP, cookie, ecc. Per una determinata richiesta, \u00e8 possibile accedere all'oggetto di richiesta corrispondente tramite il componente \nrequest\n dell'applicazione che \u00e8 un'istanza di \nyii \\ web \\ Request\n, per impostazione predefinita. In questa sezione, descriveremo come puoi utilizzare questo componente nelle tue applicazioni.\n\n\nRichiesta dei parametri\n\n\nPer ottenere i parametri da una richiesta, puoi chiamare i metodi \nget()\n e \npost()\n del componente \nrequest\n. Restituiscono i valori di \n$_GET\n e \n$_POST\n. Per esempio,\n\n\n$request = Yii::$app-\nrequest;\n\n$get = $request-\nget();\n// equivalent to: $get = $_GET;\n\n$id = $request-\nget('id');\n// equivalent to: $id = isset($_GET['id']) ? $_GET['id'] : null;\n\n$id = $request-\nget('id', 1);\n// equivalent to: $id = isset($_GET['id']) ? $_GET['id'] : 1;\n\n$post = $request-\npost();\n// equivalent to: $post = $_POST;\n\n$name = $request-\npost('name');\n// equivalent to: $name = isset($_POST['name']) ? $_POST['name'] : null;\n\n$name = $request-\npost('name', '');\n// equivalent to: $name = isset($_POST['name']) ? $_POST['name'] : '';\n\n\n\n\n\nInfo\n\n\nInvece di accedere direttamente a \n$_GET\n e \n$_POST\n e recuperare i parametri della richiesta, \u00e8 consigliabile ottenerli tramite il componente \nrequest\n come mostrato sopra. Ci\u00f2 render\u00e0 pi\u00f9 facili i test di scrittura perch\u00e9 \u00e8 possibile creare un componente di richiesta fittizia con dati di richiesta falsi.\n\n\n\n\nQuando si implementano le API RESTful , \u00e8 spesso necessario recuperare i parametri inviati tramite PUT, PATCH o altri metodi di richiesta. \u00c8 possibile ottenere questi parametri chiamando i metodi \nyii \\ web \\ Request :: getBodyParam()\n. Per esempio,\n\n\n$request = Yii::$app-\nrequest;\n\n// returns all parameters\n$params = $request-\nbodyParams;\n\n// returns the parameter \"id\"\n$param = $request-\ngetBodyParam('id');\n\n\n\n\n\nInfo\n\n\nA differenza dei parametri \nGET\n, i parametri inviati via POST, PUT, PATCH ecc.. vengono inviati nel corpo della richiesta. Il componente \nrequest\n analizzer\u00e0 questi parametri quando li accederai attraverso i metodi descritti sopra. \u00c8 possibile personalizzare il modo in cui vengono analizzati questi parametri configurando la propriet\u00e0 \nyii \\ web \\ Request :: $ parsers\n.\n\n\n\n\nMetodi relativi alle richieste\n\n\n\u00c8 possibile ottenere il metodo HTTP utilizzato la richiesta corrente tramite l'espressione \nYii::$app-\nrequest-\nmethod\n. \u00c8 inoltre disponibile un intero set di propriet\u00e0 booleane per verificare se il metodo corrente \u00e8 di un certo tipo. Per esempio,\n\n\n$request = Yii::$app-\nrequest;\n\nif ($request-\nisAjax) { /* the request is an AJAX request */ }\nif ($request-\nisGet)  { /* the request method is GET */ }\nif ($request-\nisPost) { /* the request method is POST */ }\nif ($request-\nisPut)  { /* the request method is PUT */ }\n\n\n\nRichiesta degli URL\n\n\nIl componente \nrequest\n offre molti modi per ispezionare l'URL attualmente richiesto.\n\n\nSupponendo che l'URL richiesto sia \nhttp://example.com/admin/index.php/product?id=100\n, puoi ottenere varie parti di questo URL come riepilogato di seguito:\n\n\n\n\nyii \\ web \\ Request :: url\n: restituisce \n/admin/index.php/product?id=100\n, che \u00e8 l'URL senza la parte di informazione dell'host.\n\n\nyii \\ web \\ Request :: absoluteUrl\n: restituisce \nhttp://example.com/admin/index.php/product?id=100\n, che \u00e8 l'URL intero che include la parte di informazioni sull'host.\n\n\nyii \\ web \\ Request :: hostInfo\n: restituisce \nhttp://example.com\n, che \u00e8 la parte di informazioni sull'host dell'URL.\n\n\nyii \\ web \\ Request :: pathInfo\n: restituisce \n/product\n, che \u00e8 la parte dopo lo script di immissione e prima del punto interrogativo (stringa di query).\n\n\nyii \\ web \\ Request :: queryString\n: restituisce \nid=100\n, che \u00e8 la parte dopo il punto interrogativo.\n\n\nyii \\ web \\ Request :: baseUrl\n: restituisce \n/admin\n, che \u00e8 la parte dopo le informazioni sull'host e prima del nome dello script di immissione.\n\n\nyii \\ web \\ Request :: scriptUrl\n: restituisce \n/admin/index.php\n, che \u00e8 l'URL senza informazioni sul percorso e stringa di query.\n\n\nyii \\ web \\ Request :: serverName\n: restituisce \nexample.com\n, che \u00e8 il nome host nell'URL.\n\n\nyii \\ web \\ Request :: serverPort\n: restituisce 80, che \u00e8 la porta utilizzata dal server Web.\n\n\n\n\nIntestazioni HTTP\n\n\n\u00c8 possibile ottenere le informazioni dell'intestazione HTTP attraverso la raccolta dell'intestazione restituita dalla propriet\u00e0 \nyii \\ web \\ Request ::\n. Per esempio,\n\n\n// $headers is an object of yii\\web\\HeaderCollection \n$headers = Yii::$app-\nrequest-\nheaders;\n\n// returns the Accept header value\n$accept = $headers-\nget('Accept');\n\nif ($headers-\nhas('User-Agent')) { /* there is User-Agent header */ }\n\n\n\nIl componente \nrequest\n fornisce inoltre supporto per l'accesso rapido ad alcune intestazioni comunemente utilizzate, tra cui:\n\n\n\n\nyii \\ web \\ Request :: userAgent\n: restituisce il valore \nUser-Agent\n dell'intestazione.\n\n\nyii \\ web \\ Request :: contentType\n: restituisce il valore \nContent-Type\n dell'intestazione che indica il tipo MIME dei dati nel corpo della richiesta.\n\n\nyii \\ web \\ Request :: acceptableContentTypes\n: restituisce i tipi MIME di contenuto accettabili dagli utenti. I tipi restituiti sono ordinati in base al loro punteggio di qualit\u00e0. I tipi con i punteggi pi\u00f9 alti verranno restituiti per primi.\n\n\nyii \\ web \\ Request :: acceptableLingue\n: restituisce le lingue accettabili dagli utenti. Le lingue restituite sono ordinate in base al loro livello di preferenza. Il primo elemento rappresenta la lingua pi\u00f9 preferita.\n\n\n\n\nSe l'applicazione supporta pi\u00f9 lingue e si desidera visualizzare le pagine nella lingua che \u00e8 la pi\u00f9 preferita dall'utente finale, \u00e8 possibile utilizzare il metodo di negoziazione della lingua \nyii \\ web \\ Request :: getPreferredLanguagd()\n. Questo metodo prende un elenco di lingue supportate dall'applicazione, le confronta con \nyii \\ web \\ Request :: acceptable\n e restituisce la lingua pi\u00f9 appropriata.\n\n\n\n\nTip\n\n\nE' anche possibile utilizzare il filtro \nContentNegotiator\n per determinare in modo dinamico quale tipo di contenuto e lingua devono essere utilizzati nella risposta. Il filtro implementa la negoziazione del contenuto in cima alle propriet\u00e0 e ai metodi descritti sopra.\n\n\n\n\nInformazioni sul cliente\n\n\n\u00c8 possibile ottenere il nome host e l'indirizzo IP del computer client tramite \nyii \\ web \\ Request :: userHost\n e \nyii \\ web \\ Request :: userIP\n. Per esempio,\n\n\n$userHost = Yii::$app-\nrequest-\nuserHost;\n$userIP = Yii::$app-\nrequest-\nuserIP;\n\n\n\nProxy e intestazioni affidabili\n\n\nNella sezione precedente hai visto come ottenere informazioni utente come host e indirizzo IP. Questo funzioner\u00e0 immediatamente in una configurazione normale in cui un singolo server web viene utilizzato per servire il sito web. Tuttavia, se l'applicazione Yii funziona dietro un proxy inverso, \u00e8 necessario aggiungere ulteriore configurazione per recuperare queste informazioni poich\u00e9 il client diretto ora \u00e8 il proxy e l'indirizzo IP dell'utente viene passato all'applicazione Yii da un'intestazione impostata dal proxy.\n\n\nNon dovresti fidarti ciecamente delle intestazioni fornite dai proxy, a meno che tu non ti fidi esplicitamente del proxy. Dal momento che Yii 2.0.13 supporta la configurazione di proxy fidati tramite le propriet\u00e0 \ntrustedHosts\n, \nsecureHeaders\n, \nipHeaders\n e \nsecureProtocolHeaders\n del componente \nrequest\n.\n\n\nDi seguito \u00e8 riportata una richiesta di configurazione per un'applicazione che viene eseguita dietro una matrice di proxy inversi, che si trovano nella rete IP \n10.0.2.0/24\n:\n\n\n'request' =\n [\n    // ...\n    'trustedHosts' =\n [\n        '/^10\\.0\\.2\\.\\d+$/',\n    ],\n],\n\n\n\nL'IP viene inviato dal proxy \nX-Forwarded-For\n nell'intestazione per impostazione predefinita e viene inviato il protocollo ( \nhttp\n o \nhttps\n) \nX-Forwarded-Proto\n.\n\n\nNel caso in cui i proxy utilizzino intestazioni diverse, \u00e8 possibile utilizzare la configurazione della richiesta per regolarle, ad esempio:\n\n\n'request' =\n [\n    // ...\n    'trustedHosts' =\n [\n        '/^10\\.0\\.2\\.\\d+$/' =\n [\n            'X-ProxyUser-Ip',\n            'Front-End-Https',\n        ],\n    ],\n    'secureHeaders' =\n [\n             'X-Forwarded-For',\n             'X-Forwarded-Host',\n            'X-Forwarded-Proto',\n            'X-Proxy-User-Ip',\n            'Front-End-Https',\n        ];\n    'ipHeaders' =\n [\n        'X-Proxy-User-Ip',\n    ],\n    'secureProtocolHeaders' =\n [\n        'Front-End-Https' =\n ['on']\n    ],\n],\n\n\n\nCon la configurazione di cui sopra indicata, tutte le intestazioni elencate \nsecureHeaders\n sono filtrate dalla richiesta, ad eccezione delle intestazioni \nX-ProxyUser-Ip\n e \nFront-End-Https\n nel caso in cui la richiesta venga effettuata dal proxy. In questo caso il primo viene utilizzato per recuperare l'IP dell'utente come configurato in \nipHeaders\n e quest'ultimo verr\u00e0 utilizzato per determinare il risultato di \nyii \\ web \\ Request :: getIsSecureConnection()\n.",
            "title": "Requests"
        },
        {
            "location": "/handling-requests/sub-requests/#requests",
            "text": "Le richieste fatte ad un'applicazione sono rappresentate in termini di oggetti  yii \\ web \\ Request  che forniscono informazioni come parametri di richiesta, intestazioni HTTP, cookie, ecc. Per una determinata richiesta, \u00e8 possibile accedere all'oggetto di richiesta corrispondente tramite il componente  request  dell'applicazione che \u00e8 un'istanza di  yii \\ web \\ Request , per impostazione predefinita. In questa sezione, descriveremo come puoi utilizzare questo componente nelle tue applicazioni.",
            "title": "Requests"
        },
        {
            "location": "/handling-requests/sub-requests/#richiesta-dei-parametri",
            "text": "Per ottenere i parametri da una richiesta, puoi chiamare i metodi  get()  e  post()  del componente  request . Restituiscono i valori di  $_GET  e  $_POST . Per esempio,  $request = Yii::$app- request;\n\n$get = $request- get();\n// equivalent to: $get = $_GET;\n\n$id = $request- get('id');\n// equivalent to: $id = isset($_GET['id']) ? $_GET['id'] : null;\n\n$id = $request- get('id', 1);\n// equivalent to: $id = isset($_GET['id']) ? $_GET['id'] : 1;\n\n$post = $request- post();\n// equivalent to: $post = $_POST;\n\n$name = $request- post('name');\n// equivalent to: $name = isset($_POST['name']) ? $_POST['name'] : null;\n\n$name = $request- post('name', '');\n// equivalent to: $name = isset($_POST['name']) ? $_POST['name'] : '';   Info  Invece di accedere direttamente a  $_GET  e  $_POST  e recuperare i parametri della richiesta, \u00e8 consigliabile ottenerli tramite il componente  request  come mostrato sopra. Ci\u00f2 render\u00e0 pi\u00f9 facili i test di scrittura perch\u00e9 \u00e8 possibile creare un componente di richiesta fittizia con dati di richiesta falsi.   Quando si implementano le API RESTful , \u00e8 spesso necessario recuperare i parametri inviati tramite PUT, PATCH o altri metodi di richiesta. \u00c8 possibile ottenere questi parametri chiamando i metodi  yii \\ web \\ Request :: getBodyParam() . Per esempio,  $request = Yii::$app- request;\n\n// returns all parameters\n$params = $request- bodyParams;\n\n// returns the parameter \"id\"\n$param = $request- getBodyParam('id');   Info  A differenza dei parametri  GET , i parametri inviati via POST, PUT, PATCH ecc.. vengono inviati nel corpo della richiesta. Il componente  request  analizzer\u00e0 questi parametri quando li accederai attraverso i metodi descritti sopra. \u00c8 possibile personalizzare il modo in cui vengono analizzati questi parametri configurando la propriet\u00e0  yii \\ web \\ Request :: $ parsers .",
            "title": "Richiesta dei parametri"
        },
        {
            "location": "/handling-requests/sub-requests/#metodi-relativi-alle-richieste",
            "text": "\u00c8 possibile ottenere il metodo HTTP utilizzato la richiesta corrente tramite l'espressione  Yii::$app- request- method . \u00c8 inoltre disponibile un intero set di propriet\u00e0 booleane per verificare se il metodo corrente \u00e8 di un certo tipo. Per esempio,  $request = Yii::$app- request;\n\nif ($request- isAjax) { /* the request is an AJAX request */ }\nif ($request- isGet)  { /* the request method is GET */ }\nif ($request- isPost) { /* the request method is POST */ }\nif ($request- isPut)  { /* the request method is PUT */ }",
            "title": "Metodi relativi alle richieste"
        },
        {
            "location": "/handling-requests/sub-requests/#richiesta-degli-url",
            "text": "Il componente  request  offre molti modi per ispezionare l'URL attualmente richiesto.  Supponendo che l'URL richiesto sia  http://example.com/admin/index.php/product?id=100 , puoi ottenere varie parti di questo URL come riepilogato di seguito:   yii \\ web \\ Request :: url : restituisce  /admin/index.php/product?id=100 , che \u00e8 l'URL senza la parte di informazione dell'host.  yii \\ web \\ Request :: absoluteUrl : restituisce  http://example.com/admin/index.php/product?id=100 , che \u00e8 l'URL intero che include la parte di informazioni sull'host.  yii \\ web \\ Request :: hostInfo : restituisce  http://example.com , che \u00e8 la parte di informazioni sull'host dell'URL.  yii \\ web \\ Request :: pathInfo : restituisce  /product , che \u00e8 la parte dopo lo script di immissione e prima del punto interrogativo (stringa di query).  yii \\ web \\ Request :: queryString : restituisce  id=100 , che \u00e8 la parte dopo il punto interrogativo.  yii \\ web \\ Request :: baseUrl : restituisce  /admin , che \u00e8 la parte dopo le informazioni sull'host e prima del nome dello script di immissione.  yii \\ web \\ Request :: scriptUrl : restituisce  /admin/index.php , che \u00e8 l'URL senza informazioni sul percorso e stringa di query.  yii \\ web \\ Request :: serverName : restituisce  example.com , che \u00e8 il nome host nell'URL.  yii \\ web \\ Request :: serverPort : restituisce 80, che \u00e8 la porta utilizzata dal server Web.",
            "title": "Richiesta degli URL"
        },
        {
            "location": "/handling-requests/sub-requests/#intestazioni-http",
            "text": "\u00c8 possibile ottenere le informazioni dell'intestazione HTTP attraverso la raccolta dell'intestazione restituita dalla propriet\u00e0  yii \\ web \\ Request :: . Per esempio,  // $headers is an object of yii\\web\\HeaderCollection \n$headers = Yii::$app- request- headers;\n\n// returns the Accept header value\n$accept = $headers- get('Accept');\n\nif ($headers- has('User-Agent')) { /* there is User-Agent header */ }  Il componente  request  fornisce inoltre supporto per l'accesso rapido ad alcune intestazioni comunemente utilizzate, tra cui:   yii \\ web \\ Request :: userAgent : restituisce il valore  User-Agent  dell'intestazione.  yii \\ web \\ Request :: contentType : restituisce il valore  Content-Type  dell'intestazione che indica il tipo MIME dei dati nel corpo della richiesta.  yii \\ web \\ Request :: acceptableContentTypes : restituisce i tipi MIME di contenuto accettabili dagli utenti. I tipi restituiti sono ordinati in base al loro punteggio di qualit\u00e0. I tipi con i punteggi pi\u00f9 alti verranno restituiti per primi.  yii \\ web \\ Request :: acceptableLingue : restituisce le lingue accettabili dagli utenti. Le lingue restituite sono ordinate in base al loro livello di preferenza. Il primo elemento rappresenta la lingua pi\u00f9 preferita.   Se l'applicazione supporta pi\u00f9 lingue e si desidera visualizzare le pagine nella lingua che \u00e8 la pi\u00f9 preferita dall'utente finale, \u00e8 possibile utilizzare il metodo di negoziazione della lingua  yii \\ web \\ Request :: getPreferredLanguagd() . Questo metodo prende un elenco di lingue supportate dall'applicazione, le confronta con  yii \\ web \\ Request :: acceptable  e restituisce la lingua pi\u00f9 appropriata.   Tip  E' anche possibile utilizzare il filtro  ContentNegotiator  per determinare in modo dinamico quale tipo di contenuto e lingua devono essere utilizzati nella risposta. Il filtro implementa la negoziazione del contenuto in cima alle propriet\u00e0 e ai metodi descritti sopra.",
            "title": "Intestazioni HTTP"
        },
        {
            "location": "/handling-requests/sub-requests/#informazioni-sul-cliente",
            "text": "\u00c8 possibile ottenere il nome host e l'indirizzo IP del computer client tramite  yii \\ web \\ Request :: userHost  e  yii \\ web \\ Request :: userIP . Per esempio,  $userHost = Yii::$app- request- userHost;\n$userIP = Yii::$app- request- userIP;",
            "title": "Informazioni sul cliente"
        },
        {
            "location": "/handling-requests/sub-requests/#proxy-e-intestazioni-affidabili",
            "text": "Nella sezione precedente hai visto come ottenere informazioni utente come host e indirizzo IP. Questo funzioner\u00e0 immediatamente in una configurazione normale in cui un singolo server web viene utilizzato per servire il sito web. Tuttavia, se l'applicazione Yii funziona dietro un proxy inverso, \u00e8 necessario aggiungere ulteriore configurazione per recuperare queste informazioni poich\u00e9 il client diretto ora \u00e8 il proxy e l'indirizzo IP dell'utente viene passato all'applicazione Yii da un'intestazione impostata dal proxy.  Non dovresti fidarti ciecamente delle intestazioni fornite dai proxy, a meno che tu non ti fidi esplicitamente del proxy. Dal momento che Yii 2.0.13 supporta la configurazione di proxy fidati tramite le propriet\u00e0  trustedHosts ,  secureHeaders ,  ipHeaders  e  secureProtocolHeaders  del componente  request .  Di seguito \u00e8 riportata una richiesta di configurazione per un'applicazione che viene eseguita dietro una matrice di proxy inversi, che si trovano nella rete IP  10.0.2.0/24 :  'request' =  [\n    // ...\n    'trustedHosts' =  [\n        '/^10\\.0\\.2\\.\\d+$/',\n    ],\n],  L'IP viene inviato dal proxy  X-Forwarded-For  nell'intestazione per impostazione predefinita e viene inviato il protocollo (  http  o  https )  X-Forwarded-Proto .  Nel caso in cui i proxy utilizzino intestazioni diverse, \u00e8 possibile utilizzare la configurazione della richiesta per regolarle, ad esempio:  'request' =  [\n    // ...\n    'trustedHosts' =  [\n        '/^10\\.0\\.2\\.\\d+$/' =  [\n            'X-ProxyUser-Ip',\n            'Front-End-Https',\n        ],\n    ],\n    'secureHeaders' =  [\n             'X-Forwarded-For',\n             'X-Forwarded-Host',\n            'X-Forwarded-Proto',\n            'X-Proxy-User-Ip',\n            'Front-End-Https',\n        ];\n    'ipHeaders' =  [\n        'X-Proxy-User-Ip',\n    ],\n    'secureProtocolHeaders' =  [\n        'Front-End-Https' =  ['on']\n    ],\n],  Con la configurazione di cui sopra indicata, tutte le intestazioni elencate  secureHeaders  sono filtrate dalla richiesta, ad eccezione delle intestazioni  X-ProxyUser-Ip  e  Front-End-Https  nel caso in cui la richiesta venga effettuata dal proxy. In questo caso il primo viene utilizzato per recuperare l'IP dell'utente come configurato in  ipHeaders  e quest'ultimo verr\u00e0 utilizzato per determinare il risultato di  yii \\ web \\ Request :: getIsSecureConnection() .",
            "title": "Proxy e intestazioni affidabili"
        },
        {
            "location": "/handling-requests/sub-responses/",
            "text": "Responses\n\n\nQuando un'applicazione termina la gestione di una richiesta, genera un oggetto risposta e lo invia all'utente finale. L'oggetto risposta contiene informazioni come il codice di stato HTTP, le intestazioni HTTP e il corpo. L'obiettivo finale dello sviluppo di applicazioni Web \u00e8 essenzialmente quello di costruire tali oggetti di risposta su varie richieste.\n\n\nNella maggior parte dei casi dovresti occuparti principalmente del componente \nresponse\n dell'applicazione, che \u00e8 un'istanza di \nyii \\ web \\ Response\n, per impostazione predefinita. Tuttavia, Yii consente anche di creare i propri oggetti di risposta e inviarli agli utenti finali come spiegheremo di seguito.\n\n\nIn questa sezione, descriveremo come comporre e inviare risposte agli utenti finali.\n\n\nStato del codice\n\n\nUna delle prime cose che dovresti fare quando costruisci una risposta \u00e8 dichiarare se la richiesta \u00e8 gestita con successo. Questo viene fatto impostando la propriet\u00e0 \nyii \\ web \\ Response :: statusCode\n che pu\u00f2 assumere uno dei codici di stato HTTP validi . Ad esempio, per indicare che la richiesta \u00e8 stata gestita correttamente, \u00e8 possibile impostare il codice di stato su 200, come nell'esempio seguente:\n\n\nYii::$app-\nresponse-\nstatusCode = 200;\n\n\n\nTuttavia, nella maggior parte dei casi non \u00e8 necessario impostare in modo esplicito il codice di stato. Ci\u00f2 \u00e8 dovuto al fatto che il valore predefinito di \nyii \\ web \\ Response :: statusCode\n \u00e8 200. E se si desidera indicare che la richiesta non ha esito positivo, \u00e8 possibile generare un'eccezione HTTP appropriata come la seguente:\n\n\nthrow new \\yii\\web\\NotFoundHttpException;\n\n\n\nQuando il gestore degli errori rileva un'eccezione, estrae il codice di stato dall'eccezione e lo assegna alla risposta. Per l'eccezione precedente \nyii \\ web \\ NotFoundHttpException\n, \u00e8 associato allo stato HTTP 404. Le seguenti eccezioni HTTP sono predefinite in Yii:\n\n\n\n\nyii \\ web \\ BadRequestHttpException\n: codice di stato 400.\n\n\nyii \\ web \\ ConflictHttpException\n: codice di stato 409.\n\n\nyii \\ web \\ ForbiddenHttpException\n: codice di stato 403.\n\n\nyii \\ web \\ GoneHttpException\n: codice di stato 410.\n\n\nyii \\ web \\ MethodNotAllowedHttpException\n: codice di stato 405.\n\n\nyii \\ web \\ NotAcceptableHttpException\n: codice di stato 406.\n\n\nyii \\ web \\ NotFoundHttpException\n: codice di stato 404.\n\n\nyii \\ web \\ ServerErrorHttpException\n: codice di stato 500.\n\n\nyii \\ web \\ TooManyRequestsHttpException\n: codice di stato 429.\n\n\nyii \\ web \\ UnauthorizedHttpException\n: codice di stato 401.\n\n\nyii \\ web \\ UnsupportedMediaTypeHttpException\n: codice di stato 415.\n\n\n\n\nSe l'eccezione che vuoi lanciare non \u00e8 tra quelle elencate sopra, puoi crearne una estendendoti da \nyii \\ web \\ HttpException\n, o lanciarla direttamente con un codice di stato, ad esempio,\n\n\nthrow new \\yii\\web\\HttpException(402);\n\n\n\nIntestazioni HTTP\n\n\n\u00c8 possibile inviare intestazioni HTTP manipolando le intestazioni \nyii \\ web \\ Response ::\n nel componente \nresponse\n. Per esempio,\n\n\n$headers = Yii::$app-\nresponse-\nheaders;\n\n// add a Pragma header. Existing Pragma headers will NOT be overwritten.\n$headers-\nadd('Pragma', 'no-cache');\n\n// set a Pragma header. Any existing Pragma headers will be discarded.\n$headers-\nset('Pragma', 'no-cache');\n\n// remove Pragma header(s) and return the removed Pragma header values in an array\n$values = $headers-\nremove('Pragma');\n\n\n\n\n\nInfo\n\n\nI nomi delle intestazioni non fanno distinzione tra maiuscole e minuscole. E le intestazioni appena registrate non vengono inviate all'utente finch\u00e9 non viene chiamato il metodo \nyii \\ web \\ Response :: send ()\n.\n\n\n\n\nRisposta da perte del Body\n\n\nLa maggior parte delle risposte dovrebbe avere un corpo che dia il contenuto che si desidera mostrare agli utenti finali.\n\n\nSe si dispone gi\u00e0 di una stringa di corpo formattata, \u00e8 possibile assegnarla alla propriet\u00e0 del contenuto \nyii \\ web \\ Response :: $\n della risposta. Per esempio,\n\n\nYii::$app-\nresponse-\ncontent = 'hello world!';\n\n\n\nSe i tuoi dati devono essere formattati prima di inviarli agli utenti finali, devi impostare sia il formato che le propriet\u00e0 dei dati . La propriet\u00e0 \nformat\n specifica in quale formato i dati devono essere formattati. Per esempio,\n\n\n$response = Yii::$app-\nresponse;\n$response-\nformat = \\yii\\web\\Response::FORMAT_JSON;\n$response-\ndata = ['message' =\n 'hello world'];\n\n\n\nYii supporta i seguenti formati pronti all'uso, ciascuno implementato da una classe di formattazione . \u00c8 possibile personalizzare questi formattatori o aggiungerne di nuovi configurando la propriet\u00e0 \nyii \\ web \\ Response :: $ formatters\n.\n\n\n\n\nHTML\n: implementato da \nyii \\ web \\ HtmlResponseFormatter\n.\n\n\nXML\n:  implementato da \nyii \\ web \\ XmlResponseFormatter\n.\n\n\nJSON\n: implementato da \nyii \\ web \\ JsonResponseFormatter\n.\n\n\nJSONP\n: implementato da \nyii \\ web \\ JsonResponseFormatter\n.\n\n\nRAW\n: utilizzare questo formato se si desidera inviare la risposta direttamente senza applicare alcuna formattazione.\n\n\n\n\nMentre il corpo della risposta pu\u00f2 essere impostato esplicitamente come mostrato sopra, nella maggior parte dei casi \u00e8 possibile impostarlo implicitamente dal valore di ritorno dei metodi di azione . Un caso d'uso comune \u00e8 come il seguente:\n\n\npublic function actionIndex(){\n\n    return $this-\nrender('index');\n\n}\n\n\n\nL'azione \nindex\n sopra indicata,restituisce il risultato del rendering della vista \nindex\n. Il valore di ritorno sar\u00e0 preso dal componente \nresponse\n, formattato e quindi inviato agli utenti finali.\n\n\nPoich\u00e9,per impostazione predefinita, il formato di risposta \u00e8 HTML , \u00e8 necessario restituire una stringa solo in un metodo di azione. Se si desidera utilizzare un formato di risposta diverso, \u00e8 necessario impostarlo prima di restituire i dati. Per esempio,\n\n\npublic function actionInfo(){\n\n    \\Yii::$app-\nresponse-\nformat = \\yii\\web\\Response::FORMAT_JSON;\n    return [\n        'message' =\n 'hello world',\n        'code' =\n 100,\n    ];\n}\n\n\n\nCome gi\u00e0 accennato, oltre a utilizzare il componente predefinito dell'applicazione\nresponse\n, \u00e8 anche possibile creare i propri oggetti di risposta e inviarli agli utenti finali. Puoi farlo restituendo tale oggetto in un metodo di azione, come il seguente,\n\n\npublic function actionInfo(){\n\n    return \\Yii::createObject([\n        'class' =\n 'yii\\web\\Response',\n        'format' =\n \\yii\\web\\Response::FORMAT_JSON,\n        'data' =\n [\n            'message' =\n 'hello world',\n            'code' =\n 100,\n        ],\n    ]);\n}\n\n\n\n\n\nWarning\n\n\nSe si creano oggetti di risposta personalizzati, non sar\u00e0 possibile sfruttare le configurazioni impostate per il componente \nresponse\n nella configurazione dell'applicazione. Tuttavia, \u00e8 possibile utilizzare la \"dependency injection\" per applicare una configurazione comune ai nuovi oggetti risposta.\n\n\n\n\nReindirizzamento del browser\n\n\nIl reindirizzamento del browser si basa sull'invio dell'intestazione HTTP \nLocation\n. Poich\u00e9 questa funzione \u00e8 comunemente utilizzata, Yii fornisce un supporto speciale per questo.\n\n\n\u00c8 possibile reindirizzare il browser utente a un URL chiamando il metodo \nyii \\ web \\ Response :: redirect()\n. Il metodo imposta l'intestazione \nLocation\n appropriata con l'URL specificato e restituisce l'oggetto risposta. In un metodo di azione, puoi chiamare la sua versione di collegamento \nyii \\ web \\ Controller :: redirect()\n. Per esempio,\n\n\npublic function actionOld{\n\n    return $this-\nredirect('http://example.com/new', 301);\n\n}\n\n\n\nNel codice precedente, il metodo \naction\n restituisce il risultato del metodo \nredirect()\n. Come spiegato in precedenza, l'oggetto risposta restituito da un metodo di azione verr\u00e0 utilizzato come risposta inviata agli utenti finali.\n\n\nIn luoghi diversi da un metodo di azione, \u00e8 necessario chiamare direttamente\nyii \\ web \\ Response :: redirect()\n seguito da una chiamata concatenata al metodo \nyii \\ web \\ Response :: send()\n per garantire che nessun contenuto aggiuntivo venga aggiunto al risposta.\n\n\n\\Yii::$app-\nresponse-\nredirect('http://example.com/new', 301)-\nsend();\n\n\n\n\n\nInfo\n\n\nPer impostazione predefinita, il metodo \nyii \\ web \\ Response :: redirect ()\n imposta il codice di stato della risposta su 302 che indica al browser che la risorsa richiesta \u00e8 temporaneamente posizionata in un URL differente. Puoi passare un codice di stato 301 per dire al browser che la risorsa \u00e8 stata trasferita permanentemente.\n\n\n\n\nQuando la richiesta corrente \u00e8 una richiesta AJAX, l'invio dell'intestazione \nLocation\n non causer\u00e0 automaticamente il reindirizzamento del browser. Per risolvere questo problema, il metodo \nyii \\ web \\ Response :: redirect()\n imposta un'intestazione \nX-Redirect\n con l'URL di reindirizzamento come valore. Sul lato client, \u00e8 possibile scrivere codice JavaScript per leggere questo valore di intestazione e reindirizzare il browser di conseguenza.\n\n\n\n\nInfo\n\n\nYii viene fornito con un file Javascript chiamato \nyii.js\n che fornisce un insieme di utilit\u00e0 JavaScript comunemente utilizzate, incluso il reindirizzamento del browser basato sull'intestazione \nX-Redirect\n. Pertanto, se si utilizza questo file JavaScript (registrando il bundle asset \nyii \\ web \\ YiiAsset\n ), non \u00e8 necessario scrivere nulla per supportare il reindirizzamento AJAX.\n\n\n\n\nInvio di file\n\n\nCome il reindirizzamento del browser, l'invio di file \u00e8 un'altra funzionalit\u00e0 che si basa su intestazioni HTTP specifiche. Yii fornisce una serie di metodi per supportare varie esigenze di invio di file. Hanno tutti il \u200b\u200bsupporto integrato per l'intestazione della gamma HTTP.\n\n\n\n\nyii \\ web \\ Response :: sendFile()\n: invia un file esistente a un client.\n\n\nyii \\ web \\ Response :: sendContentAsFile()\n: invia una stringa di testo come file a un client.\n\n\nyii \\ web \\ Response :: sendStreamAsFile()\n: invia un flusso di file esistente come file a un client.\n\n\n\n\nQuesti metodi hanno la stessa firma del metodo con l'oggetto di risposta come valore di ritorno. Se il file da inviare \u00e8 molto grande, dovresti considerare l'utilizzo di \nyii \\ web \\ Response :: sendStreamAsFile()\n perch\u00e9 \u00e8 pi\u00f9 efficiente in termini di memoria. L'esempio seguente mostra come inviare un file in un'azione del controllore:\n\n\npublic function actionDownload(){\n\n    return \\Yii::$app-\nresponse-\nsendFile('path/to/file.txt');\n\n}\n\n\n\nSe si chiama il metodo di invio del file in posizioni diverse da un metodo di azione, \u00e8 necessario chiamare anche il metodo \nyii \\ web \\ Response :: send()\n in seguito per garantire che alla risposta non vengano aggiunti ulteriori contenuti.\n\n\n\\Yii::$app-\nresponse-\nsendFile('path/to/file.txt')-\nsend();\n\n\n\nAlcuni server Web hanno un supporto speciale per l'invio di file chiamato \nX-Sendfile\n. L'idea \u00e8 di reindirizzare la richiesta di un file al server Web che servir\u00e0 direttamente il file. Di conseguenza, l'applicazione Web pu\u00f2 terminare prima mentre il server Web sta inviando il file. Per utilizzare questa funzione, \u00e8 possibile chiamare \nyii \\ web \\ Response :: xSendFile()\n. Il seguente elenco riepiloga come abilitare la funzione \nX-Sendfile\n per alcuni server Web popolari:\n\n\n\n\nApache: \nX-Sendfile\n\n\nLighttpd v1.4: \nX-LIGHTTPD-send-file\n\n\nLighttpd v1.5: \nX-Sendfile\n\n\nNginx: \nX-Accel-Redirect\n\n\nCherokee: \nX-Sendfile\n e \nX-Accel-Redirect\n\n\n\n\nInvio della risposta\n\n\nIl contenuto di una risposta non viene inviato all'utente finch\u00e9 non viene chiamato il metodo \nyii \\ web \\ Response :: send ()\n. Per impostazione predefinita, questo metodo verr\u00e0 chiamato automaticamente alla fine di \nyii \\ base \\ Application :: run()\n. Tuttavia, \u00e8 possibile chiamare esplicitamente questo metodo per forzare l'invio della risposta immediatamente.\n\n\nIl metodo \nyii \\ web \\ Response :: send()\n esegue i seguenti passi per inviare una risposta:\n\n\n\n\nInnescare l'evento \nYii \\ web \\ Response :: EVENT_BEFORE_SEND\n.\n\n\nChiama il metodo \nyii \\ web \\ Response :: prepare()\n per formattare i dati di risposta nel contenuto della risposta .\n\n\nInnescare l'evento \nYii \\ web \\ Response :: EVENT_AFTER_PREPARE\n.\n\n\nChiama il metodo \nYii \\ web \\ Response :: sendHeaders ()\n per inviare le intestazioni HTTP registrate.\n\n\nChiamare il metodo \nyii \\ web \\ Response :: sendContent ()\n per inviare il contenuto del corpo della risposta.\n\n\nInnescare l'evento \nYii \\ web \\ Response :: EVENT_AFTER_SEND\n.\n\n\n\n\nDopo che il metodo \nyii \\ web \\ Response :: send ()\n viene chiamato una volta, qualsiasi ulteriore chiamata a questo metodo verr\u00e0 ignorata. Ci\u00f2 significa che una volta inviata la risposta,non potrai aggiungere altro contenuto ad essa.\n\n\nCome puoi vedere, il metodo \nyii \\ web \\ Response :: send()\n attiva numerosi eventi utili. Rispondendo a questi eventi, \u00e8 possibile regolare o decorare la risposta.",
            "title": "Responses"
        },
        {
            "location": "/handling-requests/sub-responses/#responses",
            "text": "Quando un'applicazione termina la gestione di una richiesta, genera un oggetto risposta e lo invia all'utente finale. L'oggetto risposta contiene informazioni come il codice di stato HTTP, le intestazioni HTTP e il corpo. L'obiettivo finale dello sviluppo di applicazioni Web \u00e8 essenzialmente quello di costruire tali oggetti di risposta su varie richieste.  Nella maggior parte dei casi dovresti occuparti principalmente del componente  response  dell'applicazione, che \u00e8 un'istanza di  yii \\ web \\ Response , per impostazione predefinita. Tuttavia, Yii consente anche di creare i propri oggetti di risposta e inviarli agli utenti finali come spiegheremo di seguito.  In questa sezione, descriveremo come comporre e inviare risposte agli utenti finali.",
            "title": "Responses"
        },
        {
            "location": "/handling-requests/sub-responses/#stato-del-codice",
            "text": "Una delle prime cose che dovresti fare quando costruisci una risposta \u00e8 dichiarare se la richiesta \u00e8 gestita con successo. Questo viene fatto impostando la propriet\u00e0  yii \\ web \\ Response :: statusCode  che pu\u00f2 assumere uno dei codici di stato HTTP validi . Ad esempio, per indicare che la richiesta \u00e8 stata gestita correttamente, \u00e8 possibile impostare il codice di stato su 200, come nell'esempio seguente:  Yii::$app- response- statusCode = 200;  Tuttavia, nella maggior parte dei casi non \u00e8 necessario impostare in modo esplicito il codice di stato. Ci\u00f2 \u00e8 dovuto al fatto che il valore predefinito di  yii \\ web \\ Response :: statusCode  \u00e8 200. E se si desidera indicare che la richiesta non ha esito positivo, \u00e8 possibile generare un'eccezione HTTP appropriata come la seguente:  throw new \\yii\\web\\NotFoundHttpException;  Quando il gestore degli errori rileva un'eccezione, estrae il codice di stato dall'eccezione e lo assegna alla risposta. Per l'eccezione precedente  yii \\ web \\ NotFoundHttpException , \u00e8 associato allo stato HTTP 404. Le seguenti eccezioni HTTP sono predefinite in Yii:   yii \\ web \\ BadRequestHttpException : codice di stato 400.  yii \\ web \\ ConflictHttpException : codice di stato 409.  yii \\ web \\ ForbiddenHttpException : codice di stato 403.  yii \\ web \\ GoneHttpException : codice di stato 410.  yii \\ web \\ MethodNotAllowedHttpException : codice di stato 405.  yii \\ web \\ NotAcceptableHttpException : codice di stato 406.  yii \\ web \\ NotFoundHttpException : codice di stato 404.  yii \\ web \\ ServerErrorHttpException : codice di stato 500.  yii \\ web \\ TooManyRequestsHttpException : codice di stato 429.  yii \\ web \\ UnauthorizedHttpException : codice di stato 401.  yii \\ web \\ UnsupportedMediaTypeHttpException : codice di stato 415.   Se l'eccezione che vuoi lanciare non \u00e8 tra quelle elencate sopra, puoi crearne una estendendoti da  yii \\ web \\ HttpException , o lanciarla direttamente con un codice di stato, ad esempio,  throw new \\yii\\web\\HttpException(402);",
            "title": "Stato del codice"
        },
        {
            "location": "/handling-requests/sub-responses/#intestazioni-http",
            "text": "\u00c8 possibile inviare intestazioni HTTP manipolando le intestazioni  yii \\ web \\ Response ::  nel componente  response . Per esempio,  $headers = Yii::$app- response- headers;\n\n// add a Pragma header. Existing Pragma headers will NOT be overwritten.\n$headers- add('Pragma', 'no-cache');\n\n// set a Pragma header. Any existing Pragma headers will be discarded.\n$headers- set('Pragma', 'no-cache');\n\n// remove Pragma header(s) and return the removed Pragma header values in an array\n$values = $headers- remove('Pragma');   Info  I nomi delle intestazioni non fanno distinzione tra maiuscole e minuscole. E le intestazioni appena registrate non vengono inviate all'utente finch\u00e9 non viene chiamato il metodo  yii \\ web \\ Response :: send () .",
            "title": "Intestazioni HTTP"
        },
        {
            "location": "/handling-requests/sub-responses/#risposta-da-perte-del-body",
            "text": "La maggior parte delle risposte dovrebbe avere un corpo che dia il contenuto che si desidera mostrare agli utenti finali.  Se si dispone gi\u00e0 di una stringa di corpo formattata, \u00e8 possibile assegnarla alla propriet\u00e0 del contenuto  yii \\ web \\ Response :: $  della risposta. Per esempio,  Yii::$app- response- content = 'hello world!';  Se i tuoi dati devono essere formattati prima di inviarli agli utenti finali, devi impostare sia il formato che le propriet\u00e0 dei dati . La propriet\u00e0  format  specifica in quale formato i dati devono essere formattati. Per esempio,  $response = Yii::$app- response;\n$response- format = \\yii\\web\\Response::FORMAT_JSON;\n$response- data = ['message' =  'hello world'];  Yii supporta i seguenti formati pronti all'uso, ciascuno implementato da una classe di formattazione . \u00c8 possibile personalizzare questi formattatori o aggiungerne di nuovi configurando la propriet\u00e0  yii \\ web \\ Response :: $ formatters .   HTML : implementato da  yii \\ web \\ HtmlResponseFormatter .  XML :  implementato da  yii \\ web \\ XmlResponseFormatter .  JSON : implementato da  yii \\ web \\ JsonResponseFormatter .  JSONP : implementato da  yii \\ web \\ JsonResponseFormatter .  RAW : utilizzare questo formato se si desidera inviare la risposta direttamente senza applicare alcuna formattazione.   Mentre il corpo della risposta pu\u00f2 essere impostato esplicitamente come mostrato sopra, nella maggior parte dei casi \u00e8 possibile impostarlo implicitamente dal valore di ritorno dei metodi di azione . Un caso d'uso comune \u00e8 come il seguente:  public function actionIndex(){\n\n    return $this- render('index');\n\n}  L'azione  index  sopra indicata,restituisce il risultato del rendering della vista  index . Il valore di ritorno sar\u00e0 preso dal componente  response , formattato e quindi inviato agli utenti finali.  Poich\u00e9,per impostazione predefinita, il formato di risposta \u00e8 HTML , \u00e8 necessario restituire una stringa solo in un metodo di azione. Se si desidera utilizzare un formato di risposta diverso, \u00e8 necessario impostarlo prima di restituire i dati. Per esempio,  public function actionInfo(){\n\n    \\Yii::$app- response- format = \\yii\\web\\Response::FORMAT_JSON;\n    return [\n        'message' =  'hello world',\n        'code' =  100,\n    ];\n}  Come gi\u00e0 accennato, oltre a utilizzare il componente predefinito dell'applicazione response , \u00e8 anche possibile creare i propri oggetti di risposta e inviarli agli utenti finali. Puoi farlo restituendo tale oggetto in un metodo di azione, come il seguente,  public function actionInfo(){\n\n    return \\Yii::createObject([\n        'class' =  'yii\\web\\Response',\n        'format' =  \\yii\\web\\Response::FORMAT_JSON,\n        'data' =  [\n            'message' =  'hello world',\n            'code' =  100,\n        ],\n    ]);\n}   Warning  Se si creano oggetti di risposta personalizzati, non sar\u00e0 possibile sfruttare le configurazioni impostate per il componente  response  nella configurazione dell'applicazione. Tuttavia, \u00e8 possibile utilizzare la \"dependency injection\" per applicare una configurazione comune ai nuovi oggetti risposta.",
            "title": "Risposta da perte del Body"
        },
        {
            "location": "/handling-requests/sub-responses/#reindirizzamento-del-browser",
            "text": "Il reindirizzamento del browser si basa sull'invio dell'intestazione HTTP  Location . Poich\u00e9 questa funzione \u00e8 comunemente utilizzata, Yii fornisce un supporto speciale per questo.  \u00c8 possibile reindirizzare il browser utente a un URL chiamando il metodo  yii \\ web \\ Response :: redirect() . Il metodo imposta l'intestazione  Location  appropriata con l'URL specificato e restituisce l'oggetto risposta. In un metodo di azione, puoi chiamare la sua versione di collegamento  yii \\ web \\ Controller :: redirect() . Per esempio,  public function actionOld{\n\n    return $this- redirect('http://example.com/new', 301);\n\n}  Nel codice precedente, il metodo  action  restituisce il risultato del metodo  redirect() . Come spiegato in precedenza, l'oggetto risposta restituito da un metodo di azione verr\u00e0 utilizzato come risposta inviata agli utenti finali.  In luoghi diversi da un metodo di azione, \u00e8 necessario chiamare direttamente yii \\ web \\ Response :: redirect()  seguito da una chiamata concatenata al metodo  yii \\ web \\ Response :: send()  per garantire che nessun contenuto aggiuntivo venga aggiunto al risposta.  \\Yii::$app- response- redirect('http://example.com/new', 301)- send();   Info  Per impostazione predefinita, il metodo  yii \\ web \\ Response :: redirect ()  imposta il codice di stato della risposta su 302 che indica al browser che la risorsa richiesta \u00e8 temporaneamente posizionata in un URL differente. Puoi passare un codice di stato 301 per dire al browser che la risorsa \u00e8 stata trasferita permanentemente.   Quando la richiesta corrente \u00e8 una richiesta AJAX, l'invio dell'intestazione  Location  non causer\u00e0 automaticamente il reindirizzamento del browser. Per risolvere questo problema, il metodo  yii \\ web \\ Response :: redirect()  imposta un'intestazione  X-Redirect  con l'URL di reindirizzamento come valore. Sul lato client, \u00e8 possibile scrivere codice JavaScript per leggere questo valore di intestazione e reindirizzare il browser di conseguenza.   Info  Yii viene fornito con un file Javascript chiamato  yii.js  che fornisce un insieme di utilit\u00e0 JavaScript comunemente utilizzate, incluso il reindirizzamento del browser basato sull'intestazione  X-Redirect . Pertanto, se si utilizza questo file JavaScript (registrando il bundle asset  yii \\ web \\ YiiAsset  ), non \u00e8 necessario scrivere nulla per supportare il reindirizzamento AJAX.",
            "title": "Reindirizzamento del browser"
        },
        {
            "location": "/handling-requests/sub-responses/#invio-di-file",
            "text": "Come il reindirizzamento del browser, l'invio di file \u00e8 un'altra funzionalit\u00e0 che si basa su intestazioni HTTP specifiche. Yii fornisce una serie di metodi per supportare varie esigenze di invio di file. Hanno tutti il \u200b\u200bsupporto integrato per l'intestazione della gamma HTTP.   yii \\ web \\ Response :: sendFile() : invia un file esistente a un client.  yii \\ web \\ Response :: sendContentAsFile() : invia una stringa di testo come file a un client.  yii \\ web \\ Response :: sendStreamAsFile() : invia un flusso di file esistente come file a un client.   Questi metodi hanno la stessa firma del metodo con l'oggetto di risposta come valore di ritorno. Se il file da inviare \u00e8 molto grande, dovresti considerare l'utilizzo di  yii \\ web \\ Response :: sendStreamAsFile()  perch\u00e9 \u00e8 pi\u00f9 efficiente in termini di memoria. L'esempio seguente mostra come inviare un file in un'azione del controllore:  public function actionDownload(){\n\n    return \\Yii::$app- response- sendFile('path/to/file.txt');\n\n}  Se si chiama il metodo di invio del file in posizioni diverse da un metodo di azione, \u00e8 necessario chiamare anche il metodo  yii \\ web \\ Response :: send()  in seguito per garantire che alla risposta non vengano aggiunti ulteriori contenuti.  \\Yii::$app- response- sendFile('path/to/file.txt')- send();  Alcuni server Web hanno un supporto speciale per l'invio di file chiamato  X-Sendfile . L'idea \u00e8 di reindirizzare la richiesta di un file al server Web che servir\u00e0 direttamente il file. Di conseguenza, l'applicazione Web pu\u00f2 terminare prima mentre il server Web sta inviando il file. Per utilizzare questa funzione, \u00e8 possibile chiamare  yii \\ web \\ Response :: xSendFile() . Il seguente elenco riepiloga come abilitare la funzione  X-Sendfile  per alcuni server Web popolari:   Apache:  X-Sendfile  Lighttpd v1.4:  X-LIGHTTPD-send-file  Lighttpd v1.5:  X-Sendfile  Nginx:  X-Accel-Redirect  Cherokee:  X-Sendfile  e  X-Accel-Redirect",
            "title": "Invio di file"
        },
        {
            "location": "/handling-requests/sub-responses/#invio-della-risposta",
            "text": "Il contenuto di una risposta non viene inviato all'utente finch\u00e9 non viene chiamato il metodo  yii \\ web \\ Response :: send () . Per impostazione predefinita, questo metodo verr\u00e0 chiamato automaticamente alla fine di  yii \\ base \\ Application :: run() . Tuttavia, \u00e8 possibile chiamare esplicitamente questo metodo per forzare l'invio della risposta immediatamente.  Il metodo  yii \\ web \\ Response :: send()  esegue i seguenti passi per inviare una risposta:   Innescare l'evento  Yii \\ web \\ Response :: EVENT_BEFORE_SEND .  Chiama il metodo  yii \\ web \\ Response :: prepare()  per formattare i dati di risposta nel contenuto della risposta .  Innescare l'evento  Yii \\ web \\ Response :: EVENT_AFTER_PREPARE .  Chiama il metodo  Yii \\ web \\ Response :: sendHeaders ()  per inviare le intestazioni HTTP registrate.  Chiamare il metodo  yii \\ web \\ Response :: sendContent ()  per inviare il contenuto del corpo della risposta.  Innescare l'evento  Yii \\ web \\ Response :: EVENT_AFTER_SEND .   Dopo che il metodo  yii \\ web \\ Response :: send ()  viene chiamato una volta, qualsiasi ulteriore chiamata a questo metodo verr\u00e0 ignorata. Ci\u00f2 significa che una volta inviata la risposta,non potrai aggiungere altro contenuto ad essa.  Come puoi vedere, il metodo  yii \\ web \\ Response :: send()  attiva numerosi eventi utili. Rispondendo a questi eventi, \u00e8 possibile regolare o decorare la risposta.",
            "title": "Invio della risposta"
        },
        {
            "location": "/handling-requests/sub-session-cookies/",
            "text": "Session e Cookies\n\n\nLe sessioni e i cookie consentono di mantenere i dati su pi\u00f9 richieste degli utenti. In semplice PHP \u00e8 possibile accedervi tramite le variabili globali \n$_SESSION\n e \n$_COOKIE\n. Yii incapsula sessioni e cookie come oggetti e quindi ti consente di accedervi in \u200b\u200bmodo orientato agli oggetti con ulteriori utili miglioramenti.\n\n\nSessioni\n\n\nCome le request e le responses , \u00e8 possibile accedere alle sessioni tramite il componente \nsession\n dell'applicazione, che \u00e8 un'istanza di \nyii \\ web \\ Session\n, per impostazione predefinita.\n\n\nApertura e chiusura delle sessioni\n\n\nPer aprire e chiudere una sessione, puoi fare quanto segue:\n\n\n$session = Yii::$app-\nsession;\n\n// check if a session is already open\nif ($session-\nisActive) ...\n\n// open a session\n$session-\nopen();\n\n// close a session\n$session-\nclose();\n\n// destroys all data registered to a session.\n$session-\ndestroy();\n\n\n\nPuoi chiamare \nopen()\n e \nclose()\n pi\u00f9 volte,senza causare errori; internamente i metodi controlleranno prima se la sessione \u00e8 gi\u00e0 aperta.\n\n\nAccesso ai dati della sessione\n\n\nPer accedere ai dati memorizzati nella sessione, \u00e8 possibile effettuare le seguenti operazioni:\n\n\n$session = Yii::$app-\nsession;\n\n// get a session variable. The following usages are equivalent:\n$language = $session-\nget('language');\n$language = $session['language'];\n$language = isset($_SESSION['language']) ? $_SESSION['language'] : null;\n\n// set a session variable. The following usages are equivalent:\n$session-\nset('language', 'en-US');\n$session['language'] = 'en-US';\n$_SESSION['language'] = 'en-US';\n\n// remove a session variable. The following usages are equivalent:\n$session-\nremove('language');\nunset($session['language']);\nunset($_SESSION['language']);\n\n// check if a session variable exists. The following usages are equivalent:\nif ($session-\nhas('language')) ...\nif (isset($session['language'])) ...\nif (isset($_SESSION['language'])) ...\n\n// traverse all session variables. The following usages are equivalent:\nforeach ($session as $name =\n $value) ...\nforeach ($_SESSION as $name =\n $value) ...\n\n\n\n\n\nInfo\n\n\nQuando si accede ai dati della sessione attraverso il componente \nsession\n, una sessione verr\u00e0 aperta automaticamente se non \u00e8 stata eseguita in precedenza. Questo \u00e8 diverso dall'accedere ai dati della sessione attraverso \n$_SESSION\n, che richiede un esplicito richiamo di \nsession_start()\n.\n\n\n\n\nQuando si lavora con dati di sessione che sono matrici, il componente \nsession\n presenta una limitazione che impedisce di modificare direttamente un elemento dell'array. Per esempio,\n\n\n$session = Yii::$app-\nsession;\n\n// the following code will NOT work\n$session['captcha']['number'] = 5;\n$session['captcha']['lifetime'] = 3600;\n\n// the following code works:\n$session['captcha'] = [\n    'number' =\n 5,\n    'lifetime' =\n 3600,\n];\n\n// the following code also works:\necho $session['captcha']['lifetime'];\n\n\n\n\u00c8 possibile utilizzare uno dei seguenti metodi per risolvere questo problema:\n\n\n$session = Yii::$app-\nsession;\n\n// directly use $_SESSION (make sure Yii::$app-\nsession-\nopen() has been called)\n$_SESSION['captcha']['number'] = 5;\n$_SESSION['captcha']['lifetime'] = 3600;\n\n// get the whole array first, modify it and then save it back\n$captcha = $session['captcha'];\n$captcha['number'] = 5;\n$captcha['lifetime'] = 3600;\n$session['captcha'] = $captcha;\n\n// use ArrayObject instead of array\n$session['captcha'] = new \\ArrayObject;\n...\n$session['captcha']['number'] = 5;\n$session['captcha']['lifetime'] = 3600;\n\n// store array data by keys with a common prefix\n$session['captcha.number'] = 5;\n$session['captcha.lifetime'] = 3600;\n\n\n\nPer migliorare le prestazioni e la leggibilit\u00e0 del codice, consigliamo l'ultima soluzione. Cio\u00e8, invece di memorizzare una matrice come una singola variabile di sessione, si memorizza ogni elemento dell'array come una variabile di sessione che condivide lo stesso prefisso chiave con altri elementi dell'array.\n\n\nArchiviazione personalizzata di una sessione\n\n\nLa classe predefinita \nyii \\ web \\ Session\n memorizza i dati di sessione come file sul server. Yii fornisce inoltre le seguenti classi di sessione che implementano diverse sessioni di archiviazione:\n\n\n\n\nyii \\ web \\ DbSession\n: memorizza i dati di sessione in una tabella di database.\n\n\nyii \\ web \\ CacheSession\n: memorizza i dati della sessione in una cache con l'aiuto di un componente configurato della cache.\n\n\nyii \\ redis \\ Session\n: memorizza i dati della sessione usando \nredis\n come supporto di memorizzazione.\n\n\nyii \\ mongodb \\ Session\n: memorizza i dati della sessione in un MongoDB.\n\n\n\n\nTutte queste classi di sessione supportano lo stesso insieme di metodi API. Di conseguenza, \u00e8 possibile passare a una classe di archiviazione di sessione diversa senza la necessit\u00e0 di modificare il codice dell'applicazione che utilizza le sessioni.\n\n\n\n\nWarning\n\n\nSe si desidera accedere ai dati della sessione \n$_SESSION\n durante l'utilizzo della memorizzazione della sessione personalizzata, \u00e8 necessario assicurarsi che la sessione sia gi\u00e0 stata avviata da \nyii \\ web \\ Session :: open()\n. Questo perch\u00e9 i gestori di archiviazione di sessione personalizzati sono registrati all'interno di questo metodo.\n\n\n\n\nPer informazioni su come configurare e utilizzare queste classi di componenti, fare riferimento alla relativa documentazione API. Di seguito \u00e8 riportato un esempio che mostra come configurare \nyii \\ web \\ DbSession\n nella configurazione dell'applicazione per utilizzare una tabella di database per l'archiviazione di sessione:\n\n\nreturn [\n    'components' =\n [\n        'session' =\n [\n            'class' =\n 'yii\\web\\DbSession',\n            // 'db' =\n 'mydb',  // the application component ID of the DB connection. Defaults to 'db'.\n            // 'sessionTable' =\n 'my_session', // session table name. Defaults to 'session'.\n        ],\n    ],\n];\n\n\n\n\u00c8 inoltre necessario creare la seguente tabella del database per memorizzare i dati della sessione:\n\n\nCREATE TABLE session\n(\n    id CHAR(40) NOT NULL PRIMARY KEY,\n    expire INTEGER,\n    data BLOB\n)\n\n\n\ndove 'BLOB' si riferisce al tipo BLOB del tuo DBMS preferito. Di seguito sono riportati i tipi di BLOB che possono essere utilizzati per alcuni DBMS popolari:\n\n\n\n\nMySQL: LONGBLOB\n\n\nPostgreSQL: BYTEA\n\n\nMSSQL: BLOB\n\n\n\n\n\n\nWarning\n\n\nIn base all'impostazione \nphp.ini\n di \nsession.hash_function\n, potrebbe essere necessario regolare la lunghezza della colonna \nid\n. Ad esempio, se \nsession.hash_function=sha256\n, dovresti usare una lunghezza 64 invece di 40.\n\n\n\n\nIn alternativa, questo pu\u00f2 essere realizzato con la seguente migrazione:\n\n\n?php\n\nuse yii\\db\\Migration;\n\nclass m170529_050554_create_table_session extends Migration{\n\n    public function up(){\n\n        $this-\ncreateTable('{{%session}}', [\n            'id' =\n $this-\nchar(64)-\nnotNull(),\n            'expire' =\n $this-\ninteger(),\n            'data' =\n $this-\nbinary()\n        ]);\n        $this-\naddPrimaryKey('pk-id', '{{%session}}', 'id');\n    }\n\n    public function down(){\n\n        $this-\ndropTable('{{%session}}');\n\n    }\n}\n\n\n\nDati flash\n\n\nI dati Flash sono un tipo speciale di dati di sessione che, una volta impostati in una richiesta, saranno disponibili solo durante la richiesta successiva e verranno automaticamente eliminati in seguito. I dati flash vengono comunemente utilizzati per implementare i messaggi che devono essere visualizzati una sola volta agli utenti finali, ad esempio un messaggio di conferma visualizzato dopo che un utente ha inviato correttamente un modulo.\n\n\n\u00c8 possibile impostare e accedere ai dati flash tramite il componente \nsession\n dell'applicazione. Per esempio,\n\n\n$session = Yii::$app-\nsession;\n\n// Request #1\n// set a flash message named as \"postDeleted\"\n$session-\nsetFlash('postDeleted', 'You have successfully deleted your post.');\n\n// Request #2\n// display the flash message named \"postDeleted\"\necho $session-\ngetFlash('postDeleted');\n\n// Request #3\n// $result will be false since the flash message was automatically deleted\n$result = $session-\nhasFlash('postDeleted');\n\n\n\nCome i normali dati di sessione, \u00e8 possibile memorizzare dati arbitrari come dati flash.\n\n\nQuando chiami \nyii \\ web \\ Session :: setFlash()\n, sovrascriver\u00e0 tutti i dati flash esistenti che hanno lo stesso nome. Per aggiungere nuovi dati flash a un messaggio esistente con lo stesso nome, \u00e8 possibile chiamare \nyii \\ web \\ Session :: addFlash()\n. Per esempio:\n\n\n$session = Yii::$app-\nsession;\n\n// Request #1\n// add a few flash messages under the name of \"alerts\"\n$session-\naddFlash('alerts', 'You have successfully deleted your post.');\n$session-\naddFlash('alerts', 'You have successfully added a new friend.');\n$session-\naddFlash('alerts', 'You are promoted.');\n\n// Request #2\n// $alerts is an array of the flash messages under the name of \"alerts\"\n$alerts = $session-\ngetFlash('alerts');\n\n\n\n\n\nWarning\n\n\nCerca di non utilizzare \nyii \\ web \\ Session :: setFlash ()\n insieme a \nyii \\ web \\ Session :: addFlash ()\n per i dati flash con lo stesso nome. Questo perch\u00e9 il secondo metodo trasformer\u00e0 automaticamente i dati flash in una matrice in modo che possa aggiungere nuovi dati flash con lo stesso nome. Di conseguenza, quando chiami \nyii \\ web \\ Session :: getFlash ()\n, potresti trovare a volte una matrice mentre a volte ottieni una stringa, a seconda dell'ordine di invocazione di questi due metodi.\n\n\n\n\n\n\nTip\n\n\nPer la visualizzazione dei messaggi Flash \u00e8 possibile utilizzare il widget \nAlert\n di avvio nel seguente modo:\n\n\necho Alert::widget([\n    'options' =\n ['class' =\n 'alert-info'],\n    'body' =\n Yii::$app-\nsession-\ngetFlash('postDeleted'),\n]);\n\n\n\n\n\nCookies\n\n\nYii rappresenta ciascun cookie come oggetto di \nyii \\ web \\ Cookie\n. Sia \nyii \\ web \\ Request\n che \nyii \\ web \\ Response\n gestiscono una raccolta di cookie tramite la propriet\u00e0 denominata cookies. La raccolta di cookie nel primo, rappresenta i cookie inviati in una richiesta,mentre la raccolta di cookie in quest'ultimo, rappresenta i cookie che devono essere inviati all'utente.\n\n\nLa parte dell'applicazione che riguarda direttamente la richiesta e la risposta \u00e8 il controller. Pertanto, i cookie devono essere letti e inviati nel controller.\n\n\nLettura dei cookie\n\n\n\u00c8 possibile ottenere i cookie nella richiesta corrente utilizzando il seguente codice:\n\n\n// get the cookie collection (yii\\web\\CookieCollection) from the \"request\" component\n$cookies = Yii::$app-\nrequest-\ncookies;\n\n// get the \"language\" cookie value. If the cookie does not exist, return \"en\" as the default value.\n$language = $cookies-\ngetValue('language', 'en');\n\n// an alternative way of getting the \"language\" cookie value\nif (($cookie = $cookies-\nget('language')) !== null) {\n    $language = $cookie-\nvalue;\n}\n\n// you may also use $cookies like an array\nif (isset($cookies['language'])) {\n    $language = $cookies['language']-\nvalue;\n}\n\n// check if there is a \"language\" cookie\nif ($cookies-\nhas('language')) ...\nif (isset($cookies['language'])) ...\n\n\n\nInvio dei cookies\n\n\nPuoi inviare cookie agli utenti finali utilizzando il seguente codice:\n\n\n// get the cookie collection (yii\\web\\CookieCollection) from the \"response\" component\n$cookies = Yii::$app-\nresponse-\ncookies;\n\n// add a new cookie to the response to be sent\n$cookies-\nadd(new \\yii\\web\\Cookie([\n    'name' =\n 'language',\n    'value' =\n 'zh-CN',\n]));\n\n// remove a cookie\n$cookies-\nremove('language');\n// equivalent to the following\nunset($cookies['language']);\n\n\n\nOltre al nome, alle propriet\u00e0 del valore mostrate negli esempi precedenti, la classe \nyii \\ web \\ Cookie\n definisce anche altre propriet\u00e0 per rappresentare completamente tutte le informazioni sui cookie disponibili, come il dominio, la scadenza, ecc.. \u00c8 possibile configurare queste propriet\u00e0 come necessario per preparare un cookie e quindi aggiungerlo alla raccolta di cookie della risposta.\n\n\nConvalida dei cookier\n\n\nDurante la lettura e l'invio di cookie tramite i componenti \nrequest\n e \nresponse\n come mostrato nelle ultime due sottosezioni, si gode della maggiore sicurezza della convalida dei cookie che protegge i cookie dalla modifica sul lato client. Ci\u00f2 si ottiene firmando ogni cookie con una stringa \nhash\n, che consente all'applicazione di stabilire se un cookie \u00e8 stato modificato sul lato client. In tal caso, il cookie NON sar\u00e0 accessibile tramite i cookie \nyii \\ web \\ Request ::\n del componente \nrequest\n.\n\n\n\n\nWarning\n\n\nLa convalida dei cookie protegge solo i valori dei cookie dalla modifica. Se un cookie non supera la convalida, puoi comunque accedervi \n$_COOKIE\n. Ci\u00f2 \u00e8 dovuto al fatto che le librerie di terze parti possono manipolare i cookie a modo loro, il che non implica la convalida dei cookie.\n\n\n\n\nLa convalida dei cookie \u00e8 abilitata per impostazione predefinita. \u00c8 possibile disabilitarlo impostando la propriet\u00e0 \nYii \\ web \\ Request :: $ enableCookieValidation\n  di essere \nfalse\n, anche se si consiglia vivamente di non farlo.\n\n\n\n\nWarning\n\n\nI cookie che vengono letti direttamente / inviati tramite \n$_COOKIE\n e \nsetcookie()\n NON saranno convalidati.\n\n\n\n\nQuando si utilizza la convalida dei cookie, \u00e8 necessario specificare un \nyii \\ web \\ Request :: $ cookieValidationKey\n che verr\u00e0 utilizzato per generare le stringhe \nhash\n summenzionate. \u00c8 possibile farlo configurando il componente \nrequest\n nella configurazione dell'applicazione:\n\n\nreturn [\n    'components' =\n [\n        'request' =\n [\n            'cookieValidationKey' =\n 'fill in a secret key here',\n        ],\n    ],\n];\n\n\n\n\n\nInfo\n\n\ncookieValidationKey\n \u00e8 fondamentale per la sicurezza dell'applicazione. Dovrebbe essere noto solo alle persone di cui ti fidi. Non memorizzarlo nel sistema di controllo della versione.",
            "title": "Session & Cookies"
        },
        {
            "location": "/handling-requests/sub-session-cookies/#session-e-cookies",
            "text": "Le sessioni e i cookie consentono di mantenere i dati su pi\u00f9 richieste degli utenti. In semplice PHP \u00e8 possibile accedervi tramite le variabili globali  $_SESSION  e  $_COOKIE . Yii incapsula sessioni e cookie come oggetti e quindi ti consente di accedervi in \u200b\u200bmodo orientato agli oggetti con ulteriori utili miglioramenti.",
            "title": "Session e Cookies"
        },
        {
            "location": "/handling-requests/sub-session-cookies/#sessioni",
            "text": "Come le request e le responses , \u00e8 possibile accedere alle sessioni tramite il componente  session  dell'applicazione, che \u00e8 un'istanza di  yii \\ web \\ Session , per impostazione predefinita.",
            "title": "Sessioni"
        },
        {
            "location": "/handling-requests/sub-session-cookies/#apertura-e-chiusura-delle-sessioni",
            "text": "Per aprire e chiudere una sessione, puoi fare quanto segue:  $session = Yii::$app- session;\n\n// check if a session is already open\nif ($session- isActive) ...\n\n// open a session\n$session- open();\n\n// close a session\n$session- close();\n\n// destroys all data registered to a session.\n$session- destroy();  Puoi chiamare  open()  e  close()  pi\u00f9 volte,senza causare errori; internamente i metodi controlleranno prima se la sessione \u00e8 gi\u00e0 aperta.",
            "title": "Apertura e chiusura delle sessioni"
        },
        {
            "location": "/handling-requests/sub-session-cookies/#accesso-ai-dati-della-sessione",
            "text": "Per accedere ai dati memorizzati nella sessione, \u00e8 possibile effettuare le seguenti operazioni:  $session = Yii::$app- session;\n\n// get a session variable. The following usages are equivalent:\n$language = $session- get('language');\n$language = $session['language'];\n$language = isset($_SESSION['language']) ? $_SESSION['language'] : null;\n\n// set a session variable. The following usages are equivalent:\n$session- set('language', 'en-US');\n$session['language'] = 'en-US';\n$_SESSION['language'] = 'en-US';\n\n// remove a session variable. The following usages are equivalent:\n$session- remove('language');\nunset($session['language']);\nunset($_SESSION['language']);\n\n// check if a session variable exists. The following usages are equivalent:\nif ($session- has('language')) ...\nif (isset($session['language'])) ...\nif (isset($_SESSION['language'])) ...\n\n// traverse all session variables. The following usages are equivalent:\nforeach ($session as $name =  $value) ...\nforeach ($_SESSION as $name =  $value) ...   Info  Quando si accede ai dati della sessione attraverso il componente  session , una sessione verr\u00e0 aperta automaticamente se non \u00e8 stata eseguita in precedenza. Questo \u00e8 diverso dall'accedere ai dati della sessione attraverso  $_SESSION , che richiede un esplicito richiamo di  session_start() .   Quando si lavora con dati di sessione che sono matrici, il componente  session  presenta una limitazione che impedisce di modificare direttamente un elemento dell'array. Per esempio,  $session = Yii::$app- session;\n\n// the following code will NOT work\n$session['captcha']['number'] = 5;\n$session['captcha']['lifetime'] = 3600;\n\n// the following code works:\n$session['captcha'] = [\n    'number' =  5,\n    'lifetime' =  3600,\n];\n\n// the following code also works:\necho $session['captcha']['lifetime'];  \u00c8 possibile utilizzare uno dei seguenti metodi per risolvere questo problema:  $session = Yii::$app- session;\n\n// directly use $_SESSION (make sure Yii::$app- session- open() has been called)\n$_SESSION['captcha']['number'] = 5;\n$_SESSION['captcha']['lifetime'] = 3600;\n\n// get the whole array first, modify it and then save it back\n$captcha = $session['captcha'];\n$captcha['number'] = 5;\n$captcha['lifetime'] = 3600;\n$session['captcha'] = $captcha;\n\n// use ArrayObject instead of array\n$session['captcha'] = new \\ArrayObject;\n...\n$session['captcha']['number'] = 5;\n$session['captcha']['lifetime'] = 3600;\n\n// store array data by keys with a common prefix\n$session['captcha.number'] = 5;\n$session['captcha.lifetime'] = 3600;  Per migliorare le prestazioni e la leggibilit\u00e0 del codice, consigliamo l'ultima soluzione. Cio\u00e8, invece di memorizzare una matrice come una singola variabile di sessione, si memorizza ogni elemento dell'array come una variabile di sessione che condivide lo stesso prefisso chiave con altri elementi dell'array.",
            "title": "Accesso ai dati della sessione"
        },
        {
            "location": "/handling-requests/sub-session-cookies/#archiviazione-personalizzata-di-una-sessione",
            "text": "La classe predefinita  yii \\ web \\ Session  memorizza i dati di sessione come file sul server. Yii fornisce inoltre le seguenti classi di sessione che implementano diverse sessioni di archiviazione:   yii \\ web \\ DbSession : memorizza i dati di sessione in una tabella di database.  yii \\ web \\ CacheSession : memorizza i dati della sessione in una cache con l'aiuto di un componente configurato della cache.  yii \\ redis \\ Session : memorizza i dati della sessione usando  redis  come supporto di memorizzazione.  yii \\ mongodb \\ Session : memorizza i dati della sessione in un MongoDB.   Tutte queste classi di sessione supportano lo stesso insieme di metodi API. Di conseguenza, \u00e8 possibile passare a una classe di archiviazione di sessione diversa senza la necessit\u00e0 di modificare il codice dell'applicazione che utilizza le sessioni.   Warning  Se si desidera accedere ai dati della sessione  $_SESSION  durante l'utilizzo della memorizzazione della sessione personalizzata, \u00e8 necessario assicurarsi che la sessione sia gi\u00e0 stata avviata da  yii \\ web \\ Session :: open() . Questo perch\u00e9 i gestori di archiviazione di sessione personalizzati sono registrati all'interno di questo metodo.   Per informazioni su come configurare e utilizzare queste classi di componenti, fare riferimento alla relativa documentazione API. Di seguito \u00e8 riportato un esempio che mostra come configurare  yii \\ web \\ DbSession  nella configurazione dell'applicazione per utilizzare una tabella di database per l'archiviazione di sessione:  return [\n    'components' =  [\n        'session' =  [\n            'class' =  'yii\\web\\DbSession',\n            // 'db' =  'mydb',  // the application component ID of the DB connection. Defaults to 'db'.\n            // 'sessionTable' =  'my_session', // session table name. Defaults to 'session'.\n        ],\n    ],\n];  \u00c8 inoltre necessario creare la seguente tabella del database per memorizzare i dati della sessione:  CREATE TABLE session\n(\n    id CHAR(40) NOT NULL PRIMARY KEY,\n    expire INTEGER,\n    data BLOB\n)  dove 'BLOB' si riferisce al tipo BLOB del tuo DBMS preferito. Di seguito sono riportati i tipi di BLOB che possono essere utilizzati per alcuni DBMS popolari:   MySQL: LONGBLOB  PostgreSQL: BYTEA  MSSQL: BLOB    Warning  In base all'impostazione  php.ini  di  session.hash_function , potrebbe essere necessario regolare la lunghezza della colonna  id . Ad esempio, se  session.hash_function=sha256 , dovresti usare una lunghezza 64 invece di 40.   In alternativa, questo pu\u00f2 essere realizzato con la seguente migrazione:  ?php\n\nuse yii\\db\\Migration;\n\nclass m170529_050554_create_table_session extends Migration{\n\n    public function up(){\n\n        $this- createTable('{{%session}}', [\n            'id' =  $this- char(64)- notNull(),\n            'expire' =  $this- integer(),\n            'data' =  $this- binary()\n        ]);\n        $this- addPrimaryKey('pk-id', '{{%session}}', 'id');\n    }\n\n    public function down(){\n\n        $this- dropTable('{{%session}}');\n\n    }\n}",
            "title": "Archiviazione personalizzata di una sessione"
        },
        {
            "location": "/handling-requests/sub-session-cookies/#dati-flash",
            "text": "I dati Flash sono un tipo speciale di dati di sessione che, una volta impostati in una richiesta, saranno disponibili solo durante la richiesta successiva e verranno automaticamente eliminati in seguito. I dati flash vengono comunemente utilizzati per implementare i messaggi che devono essere visualizzati una sola volta agli utenti finali, ad esempio un messaggio di conferma visualizzato dopo che un utente ha inviato correttamente un modulo.  \u00c8 possibile impostare e accedere ai dati flash tramite il componente  session  dell'applicazione. Per esempio,  $session = Yii::$app- session;\n\n// Request #1\n// set a flash message named as \"postDeleted\"\n$session- setFlash('postDeleted', 'You have successfully deleted your post.');\n\n// Request #2\n// display the flash message named \"postDeleted\"\necho $session- getFlash('postDeleted');\n\n// Request #3\n// $result will be false since the flash message was automatically deleted\n$result = $session- hasFlash('postDeleted');  Come i normali dati di sessione, \u00e8 possibile memorizzare dati arbitrari come dati flash.  Quando chiami  yii \\ web \\ Session :: setFlash() , sovrascriver\u00e0 tutti i dati flash esistenti che hanno lo stesso nome. Per aggiungere nuovi dati flash a un messaggio esistente con lo stesso nome, \u00e8 possibile chiamare  yii \\ web \\ Session :: addFlash() . Per esempio:  $session = Yii::$app- session;\n\n// Request #1\n// add a few flash messages under the name of \"alerts\"\n$session- addFlash('alerts', 'You have successfully deleted your post.');\n$session- addFlash('alerts', 'You have successfully added a new friend.');\n$session- addFlash('alerts', 'You are promoted.');\n\n// Request #2\n// $alerts is an array of the flash messages under the name of \"alerts\"\n$alerts = $session- getFlash('alerts');   Warning  Cerca di non utilizzare  yii \\ web \\ Session :: setFlash ()  insieme a  yii \\ web \\ Session :: addFlash ()  per i dati flash con lo stesso nome. Questo perch\u00e9 il secondo metodo trasformer\u00e0 automaticamente i dati flash in una matrice in modo che possa aggiungere nuovi dati flash con lo stesso nome. Di conseguenza, quando chiami  yii \\ web \\ Session :: getFlash () , potresti trovare a volte una matrice mentre a volte ottieni una stringa, a seconda dell'ordine di invocazione di questi due metodi.    Tip  Per la visualizzazione dei messaggi Flash \u00e8 possibile utilizzare il widget  Alert  di avvio nel seguente modo:  echo Alert::widget([\n    'options' =  ['class' =  'alert-info'],\n    'body' =  Yii::$app- session- getFlash('postDeleted'),\n]);",
            "title": "Dati flash"
        },
        {
            "location": "/handling-requests/sub-session-cookies/#cookies",
            "text": "Yii rappresenta ciascun cookie come oggetto di  yii \\ web \\ Cookie . Sia  yii \\ web \\ Request  che  yii \\ web \\ Response  gestiscono una raccolta di cookie tramite la propriet\u00e0 denominata cookies. La raccolta di cookie nel primo, rappresenta i cookie inviati in una richiesta,mentre la raccolta di cookie in quest'ultimo, rappresenta i cookie che devono essere inviati all'utente.  La parte dell'applicazione che riguarda direttamente la richiesta e la risposta \u00e8 il controller. Pertanto, i cookie devono essere letti e inviati nel controller.",
            "title": "Cookies"
        },
        {
            "location": "/handling-requests/sub-session-cookies/#lettura-dei-cookie",
            "text": "\u00c8 possibile ottenere i cookie nella richiesta corrente utilizzando il seguente codice:  // get the cookie collection (yii\\web\\CookieCollection) from the \"request\" component\n$cookies = Yii::$app- request- cookies;\n\n// get the \"language\" cookie value. If the cookie does not exist, return \"en\" as the default value.\n$language = $cookies- getValue('language', 'en');\n\n// an alternative way of getting the \"language\" cookie value\nif (($cookie = $cookies- get('language')) !== null) {\n    $language = $cookie- value;\n}\n\n// you may also use $cookies like an array\nif (isset($cookies['language'])) {\n    $language = $cookies['language']- value;\n}\n\n// check if there is a \"language\" cookie\nif ($cookies- has('language')) ...\nif (isset($cookies['language'])) ...",
            "title": "Lettura dei cookie"
        },
        {
            "location": "/handling-requests/sub-session-cookies/#invio-dei-cookies",
            "text": "Puoi inviare cookie agli utenti finali utilizzando il seguente codice:  // get the cookie collection (yii\\web\\CookieCollection) from the \"response\" component\n$cookies = Yii::$app- response- cookies;\n\n// add a new cookie to the response to be sent\n$cookies- add(new \\yii\\web\\Cookie([\n    'name' =  'language',\n    'value' =  'zh-CN',\n]));\n\n// remove a cookie\n$cookies- remove('language');\n// equivalent to the following\nunset($cookies['language']);  Oltre al nome, alle propriet\u00e0 del valore mostrate negli esempi precedenti, la classe  yii \\ web \\ Cookie  definisce anche altre propriet\u00e0 per rappresentare completamente tutte le informazioni sui cookie disponibili, come il dominio, la scadenza, ecc.. \u00c8 possibile configurare queste propriet\u00e0 come necessario per preparare un cookie e quindi aggiungerlo alla raccolta di cookie della risposta.",
            "title": "Invio dei cookies"
        },
        {
            "location": "/handling-requests/sub-session-cookies/#convalida-dei-cookier",
            "text": "Durante la lettura e l'invio di cookie tramite i componenti  request  e  response  come mostrato nelle ultime due sottosezioni, si gode della maggiore sicurezza della convalida dei cookie che protegge i cookie dalla modifica sul lato client. Ci\u00f2 si ottiene firmando ogni cookie con una stringa  hash , che consente all'applicazione di stabilire se un cookie \u00e8 stato modificato sul lato client. In tal caso, il cookie NON sar\u00e0 accessibile tramite i cookie  yii \\ web \\ Request ::  del componente  request .   Warning  La convalida dei cookie protegge solo i valori dei cookie dalla modifica. Se un cookie non supera la convalida, puoi comunque accedervi  $_COOKIE . Ci\u00f2 \u00e8 dovuto al fatto che le librerie di terze parti possono manipolare i cookie a modo loro, il che non implica la convalida dei cookie.   La convalida dei cookie \u00e8 abilitata per impostazione predefinita. \u00c8 possibile disabilitarlo impostando la propriet\u00e0  Yii \\ web \\ Request :: $ enableCookieValidation   di essere  false , anche se si consiglia vivamente di non farlo.   Warning  I cookie che vengono letti direttamente / inviati tramite  $_COOKIE  e  setcookie()  NON saranno convalidati.   Quando si utilizza la convalida dei cookie, \u00e8 necessario specificare un  yii \\ web \\ Request :: $ cookieValidationKey  che verr\u00e0 utilizzato per generare le stringhe  hash  summenzionate. \u00c8 possibile farlo configurando il componente  request  nella configurazione dell'applicazione:  return [\n    'components' =  [\n        'request' =  [\n            'cookieValidationKey' =  'fill in a secret key here',\n        ],\n    ],\n];   Info  cookieValidationKey  \u00e8 fondamentale per la sicurezza dell'applicazione. Dovrebbe essere noto solo alle persone di cui ti fidi. Non memorizzarlo nel sistema di controllo della versione.",
            "title": "Convalida dei cookier"
        },
        {
            "location": "/handling-requests/sub-handling-error/",
            "text": "Gestione degli errori\n\n\nYii include un gestore di errori incorporato che rende la gestione degli errori un'esperienza molto pi\u00f9 piacevole di prima. In particolare, il gestore degli errori Yii effettua le seguenti operazioni per migliorare la gestione degli errori:\n\n\n\n\nTutti gli errori PHP non fatali (ad es. avvertimenti, notifiche) vengono convertiti in eccezioni \nCatchable\n.\n\n\nEccezioni e errori fatali di PHP vengono visualizzati con informazioni dettagliate sullo stack di chiamata e linee di codice sorgente in modalit\u00e0 di debug.\n\n\nSupporta l'utilizzo di un'azione del controller dedicata per visualizzare gli errori.\n\n\nSupporta diversi formati di risposta agli errori.\n\n\n\n\nIl gestore degli errori \u00e8 abilitato per impostazione predefinita. Si pu\u00f2 disabilitarlo definendo la costante \nYII_ENABLE_ERROR_HANDLER\n di essere \nfalse\n nell'entry script della vostra applicazione.\n\n\nUtilizziamo l'Error Handle\n\n\nIl gestore degli errori \u00e8 registrato come un componente dell'applicazione denominato \nerrorHandler\n. Puoi configurarlo nella configurazione dell'applicazione come segue:\n\n\nreturn [\n    'components' =\n [\n        'errorHandler' =\n [\n            'maxSourceLines' =\n 20,\n        ],\n    ],\n];\n\n\n\nCon la configurazione di cui sopra indicata, il numero di linee di codice sorgente da visualizzare nelle pagine delle eccezioni sar\u00e0 fino a 20.\n\n\nCome gi\u00e0 detto, il gestore degli errori trasforma tutti gli errori PHP non fatali in eccezioni \nCatchable\n. Ci\u00f2 significa che \u00e8 possibile utilizzare il seguente codice per gestire gli errori PHP:\n\n\nuse Yii;\nuse yii\\base\\ErrorException;\n\ntry {\n    10/0;\n} catch (ErrorException $e) {\n    Yii::warning(\"Division by zero.\");\n}\n\n// execution continues...\n\n\n\nSe vuoi mostrare una pagina di errore che informa l'utente che la sua richiesta non \u00e8 valida o inaspettata, puoi semplicemente lanciare un'eccezione HTTP , come \nyii \\ web \\ NotFoundHttpException\n. Il gestore degli errori imposter\u00e0 correttamente il codice di stato HTTP della risposta e utilizzer\u00e0 una vista di errore appropriata per visualizzare il messaggio di errore.\n\n\nuse yii\\web\\NotFoundHttpException;\n\nthrow new NotFoundHttpException();\n\n\n\nPersonalizzazione della visualizzazione degli errori\n\n\nIl gestore degli errori regola la visualizzazione degli errori in base al valore della costante \nYII_DEBUG\n. Quando \nYII_DEBUG\n \u00e8 a \ntrue\n(ovvero in modalit\u00e0 di debug), il gestore degli errori visualizza eccezioni con informazioni dettagliate sullo stack delle chiamate e linee del codice sorgente per facilitare il debugging. E quando \nYII_DEBUG\n \u00e8 a \nfalse\n, verr\u00e0 visualizzato solo il messaggio di errore per evitare di rivelare informazioni sensibili sull'applicazione.\n\n\n\n\nInfo\n\n\nSe un'eccezione \u00e8 discendente da \nyii \\ base \\ UserException\n, non verr\u00e0 visualizzato alcuno stack di chiamate indipendentemente dal valore di \nYII_DEBUG\n. Questo perch\u00e9 tali eccezioni sono considerate causate da errori dell'utente e gli sviluppatori non hanno bisogno di aggiustare nulla.\n\n\n\n\nPer impostazione predefinita, il gestore errori visualizza gli errori utilizzando due viste :\n\n\n\n\n@yii/views/errorHandler/error.php\n: usato quando devono essere visualizzati gli errori SENZA informazioni sullo stack di chiamata. Quando \nYII_DEBUG\n \u00e8 a \nfalse\n, questa \u00e8 l'unica visualizzazione di errore da visualizzare.\n\n\n@yii/views/errorHandler/exception.php\n: usato quando devono essere visualizzati gli errori CON le informazioni sullo stack delle chiamate.\n\n\n\n\n\u00c8 possibile configurare le propriet\u00e0 \nerrorView`` e\nexceptionView` del gestore degli errori per utilizzare le proprie visualizzazioni per personalizzare la visualizzazione degli errori.\n\n\nUtilizzo delle azioni di errori\n\n\nUn modo migliore per personalizzare la visualizzazione degli errori consiste nell'utilizzare azioni di errore dedicati. Per fare ci\u00f2, dobbiamo configurare innanzitutto la propriet\u00e0 \nerrorAction\n del componente \nerrorHandler\n come segue:\n\n\nreturn [\n    'components' =\n [\n        'errorHandler' =\n [\n            'errorAction' =\n 'site/error',\n        ],\n    ]\n];\n\n\n\nLa propriet\u00e0 \nerrorAction\n prende una rotta verso un'azione. La configurazione precedente indica che quando \u00e8 necessario visualizzare un errore senza informazioni sullo stack di chiamata, l'azione \nsite/error\n deve essere eseguita.\n\n\n\u00c8 possibile creare l'azione \nsite/error\n come segue,\n\n\nnamespace app\\controllers;\n\nuse Yii;\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public function actions(){\n\n        return [\n            'error' =\n [\n                'class' =\n 'yii\\web\\ErrorAction',\n            ],\n        ];\n    }\n}\n\n\n\nIl codice precedente definisce l'azione \nerror\n utilizzando la classe \nyii \\ web \\ ErrorAction\n che esegue il rendering di un errore utilizzando una vista denominata \nerror\n.\n\n\nOltre a usare \nyii \\ web \\ ErrorAction\n, puoi anche definire l'azione \nerror\n usando un metodo di azione come il seguente,\n\n\npublic function actionError(){\n\n    $exception = Yii::$app-\nerrorHandler-\nexception;\n    if ($exception !== null) {\n        return $this-\nrender('error', ['exception' =\n $exception]);\n    }\n}\n\n\n\nOra dovresti creare un file di visualizzazione situato in \nviews/site/error.php\n. In questo file di visualizzazione, \u00e8 possibile accedere alle seguenti variabili se l'azione di errore \u00e8 definita come \nyii \\ web \\ ErrorAction\n:\n\n\n\n\nname\n: il nome dell'errore;\n\n\nmessage\n: il messaggio di errore;\n\n\nexception\n: l'oggetto di eccezione attraverso il quale \u00e8 possibile recuperare informazioni pi\u00f9 utili, come codice di stato HTTP, codice di errore, stack di chiamate di errore, ecc.\n\n\n\n\n\n\nWarning\n\n\nSe \u00e8 necessario reindirizzare la pagina in un gestore errori, conviene farlo nel seguente modo:\n    Yii::$app-\ngetResponse()-\nredirect($url)-\nsend();\n    return;\n\n\n\n\nPersonalizzazione del formato di risposta degli errori\n\n\nIl gestore degli errori visualizza gli errori in base all'impostazione del formato della risposta. Se il formato della risposta \u00e8 html, utilizzer\u00e0 l'errore o la visualizzazione delle eccezioni per visualizzare gli errori, come descritto nell'ultima sottosezione. Per altri formati di risposta, il gestore degli errori assegner\u00e0 la rappresentazione dell'array dell'eccezione alla propriet\u00e0 dei dati \nyii \\ web \\ Response :: $\n che verr\u00e0 quindi convertita in diversi formati di conseguenza. Ad esempio, se il formato della risposta \u00e8 \njson\n, potresti vedere la seguente risposta:\n\n\nHTTP/1.1 404 Not Found\nDate: Sun, 02 Mar 2014 05:31:43 GMT\nServer: Apache/2.2.26 (Unix) DAV/2 PHP/5.4.20 mod_ssl/2.2.26 OpenSSL/0.9.8y\nTransfer-Encoding: chunked\nContent-Type: application/json; charset=UTF-8\n\n{\n    \"name\": \"Not Found Exception\",\n    \"message\": \"The requested resource was not found.\",\n    \"code\": 0,\n    \"status\": 404\n}\n\n\n\n\u00c8 possibile personalizzare il formato di risposta dell'errore rispondendo all'evento \nbeforeSend\n del componente \nresponse\n nella configurazione dell'applicazione:\n\n\nreturn [\n    // ...\n    'components' =\n [\n        'response' =\n [\n            'class' =\n 'yii\\web\\Response',\n            'on beforeSend' =\n function ($event) {\n                $response = $event-\nsender;\n                if ($response-\ndata !== null) {\n                    $response-\ndata = [\n                        'success' =\n $response-\nisSuccessful,\n                        'data' =\n $response-\ndata,\n                    ];\n                    $response-\nstatusCode = 200;\n                }\n            },\n        ],\n    ],\n];\n\n\n\nIl codice sopra indicato riformatter\u00e0 la risposta all'errore come la seguente:\n\n\nHTTP/1.1 200 OK\nDate: Sun, 02 Mar 2014 05:31:43 GMT\nServer: Apache/2.2.26 (Unix) DAV/2 PHP/5.4.20 mod_ssl/2.2.26 OpenSSL/0.9.8y\nTransfer-Encoding: chunked\nContent-Type: application/json; charset=UTF-8\n\n{\n    \"success\": false,\n    \"data\": {\n        \"name\": \"Not Found Exception\",\n        \"message\": \"The requested resource was not found.\",\n        \"code\": 0,\n        \"status\": 404\n    }\n}",
            "title": "Gestione degli errori"
        },
        {
            "location": "/handling-requests/sub-handling-error/#gestione-degli-errori",
            "text": "Yii include un gestore di errori incorporato che rende la gestione degli errori un'esperienza molto pi\u00f9 piacevole di prima. In particolare, il gestore degli errori Yii effettua le seguenti operazioni per migliorare la gestione degli errori:   Tutti gli errori PHP non fatali (ad es. avvertimenti, notifiche) vengono convertiti in eccezioni  Catchable .  Eccezioni e errori fatali di PHP vengono visualizzati con informazioni dettagliate sullo stack di chiamata e linee di codice sorgente in modalit\u00e0 di debug.  Supporta l'utilizzo di un'azione del controller dedicata per visualizzare gli errori.  Supporta diversi formati di risposta agli errori.   Il gestore degli errori \u00e8 abilitato per impostazione predefinita. Si pu\u00f2 disabilitarlo definendo la costante  YII_ENABLE_ERROR_HANDLER  di essere  false  nell'entry script della vostra applicazione.",
            "title": "Gestione degli errori"
        },
        {
            "location": "/handling-requests/sub-handling-error/#utilizziamo-lerror-handle",
            "text": "Il gestore degli errori \u00e8 registrato come un componente dell'applicazione denominato  errorHandler . Puoi configurarlo nella configurazione dell'applicazione come segue:  return [\n    'components' =  [\n        'errorHandler' =  [\n            'maxSourceLines' =  20,\n        ],\n    ],\n];  Con la configurazione di cui sopra indicata, il numero di linee di codice sorgente da visualizzare nelle pagine delle eccezioni sar\u00e0 fino a 20.  Come gi\u00e0 detto, il gestore degli errori trasforma tutti gli errori PHP non fatali in eccezioni  Catchable . Ci\u00f2 significa che \u00e8 possibile utilizzare il seguente codice per gestire gli errori PHP:  use Yii;\nuse yii\\base\\ErrorException;\n\ntry {\n    10/0;\n} catch (ErrorException $e) {\n    Yii::warning(\"Division by zero.\");\n}\n\n// execution continues...  Se vuoi mostrare una pagina di errore che informa l'utente che la sua richiesta non \u00e8 valida o inaspettata, puoi semplicemente lanciare un'eccezione HTTP , come  yii \\ web \\ NotFoundHttpException . Il gestore degli errori imposter\u00e0 correttamente il codice di stato HTTP della risposta e utilizzer\u00e0 una vista di errore appropriata per visualizzare il messaggio di errore.  use yii\\web\\NotFoundHttpException;\n\nthrow new NotFoundHttpException();",
            "title": "Utilizziamo l'Error Handle"
        },
        {
            "location": "/handling-requests/sub-handling-error/#personalizzazione-della-visualizzazione-degli-errori",
            "text": "Il gestore degli errori regola la visualizzazione degli errori in base al valore della costante  YII_DEBUG . Quando  YII_DEBUG  \u00e8 a  true (ovvero in modalit\u00e0 di debug), il gestore degli errori visualizza eccezioni con informazioni dettagliate sullo stack delle chiamate e linee del codice sorgente per facilitare il debugging. E quando  YII_DEBUG  \u00e8 a  false , verr\u00e0 visualizzato solo il messaggio di errore per evitare di rivelare informazioni sensibili sull'applicazione.   Info  Se un'eccezione \u00e8 discendente da  yii \\ base \\ UserException , non verr\u00e0 visualizzato alcuno stack di chiamate indipendentemente dal valore di  YII_DEBUG . Questo perch\u00e9 tali eccezioni sono considerate causate da errori dell'utente e gli sviluppatori non hanno bisogno di aggiustare nulla.   Per impostazione predefinita, il gestore errori visualizza gli errori utilizzando due viste :   @yii/views/errorHandler/error.php : usato quando devono essere visualizzati gli errori SENZA informazioni sullo stack di chiamata. Quando  YII_DEBUG  \u00e8 a  false , questa \u00e8 l'unica visualizzazione di errore da visualizzare.  @yii/views/errorHandler/exception.php : usato quando devono essere visualizzati gli errori CON le informazioni sullo stack delle chiamate.   \u00c8 possibile configurare le propriet\u00e0  errorView`` e exceptionView` del gestore degli errori per utilizzare le proprie visualizzazioni per personalizzare la visualizzazione degli errori.",
            "title": "Personalizzazione della visualizzazione degli errori"
        },
        {
            "location": "/handling-requests/sub-handling-error/#utilizzo-delle-azioni-di-errori",
            "text": "Un modo migliore per personalizzare la visualizzazione degli errori consiste nell'utilizzare azioni di errore dedicati. Per fare ci\u00f2, dobbiamo configurare innanzitutto la propriet\u00e0  errorAction  del componente  errorHandler  come segue:  return [\n    'components' =  [\n        'errorHandler' =  [\n            'errorAction' =  'site/error',\n        ],\n    ]\n];  La propriet\u00e0  errorAction  prende una rotta verso un'azione. La configurazione precedente indica che quando \u00e8 necessario visualizzare un errore senza informazioni sullo stack di chiamata, l'azione  site/error  deve essere eseguita.  \u00c8 possibile creare l'azione  site/error  come segue,  namespace app\\controllers;\n\nuse Yii;\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public function actions(){\n\n        return [\n            'error' =  [\n                'class' =  'yii\\web\\ErrorAction',\n            ],\n        ];\n    }\n}  Il codice precedente definisce l'azione  error  utilizzando la classe  yii \\ web \\ ErrorAction  che esegue il rendering di un errore utilizzando una vista denominata  error .  Oltre a usare  yii \\ web \\ ErrorAction , puoi anche definire l'azione  error  usando un metodo di azione come il seguente,  public function actionError(){\n\n    $exception = Yii::$app- errorHandler- exception;\n    if ($exception !== null) {\n        return $this- render('error', ['exception' =  $exception]);\n    }\n}  Ora dovresti creare un file di visualizzazione situato in  views/site/error.php . In questo file di visualizzazione, \u00e8 possibile accedere alle seguenti variabili se l'azione di errore \u00e8 definita come  yii \\ web \\ ErrorAction :   name : il nome dell'errore;  message : il messaggio di errore;  exception : l'oggetto di eccezione attraverso il quale \u00e8 possibile recuperare informazioni pi\u00f9 utili, come codice di stato HTTP, codice di errore, stack di chiamate di errore, ecc.    Warning  Se \u00e8 necessario reindirizzare la pagina in un gestore errori, conviene farlo nel seguente modo:\n    Yii::$app- getResponse()- redirect($url)- send();\n    return;",
            "title": "Utilizzo delle azioni di errori"
        },
        {
            "location": "/handling-requests/sub-handling-error/#personalizzazione-del-formato-di-risposta-degli-errori",
            "text": "Il gestore degli errori visualizza gli errori in base all'impostazione del formato della risposta. Se il formato della risposta \u00e8 html, utilizzer\u00e0 l'errore o la visualizzazione delle eccezioni per visualizzare gli errori, come descritto nell'ultima sottosezione. Per altri formati di risposta, il gestore degli errori assegner\u00e0 la rappresentazione dell'array dell'eccezione alla propriet\u00e0 dei dati  yii \\ web \\ Response :: $  che verr\u00e0 quindi convertita in diversi formati di conseguenza. Ad esempio, se il formato della risposta \u00e8  json , potresti vedere la seguente risposta:  HTTP/1.1 404 Not Found\nDate: Sun, 02 Mar 2014 05:31:43 GMT\nServer: Apache/2.2.26 (Unix) DAV/2 PHP/5.4.20 mod_ssl/2.2.26 OpenSSL/0.9.8y\nTransfer-Encoding: chunked\nContent-Type: application/json; charset=UTF-8\n\n{\n    \"name\": \"Not Found Exception\",\n    \"message\": \"The requested resource was not found.\",\n    \"code\": 0,\n    \"status\": 404\n}  \u00c8 possibile personalizzare il formato di risposta dell'errore rispondendo all'evento  beforeSend  del componente  response  nella configurazione dell'applicazione:  return [\n    // ...\n    'components' =  [\n        'response' =  [\n            'class' =  'yii\\web\\Response',\n            'on beforeSend' =  function ($event) {\n                $response = $event- sender;\n                if ($response- data !== null) {\n                    $response- data = [\n                        'success' =  $response- isSuccessful,\n                        'data' =  $response- data,\n                    ];\n                    $response- statusCode = 200;\n                }\n            },\n        ],\n    ],\n];  Il codice sopra indicato riformatter\u00e0 la risposta all'errore come la seguente:  HTTP/1.1 200 OK\nDate: Sun, 02 Mar 2014 05:31:43 GMT\nServer: Apache/2.2.26 (Unix) DAV/2 PHP/5.4.20 mod_ssl/2.2.26 OpenSSL/0.9.8y\nTransfer-Encoding: chunked\nContent-Type: application/json; charset=UTF-8\n\n{\n    \"success\": false,\n    \"data\": {\n        \"name\": \"Not Found Exception\",\n        \"message\": \"The requested resource was not found.\",\n        \"code\": 0,\n        \"status\": 404\n    }\n}",
            "title": "Personalizzazione del formato di risposta degli errori"
        },
        {
            "location": "/handling-requests/sub-logging/",
            "text": "Registrazione\n\n\nYii fornisce un potente framework di registrazione che \u00e8 altamente personalizzabile ed estensibile. Utilizzando questo framework, puoi facilmente registrare vari tipi di messaggi, filtrarli e riunirli a target diversi, come file, database, e-mail.\n\n\nL'utilizzo del framework di registrazione Yii prevede i passaggi seguenti:\n\n\n\n\nRegistra i messaggi di log in vari punti del tuo codice;\n\n\nConfigurare le destinazioni dei registri nella configurazione dell'applicazione per filtrare ed esportare i messaggi di registro;\n\n\nEsaminare i messaggi registrati filtrati esportati da destinazioni diverse (ad esempio il debugger Yii ).\n\n\n\n\nIn questa sezione, descriveremo principalmente i primi due passaggi.\n\n\nRegistrazione dei messaggi\n\n\nRegistrare i messaggi di registro \u00e8 semplice, come chiamare uno dei seguenti metodi di registrazione:\n\n\n\n\nYii :: trace()\n: registra un messaggio per tracciare come funziona un pezzo di codice. Questo \u00e8 principalmente per uso di sviluppo.\n\n\nYii :: info()\n: registra un messaggio che trasmette alcune informazioni utili.\n\n\nYii :: warning()\n: registra un messaggio di avviso che indica che \u00e8 accaduto qualcosa di inaspettato;\n\n\nYii :: error()\n: registra un errore fatale che dovrebbe essere esaminato il prima possibile.\n\n\n\n\nQuesti metodi di registrazione, permettono di reigstrare i messaggi di registro a vari livelli e categorie di gravit\u00e0. Condividono la stessa firma di funzione \nfunction\n (\n$message\n, \n$category = 'application'\n), dove \n$message\n sta per il messaggio di registro da registrare, mentre \n$category\n \u00e8 la categoria del messaggio di registro. Il codice nell'esempio seguente registra un messaggio di traccia sotto la categoria predefinita application:\n\n\nYii::trace('start calculating average revenue');\n\n\n\n\n\nInfo\n\n\nI messaggi di registro possono essere stringhe e anche dati complessi, come matrici o oggetti. \u00c8 responsabilit\u00e0 degli obiettivi di registro gestire adeguatamente i messaggi di registro. Per impostazione predefinita, se un messaggio di registro non \u00e8 una stringa, verr\u00e0 esportato come stringa chiamando \nyii \\ helpers \\ VarDumper :: export()\n.\n\n\n\n\nPer organizzare e filtrare meglio i messaggi di registro, si consiglia di specificare una categoria appropriata per ciascun messaggio di registro. \u00c8 possibile scegliere uno schema di denominazione gerarchico per categorie, che render\u00e0 pi\u00f9 semplice per le destinazioni di registro filtrare i messaggi in base alle loro categorie. Uno schema di denominazione semplice ma efficace consiste nell'utilizzare la costante magica PHP \nMETHOD\n per i nomi delle categorie. Questo \u00e8 anche l'approccio utilizzato nel codice del core Yii. Per esempio,\n\n\nYii::trace('start calculating average revenue', __METHOD__);\n\n\n\nLa costante \nMETHOD\n  viene valutata come il nome del metodo (preceduto dal nome completo della classe) in cui appare la costante. Ad esempio, \u00e8 uguale alla stringa \n'app\\controllers\\RevenueController::calculate'\n se la suddetta linea di codice \u00e8 chiamata all'interno di questo metodo.\n\n\nRegistrare gli obiettivi\n\n\nUna destinazione del log \u00e8 un'istanza della classe \nyii \\ log \\ Target\n o della sua classe figlio. Filtra i messaggi di registro in base ai livelli di gravit\u00e0 e alle categorie e quindi li esporta su un supporto. Ad esempio, una destinazione del database esporta i messaggi di log filtrati in una tabella di database, mentre una destinazione di posta elettronica esporta i messaggi di registro in indirizzi di posta elettronica specificati.\n\n\n\u00c8 possibile registrare pi\u00f9 destinazioni di registro in un'applicazione configurandole tramite il componente \nlog\n dell'applicazione nella configurazione dell'applicazione, come nell'esempio seguente:\n\n\nreturn [\n    // the \"log\" component must be loaded during bootstrapping time\n    'bootstrap' =\n ['log'],\n\n    'components' =\n [\n        'log' =\n [\n            'targets' =\n [\n                [\n                    'class' =\n 'yii\\log\\DbTarget',\n                    'levels' =\n ['error', 'warning'],\n                ],\n                [\n                    'class' =\n 'yii\\log\\EmailTarget',\n                    'levels' =\n ['error'],\n                    'categories' =\n ['yii\\db\\*'],\n                    'message' =\n [\n                    'from' =\n ['log@example.com'],\n                    'to' =\n ['admin@example.com', 'developer@example.com'],\n                    'subject' =\n 'Database errors at example.com',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nWarning\n\n\nIl componente \nlog\n deve essere caricato durante il tempo in cui \u00e8 attivo il componente \nbootstrap\n,in modo che possa inviare prontamente messaggi di log alle destinazioni. Questo \u00e8 il motivo per cui \u00e8 elencato nella matrice \nbootstrap\n come nell'esempio mostrato sopra.\n\n\n\n\nNel codice precedente, due destinazioni di registro sono registrate nella propriet\u00e0 \nyii \\ log \\ Dispatcher :: $ target\n:\n\n\n\n\nil primo target seleziona i messaggi di errore e di avviso e li salva in una tabella del database;\n\n\nil secondo target seleziona i messaggi di errore nelle categorie di cui iniziano i nomi \nyii\\db\\\n e li invia in un messaggio di posta elettronica a entrambi \nadmin@example.com\n e \ndeveloper@example.com\n.\n\n\n\n\nYii viene fornito con i seguenti obiettivi di registro incorporati.\n\n\n\n\nyii \\ log \\ DbTarget\n: memorizza i messaggi di log in una tabella di database.\n\n\nyii \\ log \\ EmailTarget\n: invia messaggi di log a indirizzi di posta elettronica pre-specificati.\n\n\nyii \\ log \\ FileTarget\n: salva i messaggi di log nei file.\n\n\nyii \\ log \\ SyslogTarget\n: salva i messaggi di log in syslog chiamando la funzione PHP \nsyslog()\n.\n\n\n\n\nDi seguito, descriveremo le caratteristiche comuni a tutti gli obiettivi di registro.\n\n\nFiltro dei messaggi\n\n\nPer ciascuna destinazione del registro, \u00e8 possibile configurare le propriet\u00e0 dei livelli e delle categorie \nyii \\ log \\ Target ::\n per specificare i livelli di gravit\u00e0 e le categorie dei messaggi che l'obiettivo deve elaborare.\n\n\nLa propriet\u00e0 \nyii \\ log \\ Target :: levels\n accettano una matrice costituita da uno o pi\u00f9 dei seguenti valori:\n\n\n\n\nerror\n: corrispondente ai messaggi registrati da \nYii :: error ()\n.\n\n\nwarning\n: corrispondente ai messaggi registrati da \nYii :: warning ()\n.\n\n\ninfo\n: corrispondente ai messaggi registrati da \nYii :: info ()\n.\n\n\ntrace\n: corrisponde ai messaggi registrati da \nYii :: trace ()\n.\n\n\nprofile\n: corrispondente ai messaggi registrati da \nYii :: beginProfile ()\n e \nYii :: endProfile ()\n , che verranno spiegati in maggior dettaglio nella sottosezione \"Profiling\".\n\n\n\n\nSe non si specifica la propriet\u00e0 \nyii \\ log \\ Target :: levels\n, significa che la destinazione elaborer\u00e0 i messaggi di qualsiasi livello di gravit\u00e0.\n\n\nLa propriet\u00e0 \ncategories\n accetta un array costituito da nomi o pattern di categorie messaggi. Una destinazione elaborer\u00e0 solo i messaggi la cui categoria pu\u00f2 essere trovata o corrispondere a uno dei modelli in questo array. Un modello di categoria \u00e8 un prefisso del nome della categoria con un asterisco \n*\n all'estremit\u00e0. Un nome di categoria corrisponde a un modello di categoria se inizia con lo stesso prefisso del modello. Ad esempio, \nyii\\db\\Command::execute\n e \nyii\\db\\Command::query\n vengono utilizzati come nomi di categorie per i messaggi di registro registrati nella classe \nyii \\ db \\ Command\n. Entrambi corrispondono allo schema \n yii\\db* \n.\n\n\nSe non si specifica la propriet\u00e0 delle categorie, significa che la destinazione elaborer\u00e0 i messaggi di qualsiasi categoria.\n\n\nOltre a inserire nella \nwhitelist\n le categorie in base alla loro propriet\u00e0, \u00e8 possibile aggiungere anche determinate categorie per la propriet\u00e0 \nexcept\n. Se la categoria di un messaggio viene trovata o corrisponde a uno dei pattern in questa propriet\u00e0, NON verr\u00e0 elaborata dalla destinazione.\n\n\nLa seguente configurazione specifica che la destinazione deve elaborare solo i messaggi di errore e di avvertimento nelle categorie i cui nomi corrispondono a \nyii\\db*\n o \n yii\\web\\HttpException:\n \n*, ma non a quelli \n yii\\web\\HttpException:404 \n.\n\n\n[\n    'class' =\n 'yii\\log\\FileTarget',\n    'levels' =\n ['error', 'warning'],\n    'categories' =\n [\n        'yii\\db\\*',\n        'yii\\web\\HttpException:*',\n    ],\n    'except' =\n [\n        'yii\\web\\HttpException:404',\n    ],\n]\n\n\n\n\n\nNote\n\n\nQuando viene rilevata un'eccezione HTTP dal gestore degli errori , verr\u00e0 registrato un messaggio di errore con il nome della categoria nel formato di \nyii\\web\\HttpException:ErrorCode\n. Ad esempio, \nyii \\ web \\ NotFoundHttpException\n causer\u00e0 un messaggio di errore di categoria \nyii\\web\\HttpException:404\n.\n\n\n\n\nFormattazione del messaggio\n\n\nLe destinazioni log esportano i messaggi di log filtrati in un determinato formato. Ad esempio, se si installa una destinazione del registro della classe \nyii \\ log \\ FileTarget\n, \u00e8 possibile trovare un messaggio di registro simile al seguente nel \nruntime/log/app.logfile\n:\n\n\n2014-10-04 18:10:15 [::1][][-][trace][yii\\base\\Module::getModule] Loading module: debug\n\n\n\nPer impostazione predefinita, i messaggi di registro verranno formattati come segue da \nyii \\ log \\ Target :: formatMessage ()\n:\n\n\nTimestamp [IP address][User ID][Session ID][Severity Level][Category] Message Text\n\n\n\n\u00c8 possibile personalizzare questo formato configurando la propriet\u00e0 \nyii \\ log \\ Target :: $\n che accetta una chiamata PHP restituendo un prefisso con un messaggio personalizzato. Ad esempio, il codice seguente configura una destinazione del registro per aggiungere un prefisso a ciascun messaggio con l'ID utente corrente (l'indirizzo IP e l'ID sessione vengono rimossi per motivi di riservatezza).\n\n\n[\n    'class' =\n 'yii\\log\\FileTarget',\n    'prefix' =\n function ($message) {\n        $user = Yii::$app-\nhas('user', true) ? Yii::$app-\nget('user') : null;\n        $userID = $user ? $user-\ngetId(false) : '-';\n        return \"[$userID]\";\n    }\n]\n\n\n\nOltre ai prefissi dei messaggi, gli obiettivi di registro aggiungono anche alcune informazioni di contesto a ciascun batch relativo ai messaggi di registro. Per impostazione predefinita, sono inclusi i valori di queste variabili PHP globali: \n$_GET\n, \n$_POST\n, \n$_FILES\n, \n$_COOKIE\n, \n$_SESSION\n e \n$_SERVER\n. \u00c8 possibile modificare questo comportamento configurando la propriet\u00e0 \nyii \\ log \\ Target :: $ logVars\n con i nomi delle variabili globali che si desidera includere dalla destinazione del registro. Ad esempio, la seguente configurazione di destinazione del registro specifica che solo il valore della variabile \n$_SERVER\n verr\u00e0 aggiunta ai messaggi di registro.\n\n\n[\n    'class' =\n 'yii\\log\\FileTarget',\n    'logVars' =\n ['_SERVER'],\n]\n\n\n\n\u00c8 possibile configurare \nlogVars\n cos\u00ec che sia una matrice vuota per disabilitare completamente l'inclusione delle informazioni di contesto. Altrimenti se si desidera implementare il proprio modo di fornire informazioni di contesto, \u00e8 possibile sovrascrivere il metodo \nyii \\ log \\ Target :: getContextMessage ()\n.\n\n\nTraccia dei messaggi tramite livelli\n\n\nDurante lo sviluppo, \u00e8 spesso preferibile vedere da dove proviene ogni messaggio di registro. Questo pu\u00f2 essere ottenuto configurando la propriet\u00e0 \nyii \\ log \\ Dispatcher :: traceLevel\n del componente \nlog\n come la seguente:\n\n\nreturn [\n    'bootstrap' =\n ['log'],\n    'components' =\n [\n        'log' =\n [\n            'traceLevel' =\n YII_DEBUG ? 3 : 0,\n            'targets' =\n [...],\n        ],\n    ],\n];\n\n\n\nLa configurazione dell'applicazione sopra imposta \nyii \\ log \\ Dispatcher :: traceLevel\n pu\u00f2 essere 3 se \nYII_DEBUG\n \u00e8 a 0 e se \nYII_DEBUG\n \u00e8 off. Ci\u00f2 significa che, se \nYII_DEBUG\n \u00e8 attivo, ogni messaggio di registro verr\u00e0 aggiunto con almeno 3 livelli dello stack di chiamate a cui viene registrato il messaggio di registro; e se \nYII_DEBUG\n \u00e8 disattivato,non verranno incluse le informazioni sullo stack di chiamata.\n\n\nFlushing e esportazione dei messaggi\n\n\nCome gi\u00e0 detto, i messaggi di log sono mantenuti in un array dall'oggetto \nlogger\n. Per limitare il consumo di memoria da parte di questo array, il registratore scaricher\u00e0 i messaggi registrati sugli obiettivi del registro ogni volta che l'array accumula un certo numero di messaggi di registro. \u00c8 possibile personalizzare questo numero configurando la propriet\u00e0 \nyii \\ log \\ Dispatcher :: flushInterval\n del componente \nlog\n:\n\n\nreturn [\n    'bootstrap' =\n ['log'],\n    'components' =\n [\n        'log' =\n [\n            'flushInterval' =\n 100,   // default is 1000\n            'targets' =\n [...],\n        ],\n    ],\n];\n\n\n\nQuando l' oggetto \nlogger\n scarica i messaggi di log per registrare gli obiettivi , non vengono esportati immediatamente. Invece, l'esportazione del messaggio si verifica solo quando una destinazione del registro accumula un certo numero di messaggi filtrati. \u00c8 possibile personalizzare questo numero configurando la propriet\u00e0 \nexportInterval\n dei singoli target di registro , come il seguente,\n\n\n[\n    'class' =\n 'yii\\log\\FileTarget',\n    'exportInterval' =\n 100,  // default is 1000\n]\n\n\n\nA causa dell'impostazione del livello di scarico e di esportazione, per impostazione predefinita quando si chiama \nYii::trace()\n o qualsiasi altro metodo di registrazione, NON si vedr\u00e0 immediatamente il messaggio di registro nelle destinazioni del registro. Questo potrebbe essere un problema per alcune applicazioni per console di lunga durata. Per visualizzare immediatamente ciascun messaggio di registro nelle destinazioni del registro, \u00e8 necessario impostare sia \nyii \\ log \\ Dispatcher :: flushInterval\n che \nexportInterval\n a 1, come mostrato di seguito:\n\n\nreturn [\n    'bootstrap' =\n ['log'],\n    'components' =\n [\n        'log' =\n [\n            'flushInterval' =\n 1,\n            'targets' =\n [\n                [\n                    'class' =\n 'yii\\log\\FileTarget',\n                    'exportInterval' =\n 1,\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nWarning\n\n\nIl flusso e l'esportazione frequente di messaggi, peggiora le prestazioni dell'applicazione.\n\n\n\n\nAttivare i registri del registro\n\n\n\u00c8 possibile abilitare o disabilitare una destinazione del registro configurando la propriet\u00e0 \nyii \\ log \\ Target :: enabled\n. Puoi farlo tramite la configurazione di destinazione del registro o la seguente istruzione PHP nel tuo codice:\n\n\nYii::$app-\nlog-\ntargets['file']-\nenabled = false;\n\n\n\nIl codice sopra richiede di nominare un target come \nfile\n, come illustrato di seguito, utilizzando le chiavi stringa \ntargets\n nell'array:\n\n\nreturn [\n    'bootstrap' =\n ['log'],\n    'components' =\n [\n        'log' =\n [\n            'targets' =\n [\n                'file' =\n [\n                    'class' =\n 'yii\\log\\FileTarget',\n                ],\n                'db' =\n [\n                    'class' =\n 'yii\\log\\DbTarget',\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nDalla versione 2.0.13, \u00e8 possibile configurare \nyii \\ log \\ Target ::\n abilitato con una metodo callable per definire una condizione dinamica per l'eventuale abilitazione o meno della destinazione del registro. \n\n\nCreazione di nuovi obiettivi\n\n\nLa creazione di una nuova classe di destinazione del registro \u00e8 molto semplice. \u00c8 principalmente necessario implementare il metodo \nyii \\ log \\ Target :: export ()\n che invia il contenuto della matrice \nyii \\ log \\ Target :: $\n a un supporto designato. \u00c8 possibile chiamare il metodo \nyii \\ log \\ Target :: formatMessage()\n per formattare ciascun messaggio. \n\n\n\n\nTip\n\n\nInvece di creare i propri logger, \u00e8 possibile provare qualsiasi programma di registrazione compatibile con \nPSR-3\n come \nMonolog\n,utilizzando l'estensione di destinazione del registro PSR.\n\n\n\n\nPerformance profiling\n\n\nIl \nperformance profiling\n \u00e8 un tipo speciale di registrazione dei messaggi che viene utilizzato per misurare il tempo impiegato da determinati blocchi di codice e individuare i colli di bottiglia delle prestazioni. Ad esempio, la classe \nyii \\ db \\ Command\n utilizza il profilo delle prestazioni per individuare il tempo impiegato da ciascuna query DB.\n\n\nPer utilizzare il profilo delle prestazioni, identificare innanzitutto i blocchi di codice che devono essere profilati. Quindi racchiudi ciascun blocco di codice come segue:\n\n\n\\Yii::beginProfile('myBenchmark');\n\n...code block being profiled...\n\n\\Yii::endProfile('myBenchmark');\n\n\n\ndove \nmyBenchmark\n sta per un token univoco che identifica un blocco di codice. Successivamente, quando si esamina il risultato del profilo, si utilizzer\u00e0 questo token per individuare il tempo trascorso dal blocco di codice corrispondente.\n\n\n\u00c8 importante assicurarsi che le coppie di \nbeginProfile\n e \nendProfile\n siano correttamente annidate. Per esempio,\n\n\n\\Yii::beginProfile('block1');\n\n    // some code to be profiled\n\n    \\Yii::beginProfile('block2');\n        // some other code to be profiled\n    \\Yii::endProfile('block2');\n\n\\Yii::endProfile('block1');\n\n\n\nSe per caso ti dimentichi di inserire \n\\Yii::endProfile('block1')\n o cambi l'ordine di \n\\Yii::endProfile('block1')\n e \n\\Yii::endProfile('block2')\n, il profilo delle prestazioni non funzioner\u00e0.\n\n\nPer ogni blocco di codice che viene profilato, viene registrato un messaggio di registro con il livello di gravit\u00e0 profile. \u00c8 possibile configurare un obiettivo di registro per raccogliere tali messaggi ed esportarli. Il debugger Yii ha un pannello di profilazione delle prestazioni integrato che mostra i risultati del profilo.",
            "title": "Registrazione"
        },
        {
            "location": "/handling-requests/sub-logging/#registrazione",
            "text": "Yii fornisce un potente framework di registrazione che \u00e8 altamente personalizzabile ed estensibile. Utilizzando questo framework, puoi facilmente registrare vari tipi di messaggi, filtrarli e riunirli a target diversi, come file, database, e-mail.  L'utilizzo del framework di registrazione Yii prevede i passaggi seguenti:   Registra i messaggi di log in vari punti del tuo codice;  Configurare le destinazioni dei registri nella configurazione dell'applicazione per filtrare ed esportare i messaggi di registro;  Esaminare i messaggi registrati filtrati esportati da destinazioni diverse (ad esempio il debugger Yii ).   In questa sezione, descriveremo principalmente i primi due passaggi.",
            "title": "Registrazione"
        },
        {
            "location": "/handling-requests/sub-logging/#registrazione-dei-messaggi",
            "text": "Registrare i messaggi di registro \u00e8 semplice, come chiamare uno dei seguenti metodi di registrazione:   Yii :: trace() : registra un messaggio per tracciare come funziona un pezzo di codice. Questo \u00e8 principalmente per uso di sviluppo.  Yii :: info() : registra un messaggio che trasmette alcune informazioni utili.  Yii :: warning() : registra un messaggio di avviso che indica che \u00e8 accaduto qualcosa di inaspettato;  Yii :: error() : registra un errore fatale che dovrebbe essere esaminato il prima possibile.   Questi metodi di registrazione, permettono di reigstrare i messaggi di registro a vari livelli e categorie di gravit\u00e0. Condividono la stessa firma di funzione  function  ( $message ,  $category = 'application' ), dove  $message  sta per il messaggio di registro da registrare, mentre  $category  \u00e8 la categoria del messaggio di registro. Il codice nell'esempio seguente registra un messaggio di traccia sotto la categoria predefinita application:  Yii::trace('start calculating average revenue');   Info  I messaggi di registro possono essere stringhe e anche dati complessi, come matrici o oggetti. \u00c8 responsabilit\u00e0 degli obiettivi di registro gestire adeguatamente i messaggi di registro. Per impostazione predefinita, se un messaggio di registro non \u00e8 una stringa, verr\u00e0 esportato come stringa chiamando  yii \\ helpers \\ VarDumper :: export() .   Per organizzare e filtrare meglio i messaggi di registro, si consiglia di specificare una categoria appropriata per ciascun messaggio di registro. \u00c8 possibile scegliere uno schema di denominazione gerarchico per categorie, che render\u00e0 pi\u00f9 semplice per le destinazioni di registro filtrare i messaggi in base alle loro categorie. Uno schema di denominazione semplice ma efficace consiste nell'utilizzare la costante magica PHP  METHOD  per i nomi delle categorie. Questo \u00e8 anche l'approccio utilizzato nel codice del core Yii. Per esempio,  Yii::trace('start calculating average revenue', __METHOD__);  La costante  METHOD   viene valutata come il nome del metodo (preceduto dal nome completo della classe) in cui appare la costante. Ad esempio, \u00e8 uguale alla stringa  'app\\controllers\\RevenueController::calculate'  se la suddetta linea di codice \u00e8 chiamata all'interno di questo metodo.",
            "title": "Registrazione dei messaggi"
        },
        {
            "location": "/handling-requests/sub-logging/#registrare-gli-obiettivi",
            "text": "Una destinazione del log \u00e8 un'istanza della classe  yii \\ log \\ Target  o della sua classe figlio. Filtra i messaggi di registro in base ai livelli di gravit\u00e0 e alle categorie e quindi li esporta su un supporto. Ad esempio, una destinazione del database esporta i messaggi di log filtrati in una tabella di database, mentre una destinazione di posta elettronica esporta i messaggi di registro in indirizzi di posta elettronica specificati.  \u00c8 possibile registrare pi\u00f9 destinazioni di registro in un'applicazione configurandole tramite il componente  log  dell'applicazione nella configurazione dell'applicazione, come nell'esempio seguente:  return [\n    // the \"log\" component must be loaded during bootstrapping time\n    'bootstrap' =  ['log'],\n\n    'components' =  [\n        'log' =  [\n            'targets' =  [\n                [\n                    'class' =  'yii\\log\\DbTarget',\n                    'levels' =  ['error', 'warning'],\n                ],\n                [\n                    'class' =  'yii\\log\\EmailTarget',\n                    'levels' =  ['error'],\n                    'categories' =  ['yii\\db\\*'],\n                    'message' =  [\n                    'from' =  ['log@example.com'],\n                    'to' =  ['admin@example.com', 'developer@example.com'],\n                    'subject' =  'Database errors at example.com',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];   Warning  Il componente  log  deve essere caricato durante il tempo in cui \u00e8 attivo il componente  bootstrap ,in modo che possa inviare prontamente messaggi di log alle destinazioni. Questo \u00e8 il motivo per cui \u00e8 elencato nella matrice  bootstrap  come nell'esempio mostrato sopra.   Nel codice precedente, due destinazioni di registro sono registrate nella propriet\u00e0  yii \\ log \\ Dispatcher :: $ target :   il primo target seleziona i messaggi di errore e di avviso e li salva in una tabella del database;  il secondo target seleziona i messaggi di errore nelle categorie di cui iniziano i nomi  yii\\db\\  e li invia in un messaggio di posta elettronica a entrambi  admin@example.com  e  developer@example.com .   Yii viene fornito con i seguenti obiettivi di registro incorporati.   yii \\ log \\ DbTarget : memorizza i messaggi di log in una tabella di database.  yii \\ log \\ EmailTarget : invia messaggi di log a indirizzi di posta elettronica pre-specificati.  yii \\ log \\ FileTarget : salva i messaggi di log nei file.  yii \\ log \\ SyslogTarget : salva i messaggi di log in syslog chiamando la funzione PHP  syslog() .   Di seguito, descriveremo le caratteristiche comuni a tutti gli obiettivi di registro.",
            "title": "Registrare gli obiettivi"
        },
        {
            "location": "/handling-requests/sub-logging/#filtro-dei-messaggi",
            "text": "Per ciascuna destinazione del registro, \u00e8 possibile configurare le propriet\u00e0 dei livelli e delle categorie  yii \\ log \\ Target ::  per specificare i livelli di gravit\u00e0 e le categorie dei messaggi che l'obiettivo deve elaborare.  La propriet\u00e0  yii \\ log \\ Target :: levels  accettano una matrice costituita da uno o pi\u00f9 dei seguenti valori:   error : corrispondente ai messaggi registrati da  Yii :: error () .  warning : corrispondente ai messaggi registrati da  Yii :: warning () .  info : corrispondente ai messaggi registrati da  Yii :: info () .  trace : corrisponde ai messaggi registrati da  Yii :: trace () .  profile : corrispondente ai messaggi registrati da  Yii :: beginProfile ()  e  Yii :: endProfile ()  , che verranno spiegati in maggior dettaglio nella sottosezione \"Profiling\".   Se non si specifica la propriet\u00e0  yii \\ log \\ Target :: levels , significa che la destinazione elaborer\u00e0 i messaggi di qualsiasi livello di gravit\u00e0.  La propriet\u00e0  categories  accetta un array costituito da nomi o pattern di categorie messaggi. Una destinazione elaborer\u00e0 solo i messaggi la cui categoria pu\u00f2 essere trovata o corrispondere a uno dei modelli in questo array. Un modello di categoria \u00e8 un prefisso del nome della categoria con un asterisco  *  all'estremit\u00e0. Un nome di categoria corrisponde a un modello di categoria se inizia con lo stesso prefisso del modello. Ad esempio,  yii\\db\\Command::execute  e  yii\\db\\Command::query  vengono utilizzati come nomi di categorie per i messaggi di registro registrati nella classe  yii \\ db \\ Command . Entrambi corrispondono allo schema   yii\\db*  .  Se non si specifica la propriet\u00e0 delle categorie, significa che la destinazione elaborer\u00e0 i messaggi di qualsiasi categoria.  Oltre a inserire nella  whitelist  le categorie in base alla loro propriet\u00e0, \u00e8 possibile aggiungere anche determinate categorie per la propriet\u00e0  except . Se la categoria di un messaggio viene trovata o corrisponde a uno dei pattern in questa propriet\u00e0, NON verr\u00e0 elaborata dalla destinazione.  La seguente configurazione specifica che la destinazione deve elaborare solo i messaggi di errore e di avvertimento nelle categorie i cui nomi corrispondono a  yii\\db*  o   yii\\web\\HttpException:   *, ma non a quelli   yii\\web\\HttpException:404  .  [\n    'class' =  'yii\\log\\FileTarget',\n    'levels' =  ['error', 'warning'],\n    'categories' =  [\n        'yii\\db\\*',\n        'yii\\web\\HttpException:*',\n    ],\n    'except' =  [\n        'yii\\web\\HttpException:404',\n    ],\n]   Note  Quando viene rilevata un'eccezione HTTP dal gestore degli errori , verr\u00e0 registrato un messaggio di errore con il nome della categoria nel formato di  yii\\web\\HttpException:ErrorCode . Ad esempio,  yii \\ web \\ NotFoundHttpException  causer\u00e0 un messaggio di errore di categoria  yii\\web\\HttpException:404 .",
            "title": "Filtro dei messaggi"
        },
        {
            "location": "/handling-requests/sub-logging/#formattazione-del-messaggio",
            "text": "Le destinazioni log esportano i messaggi di log filtrati in un determinato formato. Ad esempio, se si installa una destinazione del registro della classe  yii \\ log \\ FileTarget , \u00e8 possibile trovare un messaggio di registro simile al seguente nel  runtime/log/app.logfile :  2014-10-04 18:10:15 [::1][][-][trace][yii\\base\\Module::getModule] Loading module: debug  Per impostazione predefinita, i messaggi di registro verranno formattati come segue da  yii \\ log \\ Target :: formatMessage () :  Timestamp [IP address][User ID][Session ID][Severity Level][Category] Message Text  \u00c8 possibile personalizzare questo formato configurando la propriet\u00e0  yii \\ log \\ Target :: $  che accetta una chiamata PHP restituendo un prefisso con un messaggio personalizzato. Ad esempio, il codice seguente configura una destinazione del registro per aggiungere un prefisso a ciascun messaggio con l'ID utente corrente (l'indirizzo IP e l'ID sessione vengono rimossi per motivi di riservatezza).  [\n    'class' =  'yii\\log\\FileTarget',\n    'prefix' =  function ($message) {\n        $user = Yii::$app- has('user', true) ? Yii::$app- get('user') : null;\n        $userID = $user ? $user- getId(false) : '-';\n        return \"[$userID]\";\n    }\n]  Oltre ai prefissi dei messaggi, gli obiettivi di registro aggiungono anche alcune informazioni di contesto a ciascun batch relativo ai messaggi di registro. Per impostazione predefinita, sono inclusi i valori di queste variabili PHP globali:  $_GET ,  $_POST ,  $_FILES ,  $_COOKIE ,  $_SESSION  e  $_SERVER . \u00c8 possibile modificare questo comportamento configurando la propriet\u00e0  yii \\ log \\ Target :: $ logVars  con i nomi delle variabili globali che si desidera includere dalla destinazione del registro. Ad esempio, la seguente configurazione di destinazione del registro specifica che solo il valore della variabile  $_SERVER  verr\u00e0 aggiunta ai messaggi di registro.  [\n    'class' =  'yii\\log\\FileTarget',\n    'logVars' =  ['_SERVER'],\n]  \u00c8 possibile configurare  logVars  cos\u00ec che sia una matrice vuota per disabilitare completamente l'inclusione delle informazioni di contesto. Altrimenti se si desidera implementare il proprio modo di fornire informazioni di contesto, \u00e8 possibile sovrascrivere il metodo  yii \\ log \\ Target :: getContextMessage () .",
            "title": "Formattazione del messaggio"
        },
        {
            "location": "/handling-requests/sub-logging/#traccia-dei-messaggi-tramite-livelli",
            "text": "Durante lo sviluppo, \u00e8 spesso preferibile vedere da dove proviene ogni messaggio di registro. Questo pu\u00f2 essere ottenuto configurando la propriet\u00e0  yii \\ log \\ Dispatcher :: traceLevel  del componente  log  come la seguente:  return [\n    'bootstrap' =  ['log'],\n    'components' =  [\n        'log' =  [\n            'traceLevel' =  YII_DEBUG ? 3 : 0,\n            'targets' =  [...],\n        ],\n    ],\n];  La configurazione dell'applicazione sopra imposta  yii \\ log \\ Dispatcher :: traceLevel  pu\u00f2 essere 3 se  YII_DEBUG  \u00e8 a 0 e se  YII_DEBUG  \u00e8 off. Ci\u00f2 significa che, se  YII_DEBUG  \u00e8 attivo, ogni messaggio di registro verr\u00e0 aggiunto con almeno 3 livelli dello stack di chiamate a cui viene registrato il messaggio di registro; e se  YII_DEBUG  \u00e8 disattivato,non verranno incluse le informazioni sullo stack di chiamata.",
            "title": "Traccia dei messaggi tramite livelli"
        },
        {
            "location": "/handling-requests/sub-logging/#flushing-e-esportazione-dei-messaggi",
            "text": "Come gi\u00e0 detto, i messaggi di log sono mantenuti in un array dall'oggetto  logger . Per limitare il consumo di memoria da parte di questo array, il registratore scaricher\u00e0 i messaggi registrati sugli obiettivi del registro ogni volta che l'array accumula un certo numero di messaggi di registro. \u00c8 possibile personalizzare questo numero configurando la propriet\u00e0  yii \\ log \\ Dispatcher :: flushInterval  del componente  log :  return [\n    'bootstrap' =  ['log'],\n    'components' =  [\n        'log' =  [\n            'flushInterval' =  100,   // default is 1000\n            'targets' =  [...],\n        ],\n    ],\n];  Quando l' oggetto  logger  scarica i messaggi di log per registrare gli obiettivi , non vengono esportati immediatamente. Invece, l'esportazione del messaggio si verifica solo quando una destinazione del registro accumula un certo numero di messaggi filtrati. \u00c8 possibile personalizzare questo numero configurando la propriet\u00e0  exportInterval  dei singoli target di registro , come il seguente,  [\n    'class' =  'yii\\log\\FileTarget',\n    'exportInterval' =  100,  // default is 1000\n]  A causa dell'impostazione del livello di scarico e di esportazione, per impostazione predefinita quando si chiama  Yii::trace()  o qualsiasi altro metodo di registrazione, NON si vedr\u00e0 immediatamente il messaggio di registro nelle destinazioni del registro. Questo potrebbe essere un problema per alcune applicazioni per console di lunga durata. Per visualizzare immediatamente ciascun messaggio di registro nelle destinazioni del registro, \u00e8 necessario impostare sia  yii \\ log \\ Dispatcher :: flushInterval  che  exportInterval  a 1, come mostrato di seguito:  return [\n    'bootstrap' =  ['log'],\n    'components' =  [\n        'log' =  [\n            'flushInterval' =  1,\n            'targets' =  [\n                [\n                    'class' =  'yii\\log\\FileTarget',\n                    'exportInterval' =  1,\n                ],\n            ],\n        ],\n    ],\n];   Warning  Il flusso e l'esportazione frequente di messaggi, peggiora le prestazioni dell'applicazione.",
            "title": "Flushing e esportazione dei messaggi"
        },
        {
            "location": "/handling-requests/sub-logging/#attivare-i-registri-del-registro",
            "text": "\u00c8 possibile abilitare o disabilitare una destinazione del registro configurando la propriet\u00e0  yii \\ log \\ Target :: enabled . Puoi farlo tramite la configurazione di destinazione del registro o la seguente istruzione PHP nel tuo codice:  Yii::$app- log- targets['file']- enabled = false;  Il codice sopra richiede di nominare un target come  file , come illustrato di seguito, utilizzando le chiavi stringa  targets  nell'array:  return [\n    'bootstrap' =  ['log'],\n    'components' =  [\n        'log' =  [\n            'targets' =  [\n                'file' =  [\n                    'class' =  'yii\\log\\FileTarget',\n                ],\n                'db' =  [\n                    'class' =  'yii\\log\\DbTarget',\n                ],\n            ],\n        ],\n    ],\n];  Dalla versione 2.0.13, \u00e8 possibile configurare  yii \\ log \\ Target ::  abilitato con una metodo callable per definire una condizione dinamica per l'eventuale abilitazione o meno della destinazione del registro.",
            "title": "Attivare i registri del registro"
        },
        {
            "location": "/handling-requests/sub-logging/#creazione-di-nuovi-obiettivi",
            "text": "La creazione di una nuova classe di destinazione del registro \u00e8 molto semplice. \u00c8 principalmente necessario implementare il metodo  yii \\ log \\ Target :: export ()  che invia il contenuto della matrice  yii \\ log \\ Target :: $  a un supporto designato. \u00c8 possibile chiamare il metodo  yii \\ log \\ Target :: formatMessage()  per formattare ciascun messaggio.    Tip  Invece di creare i propri logger, \u00e8 possibile provare qualsiasi programma di registrazione compatibile con  PSR-3  come  Monolog ,utilizzando l'estensione di destinazione del registro PSR.",
            "title": "Creazione di nuovi obiettivi"
        },
        {
            "location": "/handling-requests/sub-logging/#performance-profiling",
            "text": "Il  performance profiling  \u00e8 un tipo speciale di registrazione dei messaggi che viene utilizzato per misurare il tempo impiegato da determinati blocchi di codice e individuare i colli di bottiglia delle prestazioni. Ad esempio, la classe  yii \\ db \\ Command  utilizza il profilo delle prestazioni per individuare il tempo impiegato da ciascuna query DB.  Per utilizzare il profilo delle prestazioni, identificare innanzitutto i blocchi di codice che devono essere profilati. Quindi racchiudi ciascun blocco di codice come segue:  \\Yii::beginProfile('myBenchmark');\n\n...code block being profiled...\n\n\\Yii::endProfile('myBenchmark');  dove  myBenchmark  sta per un token univoco che identifica un blocco di codice. Successivamente, quando si esamina il risultato del profilo, si utilizzer\u00e0 questo token per individuare il tempo trascorso dal blocco di codice corrispondente.  \u00c8 importante assicurarsi che le coppie di  beginProfile  e  endProfile  siano correttamente annidate. Per esempio,  \\Yii::beginProfile('block1');\n\n    // some code to be profiled\n\n    \\Yii::beginProfile('block2');\n        // some other code to be profiled\n    \\Yii::endProfile('block2');\n\n\\Yii::endProfile('block1');  Se per caso ti dimentichi di inserire  \\Yii::endProfile('block1')  o cambi l'ordine di  \\Yii::endProfile('block1')  e  \\Yii::endProfile('block2') , il profilo delle prestazioni non funzioner\u00e0.  Per ogni blocco di codice che viene profilato, viene registrato un messaggio di registro con il livello di gravit\u00e0 profile. \u00c8 possibile configurare un obiettivo di registro per raccogliere tali messaggi ed esportarli. Il debugger Yii ha un pannello di profilazione delle prestazioni integrato che mostra i risultati del profilo.",
            "title": "Performance profiling"
        },
        {
            "location": "/key-concepts/sub-components/",
            "text": "Componenti\n\n\nI componenti sono gli elementi principali delle applicazioni Yii. I componenti sono istanze di \nyii \\ base \\ Components\n o una classe estesa. Le tre funzionalit\u00e0 principali che i componenti forniscono ad altre classi sono:\n\n\n\n\nPropriet\u00e0,\n\n\nEventi,\n\n\nComportamenti.\n\n\n\n\nSeparatamente e combinate, queste caratteristiche rendono le classi Yii molto pi\u00f9 personalizzabili e pi\u00f9 facili da usare. Ad esempio, il widget per la selezione della data (un componente dell'interfaccia utente),  pu\u00f2 essere utilizzato in una vista per generare un selettore di date interattivo:\n\n\nuse yii\\jui\\DatePicker;\n\necho DatePicker::widget([\n    'language' =\n 'ru',\n    'name'  =\n 'country',\n    'clientOptions' =\n [\n        'dateFormat' =\n 'yy-mm-dd',\n    ],\n]);\n\n\n\nLe propriet\u00e0 del widget sono facilmente scrivibili perch\u00e9 la classe estende \nyii \\ base \\ Component\n.\n\n\nSebbene i componenti siano molto potenti, sono un po 'pi\u00f9 pesanti degli oggetti normali, poich\u00e9 richiedono in particolare memoria e tempo di CPU aggiuntivi per supportare le funzionalit\u00e0 di eventi e comportamenti. Se i tuoi componenti non hanno bisogno di queste due funzionalit\u00e0, potresti prendere in considerazione l'estensione della classe del componente da \nyii \\ base \\ BaseObject\n anzich\u00e9 \nyii \\ base \\ Component\n. In questo modo i tuoi componenti saranno efficienti come normali oggetti PHP, ma con un supporto aggiuntivo per le propriet\u00e0.\n\n\nQuando estendi la tua classe da \nyii \\ base \\ Component\n o \nyii \\ base \\ BaseObject\n, ti consigliamo di seguire queste convenzioni:\n\n\n\n\nSe si esegue l'override del costruttore, ci conviene specificare un parametro \n$config\n come ultimo parametro del costruttore e quindi passarlo al costruttore genitore.\n\n\nChiamare sempre il costruttore genitore alla fine del tuo costruttore override.\n\n\nSe si esegue l'override del metodo \nyii \\ base \\ BaseObject :: init ()\n, assicurarsi di chiamare l'implementazione genitore \ninit()\n all'inizio del metodo \ninit()\n.\n\n\n\n\nPer esempio:\n\n\n?php\n\nnamespace yii\\components\\MyClass;\n\nuse yii\\base\\BaseObject;\n\nclass MyClass extends BaseObject{\n\n    public $prop1;\n    public $prop2;\n\n    public function __construct($param1, $param2, $config = []){\n\n        // ... initialization before configuration is applied\n\n        parent::__construct($config);\n    }\n\n    public function init(){\n\n        parent::init();\n\n        // ... initialization after configuration is applied\n    }\n}\n\n\n\nSeguendo queste linee guida, i tuoi componenti saranno configurabili al momento della loro creazione. Per esempio:\n\n\n$component = new MyClass(1, 2, ['prop1' =\n 3, 'prop2' =\n 4]);\n// alternatively\n$component = \\Yii::createObject([\n    'class' =\n MyClass::className(),\n    'prop1' =\n 3,\n    'prop2' =\n 4,\n], [1, 2]);\n\n\n\n\n\nInfo\n\n\nMentre l'approccio per chiamare \nYii :: createObject()\n sembra complicato, non \u00e8 cos\u00ec.Questo metodo \u00e8 pi\u00f9 potente perch\u00e9 \u00e8 implementato su un contenitore di dipendenze.\n\n\n\n\nLa classe \nyii \\ base \\ BaseObject\n impone il seguente ciclo di vita dell'oggetto:\n\n\n\n\nPre-inizializzazione all'interno del costruttore. \u00c8 possibile impostare i valori delle propriet\u00e0 di default qui.\n\n\nConfigurazione dell'oggetto tramite l'attributo \n$config\n. La configurazione pu\u00f2 sovrascrivere i valori predefiniti impostati all'interno del costruttore.\n\n\nPost-inizializzazione all'interno del metodo \ninit()\n. \u00c8 possibile sovrascrivere questo metodo per eseguire controlli di integrit\u00e0 e normalizzazione delle propriet\u00e0.\n\n\nChiamare il metodo relativo all'oggetto utilizzato.\n\n\n\n\nI primi tre passaggi avvengono tutti all'interno del costruttore dell'oggetto. Ci\u00f2 significa che una volta ottenuta un'istanza di classe (cio\u00e8 un oggetto), quell'oggetto \u00e8 gi\u00e0 stato inizializzato in uno stato corretto e affidabile.",
            "title": "Componenti"
        },
        {
            "location": "/key-concepts/sub-components/#componenti",
            "text": "I componenti sono gli elementi principali delle applicazioni Yii. I componenti sono istanze di  yii \\ base \\ Components  o una classe estesa. Le tre funzionalit\u00e0 principali che i componenti forniscono ad altre classi sono:   Propriet\u00e0,  Eventi,  Comportamenti.   Separatamente e combinate, queste caratteristiche rendono le classi Yii molto pi\u00f9 personalizzabili e pi\u00f9 facili da usare. Ad esempio, il widget per la selezione della data (un componente dell'interfaccia utente),  pu\u00f2 essere utilizzato in una vista per generare un selettore di date interattivo:  use yii\\jui\\DatePicker;\n\necho DatePicker::widget([\n    'language' =  'ru',\n    'name'  =  'country',\n    'clientOptions' =  [\n        'dateFormat' =  'yy-mm-dd',\n    ],\n]);  Le propriet\u00e0 del widget sono facilmente scrivibili perch\u00e9 la classe estende  yii \\ base \\ Component .  Sebbene i componenti siano molto potenti, sono un po 'pi\u00f9 pesanti degli oggetti normali, poich\u00e9 richiedono in particolare memoria e tempo di CPU aggiuntivi per supportare le funzionalit\u00e0 di eventi e comportamenti. Se i tuoi componenti non hanno bisogno di queste due funzionalit\u00e0, potresti prendere in considerazione l'estensione della classe del componente da  yii \\ base \\ BaseObject  anzich\u00e9  yii \\ base \\ Component . In questo modo i tuoi componenti saranno efficienti come normali oggetti PHP, ma con un supporto aggiuntivo per le propriet\u00e0.  Quando estendi la tua classe da  yii \\ base \\ Component  o  yii \\ base \\ BaseObject , ti consigliamo di seguire queste convenzioni:   Se si esegue l'override del costruttore, ci conviene specificare un parametro  $config  come ultimo parametro del costruttore e quindi passarlo al costruttore genitore.  Chiamare sempre il costruttore genitore alla fine del tuo costruttore override.  Se si esegue l'override del metodo  yii \\ base \\ BaseObject :: init () , assicurarsi di chiamare l'implementazione genitore  init()  all'inizio del metodo  init() .   Per esempio:  ?php\n\nnamespace yii\\components\\MyClass;\n\nuse yii\\base\\BaseObject;\n\nclass MyClass extends BaseObject{\n\n    public $prop1;\n    public $prop2;\n\n    public function __construct($param1, $param2, $config = []){\n\n        // ... initialization before configuration is applied\n\n        parent::__construct($config);\n    }\n\n    public function init(){\n\n        parent::init();\n\n        // ... initialization after configuration is applied\n    }\n}  Seguendo queste linee guida, i tuoi componenti saranno configurabili al momento della loro creazione. Per esempio:  $component = new MyClass(1, 2, ['prop1' =  3, 'prop2' =  4]);\n// alternatively\n$component = \\Yii::createObject([\n    'class' =  MyClass::className(),\n    'prop1' =  3,\n    'prop2' =  4,\n], [1, 2]);   Info  Mentre l'approccio per chiamare  Yii :: createObject()  sembra complicato, non \u00e8 cos\u00ec.Questo metodo \u00e8 pi\u00f9 potente perch\u00e9 \u00e8 implementato su un contenitore di dipendenze.   La classe  yii \\ base \\ BaseObject  impone il seguente ciclo di vita dell'oggetto:   Pre-inizializzazione all'interno del costruttore. \u00c8 possibile impostare i valori delle propriet\u00e0 di default qui.  Configurazione dell'oggetto tramite l'attributo  $config . La configurazione pu\u00f2 sovrascrivere i valori predefiniti impostati all'interno del costruttore.  Post-inizializzazione all'interno del metodo  init() . \u00c8 possibile sovrascrivere questo metodo per eseguire controlli di integrit\u00e0 e normalizzazione delle propriet\u00e0.  Chiamare il metodo relativo all'oggetto utilizzato.   I primi tre passaggi avvengono tutti all'interno del costruttore dell'oggetto. Ci\u00f2 significa che una volta ottenuta un'istanza di classe (cio\u00e8 un oggetto), quell'oggetto \u00e8 gi\u00e0 stato inizializzato in uno stato corretto e affidabile.",
            "title": "Componenti"
        },
        {
            "location": "/key-concepts/sub-properties/",
            "text": "Propriet\u00e0\n\n\nIn PHP, le variabili dei membri all'interno di una classe, sono anche chiamate \"propriet\u00e0\". Queste variabili fanno parte della definizione di classe e sono utilizzate per rappresentare lo stato di un'istanza di classe (ad esempio, per differenziare un'istanza della classe da un'altra). In pratica, potresti spesso voler gestire la lettura o la scrittura di propriet\u00e0 in modi speciali. Ad esempio, si consiglia di tagliare sempre una stringa quando viene assegnata a una propriet\u00e0 \nlabel\n. \u00c8 possibile utilizzare il codice seguente per ottenere questo compito:\n\n\n$object-\nlabel = trim($label);\n\n\n\nLo svantaggio del codice precedente \u00e8 che dovresti chiamare \ntrim()\n ovunque nel tuo codice, dove potresti impostare la propriet\u00e0 \nlabel\n. Se, in futuro, questa propriet\u00e0 ottiene un nuovo requisito, ad esempio la prima lettera deve essere in maiuscolo, sar\u00e0 necessario modificare nuovamente ogni bit di codice a cui viene assegnato un valore label. La ripetizione del codice porta a bug ed \u00e8 una pratica che si vuole evitare il pi\u00f9 possibile.\n\n\nPer risolvere questo problema, Yii introduce una classe base chiamata \nyii \\ base \\ BaseObject\n che supporta la definizione delle propriet\u00e0 basate sui metodi delle classi getter e setter. Se una classe ha bisogno di quella funzionalit\u00e0, dovrebbe estendersi da \nyii \\ base \\ BaseObject\n o da una classe figlio.\n\n\nUn metodo getter \u00e8 un metodo il cui nome inizia con la parola \nget\n; un metodo setter inizia con \nset\n. Il nome dopo il prefisso get o set definisce il nome di una propriet\u00e0. Ad esempio, un getter \ngetLabel()\n e / o un setter \nsetLabel()\n definisce una propriet\u00e0 denominata label, come mostrato nel seguente codice:\n\n\nnamespace app\\components;\n\nuse yii\\base\\BaseObject;\n\nclass Foo extends BaseObject{\n\n    private $_label;\n\n    public function getLabel(){\n\n        return $this-\n_label;\n    }\n\n    public function setLabel($value){\n\n        $this-\n_label = trim($value);\n    }\n}\n\n\n\nPer essere chiari, i metodi getter e setter creano la propriet\u00e0 label, che in questo caso si riferisce internamente a una propriet\u00e0 privata denominata \n_label\n.\n\n\nLe propriet\u00e0 definite da getter e setter possono essere utilizzate come le variabili dei membri della classe. La differenza principale \u00e8 che quando tale propriet\u00e0 viene letta, verr\u00e0 chiamato il metodo getter corrispondente; quando alla propriet\u00e0 viene assegnato un valore, verr\u00e0 chiamato il metodo setter corrispondente. Per esempio:\n\n\n// equivalent to $label = $object-\ngetLabel();\n$label = $object-\nlabel;\n\n// equivalent to $object-\nsetLabel('abc');\n$object-\nlabel = 'abc';\n\n\n\nUna propriet\u00e0 definita da un getter senza setter \u00e8 di sola lettura . Provare ad assegnare un valore a tale propriet\u00e0 causer\u00e0 un'eccezione come \nInvalidCallException\n. Allo stesso modo, una propriet\u00e0 definita da un setter senza un getter \u00e8 solo scrivibile, e il tentativo di leggere tale propriet\u00e0 causer\u00e0 anche un'eccezione. Non \u00e8 comune avere propriet\u00e0 di sola scrittura.\n\n\nEsistono diverse regole speciali per e limitazioni sulle propriet\u00e0 definite dai getter e setter:\n\n\n\n\nI nomi di tali propriet\u00e0 sono case-insensitive. Ad esempio, \n$object-\nlabel\ne \n$object-\nLabel\n sono uguali. Questo perch\u00e9 i nomi dei metodi in PHP non fanno distinzione tra maiuscole e minuscole.\n\n\nSe il nome di tale propriet\u00e0 \u00e8 uguale a una variabile di una classe, quest'ultimo avr\u00e0 la precedenza. Ad esempio, se la classe precedente \nFoo\n ha una variabile \nlabel\n, l'assegnazione \n$object-\nlabel = 'abc'\n interesser\u00e0 la variabile membro label ; quella linea non chiamerebbe il metodo setter \nsetLabel()\n.\n\n\nQueste propriet\u00e0 non supportano la visibilit\u00e0. Non fa alcuna differenza con il metodo getter o setter definitivo se la propriet\u00e0 \u00e8 pubblica, protetta o privata.\n\n\nLe propriet\u00e0 possono essere definite solo da getter non statici e / o setter. I metodi statici non saranno trattati allo stesso modo.\n\n\nUna normale chiamata a \nproperty_exists()\n non funziona per determinare le propriet\u00e0 magiche. Dovresti chiamare rispettivamente \ncanGetProperty()\n o \ncanSetProperty()\n.\n\n\n\n\nRitornando al problema descritto all'inizio di questa guida, invece di chiamare \ntrim()\n ovunque, deve essere richiamato solo nel setter \nsetLabel()\n. E se un nuovo requisito rende necessario che l'etichetta sia inizialmente in maiuscolo, il metodo \nsetLabel()\n pu\u00f2 essere rapidamente modificato senza toccare alcun altro codice. L'unico cambiamento riguarder\u00e0 universalmente ogni incarico label.",
            "title": "Propriet\u00e0"
        },
        {
            "location": "/key-concepts/sub-properties/#proprieta",
            "text": "In PHP, le variabili dei membri all'interno di una classe, sono anche chiamate \"propriet\u00e0\". Queste variabili fanno parte della definizione di classe e sono utilizzate per rappresentare lo stato di un'istanza di classe (ad esempio, per differenziare un'istanza della classe da un'altra). In pratica, potresti spesso voler gestire la lettura o la scrittura di propriet\u00e0 in modi speciali. Ad esempio, si consiglia di tagliare sempre una stringa quando viene assegnata a una propriet\u00e0  label . \u00c8 possibile utilizzare il codice seguente per ottenere questo compito:  $object- label = trim($label);  Lo svantaggio del codice precedente \u00e8 che dovresti chiamare  trim()  ovunque nel tuo codice, dove potresti impostare la propriet\u00e0  label . Se, in futuro, questa propriet\u00e0 ottiene un nuovo requisito, ad esempio la prima lettera deve essere in maiuscolo, sar\u00e0 necessario modificare nuovamente ogni bit di codice a cui viene assegnato un valore label. La ripetizione del codice porta a bug ed \u00e8 una pratica che si vuole evitare il pi\u00f9 possibile.  Per risolvere questo problema, Yii introduce una classe base chiamata  yii \\ base \\ BaseObject  che supporta la definizione delle propriet\u00e0 basate sui metodi delle classi getter e setter. Se una classe ha bisogno di quella funzionalit\u00e0, dovrebbe estendersi da  yii \\ base \\ BaseObject  o da una classe figlio.  Un metodo getter \u00e8 un metodo il cui nome inizia con la parola  get ; un metodo setter inizia con  set . Il nome dopo il prefisso get o set definisce il nome di una propriet\u00e0. Ad esempio, un getter  getLabel()  e / o un setter  setLabel()  definisce una propriet\u00e0 denominata label, come mostrato nel seguente codice:  namespace app\\components;\n\nuse yii\\base\\BaseObject;\n\nclass Foo extends BaseObject{\n\n    private $_label;\n\n    public function getLabel(){\n\n        return $this- _label;\n    }\n\n    public function setLabel($value){\n\n        $this- _label = trim($value);\n    }\n}  Per essere chiari, i metodi getter e setter creano la propriet\u00e0 label, che in questo caso si riferisce internamente a una propriet\u00e0 privata denominata  _label .  Le propriet\u00e0 definite da getter e setter possono essere utilizzate come le variabili dei membri della classe. La differenza principale \u00e8 che quando tale propriet\u00e0 viene letta, verr\u00e0 chiamato il metodo getter corrispondente; quando alla propriet\u00e0 viene assegnato un valore, verr\u00e0 chiamato il metodo setter corrispondente. Per esempio:  // equivalent to $label = $object- getLabel();\n$label = $object- label;\n\n// equivalent to $object- setLabel('abc');\n$object- label = 'abc';  Una propriet\u00e0 definita da un getter senza setter \u00e8 di sola lettura . Provare ad assegnare un valore a tale propriet\u00e0 causer\u00e0 un'eccezione come  InvalidCallException . Allo stesso modo, una propriet\u00e0 definita da un setter senza un getter \u00e8 solo scrivibile, e il tentativo di leggere tale propriet\u00e0 causer\u00e0 anche un'eccezione. Non \u00e8 comune avere propriet\u00e0 di sola scrittura.  Esistono diverse regole speciali per e limitazioni sulle propriet\u00e0 definite dai getter e setter:   I nomi di tali propriet\u00e0 sono case-insensitive. Ad esempio,  $object- label e  $object- Label  sono uguali. Questo perch\u00e9 i nomi dei metodi in PHP non fanno distinzione tra maiuscole e minuscole.  Se il nome di tale propriet\u00e0 \u00e8 uguale a una variabile di una classe, quest'ultimo avr\u00e0 la precedenza. Ad esempio, se la classe precedente  Foo  ha una variabile  label , l'assegnazione  $object- label = 'abc'  interesser\u00e0 la variabile membro label ; quella linea non chiamerebbe il metodo setter  setLabel() .  Queste propriet\u00e0 non supportano la visibilit\u00e0. Non fa alcuna differenza con il metodo getter o setter definitivo se la propriet\u00e0 \u00e8 pubblica, protetta o privata.  Le propriet\u00e0 possono essere definite solo da getter non statici e / o setter. I metodi statici non saranno trattati allo stesso modo.  Una normale chiamata a  property_exists()  non funziona per determinare le propriet\u00e0 magiche. Dovresti chiamare rispettivamente  canGetProperty()  o  canSetProperty() .   Ritornando al problema descritto all'inizio di questa guida, invece di chiamare  trim()  ovunque, deve essere richiamato solo nel setter  setLabel() . E se un nuovo requisito rende necessario che l'etichetta sia inizialmente in maiuscolo, il metodo  setLabel()  pu\u00f2 essere rapidamente modificato senza toccare alcun altro codice. L'unico cambiamento riguarder\u00e0 universalmente ogni incarico label.",
            "title": "Propriet\u00e0"
        },
        {
            "location": "/key-concepts/sub-events/",
            "text": "Eventi\n\n\nGli eventi consentono di inserire codice personalizzato nel codice esistente in determinati punti di esecuzione. \u00c8 possibile associare un codice personalizzato a un evento in modo che quando viene attivato l'evento, il codice venga eseguito automaticamente. Ad esempio, un oggetto \nmailer\n pu\u00f2 attivare un evento \nmessageSent\n quando invia correttamente un messaggio. Se si desidera tenere traccia dei messaggi inviati correttamente, \u00e8 possibile semplicemente allegare il codice di monitoraggio all'evento \nmessageSent\n.\n\n\nYii introduce una classe base chiamata \nyii \\ base \\ Component\n per supportare gli eventi. Se una classe ha bisogno di attivare eventi, dovrebbe estendersi da \nyii \\ base \\ Component\n o da una classe figlio.\n\n\nGestore degli eventi\n\n\nUn gestore di eventi \u00e8 un \ncallback PHP\n che viene eseguito quando viene attivato l'evento a cui \u00e8 collegato. \u00c8 possibile utilizzare uno dei seguenti callback:\n\n\n\n\nuna funzione PHP globale specificata come una stringa (senza parentesi), ad esempio \n'trim'\n;\n\n\nun metodo oggetto specificato come matrice di un oggetto e un nome di metodo come una stringa (senza parentesi), ad esempio \n[$object, 'methodName']\n;\n\n\nun metodo di classe statica specificato come matrice di un nome di classe e un nome di metodo come una stringa (senza parentesi), ad esempio \n['ClassName', 'methodName']\n;\n\n\nuna funzione anonima, ad es \nfunction ($event) { ... }\n.\n\n\n\n\nLa firma di un gestore di eventi \u00e8:\n\n\nfunction ($event) {\n    // $event is an object of yii\\base\\Event or a child class\n}\n\n\n\nAttraverso il paraemtro \n$event\n, un gestore di eventi pu\u00f2 ottenere le seguenti informazioni sull'evento che si \u00e8 verificato:\n\n\n\n\nnome dell'evento;\n\n\nmittente dell'evento: l'oggetto che chiama il metodo \ntrigger()\n;\n\n\ndati personalizzati: i dati che vengono forniti quando si collega il gestore degli eventi (spiegato in seguito).\n\n\n\n\nAssociazione tra gestori di eventi\n\n\n\u00c8 possibile associare un gestore a un evento chiamando il metodo \nyii \\ base \\ Component :: on ()\n. Per esempio:\n\n\n$foo = new Foo;\n\n// this handler is a global function\n$foo-\non(Foo::EVENT_HELLO, 'function_name');\n\n// this handler is an object method\n$foo-\non(Foo::EVENT_HELLO, [$object, 'methodName']);\n\n// this handler is a static class method\n$foo-\non(Foo::EVENT_HELLO, ['app\\components\\Bar', 'methodName']);\n\n// this handler is an anonymous function\n$foo-\non(Foo::EVENT_HELLO, function ($event) {\n    // event handling logic\n});\n\n\n\n\u00c8 inoltre possibile associare gestori di eventi tramite configurazioni.\n\n\nQuando si allega un gestore di eventi, \u00e8 possibile fornire dati aggiuntivi come un terzo parametro per \nyii \\ base \\ Component :: on()\n. I dati saranno resi disponibili al gestore quando l'evento viene attivato e il gestore viene chiamato. Per esempio:\n\n\n// The following code will display \"abc\" when the event is triggered\n// because $event-\ndata contains the data passed as the 3rd argument to \"on\"\n$foo-\non(Foo::EVENT_HELLO, 'function_name', 'abc');\n\nfunction function_name($event) {\n    echo $event-\ndata;\n}\n\n\n\nOrdine del gestore di eventi\n\n\nPuoi associare uno o pi\u00f9 gestori a un singolo evento. Quando viene attivato un evento, i gestori collegati verranno richiamati nell'ordine in cui sono stati associati all'evento. Se un gestore deve interrompere l'invocazione dei gestori che lo seguono, pu\u00f2 impostare la propriet\u00e0 manipolata \nyii \\ base \\ Event :: $\n del parametro \n$event\n con il valore  \ntrue\n:\n\n\n$foo-\non(Foo::EVENT_HELLO, function ($event) {\n    $event-\nhandled = true;\n});\n\n\n\nPer impostazione predefinita, un gestore appena collegato viene aggiunto alla coda del gestore esistente per l'evento. Di conseguenza, il gestore verr\u00e0 chiamato all'ultimo posto quando viene attivato l'evento. Per inserire il nuovo gestore all'inizio della coda del gestore in modo che il gestore venga chiamato per primo, puoi chiamare \nyii \\ base \\ Component :: on()\n, passando il valore \nfalse\n per il quarto parametro \n$append\n:\n\n\n$foo-\non(Foo::EVENT_HELLO, function ($event) {\n    // ...\n}, $data, false);\n\n\n\nEventi Triggering\n\n\nGli eventi Triggering vengono attivati \u200b\u200bchiamando il metodo \nyii \\ base \\ Component :: trigger()\n. Il metodo richiede un nome evento e facoltativamente un oggetto evento che descrive i parametri da passare ai gestori eventi. Per esempio:\n\n\nnamespace app\\components;\n\nuse yii\\base\\Component;\nuse yii\\base\\Event;\n\nclass Foo extends Component{\n\n    const EVENT_HELLO = 'hello';\n\n    public function bar(){\n\n        $this-\ntrigger(self::EVENT_HELLO);\n    }\n}\n\n\n\nCon il codice precedente, tutte le chiamate a \nbar()\n faranno scattare un evento chiamato \nhello\n.\n\n\n\n\nTip\n\n\nSi consiglia di utilizzare le costanti di classe per rappresentare i nomi degli eventi. Nell'esempio sopra, la costante \nEVENT_HELLO\n rappresenta l'evento \nhello\n. Questo approccio ha tre vantaggi. In primo luogo, impedisce errori di battitura. In secondo luogo, pu\u00f2 rendere gli eventi riconoscibili per il supporto di completamento automatico IDE. Terzo, puoi dire quali eventi sono supportati in una classe semplicemente controllando le sue dichiarazioni costanti.\n\n\n\n\nA volte, quando si attiva un evento, \u00e8 possibile passare informazioni aggiuntive ai gestori di eventi. Ad esempio, un mailer potrebbe voler passare le informazioni del messaggio ai gestori dell'evento \nmessageSent\n in modo che possano conoscere i dettagli dei messaggi inviati. Per fare ci\u00f2, \u00e8 possibile fornire un oggetto evento come secondo parametro al metodo \nyii \\ base \\ Component :: trigger()\n. L'oggetto evento deve essere un'istanza della classe \nyii \\ base \\ Event\n o di una classe figlio. Per esempio:\n\n\nnamespace app\\components;\n\nuse yii\\base\\Component;\nuse yii\\base\\Event;\n\nclass MessageEvent extends Event{\n\n    public $message;\n}\n\nclass Mailer extends Component{\n\n    const EVENT_MESSAGE_SENT = 'messageSent';\n\n    public function send($message){\n\n        // ...sending $message...\n\n        $event = new MessageEvent;\n        $event-\nmessage = $message;\n        $this-\ntrigger(self::EVENT_MESSAGE_SENT, $event);\n    }\n}\n\n\n\nQuando viene chiamato il metodo \nyii \\ base \\ Component :: trigger()\n, chiamer\u00e0 tutti i gestori collegati all'evento denominato.\n\n\nScollegare i gestori degli eventi\n\n\nPer scollegare un gestore da un evento, chiamare il metodo \nyii \\ base \\ Component :: off()\n. Per esempio:\n\n\n// the handler is a global function\n$foo-\noff(Foo::EVENT_HELLO, 'function_name');\n\n// the handler is an object method\n$foo-\noff(Foo::EVENT_HELLO, [$object, 'methodName']);\n\n// the handler is a static class method\n$foo-\noff(Foo::EVENT_HELLO, ['app\\components\\Bar', 'methodName']);\n\n// the handler is an anonymous function\n$foo-\noff(Foo::EVENT_HELLO, $anonymousFunction);\n\n\n\nSi noti che in generale non si dovrebbe provare a staccare una funzione anonima a meno che non la si memorizzi da qualche parte quando \u00e8 collegata all'evento. Nell'esempio sopra, si presume che la funzione anonima sia memorizzata come variabile \n$anonymousFunction\n.\n\n\nPer rimuovere tutti i gestori da un evento, \u00e8 sufficiente chiamare \nyii \\ base \\ Component :: off()\n senza il secondo parametro:\n\n\n$foo-\noff(Foo::EVENT_HELLO);\n\n\n\nGestori di eventi al livello di una classe\n\n\nLe sottosezioni sopra descritte descrivono come allegare un gestore a un evento a livello di un'istanza. A volte, potresti voler rispondere a un evento attivato da ogni istanza di una classe anzich\u00e9 solo da un'istanza specifica. Invece di collegare un gestore di eventi a ogni istanza, \u00e8 possibile associare il gestore a livello di classe chiamando il metodo statico \nyii \\ base \\ Event :: on ()\n.\n\n\nAd esempio, un oggetto \nActiveRecord\n attiver\u00e0 un evento \nEVENT_AFTER_INSERT\n ogni volta che inserisce un nuovo record nel database. Per tenere traccia degli inserimenti effettuati da ogni oggetto Active Record, \u00e8 possibile utilizzare il seguente codice:\n\n\nuse Yii;\nuse yii\\base\\Event;\nuse yii\\db\\ActiveRecord;\n\nEvent::on(ActiveRecord::className(), ActiveRecord::EVENT_AFTER_INSERT, function ($event) {\n    Yii::trace(get_class($event-\nsender) . ' is inserted');\n});\n\n\n\nIl gestore eventi verr\u00e0 richiamato ogni volta che un'istanza di ActiveRecord (o una delle sue classi secondarie) attiva l' evento \nEVENT_AFTER_INSERT\n. Nel gestore, puoi ottenere l'oggetto che ha attivato l'evento \n$event-\nsender\n.\n\n\nQuando un oggetto attiva un evento, chiamer\u00e0 prima i gestori a livello di istanza, seguiti dai gestori a livello di classe.\n\n\n\u00c8 possibile attivare un evento a livello di classe chiamando il metodo statico \nyii \\ base \\ Event :: trigger()\n. Un evento a livello di classe non \u00e8 associato a un particolare oggetto. Di conseguenza, causer\u00e0 solo l'invocazione di gestori di eventi a livello di classe. Per esempio:\n\n\nuse yii\\base\\Event;\n\nEvent::on(Foo::className(), Foo::EVENT_HELLO, function ($event) {\n    var_dump($event-\nsender);  // displays \"null\"\n});\n\nEvent::trigger(Foo::className(), Foo::EVENT_HELLO);\n\n\n\nNota che, in questo caso, l'\n$event-\nsender\n \u00e8 posto a \nnull\n all'interno dell'istanza dell'oggetto stesso.\n\n\n\n\nWarning\n\n\nPoich\u00e9 un gestore a livello di classe risponder\u00e0 a un evento attivato da qualsiasi istanza di quella classe, o qualsiasi classe figlia, dovresti usarlo attentamente, specialmente se la classe \u00e8 una classe base di basso livello, come \nyii \\ base \\ BaseObject\n.\n\n\n\n\nPer scollegare un gestore di eventi a livello di classe, chiamare \nyii \\ base \\ Event :: off ()\n. Per esempio:\n\n\n// detach $handler\nEvent::off(Foo::className(), Foo::EVENT_HELLO, $handler);\n\n// detach all handlers of Foo::EVENT_HELLO\nEvent::off(Foo::className(), Foo::EVENT_HELLO);\n\n\n\nEventi che utilizzano le interfacce\n\n\nC'\u00e8 anche un modo pi\u00f9 astratto per gestire gli eventi. Puoi creare un'interfaccia separata per l'evento speciale e implementarla nelle classi, dove ne hai bisogno.\n\n\nAd esempio, possiamo creare la seguente interfaccia:\n\n\nnamespace app\\interfaces;\n\ninterface DanceEventInterface{\n\n    const EVENT_DANCE = 'dance';\n}\n\n\n\nE due classi, che lo implementano:\n\n\nclass Dog extends Component implements DanceEventInterface{\n\n    public function meetBuddy(){\n\n        echo \"Woof!\";\n        $this-\ntrigger(DanceEventInterface::EVENT_DANCE);\n    }\n}\n\nclass Developer extends Component implements DanceEventInterface{\n\n    public function testsPassed(){\n\n        echo \"Nau!\";\n        $this-\ntrigger(DanceEventInterface::EVENT_DANCE);\n    }\n}\n\n\n\nPer gestire l'evento \nEVENT_DANCE\n, attivato da una di queste classi, chiamare \nEvent :: on()\n e passare il nome della classe dell'interfaccia come primo argomento:\n\n\nEvent::on('app\\interfaces\\DanceEventInterface', DanceEventInterface::EVENT_DANCE, function ($event) {\n    Yii::trace(get_class($event-\nsender) . ' just danced'); // Will log that Dog or Developer danced\n});\n\n\n\nPuoi attivare l'evento di tali classi:\n\n\n// trigger event for Dog class\nEvent::trigger(Dog::className(), DanceEventInterface::EVENT_DANCE);\n\n// trigger event for Developer class\nEvent::trigger(Developer::className(), DanceEventInterface::EVENT_DANCE);\n\n\n\nMa si noti che non \u00e8 possibile attivare tutte le classi che implementano l'interfaccia:\n\n\n// DOES NOT WORK. Classes that implement this interface will NOT be triggered.\nEvent::trigger('app\\interfaces\\DanceEventInterface', DanceEventInterface::EVENT_DANCE);\n\n\n\nPer staccare il gestore di eventi, dovrete chiamare il metodo \nEvent :: off()\n. Per esempio:\n\n\n// detaches $handler\nEvent::off('app\\interfaces\\DanceEventInterface', DanceEventInterface::EVENT_DANCE, $handler);\n\n// detaches all handlers of DanceEventInterface::EVENT_DANCE\nEvent::off('app\\interfaces\\DanceEventInterface', DanceEventInterface::EVENT_DANCE);\n\n\n\nEventi globali\n\n\nYii supporta un cosiddetto evento globale, che in realt\u00e0 \u00e8 un trucco basato sul meccanismo degli eventi descritto sopra. L'evento globale richiede un \"Singleton\" accessibile a livello globale, come l' istanza dell'applicazione stessa.\n\n\nPer creare l'evento globale, un mittente dell'evento chiama il metodo Singleton \ntrigger()\n per attivare l'evento, invece di chiamare il metodo \ntrigger()\n del mittente . Allo stesso modo, i gestori di eventi sono collegati all'evento sul Singleton. Per esempio:\n\n\nuse Yii;\nuse yii\\base\\Event;\nuse app\\components\\Foo;\n\nYii::$app-\non('bar', function ($event) {\n    echo get_class($event-\nsender);  // displays \"app\\components\\Foo\"\n});\n\nYii::$app-\ntrigger('bar', new Event(['sender' =\n new Foo]));\n\n\n\nUn vantaggio dell'utilizzo di eventi globali \u00e8 che non \u00e8 necessario un oggetto quando si collega un gestore all'evento che verr\u00e0 attivato dall'oggetto. Invece, l'allegato del gestore e l'attivazione dell'evento vengono entrambi eseguiti tramite Singleton (ad esempio l'istanza dell'applicazione).\n\n\nTuttavia, poich\u00e9 lo spazio dei nomi degli eventi globali \u00e8 condiviso da tutte le parti, \u00e8 necessario nominare saggiamente gli eventi globali, ad esempio introducendo una sorta di spazio dei nomi (ad esempio \"frontend.mail.sent\", \"backend.mail.sent\").",
            "title": "Eventi"
        },
        {
            "location": "/key-concepts/sub-events/#eventi",
            "text": "Gli eventi consentono di inserire codice personalizzato nel codice esistente in determinati punti di esecuzione. \u00c8 possibile associare un codice personalizzato a un evento in modo che quando viene attivato l'evento, il codice venga eseguito automaticamente. Ad esempio, un oggetto  mailer  pu\u00f2 attivare un evento  messageSent  quando invia correttamente un messaggio. Se si desidera tenere traccia dei messaggi inviati correttamente, \u00e8 possibile semplicemente allegare il codice di monitoraggio all'evento  messageSent .  Yii introduce una classe base chiamata  yii \\ base \\ Component  per supportare gli eventi. Se una classe ha bisogno di attivare eventi, dovrebbe estendersi da  yii \\ base \\ Component  o da una classe figlio.",
            "title": "Eventi"
        },
        {
            "location": "/key-concepts/sub-events/#gestore-degli-eventi",
            "text": "Un gestore di eventi \u00e8 un  callback PHP  che viene eseguito quando viene attivato l'evento a cui \u00e8 collegato. \u00c8 possibile utilizzare uno dei seguenti callback:   una funzione PHP globale specificata come una stringa (senza parentesi), ad esempio  'trim' ;  un metodo oggetto specificato come matrice di un oggetto e un nome di metodo come una stringa (senza parentesi), ad esempio  [$object, 'methodName'] ;  un metodo di classe statica specificato come matrice di un nome di classe e un nome di metodo come una stringa (senza parentesi), ad esempio  ['ClassName', 'methodName'] ;  una funzione anonima, ad es  function ($event) { ... } .   La firma di un gestore di eventi \u00e8:  function ($event) {\n    // $event is an object of yii\\base\\Event or a child class\n}  Attraverso il paraemtro  $event , un gestore di eventi pu\u00f2 ottenere le seguenti informazioni sull'evento che si \u00e8 verificato:   nome dell'evento;  mittente dell'evento: l'oggetto che chiama il metodo  trigger() ;  dati personalizzati: i dati che vengono forniti quando si collega il gestore degli eventi (spiegato in seguito).",
            "title": "Gestore degli eventi"
        },
        {
            "location": "/key-concepts/sub-events/#associazione-tra-gestori-di-eventi",
            "text": "\u00c8 possibile associare un gestore a un evento chiamando il metodo  yii \\ base \\ Component :: on () . Per esempio:  $foo = new Foo;\n\n// this handler is a global function\n$foo- on(Foo::EVENT_HELLO, 'function_name');\n\n// this handler is an object method\n$foo- on(Foo::EVENT_HELLO, [$object, 'methodName']);\n\n// this handler is a static class method\n$foo- on(Foo::EVENT_HELLO, ['app\\components\\Bar', 'methodName']);\n\n// this handler is an anonymous function\n$foo- on(Foo::EVENT_HELLO, function ($event) {\n    // event handling logic\n});  \u00c8 inoltre possibile associare gestori di eventi tramite configurazioni.  Quando si allega un gestore di eventi, \u00e8 possibile fornire dati aggiuntivi come un terzo parametro per  yii \\ base \\ Component :: on() . I dati saranno resi disponibili al gestore quando l'evento viene attivato e il gestore viene chiamato. Per esempio:  // The following code will display \"abc\" when the event is triggered\n// because $event- data contains the data passed as the 3rd argument to \"on\"\n$foo- on(Foo::EVENT_HELLO, 'function_name', 'abc');\n\nfunction function_name($event) {\n    echo $event- data;\n}",
            "title": "Associazione tra gestori di eventi"
        },
        {
            "location": "/key-concepts/sub-events/#ordine-del-gestore-di-eventi",
            "text": "Puoi associare uno o pi\u00f9 gestori a un singolo evento. Quando viene attivato un evento, i gestori collegati verranno richiamati nell'ordine in cui sono stati associati all'evento. Se un gestore deve interrompere l'invocazione dei gestori che lo seguono, pu\u00f2 impostare la propriet\u00e0 manipolata  yii \\ base \\ Event :: $  del parametro  $event  con il valore   true :  $foo- on(Foo::EVENT_HELLO, function ($event) {\n    $event- handled = true;\n});  Per impostazione predefinita, un gestore appena collegato viene aggiunto alla coda del gestore esistente per l'evento. Di conseguenza, il gestore verr\u00e0 chiamato all'ultimo posto quando viene attivato l'evento. Per inserire il nuovo gestore all'inizio della coda del gestore in modo che il gestore venga chiamato per primo, puoi chiamare  yii \\ base \\ Component :: on() , passando il valore  false  per il quarto parametro  $append :  $foo- on(Foo::EVENT_HELLO, function ($event) {\n    // ...\n}, $data, false);",
            "title": "Ordine del gestore di eventi"
        },
        {
            "location": "/key-concepts/sub-events/#eventi-triggering",
            "text": "Gli eventi Triggering vengono attivati \u200b\u200bchiamando il metodo  yii \\ base \\ Component :: trigger() . Il metodo richiede un nome evento e facoltativamente un oggetto evento che descrive i parametri da passare ai gestori eventi. Per esempio:  namespace app\\components;\n\nuse yii\\base\\Component;\nuse yii\\base\\Event;\n\nclass Foo extends Component{\n\n    const EVENT_HELLO = 'hello';\n\n    public function bar(){\n\n        $this- trigger(self::EVENT_HELLO);\n    }\n}  Con il codice precedente, tutte le chiamate a  bar()  faranno scattare un evento chiamato  hello .   Tip  Si consiglia di utilizzare le costanti di classe per rappresentare i nomi degli eventi. Nell'esempio sopra, la costante  EVENT_HELLO  rappresenta l'evento  hello . Questo approccio ha tre vantaggi. In primo luogo, impedisce errori di battitura. In secondo luogo, pu\u00f2 rendere gli eventi riconoscibili per il supporto di completamento automatico IDE. Terzo, puoi dire quali eventi sono supportati in una classe semplicemente controllando le sue dichiarazioni costanti.   A volte, quando si attiva un evento, \u00e8 possibile passare informazioni aggiuntive ai gestori di eventi. Ad esempio, un mailer potrebbe voler passare le informazioni del messaggio ai gestori dell'evento  messageSent  in modo che possano conoscere i dettagli dei messaggi inviati. Per fare ci\u00f2, \u00e8 possibile fornire un oggetto evento come secondo parametro al metodo  yii \\ base \\ Component :: trigger() . L'oggetto evento deve essere un'istanza della classe  yii \\ base \\ Event  o di una classe figlio. Per esempio:  namespace app\\components;\n\nuse yii\\base\\Component;\nuse yii\\base\\Event;\n\nclass MessageEvent extends Event{\n\n    public $message;\n}\n\nclass Mailer extends Component{\n\n    const EVENT_MESSAGE_SENT = 'messageSent';\n\n    public function send($message){\n\n        // ...sending $message...\n\n        $event = new MessageEvent;\n        $event- message = $message;\n        $this- trigger(self::EVENT_MESSAGE_SENT, $event);\n    }\n}  Quando viene chiamato il metodo  yii \\ base \\ Component :: trigger() , chiamer\u00e0 tutti i gestori collegati all'evento denominato.",
            "title": "Eventi Triggering"
        },
        {
            "location": "/key-concepts/sub-events/#scollegare-i-gestori-degli-eventi",
            "text": "Per scollegare un gestore da un evento, chiamare il metodo  yii \\ base \\ Component :: off() . Per esempio:  // the handler is a global function\n$foo- off(Foo::EVENT_HELLO, 'function_name');\n\n// the handler is an object method\n$foo- off(Foo::EVENT_HELLO, [$object, 'methodName']);\n\n// the handler is a static class method\n$foo- off(Foo::EVENT_HELLO, ['app\\components\\Bar', 'methodName']);\n\n// the handler is an anonymous function\n$foo- off(Foo::EVENT_HELLO, $anonymousFunction);  Si noti che in generale non si dovrebbe provare a staccare una funzione anonima a meno che non la si memorizzi da qualche parte quando \u00e8 collegata all'evento. Nell'esempio sopra, si presume che la funzione anonima sia memorizzata come variabile  $anonymousFunction .  Per rimuovere tutti i gestori da un evento, \u00e8 sufficiente chiamare  yii \\ base \\ Component :: off()  senza il secondo parametro:  $foo- off(Foo::EVENT_HELLO);",
            "title": "Scollegare i gestori degli eventi"
        },
        {
            "location": "/key-concepts/sub-events/#gestori-di-eventi-al-livello-di-una-classe",
            "text": "Le sottosezioni sopra descritte descrivono come allegare un gestore a un evento a livello di un'istanza. A volte, potresti voler rispondere a un evento attivato da ogni istanza di una classe anzich\u00e9 solo da un'istanza specifica. Invece di collegare un gestore di eventi a ogni istanza, \u00e8 possibile associare il gestore a livello di classe chiamando il metodo statico  yii \\ base \\ Event :: on () .  Ad esempio, un oggetto  ActiveRecord  attiver\u00e0 un evento  EVENT_AFTER_INSERT  ogni volta che inserisce un nuovo record nel database. Per tenere traccia degli inserimenti effettuati da ogni oggetto Active Record, \u00e8 possibile utilizzare il seguente codice:  use Yii;\nuse yii\\base\\Event;\nuse yii\\db\\ActiveRecord;\n\nEvent::on(ActiveRecord::className(), ActiveRecord::EVENT_AFTER_INSERT, function ($event) {\n    Yii::trace(get_class($event- sender) . ' is inserted');\n});  Il gestore eventi verr\u00e0 richiamato ogni volta che un'istanza di ActiveRecord (o una delle sue classi secondarie) attiva l' evento  EVENT_AFTER_INSERT . Nel gestore, puoi ottenere l'oggetto che ha attivato l'evento  $event- sender .  Quando un oggetto attiva un evento, chiamer\u00e0 prima i gestori a livello di istanza, seguiti dai gestori a livello di classe.  \u00c8 possibile attivare un evento a livello di classe chiamando il metodo statico  yii \\ base \\ Event :: trigger() . Un evento a livello di classe non \u00e8 associato a un particolare oggetto. Di conseguenza, causer\u00e0 solo l'invocazione di gestori di eventi a livello di classe. Per esempio:  use yii\\base\\Event;\n\nEvent::on(Foo::className(), Foo::EVENT_HELLO, function ($event) {\n    var_dump($event- sender);  // displays \"null\"\n});\n\nEvent::trigger(Foo::className(), Foo::EVENT_HELLO);  Nota che, in questo caso, l' $event- sender  \u00e8 posto a  null  all'interno dell'istanza dell'oggetto stesso.   Warning  Poich\u00e9 un gestore a livello di classe risponder\u00e0 a un evento attivato da qualsiasi istanza di quella classe, o qualsiasi classe figlia, dovresti usarlo attentamente, specialmente se la classe \u00e8 una classe base di basso livello, come  yii \\ base \\ BaseObject .   Per scollegare un gestore di eventi a livello di classe, chiamare  yii \\ base \\ Event :: off () . Per esempio:  // detach $handler\nEvent::off(Foo::className(), Foo::EVENT_HELLO, $handler);\n\n// detach all handlers of Foo::EVENT_HELLO\nEvent::off(Foo::className(), Foo::EVENT_HELLO);",
            "title": "Gestori di eventi al livello di una classe"
        },
        {
            "location": "/key-concepts/sub-events/#eventi-che-utilizzano-le-interfacce",
            "text": "C'\u00e8 anche un modo pi\u00f9 astratto per gestire gli eventi. Puoi creare un'interfaccia separata per l'evento speciale e implementarla nelle classi, dove ne hai bisogno.  Ad esempio, possiamo creare la seguente interfaccia:  namespace app\\interfaces;\n\ninterface DanceEventInterface{\n\n    const EVENT_DANCE = 'dance';\n}  E due classi, che lo implementano:  class Dog extends Component implements DanceEventInterface{\n\n    public function meetBuddy(){\n\n        echo \"Woof!\";\n        $this- trigger(DanceEventInterface::EVENT_DANCE);\n    }\n}\n\nclass Developer extends Component implements DanceEventInterface{\n\n    public function testsPassed(){\n\n        echo \"Nau!\";\n        $this- trigger(DanceEventInterface::EVENT_DANCE);\n    }\n}  Per gestire l'evento  EVENT_DANCE , attivato da una di queste classi, chiamare  Event :: on()  e passare il nome della classe dell'interfaccia come primo argomento:  Event::on('app\\interfaces\\DanceEventInterface', DanceEventInterface::EVENT_DANCE, function ($event) {\n    Yii::trace(get_class($event- sender) . ' just danced'); // Will log that Dog or Developer danced\n});  Puoi attivare l'evento di tali classi:  // trigger event for Dog class\nEvent::trigger(Dog::className(), DanceEventInterface::EVENT_DANCE);\n\n// trigger event for Developer class\nEvent::trigger(Developer::className(), DanceEventInterface::EVENT_DANCE);  Ma si noti che non \u00e8 possibile attivare tutte le classi che implementano l'interfaccia:  // DOES NOT WORK. Classes that implement this interface will NOT be triggered.\nEvent::trigger('app\\interfaces\\DanceEventInterface', DanceEventInterface::EVENT_DANCE);  Per staccare il gestore di eventi, dovrete chiamare il metodo  Event :: off() . Per esempio:  // detaches $handler\nEvent::off('app\\interfaces\\DanceEventInterface', DanceEventInterface::EVENT_DANCE, $handler);\n\n// detaches all handlers of DanceEventInterface::EVENT_DANCE\nEvent::off('app\\interfaces\\DanceEventInterface', DanceEventInterface::EVENT_DANCE);",
            "title": "Eventi che utilizzano le interfacce"
        },
        {
            "location": "/key-concepts/sub-events/#eventi-globali",
            "text": "Yii supporta un cosiddetto evento globale, che in realt\u00e0 \u00e8 un trucco basato sul meccanismo degli eventi descritto sopra. L'evento globale richiede un \"Singleton\" accessibile a livello globale, come l' istanza dell'applicazione stessa.  Per creare l'evento globale, un mittente dell'evento chiama il metodo Singleton  trigger()  per attivare l'evento, invece di chiamare il metodo  trigger()  del mittente . Allo stesso modo, i gestori di eventi sono collegati all'evento sul Singleton. Per esempio:  use Yii;\nuse yii\\base\\Event;\nuse app\\components\\Foo;\n\nYii::$app- on('bar', function ($event) {\n    echo get_class($event- sender);  // displays \"app\\components\\Foo\"\n});\n\nYii::$app- trigger('bar', new Event(['sender' =  new Foo]));  Un vantaggio dell'utilizzo di eventi globali \u00e8 che non \u00e8 necessario un oggetto quando si collega un gestore all'evento che verr\u00e0 attivato dall'oggetto. Invece, l'allegato del gestore e l'attivazione dell'evento vengono entrambi eseguiti tramite Singleton (ad esempio l'istanza dell'applicazione).  Tuttavia, poich\u00e9 lo spazio dei nomi degli eventi globali \u00e8 condiviso da tutte le parti, \u00e8 necessario nominare saggiamente gli eventi globali, ad esempio introducendo una sorta di spazio dei nomi (ad esempio \"frontend.mail.sent\", \"backend.mail.sent\").",
            "title": "Eventi globali"
        },
        {
            "location": "/key-concepts/sub-behaviors/",
            "text": "Comportamenti (Behaviors)\n\n\nI comportamenti ( o Behaviors) sono istanze di \nyii \\ base \\ Behavior\n o di una classe figlio. I comportamenti, noti anche come \"mixins\", consentono di migliorare la funzionalit\u00e0 di una classe che ha componenti gi\u00e0 esistenti, senza dover modificare l'ereditariet\u00e0 della classe stessa. Il collegamento di un behaviors a un componente, \"inietta\" i metodi e le propriet\u00e0 del comportamento stesso nel componente, rendendo accessibili tali metodi e propriet\u00e0 come se fossero definiti nella classe del componente stesso. Inoltre, un comportamento pu\u00f2 rispondere agli eventi innescati dal componente che gli consente di personalizzare la normale esecuzione del codice.\n\n\nDefinizione dei comportamenti\n\n\nPer definire un comportamento, dobbiamo creare una classe che estende \nyii \\ base \\ Behavior\n oppure che venga estesa da una classe figlio.\n\n\nPer esempio:\n\n\nnamespace app\\components;\n\nuse yii\\base\\Behavior;\n\nclass MyBehavior extends Behavior{\n\n    public $prop1;\n\n    private $_prop2;\n\n    public function getProp2(){\n\n        return $this-\n_prop2;\n    }\n\n    public function setProp2($value){\n\n        $this-\n_prop2 = $value;\n    }\n\n    public function foo(){\n\n        // ...\n    }\n}\n\n\n\nIl codice soprastante, definisce la classe di comportamento \napp\\components\\MyBehavior\n, con due propriet\u00e0 - \nprop1\n e \nprop2\n - e un metodo \nfoo()\n. Nota che la propriet\u00e0 \nprop2\n \u00e8 definita tramite il getter \ngetProp2()\n e il setter \nsetProp2()\n. Questo \u00e8 il caso in cui \nyii \\ base \\ Behavior\n estende \nyii \\ base \\ BaseObject\n e quindi supporta la definizione delle propriet\u00e0 tramite getter e setter.\n\n\nPoich\u00e9 questa classe \u00e8 un comportamento, quando \u00e8 attaccato ad un componente, questo avr\u00e0 quindi anche le propriet\u00e0 \nprop1\n e \nprop2\n e il metodo \nfoo()\n.\n\n\n\n\nTip\n\n\nAll'interno di un comportamento, \u00e8 possibile accedere al componente a cui \u00e8 collegato il comportamento tramite la propriet\u00e0 \nyii \\ base \\ Behavior :: $ owner\n.\n\n\n\n\n\n\nWarning\n\n\nNel caso in cui il metodo di comportamento \nyii \\ base \\ Behavior :: __ get ()\n e / o \nyii \\ base \\ Behavior :: __ set()\n sia sovrascritto, \u00e8 necessario eseguire l'override di \nyii \\ base \\ Behavior :: canGetProperty()\n e / o \nyii \\ base \\ Behavior :: canSetProperty()\n.\n\n\n\n\nGestione degli eventi nei componenti\n\n\nSe un comportamento deve rispondere agli eventi innnescati dal componente a cui \u00e8 collegato, dovrebbe sovrascrivere il metodo \nyii \\ base \\ Behavior :: events()\n.\n\n\nPer esempio:\n\n\nnamespace app\\components;\n\nuse yii\\db\\ActiveRecord;\nuse yii\\base\\Behavior;\n\nclass MyBehavior extends Behavior{\n\n    // ...\n\n    public function events(){\n\n        return [\n            ActiveRecord::EVENT_BEFORE_VALIDATE =\n 'beforeValidate',\n        ];\n    }\n\n    public function beforeValidate($event){\n\n        // ...\n    }\n}\n\n\n\nIl metodo \nevents()\n dovrebbe restituire un elenco di eventi e i relativi gestori. L'esempio scritto sopra, dichiara che  l'evento \nl'EVENT_BEFORE_VALIDATE\n esiste e definisce il suo gestore, \nbeforeValidate()\n. Quando si specifica un gestore di eventi, \u00e8 possibile utilizzare uno dei seguenti formati:\n\n\n\n\nuna stringa che fa riferimento al nome di un metodo della classe di un comportamento, come nell'esempio precedente.\n\n\nuna matrice di un oggetto o nome di classe e un nome di un metodo come una stringa (senza parentesi), ad esempio \n[$object, 'methodName']\n.\n\n\nuna funziona anonima.\n\n\n\n\nLa firma di un gestore d ieventi dovrebbe essere la seguente, dove l'evento \n$event\n si riferisce al parametro dell'evento stesso.\n\n\nfunction ($event) {\n}\n\n\n\nAllegare i comportamenti\n\n\nE' possibile associare un comportamento a un cmoponente in modo statico o dinamico. Il primo \u00e8 il pi\u00f9 comune.\n\n\nPer associare staticamente un comportamento, eseguire l'override del metodo \nbehaviors()\n della classe del componente a cui \u00e8 collegato il comportamento. Il metodo \nbehavior()\n dovrebbe restituire un elenco di configurazioni di comportamento. Ogni configurazione di comportamento pu\u00f2 essere un nome di classe di comportamento o un array di configurazione:\n\n\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\nuse app\\components\\MyBehavior;\n\nclass User extends ActiveRecord{\n\n    public function behaviors(){\n\n        return [\n            // anonymous behavior, behavior class name only\n            MyBehavior::className(),\n\n            // named behavior, behavior class name only\n            'myBehavior2' =\n MyBehavior::className(),\n\n            // anonymous behavior, configuration array\n            [\n                'class' =\n MyBehavior::className(),\n                'prop1' =\n 'value1',\n                'prop2' =\n 'value2',\n            ],\n\n            // named behavior, configuration array\n            'myBehavior4' =\n [\n                'class' =\n MyBehavior::className(),\n                'prop1' =\n 'value1',\n                'prop2' =\n 'value2',\n            ]\n        ];\n    }\n}\n\n\n\n\u00c8 possibile associare un nome a un comportamento specificando la chiave dell'array corrispondente alla configurazione del suo comportamento. In questo caso, il comportamento \u00e8 chiamato \"comportamento denominato\". Nell'esempio fatto sopra, ci sono due comportamenti denominati: \nmyBehavior2\n e \nmyBehavior4\n. Se un comportamento non \u00e8 associato a un nome, viene chiamato comportamento anonimo.\n\n\nPer allegare un comportamento in modo dinamico, chiamare il metodo \nyii \\ base \\ Component :: attachBehavior()\n del componente a cui viene collegato il comportamento:\n\n\nuse app\\components\\MyBehavior;\n\n// attach a behavior object\n$component-\nattachBehavior('myBehavior1', new MyBehavior);\n\n// attach a behavior class\n$component-\nattachBehavior('myBehavior2', MyBehavior::className());\n\n// attach a configuration array\n$component-\nattachBehavior('myBehavior3', [\n    'class' =\n MyBehavior::className(),\n    'prop1' =\n 'value1',\n    'prop2' =\n 'value2',\n]);\n\n\n\nPuoi collegare pi\u00f9 comportamenti contemporaneamente usando il metodo \nyii \\ base \\ Component :: attachBehaviors()\n:\n\n\n$component-\nattachBehaviors([\n    'myBehavior1' =\n new MyBehavior,  // a named behavior\n    MyBehavior::className(),          // an anonymous behavior  \n]);\n\n\n\nE' inoltre possibile allegare comportamenti tramite configurazioni, come la seguente:\n\n\n[\n    'as myBehavior2' =\n MyBehavior::className(),\n\n    'as myBehavior3' =\n [\n        'class' =\n MyBehavior::className(),\n        'prop1' =\n 'value1',\n        'prop2' =\n 'value2',\n    ],\n]\n\n\n\nUso dei comportamenti\n\n\nPer usare un comportamento, per prima cosa dobbiamo collegarlo a un componente, seguendo le istruzioni elencate sopra. Una volta che un comportamento \u00e8 collegato a un componente, il suo utilizzo \u00e8 immediato.\n\n\nE' possibile accedere a una variabile membro \"pubblica\" o a una propriet\u00e0 definita da un getter e / o setter del comportamento tramite il componente a cui \u00e8 collegato:\n\n\n// \"prop1\" is a property defined in the behavior class\necho $component-\nprop1;\n$component-\nprop1 = $value;\n\n\n\nPuoi anche chiamare un metodo pubblico del comportamento, come segue:\n\n\n// foo() is a public method defined in the behavior class\n$component-\nfoo();\n\n\n\nCome puoi vedere, anche \n$component\n se non definisce \nprop1\n e \nfoo()\n, possono essere utilizzati come se facessero parte della definizione del componente a causa del comportamento allegato.\n\n\nSe due comportamenti definiscono una stessa propriet\u00e0 o metodo e sono entrambi collegati alla stessa componente, il comportamento che \u00e8 collegato al componente, prima prevarr\u00e0 quando la propriet\u00e0 o il metodo verr\u00e0 effettuato l'accesso.\n\n\nUn comportamento pu\u00f2 essere associato a un nome quando \u00e8 collegato a un componente. Se questo \u00e8 il caso, puoi accedere all'oggetto comportamentale usando il nome:\n\n\n$behavior = $component-\ngetBehavior('myBehavior');\n\n\n\nPuoi anche ottenere tutti i comportamenti collegati a un determinato componente:\n\n\n$behaviors = $component-\ngetBehaviors();\n\n\n\nScollegare i comportamenti\n\n\nPer scollegare un comportamento, dobbiamo chiamare \nyii \\ base \\ Component :: detachBehavior ()\n con il nome associato al comportamento:\n\n\n$component-\ndetachBehavior('myBehavior1');\n\n\n\nPuoi anche scollegare tutti i comportamenti:\n\n\n$component-\ndetachBehaviors();\n\n\n\nUtilizzo di \nTimestampBehavior\n\n\nPer concludere, diamo un'occhiata a \nyii \\ behaviors \\ TimestampBehavior\n. Questo comportamento supporta l'aggiornamento automatico degli attributi di timestamp relativo ad un modello di record attivo. Ogni volta che il modello viene salvato tramite il metodo \ninsert()\n, \nupdate()\n o \nsave()\n.\n\n\nInnanzitutto, allega questo comportamento alla classe \nActiveRecord\n che prevedi di utilizzare:\n\n\nnamespace app\\models\\User;\n\nuse yii\\db\\ActiveRecord;\nuse yii\\behaviors\\TimestampBehavior;\n\nclass User extends ActiveRecord{\n\n    // ...\n\n    public function behaviors(){\n\n        return [\n            [\n                'class' =\n TimestampBehavior::className(),\n                'attributes' =\n [\n                    ActiveRecord::EVENT_BEFORE_INSERT =\n ['created_at', 'updated_at'],\n                    ActiveRecord::EVENT_BEFORE_UPDATE =\n ['updated_at'],\n                ],\n                // if you're using datetime instead of UNIX timestamp:\n                // 'value' =\n new Expression('NOW()'),\n            ],\n        ];\n    }\n}\n\n\n\nCon questo codice in atto, se si dispone di un oggetto \nUser\n e si tenta di salvarlo, lo si trover\u00e0 \ncreated_at\n e \nupdated_at\n verranno automaticamente riempito con il timestamp UNIX corrente:\n\n\n$user = new User;\n$user-\nemail = 'test@example.com';\n$user-\nsave();\necho $user-\ncreated_at;  // shows the current timestamp\n\n\n\nIl \nTimestampBehavior\n offre anche un metodo utile \ntouch()\n, che assegner\u00e0 il timestamp corrente a un attributo specificato e lo salver\u00e0 nel database:\n\n\n$user-\ntouch('login_time');\n\n\n\nAltri comportamenti\n\n\nSono disponibili diversi comportamenti interni ed esterni:\n\n\n\n\nyii \\ behaviors \\ BlameableBehavior\n: riempie automaticamente gli attributi specificati con l'ID utente corrente.\n\n\nyii \\ behaviors \\ SluggableBehavior\n: riempie automaticamente l'attributo specificato con un valore che pu\u00f2 essere utilizzato come slug in un URL.\n\n\nyii \\ behaviors \\ AttributeBehavior\n: assegna automaticamente un valore specificato a uno o pi\u00f9 attributi di un oggetto ActiveRecord quando si verificano determinati eventi.\n\n\nyii2tech \\ ar \\ softdelete \\ SoftDeleteBehavior\n - fornisce metodi per l'eliminazione soft e il ripristino graduale di ActiveRecord, ovvero imposta flag o stato che contrassegna il record come eliminato.\n\n\nyii2tech \\ ar \\ position \\ PositionBehavior\n - consente di gestire l'ordine dei record in un campo intero fornendo metodi di riordino.\n\n\n\n\nConfronto tra Behaviors e Traits (comportamenti e tratti)\n\n\nSebbene i Behaviors siano simili ai Traits in quanto entrambi \"iniettano\" le loro propriet\u00e0 e i loro metodi nella classe primaria, differiscono in molti aspetti. Come spiegato di seguito, entrambi hanno pro e contro. Sono pi\u00f9 simili ai complementi l'un l'altro piuttosto che alle alternative.\n\n\nRagioni per usare i Behaviors\n\n\nLe classi Behaviors, come le normali classi, supportano l'ereditariet\u00e0. I Traits, d'altra parte, possono essere considerati copia e incolla supportati dalla lingua. Non supportano l'ereditariet\u00e0.\n\n\nI Behaviors possono essere collegati e scollegati a un componente in modo dinamico senza richiedere modifiche della classe del componente. Per utilizzare un Trait, \u00e8 necessario modificare il codice della classe che lo utilizza.\n\n\nI Behaviors sono configurabili mentre i Traits non lo sono.\n\n\nI Behaviors possono personalizzare l'esecuzione del codice di un componente rispondendo ai suoi eventi.\n\n\nQuando possono esserci conflitti di nomi tra diversi Behaviors collegati allo stesso componente, i conflitti vengono risolti automaticamente dando la precedenza al comportamento collegato al componente. I conflitti di nome causati da diversi caratteri richiedono la risoluzione manuale rinominando le propriet\u00e0 oi metodi interessati.\n\n\nRagioni per usare i Traits\n\n\nI Traits sono molto pi\u00f9 efficienti dei comportamenti in quanto i comportamenti sono oggetti che richiedono tempo e memoria.\n\n\nGli IDE sono pi\u00f9 amichevoli ai Traits in quanto sono un costrutto di madrelingua.",
            "title": "Comportamenti (Behaviors)"
        },
        {
            "location": "/key-concepts/sub-behaviors/#comportamenti-behaviors",
            "text": "I comportamenti ( o Behaviors) sono istanze di  yii \\ base \\ Behavior  o di una classe figlio. I comportamenti, noti anche come \"mixins\", consentono di migliorare la funzionalit\u00e0 di una classe che ha componenti gi\u00e0 esistenti, senza dover modificare l'ereditariet\u00e0 della classe stessa. Il collegamento di un behaviors a un componente, \"inietta\" i metodi e le propriet\u00e0 del comportamento stesso nel componente, rendendo accessibili tali metodi e propriet\u00e0 come se fossero definiti nella classe del componente stesso. Inoltre, un comportamento pu\u00f2 rispondere agli eventi innescati dal componente che gli consente di personalizzare la normale esecuzione del codice.",
            "title": "Comportamenti (Behaviors)"
        },
        {
            "location": "/key-concepts/sub-behaviors/#definizione-dei-comportamenti",
            "text": "Per definire un comportamento, dobbiamo creare una classe che estende  yii \\ base \\ Behavior  oppure che venga estesa da una classe figlio.  Per esempio:  namespace app\\components;\n\nuse yii\\base\\Behavior;\n\nclass MyBehavior extends Behavior{\n\n    public $prop1;\n\n    private $_prop2;\n\n    public function getProp2(){\n\n        return $this- _prop2;\n    }\n\n    public function setProp2($value){\n\n        $this- _prop2 = $value;\n    }\n\n    public function foo(){\n\n        // ...\n    }\n}  Il codice soprastante, definisce la classe di comportamento  app\\components\\MyBehavior , con due propriet\u00e0 -  prop1  e  prop2  - e un metodo  foo() . Nota che la propriet\u00e0  prop2  \u00e8 definita tramite il getter  getProp2()  e il setter  setProp2() . Questo \u00e8 il caso in cui  yii \\ base \\ Behavior  estende  yii \\ base \\ BaseObject  e quindi supporta la definizione delle propriet\u00e0 tramite getter e setter.  Poich\u00e9 questa classe \u00e8 un comportamento, quando \u00e8 attaccato ad un componente, questo avr\u00e0 quindi anche le propriet\u00e0  prop1  e  prop2  e il metodo  foo() .   Tip  All'interno di un comportamento, \u00e8 possibile accedere al componente a cui \u00e8 collegato il comportamento tramite la propriet\u00e0  yii \\ base \\ Behavior :: $ owner .    Warning  Nel caso in cui il metodo di comportamento  yii \\ base \\ Behavior :: __ get ()  e / o  yii \\ base \\ Behavior :: __ set()  sia sovrascritto, \u00e8 necessario eseguire l'override di  yii \\ base \\ Behavior :: canGetProperty()  e / o  yii \\ base \\ Behavior :: canSetProperty() .",
            "title": "Definizione dei comportamenti"
        },
        {
            "location": "/key-concepts/sub-behaviors/#gestione-degli-eventi-nei-componenti",
            "text": "Se un comportamento deve rispondere agli eventi innnescati dal componente a cui \u00e8 collegato, dovrebbe sovrascrivere il metodo  yii \\ base \\ Behavior :: events() .  Per esempio:  namespace app\\components;\n\nuse yii\\db\\ActiveRecord;\nuse yii\\base\\Behavior;\n\nclass MyBehavior extends Behavior{\n\n    // ...\n\n    public function events(){\n\n        return [\n            ActiveRecord::EVENT_BEFORE_VALIDATE =  'beforeValidate',\n        ];\n    }\n\n    public function beforeValidate($event){\n\n        // ...\n    }\n}  Il metodo  events()  dovrebbe restituire un elenco di eventi e i relativi gestori. L'esempio scritto sopra, dichiara che  l'evento  l'EVENT_BEFORE_VALIDATE  esiste e definisce il suo gestore,  beforeValidate() . Quando si specifica un gestore di eventi, \u00e8 possibile utilizzare uno dei seguenti formati:   una stringa che fa riferimento al nome di un metodo della classe di un comportamento, come nell'esempio precedente.  una matrice di un oggetto o nome di classe e un nome di un metodo come una stringa (senza parentesi), ad esempio  [$object, 'methodName'] .  una funziona anonima.   La firma di un gestore d ieventi dovrebbe essere la seguente, dove l'evento  $event  si riferisce al parametro dell'evento stesso.  function ($event) {\n}",
            "title": "Gestione degli eventi nei componenti"
        },
        {
            "location": "/key-concepts/sub-behaviors/#allegare-i-comportamenti",
            "text": "E' possibile associare un comportamento a un cmoponente in modo statico o dinamico. Il primo \u00e8 il pi\u00f9 comune.  Per associare staticamente un comportamento, eseguire l'override del metodo  behaviors()  della classe del componente a cui \u00e8 collegato il comportamento. Il metodo  behavior()  dovrebbe restituire un elenco di configurazioni di comportamento. Ogni configurazione di comportamento pu\u00f2 essere un nome di classe di comportamento o un array di configurazione:  namespace app\\models;\n\nuse yii\\db\\ActiveRecord;\nuse app\\components\\MyBehavior;\n\nclass User extends ActiveRecord{\n\n    public function behaviors(){\n\n        return [\n            // anonymous behavior, behavior class name only\n            MyBehavior::className(),\n\n            // named behavior, behavior class name only\n            'myBehavior2' =  MyBehavior::className(),\n\n            // anonymous behavior, configuration array\n            [\n                'class' =  MyBehavior::className(),\n                'prop1' =  'value1',\n                'prop2' =  'value2',\n            ],\n\n            // named behavior, configuration array\n            'myBehavior4' =  [\n                'class' =  MyBehavior::className(),\n                'prop1' =  'value1',\n                'prop2' =  'value2',\n            ]\n        ];\n    }\n}  \u00c8 possibile associare un nome a un comportamento specificando la chiave dell'array corrispondente alla configurazione del suo comportamento. In questo caso, il comportamento \u00e8 chiamato \"comportamento denominato\". Nell'esempio fatto sopra, ci sono due comportamenti denominati:  myBehavior2  e  myBehavior4 . Se un comportamento non \u00e8 associato a un nome, viene chiamato comportamento anonimo.  Per allegare un comportamento in modo dinamico, chiamare il metodo  yii \\ base \\ Component :: attachBehavior()  del componente a cui viene collegato il comportamento:  use app\\components\\MyBehavior;\n\n// attach a behavior object\n$component- attachBehavior('myBehavior1', new MyBehavior);\n\n// attach a behavior class\n$component- attachBehavior('myBehavior2', MyBehavior::className());\n\n// attach a configuration array\n$component- attachBehavior('myBehavior3', [\n    'class' =  MyBehavior::className(),\n    'prop1' =  'value1',\n    'prop2' =  'value2',\n]);  Puoi collegare pi\u00f9 comportamenti contemporaneamente usando il metodo  yii \\ base \\ Component :: attachBehaviors() :  $component- attachBehaviors([\n    'myBehavior1' =  new MyBehavior,  // a named behavior\n    MyBehavior::className(),          // an anonymous behavior  \n]);  E' inoltre possibile allegare comportamenti tramite configurazioni, come la seguente:  [\n    'as myBehavior2' =  MyBehavior::className(),\n\n    'as myBehavior3' =  [\n        'class' =  MyBehavior::className(),\n        'prop1' =  'value1',\n        'prop2' =  'value2',\n    ],\n]",
            "title": "Allegare i comportamenti"
        },
        {
            "location": "/key-concepts/sub-behaviors/#uso-dei-comportamenti",
            "text": "Per usare un comportamento, per prima cosa dobbiamo collegarlo a un componente, seguendo le istruzioni elencate sopra. Una volta che un comportamento \u00e8 collegato a un componente, il suo utilizzo \u00e8 immediato.  E' possibile accedere a una variabile membro \"pubblica\" o a una propriet\u00e0 definita da un getter e / o setter del comportamento tramite il componente a cui \u00e8 collegato:  // \"prop1\" is a property defined in the behavior class\necho $component- prop1;\n$component- prop1 = $value;  Puoi anche chiamare un metodo pubblico del comportamento, come segue:  // foo() is a public method defined in the behavior class\n$component- foo();  Come puoi vedere, anche  $component  se non definisce  prop1  e  foo() , possono essere utilizzati come se facessero parte della definizione del componente a causa del comportamento allegato.  Se due comportamenti definiscono una stessa propriet\u00e0 o metodo e sono entrambi collegati alla stessa componente, il comportamento che \u00e8 collegato al componente, prima prevarr\u00e0 quando la propriet\u00e0 o il metodo verr\u00e0 effettuato l'accesso.  Un comportamento pu\u00f2 essere associato a un nome quando \u00e8 collegato a un componente. Se questo \u00e8 il caso, puoi accedere all'oggetto comportamentale usando il nome:  $behavior = $component- getBehavior('myBehavior');  Puoi anche ottenere tutti i comportamenti collegati a un determinato componente:  $behaviors = $component- getBehaviors();",
            "title": "Uso dei comportamenti"
        },
        {
            "location": "/key-concepts/sub-behaviors/#scollegare-i-comportamenti",
            "text": "Per scollegare un comportamento, dobbiamo chiamare  yii \\ base \\ Component :: detachBehavior ()  con il nome associato al comportamento:  $component- detachBehavior('myBehavior1');  Puoi anche scollegare tutti i comportamenti:  $component- detachBehaviors();",
            "title": "Scollegare i comportamenti"
        },
        {
            "location": "/key-concepts/sub-behaviors/#utilizzo-di-timestampbehavior",
            "text": "Per concludere, diamo un'occhiata a  yii \\ behaviors \\ TimestampBehavior . Questo comportamento supporta l'aggiornamento automatico degli attributi di timestamp relativo ad un modello di record attivo. Ogni volta che il modello viene salvato tramite il metodo  insert() ,  update()  o  save() .  Innanzitutto, allega questo comportamento alla classe  ActiveRecord  che prevedi di utilizzare:  namespace app\\models\\User;\n\nuse yii\\db\\ActiveRecord;\nuse yii\\behaviors\\TimestampBehavior;\n\nclass User extends ActiveRecord{\n\n    // ...\n\n    public function behaviors(){\n\n        return [\n            [\n                'class' =  TimestampBehavior::className(),\n                'attributes' =  [\n                    ActiveRecord::EVENT_BEFORE_INSERT =  ['created_at', 'updated_at'],\n                    ActiveRecord::EVENT_BEFORE_UPDATE =  ['updated_at'],\n                ],\n                // if you're using datetime instead of UNIX timestamp:\n                // 'value' =  new Expression('NOW()'),\n            ],\n        ];\n    }\n}  Con questo codice in atto, se si dispone di un oggetto  User  e si tenta di salvarlo, lo si trover\u00e0  created_at  e  updated_at  verranno automaticamente riempito con il timestamp UNIX corrente:  $user = new User;\n$user- email = 'test@example.com';\n$user- save();\necho $user- created_at;  // shows the current timestamp  Il  TimestampBehavior  offre anche un metodo utile  touch() , che assegner\u00e0 il timestamp corrente a un attributo specificato e lo salver\u00e0 nel database:  $user- touch('login_time');",
            "title": "Utilizzo di TimestampBehavior"
        },
        {
            "location": "/key-concepts/sub-behaviors/#altri-comportamenti",
            "text": "Sono disponibili diversi comportamenti interni ed esterni:   yii \\ behaviors \\ BlameableBehavior : riempie automaticamente gli attributi specificati con l'ID utente corrente.  yii \\ behaviors \\ SluggableBehavior : riempie automaticamente l'attributo specificato con un valore che pu\u00f2 essere utilizzato come slug in un URL.  yii \\ behaviors \\ AttributeBehavior : assegna automaticamente un valore specificato a uno o pi\u00f9 attributi di un oggetto ActiveRecord quando si verificano determinati eventi.  yii2tech \\ ar \\ softdelete \\ SoftDeleteBehavior  - fornisce metodi per l'eliminazione soft e il ripristino graduale di ActiveRecord, ovvero imposta flag o stato che contrassegna il record come eliminato.  yii2tech \\ ar \\ position \\ PositionBehavior  - consente di gestire l'ordine dei record in un campo intero fornendo metodi di riordino.",
            "title": "Altri comportamenti"
        },
        {
            "location": "/key-concepts/sub-behaviors/#confronto-tra-behaviors-e-traits-comportamenti-e-tratti",
            "text": "Sebbene i Behaviors siano simili ai Traits in quanto entrambi \"iniettano\" le loro propriet\u00e0 e i loro metodi nella classe primaria, differiscono in molti aspetti. Come spiegato di seguito, entrambi hanno pro e contro. Sono pi\u00f9 simili ai complementi l'un l'altro piuttosto che alle alternative.",
            "title": "Confronto tra Behaviors e Traits (comportamenti e tratti)"
        },
        {
            "location": "/key-concepts/sub-behaviors/#ragioni-per-usare-i-behaviors",
            "text": "Le classi Behaviors, come le normali classi, supportano l'ereditariet\u00e0. I Traits, d'altra parte, possono essere considerati copia e incolla supportati dalla lingua. Non supportano l'ereditariet\u00e0.  I Behaviors possono essere collegati e scollegati a un componente in modo dinamico senza richiedere modifiche della classe del componente. Per utilizzare un Trait, \u00e8 necessario modificare il codice della classe che lo utilizza.  I Behaviors sono configurabili mentre i Traits non lo sono.  I Behaviors possono personalizzare l'esecuzione del codice di un componente rispondendo ai suoi eventi.  Quando possono esserci conflitti di nomi tra diversi Behaviors collegati allo stesso componente, i conflitti vengono risolti automaticamente dando la precedenza al comportamento collegato al componente. I conflitti di nome causati da diversi caratteri richiedono la risoluzione manuale rinominando le propriet\u00e0 oi metodi interessati.",
            "title": "Ragioni per usare i Behaviors"
        },
        {
            "location": "/key-concepts/sub-behaviors/#ragioni-per-usare-i-traits",
            "text": "I Traits sono molto pi\u00f9 efficienti dei comportamenti in quanto i comportamenti sono oggetti che richiedono tempo e memoria.  Gli IDE sono pi\u00f9 amichevoli ai Traits in quanto sono un costrutto di madrelingua.",
            "title": "Ragioni per usare i Traits"
        },
        {
            "location": "/key-concepts/sub-configurations/",
            "text": "Configurazioni\n\n\nLe configurazioni sono ampiamente utilizzate in Yii. Per esempio quando si creano nuovi oggetti o si inizializzano oggetti esistenti. Le configurazioni di solito includono il nome della classe dell'oggetto che si sta creando e un elenco di valori iniziali che dovrebbero essere assegnati alle propriet\u00e0 dell'oggetto. Le configurazioni possono anche includere un elenco di gestori che devono essere collegati agli eventi dell'oggetto e / o un elenco di comportamenti che devono essere collegati all'oggetto.\n\n\nDi seguito, viene utilizzata una configurazione per creare e inizializzare una connessione al database:\n\n\n$config = [\n    'class' =\n 'yii\\db\\Connection',\n    'dsn' =\n 'mysql:host=127.0.0.1;dbname=demo',\n    'username' =\n 'root',\n    'password' =\n '',\n    'charset' =\n 'utf8',\n];\n\n$db = Yii::createObject($config);\n\n\n\nIl metodo \nYii :: createObject()\n accetta un array di configurazione come argomento e crea un oggetto creando un'istanza della classe chiamata nella configurazione. Quando l'oggetto viene istanziato, il resto della configurazione verr\u00e0 utilizzato per inizializzare le propriet\u00e0 dell'oggetto, i gestori di eventi e i comportamenti.\n\n\nSe hai gi\u00e0 un oggetto, puoi usare \nYii :: configure()\n per inizializzare le propriet\u00e0 dell'oggetto con un array di configurazione:\n\n\nYii::configure($object, $config);\n\n\n\nSi noti che, in questo caso, l'array di configurazione non deve contenere un elemento \nclass\n.\n\n\nFormato delle configurazioni\n\n\nIl formato di una configurazione pu\u00f2 essere formalmente descritto come:\n\n\n[\n    'class' =\n 'ClassName',\n    'propertyName' =\n 'propertyValue',\n    'on eventName' =\n $eventHandler,\n    'as behaviorName' =\n $behaviorConfig,\n]\n\n\n\ndove:\n\n\n\n\nL'elemento \nclass\n specifica un nome di classe completo per l'oggetto che si sta creando;\n\n\nGli elementi \npropertyName\n specificano i valori iniziali per la propriet\u00e0 denominata. Le chiavi sono i nomi delle propriet\u00e0 e i valori sono i valori iniziali corrispondenti. Possono essere configurate solo variabili membro pubbliche e propriet\u00e0 definite da getter / setter.\n\n\nGli elementi \non eventName\n speicficano quali gestori devonon essere collegati agli eventi dell'oggetto. Si noti che le chiavi dell'array sono formate dal prefisso dei nomi degli eventi con \non\n. Fare riferimento alla sezione Eventi per i formati di gestori di eventi supportati.\n\n\nGli elementi \nas behaviorName\n specificano quali comportamenti devono essere collegati all'oggetto. Si noti che le chiavi dell'array sono formate dal prefisso dei nomi degli eventi con \nas\n; il valore, \n$behaviorConfig\n rappresenta la configurazione per la creazione di un comportamento, come una configurazione normale descritta qui.\n\n\n\n\nDi seguito \u00e8 riportato un esempio che mostra una configurazione con valori di proprit\u00e0 iniziali, gestori di eventi e comportamenti:\n\n\n[\n    'class' =\n 'app\\components\\SearchEngine',\n    'apiKey' =\n 'xxxxxxxx',\n    'on search' =\n function ($event) {\n        Yii::info(\"Keyword searched: \" . $event-\nkeyword);\n    },\n    'as indexer' =\n [\n        'class' =\n 'app\\components\\IndexerBehavior',\n        // ... property init values ...\n    ],\n]\n\n\n\nUtilizzo delle configurazioni\n\n\nLe configurazioni sono utilizzate in molti posti in Yii. All'inizio di questa sezione, abbiamo mostrato come creare un oggetto secondo una configurazione usando \nYii :: createObject()\n. In questa sottosezione, descriveremo le configurazioni delle applicazioni e le configurazioni dei widget: due importanti usi delle configurazioni.\n\n\nConfigurazioni dell'applicazione\n\n\nLa configurazione per un'applicazione \u00e8 probabilmente uno degli array pi\u00f9 complessi in Yii. Questo perch\u00e9 la classe dell'applicazione ha molte propriet\u00e0 ed eventi configurabili. Ancora pi\u00f9 importante, la sua propriet\u00e0 \nyii \\ web \\ Application :: components\n pu\u00f2 ricevere una serie di configurazioni per la creazione di componenti registrati tramite l'applicazione. Di seguito \u00e8 riportato un estratto dal file di configurazione dell'applicazione per il modello di progetto di base.\n\n\n$config = [\n    'id' =\n 'basic',\n    'basePath' =\n dirname(__DIR__),\n    'extensions' =\n require __DIR__ . '/../vendor/yiisoft/extensions.php',\n    'components' =\n [\n        'cache' =\n [\n            'class' =\n 'yii\\caching\\FileCache',\n        ],\n        'mailer' =\n [\n            'class' =\n 'yii\\swiftmailer\\Mailer',\n        ],\n        'log' =\n [\n            'class' =\n 'yii\\log\\Dispatcher',\n            'traceLevel' =\n YII_DEBUG ? 3 : 0,\n            'targets' =\n [\n                [\n                    'class' =\n 'yii\\log\\FileTarget',\n                ],\n            ],\n        ],\n        'db' =\n [\n            'class' =\n 'yii\\db\\Connection',\n            'dsn' =\n 'mysql:host=localhost;dbname=stay2',\n            'username' =\n 'root',\n            'password' =\n '',\n            'charset' =\n 'utf8',\n        ],\n    ],\n];\n\n\n\nLa configurazione non ha una chaive \nclass\n. Questo perch\u00e9 \u00e8 usato come segue in uno script di entrata, dove il nome della classe \u00e8 gi\u00e0 stato dato,\n\n\n(new yii\\web\\Application($config))-\nrun();\n\n\n\nDalla versione 2.0.11, la configurazione dell'applicazione supporta la configurazione del contenitore di iniezione delle dipendenze utilizzando la propriet\u00e0 \ncontainer\n. Per esempio:\n\n\n$config = [\n    'id' =\n 'basic',\n    'basePath' =\n dirname(__DIR__),\n    'extensions' =\n require __DIR__ . '/../vendor/yiisoft/extensions.php',\n    'container' =\n [\n        'definitions' =\n [\n            'yii\\widgets\\LinkPager' =\n ['maxButtonCount' =\n 5]\n        ],\n        'singletons' =\n [\n            // Dependency Injection Container singletons configuration\n        ]\n    ]\n];\n\n\n\nConfigurazioni di widget\n\n\nQuando si utilizzano i widget , \u00e8 spesso necessario utilizzare le configurazioni per personalizzare le propriet\u00e0 del widget. Entrambi i metodi \nyii \\ base \\ Widget :: widget()\n e \nyii \\ base \\ Widget :: begin()\n possono essere utilizzati per creare un widget. Prendono un array di configurazione, come il seguente,\n\n\nuse yii\\widgets\\Menu;\n\necho Menu::widget([\n    'activateItems' =\n false,\n    'items' =\n [\n        ['label' =\n 'Home', 'url' =\n ['site/index']],\n        ['label' =\n 'Products', 'url' =\n ['product/index']],\n        ['label' =\n 'Login', 'url' =\n ['site/login'], 'visible' =\n Yii::$app-\nuser-\nisGuest],\n    ],\n]);\n\n\n\nIl codice sopra crea un widget \nMenu\n e inizializza la sua propriet\u00e0 \nactivateItems\nal valore \nfalse\n. La propriet\u00e0 \nitems\n \u00e8 configurata anche con voci di menu da visualizzare.\n\n\nSi noti che poich\u00e8 il nome della classe \u00e8 gi\u00e0 stato dato, l'array di configurazione NON deve avere la chiave \nclass\n.\n\n\nFile di configurazione\n\n\nQuando una configurazione \u00e8 molto complessa, \u00e8 prassi comune memorizzarla in uno o pi\u00f9 file PHP, noti come file di configurazione. Un file di configurazione restituisce un array PHP che rappresenta la configurazione. Ad esempio, \u00e8 possibile mantenere una configurazione dell'applicazione in un file denominato \nweb.php\n, come il seguente,\n\n\nreturn [\n    'id' =\n 'basic',\n    'basePath' =\n dirname(__DIR__),\n    'extensions' =\n require __DIR__ . '/../vendor/yiisoft/extensions.php',\n    'components' =\n require __DIR__ . '/components.php',\n];\n\n\n\nPoich\u00e9 anche la configurazione \ncomponents\n \u00e8 complessa, la si archivia in un file separato chiamato \ncomponents.php\n e \"richiede\" questo file \nweb.php\n come mostrato sopra. Il contenuto di \ncomponents.php\n \u00e8 come segue,\n\n\nreturn [\n    'cache' =\n [\n        'class' =\n 'yii\\caching\\FileCache',\n    ],\n    'mailer' =\n [\n        'class' =\n 'yii\\swiftmailer\\Mailer',\n    ],\n    'log' =\n [\n        'class' =\n 'yii\\log\\Dispatcher',\n        'traceLevel' =\n YII_DEBUG ? 3 : 0,\n        'targets' =\n [\n            [\n                'class' =\n 'yii\\log\\FileTarget',\n            ],\n        ],\n    ],\n    'db' =\n [\n        'class' =\n 'yii\\db\\Connection',\n        'dsn' =\n 'mysql:host=localhost;dbname=stay2',\n        'username' =\n 'root',\n        'password' =\n '',\n        'charset' =\n 'utf8',\n    ],\n];\n\n\n\nPer ottenere una configurazione memorizzata in un file di configurazione, \u00e8 sufficiente \"richiederla\", come la seguente:\n\n\n$config = require 'path/to/web.php';\n(new yii\\web\\Application($config))-\nrun();\n\n\n\nConfigurazioni predefinite\n\n\nIl metodo \nYii :: createObject()\n \u00e8 implementato in base a un contenitore di input delle dipendenze. Ti consente di specificare un insieme di configurazioni predefinite che verranno applicate a TUTTE le istanze delle classi specificate quando vengono create utilizzando \nYii :: createObject()\n. Le configurazioni predefinite possono essere specificate chiamando \nYii::$container-\nset()\n nel codice di bootstrap.\n\n\nAd esempio, se si desidera personalizzare \nyii \\ widgets \\ LinkPager\n in modo che TUTTI i pager di collegamento mostrino al massimo 5 pulsanti di pagina (il valore predefinito \u00e8 10), \u00e8 possibile utilizzare il seguente codice per raggiungere questo obiettivo:\n\n\n\\Yii::$container-\nset('yii\\widgets\\LinkPager', [\n    'maxButtonCount' =\n 5,\n]);\n\n\n\nSenza usare le configurazioni di default, dovresti configurare \nmaxButtonCount\n in ogni posto dove usi i cercapersone.\n\n\nCostanti ambientali\n\n\nLe configurazioni variano spesso in base all'ambiente in cui viene eseguita un'applicazione. Ad esempio, nell'ambiente di sviluppo, potresti voler utilizzare un database chiamato \nmydb_dev\n, mentre sul server di produzione potresti voler utilizzare il \nmydb_prod\n database. Per facilitare gli ambienti di passaggio, Yii fornisce una costante denominata \nYII_ENV\n che \u00e8 possibile definire nello script di entrata della propria applicazione. Per esempio,\n\n\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n\n\nPuoi definire \nYII_ENV\n uno dei seguenti valori:\n\n\n\n\nprod\n: ambiente di produzione. La costante \nYII_ENV_PROD\n avr\u00e0 un valore \ntrue\n. Questo \u00e8 il valore predefinito di \nYII_ENV\n se non lo definisci.\n\n\ndev\n: sviluppo dell'ambiente di programmazione. La costante \nYII_ENV_DEV\n avr\u00e0 un valore \ntrue\n.\n\n\ntest\n: ambiente di test. La costante \nYII_ENV_TEST\n avr\u00e0 un valore \ntrue\n.\n\n\n\n\nCon queste costanti di ambiente, \u00e8 possibile specificare le configurazioni in modo condizionale in base all'ambiente corrente. Ad esempio, la configurazione dell'applicazione potrebbe contenere il seguente codice per abilitare la barra degli strumenti di debug e il debugger nell'ambiente di sviluppo.\n\n\n$config = [...];\n\nif (YII_ENV_DEV) {\n    // configuration adjustments for 'dev' environment\n    $config['bootstrap'][] = 'debug';\n    $config['modules']['debug'] = 'yii\\debug\\Module';\n}\n\nreturn $config;",
            "title": "Configurazioni"
        },
        {
            "location": "/key-concepts/sub-configurations/#configurazioni",
            "text": "Le configurazioni sono ampiamente utilizzate in Yii. Per esempio quando si creano nuovi oggetti o si inizializzano oggetti esistenti. Le configurazioni di solito includono il nome della classe dell'oggetto che si sta creando e un elenco di valori iniziali che dovrebbero essere assegnati alle propriet\u00e0 dell'oggetto. Le configurazioni possono anche includere un elenco di gestori che devono essere collegati agli eventi dell'oggetto e / o un elenco di comportamenti che devono essere collegati all'oggetto.  Di seguito, viene utilizzata una configurazione per creare e inizializzare una connessione al database:  $config = [\n    'class' =  'yii\\db\\Connection',\n    'dsn' =  'mysql:host=127.0.0.1;dbname=demo',\n    'username' =  'root',\n    'password' =  '',\n    'charset' =  'utf8',\n];\n\n$db = Yii::createObject($config);  Il metodo  Yii :: createObject()  accetta un array di configurazione come argomento e crea un oggetto creando un'istanza della classe chiamata nella configurazione. Quando l'oggetto viene istanziato, il resto della configurazione verr\u00e0 utilizzato per inizializzare le propriet\u00e0 dell'oggetto, i gestori di eventi e i comportamenti.  Se hai gi\u00e0 un oggetto, puoi usare  Yii :: configure()  per inizializzare le propriet\u00e0 dell'oggetto con un array di configurazione:  Yii::configure($object, $config);  Si noti che, in questo caso, l'array di configurazione non deve contenere un elemento  class .",
            "title": "Configurazioni"
        },
        {
            "location": "/key-concepts/sub-configurations/#formato-delle-configurazioni",
            "text": "Il formato di una configurazione pu\u00f2 essere formalmente descritto come:  [\n    'class' =  'ClassName',\n    'propertyName' =  'propertyValue',\n    'on eventName' =  $eventHandler,\n    'as behaviorName' =  $behaviorConfig,\n]  dove:   L'elemento  class  specifica un nome di classe completo per l'oggetto che si sta creando;  Gli elementi  propertyName  specificano i valori iniziali per la propriet\u00e0 denominata. Le chiavi sono i nomi delle propriet\u00e0 e i valori sono i valori iniziali corrispondenti. Possono essere configurate solo variabili membro pubbliche e propriet\u00e0 definite da getter / setter.  Gli elementi  on eventName  speicficano quali gestori devonon essere collegati agli eventi dell'oggetto. Si noti che le chiavi dell'array sono formate dal prefisso dei nomi degli eventi con  on . Fare riferimento alla sezione Eventi per i formati di gestori di eventi supportati.  Gli elementi  as behaviorName  specificano quali comportamenti devono essere collegati all'oggetto. Si noti che le chiavi dell'array sono formate dal prefisso dei nomi degli eventi con  as ; il valore,  $behaviorConfig  rappresenta la configurazione per la creazione di un comportamento, come una configurazione normale descritta qui.   Di seguito \u00e8 riportato un esempio che mostra una configurazione con valori di proprit\u00e0 iniziali, gestori di eventi e comportamenti:  [\n    'class' =  'app\\components\\SearchEngine',\n    'apiKey' =  'xxxxxxxx',\n    'on search' =  function ($event) {\n        Yii::info(\"Keyword searched: \" . $event- keyword);\n    },\n    'as indexer' =  [\n        'class' =  'app\\components\\IndexerBehavior',\n        // ... property init values ...\n    ],\n]",
            "title": "Formato delle configurazioni"
        },
        {
            "location": "/key-concepts/sub-configurations/#utilizzo-delle-configurazioni",
            "text": "Le configurazioni sono utilizzate in molti posti in Yii. All'inizio di questa sezione, abbiamo mostrato come creare un oggetto secondo una configurazione usando  Yii :: createObject() . In questa sottosezione, descriveremo le configurazioni delle applicazioni e le configurazioni dei widget: due importanti usi delle configurazioni.",
            "title": "Utilizzo delle configurazioni"
        },
        {
            "location": "/key-concepts/sub-configurations/#configurazioni-dellapplicazione",
            "text": "La configurazione per un'applicazione \u00e8 probabilmente uno degli array pi\u00f9 complessi in Yii. Questo perch\u00e9 la classe dell'applicazione ha molte propriet\u00e0 ed eventi configurabili. Ancora pi\u00f9 importante, la sua propriet\u00e0  yii \\ web \\ Application :: components  pu\u00f2 ricevere una serie di configurazioni per la creazione di componenti registrati tramite l'applicazione. Di seguito \u00e8 riportato un estratto dal file di configurazione dell'applicazione per il modello di progetto di base.  $config = [\n    'id' =  'basic',\n    'basePath' =  dirname(__DIR__),\n    'extensions' =  require __DIR__ . '/../vendor/yiisoft/extensions.php',\n    'components' =  [\n        'cache' =  [\n            'class' =  'yii\\caching\\FileCache',\n        ],\n        'mailer' =  [\n            'class' =  'yii\\swiftmailer\\Mailer',\n        ],\n        'log' =  [\n            'class' =  'yii\\log\\Dispatcher',\n            'traceLevel' =  YII_DEBUG ? 3 : 0,\n            'targets' =  [\n                [\n                    'class' =  'yii\\log\\FileTarget',\n                ],\n            ],\n        ],\n        'db' =  [\n            'class' =  'yii\\db\\Connection',\n            'dsn' =  'mysql:host=localhost;dbname=stay2',\n            'username' =  'root',\n            'password' =  '',\n            'charset' =  'utf8',\n        ],\n    ],\n];  La configurazione non ha una chaive  class . Questo perch\u00e9 \u00e8 usato come segue in uno script di entrata, dove il nome della classe \u00e8 gi\u00e0 stato dato,  (new yii\\web\\Application($config))- run();  Dalla versione 2.0.11, la configurazione dell'applicazione supporta la configurazione del contenitore di iniezione delle dipendenze utilizzando la propriet\u00e0  container . Per esempio:  $config = [\n    'id' =  'basic',\n    'basePath' =  dirname(__DIR__),\n    'extensions' =  require __DIR__ . '/../vendor/yiisoft/extensions.php',\n    'container' =  [\n        'definitions' =  [\n            'yii\\widgets\\LinkPager' =  ['maxButtonCount' =  5]\n        ],\n        'singletons' =  [\n            // Dependency Injection Container singletons configuration\n        ]\n    ]\n];",
            "title": "Configurazioni dell'applicazione"
        },
        {
            "location": "/key-concepts/sub-configurations/#configurazioni-di-widget",
            "text": "Quando si utilizzano i widget , \u00e8 spesso necessario utilizzare le configurazioni per personalizzare le propriet\u00e0 del widget. Entrambi i metodi  yii \\ base \\ Widget :: widget()  e  yii \\ base \\ Widget :: begin()  possono essere utilizzati per creare un widget. Prendono un array di configurazione, come il seguente,  use yii\\widgets\\Menu;\n\necho Menu::widget([\n    'activateItems' =  false,\n    'items' =  [\n        ['label' =  'Home', 'url' =  ['site/index']],\n        ['label' =  'Products', 'url' =  ['product/index']],\n        ['label' =  'Login', 'url' =  ['site/login'], 'visible' =  Yii::$app- user- isGuest],\n    ],\n]);  Il codice sopra crea un widget  Menu  e inizializza la sua propriet\u00e0  activateItems al valore  false . La propriet\u00e0  items  \u00e8 configurata anche con voci di menu da visualizzare.  Si noti che poich\u00e8 il nome della classe \u00e8 gi\u00e0 stato dato, l'array di configurazione NON deve avere la chiave  class .",
            "title": "Configurazioni di widget"
        },
        {
            "location": "/key-concepts/sub-configurations/#file-di-configurazione",
            "text": "Quando una configurazione \u00e8 molto complessa, \u00e8 prassi comune memorizzarla in uno o pi\u00f9 file PHP, noti come file di configurazione. Un file di configurazione restituisce un array PHP che rappresenta la configurazione. Ad esempio, \u00e8 possibile mantenere una configurazione dell'applicazione in un file denominato  web.php , come il seguente,  return [\n    'id' =  'basic',\n    'basePath' =  dirname(__DIR__),\n    'extensions' =  require __DIR__ . '/../vendor/yiisoft/extensions.php',\n    'components' =  require __DIR__ . '/components.php',\n];  Poich\u00e9 anche la configurazione  components  \u00e8 complessa, la si archivia in un file separato chiamato  components.php  e \"richiede\" questo file  web.php  come mostrato sopra. Il contenuto di  components.php  \u00e8 come segue,  return [\n    'cache' =  [\n        'class' =  'yii\\caching\\FileCache',\n    ],\n    'mailer' =  [\n        'class' =  'yii\\swiftmailer\\Mailer',\n    ],\n    'log' =  [\n        'class' =  'yii\\log\\Dispatcher',\n        'traceLevel' =  YII_DEBUG ? 3 : 0,\n        'targets' =  [\n            [\n                'class' =  'yii\\log\\FileTarget',\n            ],\n        ],\n    ],\n    'db' =  [\n        'class' =  'yii\\db\\Connection',\n        'dsn' =  'mysql:host=localhost;dbname=stay2',\n        'username' =  'root',\n        'password' =  '',\n        'charset' =  'utf8',\n    ],\n];  Per ottenere una configurazione memorizzata in un file di configurazione, \u00e8 sufficiente \"richiederla\", come la seguente:  $config = require 'path/to/web.php';\n(new yii\\web\\Application($config))- run();",
            "title": "File di configurazione"
        },
        {
            "location": "/key-concepts/sub-configurations/#configurazioni-predefinite",
            "text": "Il metodo  Yii :: createObject()  \u00e8 implementato in base a un contenitore di input delle dipendenze. Ti consente di specificare un insieme di configurazioni predefinite che verranno applicate a TUTTE le istanze delle classi specificate quando vengono create utilizzando  Yii :: createObject() . Le configurazioni predefinite possono essere specificate chiamando  Yii::$container- set()  nel codice di bootstrap.  Ad esempio, se si desidera personalizzare  yii \\ widgets \\ LinkPager  in modo che TUTTI i pager di collegamento mostrino al massimo 5 pulsanti di pagina (il valore predefinito \u00e8 10), \u00e8 possibile utilizzare il seguente codice per raggiungere questo obiettivo:  \\Yii::$container- set('yii\\widgets\\LinkPager', [\n    'maxButtonCount' =  5,\n]);  Senza usare le configurazioni di default, dovresti configurare  maxButtonCount  in ogni posto dove usi i cercapersone.",
            "title": "Configurazioni predefinite"
        },
        {
            "location": "/key-concepts/sub-configurations/#costanti-ambientali",
            "text": "Le configurazioni variano spesso in base all'ambiente in cui viene eseguita un'applicazione. Ad esempio, nell'ambiente di sviluppo, potresti voler utilizzare un database chiamato  mydb_dev , mentre sul server di produzione potresti voler utilizzare il  mydb_prod  database. Per facilitare gli ambienti di passaggio, Yii fornisce una costante denominata  YII_ENV  che \u00e8 possibile definire nello script di entrata della propria applicazione. Per esempio,  defined('YII_ENV') or define('YII_ENV', 'dev');  Puoi definire  YII_ENV  uno dei seguenti valori:   prod : ambiente di produzione. La costante  YII_ENV_PROD  avr\u00e0 un valore  true . Questo \u00e8 il valore predefinito di  YII_ENV  se non lo definisci.  dev : sviluppo dell'ambiente di programmazione. La costante  YII_ENV_DEV  avr\u00e0 un valore  true .  test : ambiente di test. La costante  YII_ENV_TEST  avr\u00e0 un valore  true .   Con queste costanti di ambiente, \u00e8 possibile specificare le configurazioni in modo condizionale in base all'ambiente corrente. Ad esempio, la configurazione dell'applicazione potrebbe contenere il seguente codice per abilitare la barra degli strumenti di debug e il debugger nell'ambiente di sviluppo.  $config = [...];\n\nif (YII_ENV_DEV) {\n    // configuration adjustments for 'dev' environment\n    $config['bootstrap'][] = 'debug';\n    $config['modules']['debug'] = 'yii\\debug\\Module';\n}\n\nreturn $config;",
            "title": "Costanti ambientali"
        },
        {
            "location": "/key-concepts/sub-alias/",
            "text": "Alias\n\n\nGli alias vengono utilizzati per rappresentare i percorsi dei file o gli URL in modo da non dover codificare percorsi o URL assoluti nel progetto. Un alias deve iniziare con il carattere \n@\n da differenziare dai normali percorsi di file e URL.\n\n\nYii ha molti alias predefiniti gi\u00e0 disponibili. Ad esempio, l'alias \n@yii\n rappresenta il percorso di installazione del framework Yii; \n@web\n rappresenta l'URL di base per l'applicazione Web attualmente in esecuzione.\n\n\nDefinizione di alias\n\n\nE' possibile definire un alias per un percorso file o un URL chiamando \nYii :: setAlias()\n\n\n// an alias of a file path\nYii::setAlias('@foo', '/path/to/foo');\n\n// an alias of a URL\nYii::setAlias('@bar', 'http://www.example.com');\n\n// an alias of a concrete file that contains a \\foo\\Bar class\nYii::setAlias('@foo/Bar.php', '/definitely/not/foo/Bar.php');\n\n\n\n\n\nWarning\n\n\nIl percorso del file o l'alias dell'URL potrebbe non riferirsi necessariamente a un file o risorsa esistente.\n\n\n\n\nDato un alias definito, \u00e8 possibile derivare un nuovo alias (senza la necessit\u00e0 di chiamare \nYii :: setAlias()\n ) aggiungendo uno slash \n/\n seguita da uno o pi\u00f9 segmenti di percorso. Gli alias definiti tramite \nYii :: setAlias()\n diventano l' alias di root, mentre gli alias derivati \u200b\u200bda esso sono alias derivati . Ad esempio, \n@foo\n \u00e8 un alias di root, mentre \n@foo/bar/file.php\n \u00e8 un alias derivato.\n\n\nPuoi definire un alias usando un altro alias (root o derivato):\n\n\nYii::setAlias('@foobar', '@foo/bar');\n\n\n\nGli alias di root vengono generalmente definiti durante la fase di avvio. Ad esempio, \u00e8 possibile chiamare \nYii :: setAlias()\n nello script di immissione. Per comodit\u00e0, l' applicazione fornisce una propriet\u00e0 scrivibile denominata \naliases\n che \u00e8 possibile configurare nella configurazione dell'applicazione:\n\n\nreturn [\n    // ...\n    'aliases' =\n [\n        '@foo' =\n '/path/to/foo',\n        '@bar' =\n 'http://www.example.com',\n    ],\n];\n\n\n\nRisoluzione di Alias\n\n\nPuoi chiamare \nYii :: getAlias()\n per risolvere un alias di root nel percorso del file o nell'URL che rappresenta. Lo stesso metodo pu\u00f2 anche risolvere un alias derivato nel percorso o nell'URL corrispondente:\n\n\necho Yii::getAlias('@foo');               // displays: /path/to/foo\necho Yii::getAlias('@bar');               // displays: http://www.example.com   \necho Yii::getAlias('@foo/bar/file.php');  // displays: /path/to/foo/bar/file.php\n\n\n\nIl percorso / URL rappresentato da un alias derivato viene determinato sostituendo la parte dell'alias root con il percorso / URL corrispondente nell'alias derivato.\n\n\n\n\nNote\n\n\nIl metodo \nYii :: getAlias()\n non controlla se il percordo URL risultante fa riferimento a un file o una risorsa esistente.\n\n\n\n\nUn alias di root pu\u00f2 contenere anche slash \n/\n . Il metodo \nYii :: getAlias()\n \u00e8 abbastanza intelligente da stabilire quale parte di un alias \u00e8 un alias di root e quindi determina correttamente il percorso o l'URL del file corrispondente:\n\n\nYii::setAlias('@foo', '/path/to/foo');\nYii::setAlias('@foo/bar', '/path2/bar');\nYii::getAlias('@foo/test/file.php');  // displays: /path/to/foo/test/file.php\nYii::getAlias('@foo/bar/file.php');   // displays: /path2/bar/file.php\n\n\n\nSe \n@foo/bar\n non \u00e8 definito come un alias di root, verr\u00e0 visualizzata l'ultima istruzione \n/path/to/foo/bar/file.php\n.\n\n\nUtilizzo degli Alias\n\n\nGli alias sono riconosciuti in molti punti di Yii senza bisogno di chiamare \nYii :: getAlias()\n per convertirli in percorsi o URL. Ad esempio, \nyii \\ caching \\ FileCache :: $ cachePath\n pu\u00f2 accettare sia un percorso file che un alias che rappresenta un percorso file, grazie al prefisso \n@\n che consente di differenziare un percorso file da un alias.\n\n\nuse yii\\caching\\FileCache;\n\n$cache = new FileCache([\n    'cachePath' =\n '@runtime/cache',\n]);\n\n\n\nPrestare attenzione alla documentazione dell'API per verificare se una propriet\u00e0 o un parametro del metodo supporta alias.\n\n\nAlias predefiniti\n\n\nYii predefinisce un set di alias per fare facilmente riferimento ai percorsi e agli URL dei file comunemente utilizzati:\n\n\n\n\n@yii\n, la directory in cui \nBaseYii.php\n si trova il file (chiamando anche la directory framework).\n\n\n@app\n, \nyii\\ base \\ Application :: basePath\n dell'applicazione attualmente in esecuzione.\n\n\n@runtime\n, \nyii \\ base \\ Application :: runtimePath\n dell'applicazione attualmente in esecuzione. Predefinito a \n@app/runtime\n.\n\n\n@webroot\n, la directory principale Web della nostra applicazione attualmente in esecuzione. Viene determinato in base alla directory contenente lo script di immissione.\n\n\n@web\n, l'URL di base dell'applicazione Web attualmente in esecuzione. Ha lo stesso valore di \nyii \\ web \\ Request :: baseUrl\n.\n\n\n@vendor\n, \nyii \\ base \\ Application :: vendorPath\n. Il valore predefinito \u00e8 \n@app/vendor\n.\n\n\n@bower\n, la directory root che contiene i pacchetit di bower. Il valore predefinito \u00e8 \n@vendor/bower\n.\n\n\n@npm\n, la directory root che contiene i pacchetti npm. Il valore predefinito \u00e8 \n@vendor/npm\n.\n\n\n\n\nL'alias \n@yii\n viene definito quando si include il file \nYii.php\n nell'entry script. Il resto degli alias vengono definiti nel costruttore dell'applicazione quando applichiamo la sua configurazione.\n\n\nAlias di estensione\n\n\nUn alias viene automaticamente definito per ogni estensione installata tramite Composer. Ogni alias prende il nome  dell'estensione come dichiarato nel suo file \ncomposer.json\n e ogni alias rappresenta la directory radice del pacchetto. Ad esempio, se si installa l' estensione \nyiisoft/yii2-jui\n, si avr\u00e0 automaticamente l'alias \n@yii/jui\n definito durante la fase di avvio , equivalente a:\n\n\nYii::setAlias('@yii/jui', 'VendorPath/yiisoft/yii2-jui');",
            "title": "Alias"
        },
        {
            "location": "/key-concepts/sub-alias/#alias",
            "text": "Gli alias vengono utilizzati per rappresentare i percorsi dei file o gli URL in modo da non dover codificare percorsi o URL assoluti nel progetto. Un alias deve iniziare con il carattere  @  da differenziare dai normali percorsi di file e URL.  Yii ha molti alias predefiniti gi\u00e0 disponibili. Ad esempio, l'alias  @yii  rappresenta il percorso di installazione del framework Yii;  @web  rappresenta l'URL di base per l'applicazione Web attualmente in esecuzione.",
            "title": "Alias"
        },
        {
            "location": "/key-concepts/sub-alias/#definizione-di-alias",
            "text": "E' possibile definire un alias per un percorso file o un URL chiamando  Yii :: setAlias()  // an alias of a file path\nYii::setAlias('@foo', '/path/to/foo');\n\n// an alias of a URL\nYii::setAlias('@bar', 'http://www.example.com');\n\n// an alias of a concrete file that contains a \\foo\\Bar class\nYii::setAlias('@foo/Bar.php', '/definitely/not/foo/Bar.php');   Warning  Il percorso del file o l'alias dell'URL potrebbe non riferirsi necessariamente a un file o risorsa esistente.   Dato un alias definito, \u00e8 possibile derivare un nuovo alias (senza la necessit\u00e0 di chiamare  Yii :: setAlias()  ) aggiungendo uno slash  /  seguita da uno o pi\u00f9 segmenti di percorso. Gli alias definiti tramite  Yii :: setAlias()  diventano l' alias di root, mentre gli alias derivati \u200b\u200bda esso sono alias derivati . Ad esempio,  @foo  \u00e8 un alias di root, mentre  @foo/bar/file.php  \u00e8 un alias derivato.  Puoi definire un alias usando un altro alias (root o derivato):  Yii::setAlias('@foobar', '@foo/bar');  Gli alias di root vengono generalmente definiti durante la fase di avvio. Ad esempio, \u00e8 possibile chiamare  Yii :: setAlias()  nello script di immissione. Per comodit\u00e0, l' applicazione fornisce una propriet\u00e0 scrivibile denominata  aliases  che \u00e8 possibile configurare nella configurazione dell'applicazione:  return [\n    // ...\n    'aliases' =  [\n        '@foo' =  '/path/to/foo',\n        '@bar' =  'http://www.example.com',\n    ],\n];",
            "title": "Definizione di alias"
        },
        {
            "location": "/key-concepts/sub-alias/#risoluzione-di-alias",
            "text": "Puoi chiamare  Yii :: getAlias()  per risolvere un alias di root nel percorso del file o nell'URL che rappresenta. Lo stesso metodo pu\u00f2 anche risolvere un alias derivato nel percorso o nell'URL corrispondente:  echo Yii::getAlias('@foo');               // displays: /path/to/foo\necho Yii::getAlias('@bar');               // displays: http://www.example.com   \necho Yii::getAlias('@foo/bar/file.php');  // displays: /path/to/foo/bar/file.php  Il percorso / URL rappresentato da un alias derivato viene determinato sostituendo la parte dell'alias root con il percorso / URL corrispondente nell'alias derivato.   Note  Il metodo  Yii :: getAlias()  non controlla se il percordo URL risultante fa riferimento a un file o una risorsa esistente.   Un alias di root pu\u00f2 contenere anche slash  /  . Il metodo  Yii :: getAlias()  \u00e8 abbastanza intelligente da stabilire quale parte di un alias \u00e8 un alias di root e quindi determina correttamente il percorso o l'URL del file corrispondente:  Yii::setAlias('@foo', '/path/to/foo');\nYii::setAlias('@foo/bar', '/path2/bar');\nYii::getAlias('@foo/test/file.php');  // displays: /path/to/foo/test/file.php\nYii::getAlias('@foo/bar/file.php');   // displays: /path2/bar/file.php  Se  @foo/bar  non \u00e8 definito come un alias di root, verr\u00e0 visualizzata l'ultima istruzione  /path/to/foo/bar/file.php .",
            "title": "Risoluzione di Alias"
        },
        {
            "location": "/key-concepts/sub-alias/#utilizzo-degli-alias",
            "text": "Gli alias sono riconosciuti in molti punti di Yii senza bisogno di chiamare  Yii :: getAlias()  per convertirli in percorsi o URL. Ad esempio,  yii \\ caching \\ FileCache :: $ cachePath  pu\u00f2 accettare sia un percorso file che un alias che rappresenta un percorso file, grazie al prefisso  @  che consente di differenziare un percorso file da un alias.  use yii\\caching\\FileCache;\n\n$cache = new FileCache([\n    'cachePath' =  '@runtime/cache',\n]);  Prestare attenzione alla documentazione dell'API per verificare se una propriet\u00e0 o un parametro del metodo supporta alias.",
            "title": "Utilizzo degli Alias"
        },
        {
            "location": "/key-concepts/sub-alias/#alias-predefiniti",
            "text": "Yii predefinisce un set di alias per fare facilmente riferimento ai percorsi e agli URL dei file comunemente utilizzati:   @yii , la directory in cui  BaseYii.php  si trova il file (chiamando anche la directory framework).  @app ,  yii\\ base \\ Application :: basePath  dell'applicazione attualmente in esecuzione.  @runtime ,  yii \\ base \\ Application :: runtimePath  dell'applicazione attualmente in esecuzione. Predefinito a  @app/runtime .  @webroot , la directory principale Web della nostra applicazione attualmente in esecuzione. Viene determinato in base alla directory contenente lo script di immissione.  @web , l'URL di base dell'applicazione Web attualmente in esecuzione. Ha lo stesso valore di  yii \\ web \\ Request :: baseUrl .  @vendor ,  yii \\ base \\ Application :: vendorPath . Il valore predefinito \u00e8  @app/vendor .  @bower , la directory root che contiene i pacchetit di bower. Il valore predefinito \u00e8  @vendor/bower .  @npm , la directory root che contiene i pacchetti npm. Il valore predefinito \u00e8  @vendor/npm .   L'alias  @yii  viene definito quando si include il file  Yii.php  nell'entry script. Il resto degli alias vengono definiti nel costruttore dell'applicazione quando applichiamo la sua configurazione.",
            "title": "Alias predefiniti"
        },
        {
            "location": "/key-concepts/sub-alias/#alias-di-estensione",
            "text": "Un alias viene automaticamente definito per ogni estensione installata tramite Composer. Ogni alias prende il nome  dell'estensione come dichiarato nel suo file  composer.json  e ogni alias rappresenta la directory radice del pacchetto. Ad esempio, se si installa l' estensione  yiisoft/yii2-jui , si avr\u00e0 automaticamente l'alias  @yii/jui  definito durante la fase di avvio , equivalente a:  Yii::setAlias('@yii/jui', 'VendorPath/yiisoft/yii2-jui');",
            "title": "Alias di estensione"
        },
        {
            "location": "/key-concepts/sub-autoloading-class/",
            "text": "Classe Autoloading\n\n\nYii si basa sul meccanismo di autoloading della classe per individuare e includere tutti i file di classe richiesti. Fornisce un'autoloader di classe ad alte prestazioni conforme allo standard PSR-4. L'autoloader viene installato quando si include il file \nYii.php\n.\n\n\n\n\nWarning\n\n\nPer semplicit\u00e0 di descrizione, in questa sezione parleremo solo del caricamento automatico delle classi. Tuttavia, tieni presente che il contenuto che stiamo descrivendo qui si applica anche all'autoloading di interfacce e Traits.\n\n\n\n\nUso dell'autoloader di Yii\n\n\nPer utilizzare l'autoloader della classe Yii, \u00e8 necessario seguire due semplici regole durante la creazione e la denominazione delle classi:\n\n\n\n\nOgni classe deve essere in uno spazio dei nomi (ad esempio \nfoo\\bar\\MyClass\\\n)\n\n\n\n\nOgni classe deve essere salvata in un singolo file il cui percorso \u00e8 determinato dal seguente algoritmo:\n\n\n// $className is a fully qualified class name without the leading backslash\n$classFile = Yii::getAlias('@' . str_replace('\\', '/', $className) . '.php');\n\n\n\n\n\n\nAd esempio, se un nome di una classe e un namespace sono \nfoo\\bar\\MyClass\n, l' alias per il corrispondente percorso del file di classe sarebbe \n@foo/bar/MyClass.php\n. Affinch\u00e9 questo alias sia risolvibile in un percorso file, \n@foo\n o \n@foo/bar\n deve essere un alias di root.\n\n\nQuando si utilizza il modello progetto base di Yii, \u00e8 possibile mettere le classi sotto i namespace di livello superiore ad \napp\n in modo che possano essere autoloaded da Yii senza la necessit\u00e0 di definire un nuovo alias. Questo perch\u00e9 \n@app\n \u00e8 un alias predefinito e un nome di classe come \napp\\components\\MyClass\n pu\u00f2 essere risolto nel file di classe \nAppBasePath/components/MyClass.php\n, in base all'algoritmo appena descritto.\n\n\nNel modello di progetto avanzato, ogni livello ha il proprio alias di root. Ad esempio, il livello front-end ha un alias root \n@frontend\n, mentre l'alias root del tier back-end \u00e8 \n@backend\n. Di conseguenza, puoi inserire le classi front-end sotto i namespace \"frontend\", mentre le classi back-end sono sotto \"backend\". Ci\u00f2 consentir\u00e0 a queste classi di essere autoloading dell'autoloader di Yii.\n\n\nPer aggiungere un namespace personalizzato all'autoloader, \u00e8 necessario definire un alias per la directory base dei namespaces utilizzando \nYii :: setAlias()\n. Ad esempio, per caricare classi nel namespace \nfoo\n che si trovano nella \npath/to/foodirectory\n che chiamerai \nYii::setAlias('@foo', 'path/to/foo')\n.\n\n\nClass Map\n\n\nL'autoloading della classe Yii supporta la funzione mapping delle classi, che associa i nomi delle classi ai percorsi dei file di classe corrispondenti. Quando l'autoloading sta caricando una classe, controller\u00e0 innanzitutto se la classe \u00e8 stata trovata nella mappa. In tal caso, il percorso del file corrispondente verr\u00e0 incluso direttamente senza ulteriori verifiche. Questo rende la classe autoloading super veloce. In effetti, tutte le classi Yii di base vengono caricate automaticamente in questo modo.\n\n\nPuoi aggiungere una classe alla stessa mappa, memorizzata in \nYii::$classMap\n,usando:\n\n\nYii::$classMap['foo\\bar\\MyClass'] = 'path/to/MyClass.php';\n\n\n\nGli alias possono essere utilizzati per specificare i percorsi dei file di classe. \u00c8 necessario impostare la mappa della classe nel processo di avvio automatico in modo che la mappa sia pronta prima di utilizzare le classi.\n\n\nUso di altri Autoloaders\n\n\nPoich\u00e9 Yii include Composer come gestore delle dipendenze del pacchetto, si consiglia di installare anche l'autoloader Composer. Se si utilizzano librerie di terze parti con i propri caricatori automatici, \u00e8 necessario installarle.\n\n\nQuando si utilizza l'autoloader Yii insieme ad altri caricatori automatici, \u00e8 necessario includere il file \nYii.php\n dopo aver installato tutti gli altri caricatori automatici. Questo render\u00e0 l'autoloader di Yii il primo a rispondere a qualsiasi richiesta di autoloading della classe. Ad esempio, il codice seguente viene estratto dallo script di entrata del modello base del progetto di Yii. La prima riga installa l'autoloader Composer, mentre la seconda riga installa il l'autoloader Yii:\n\n\nrequire __DIR__ . '/../vendor/autoload.php';\nrequire __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';\n\n\n\n\u00c8 possibile utilizzare l'autoloader del Composer da solo senza l'autoloader di Yii. Tuttavia, cos\u00ec facendo, le prestazioni dell'autoloader della tua classe potrebbero essere ridotte, e devi seguire le regole impostate da Composer affinch\u00e9 le tue classi siano autoloadable.\n\n\n\n\nInfo\n\n\nSe non si desidera utilizzare l'autoloader di Yii, \u00e8 necessario creare la propria versione del file di \nYii.php\n e includerlo nell'entry script.\n\n\n\n\nEstensione della Classe Autoloading\n\n\nL'autoloader di Yii \u00e8 in grado di caricare automaticamente le classi di estensione. L'unico requisito \u00e8 che un'estensione specifichi correttamente la sezione \nautoload\n nel suo file \ncomposer.json\n.\n\n\nNel caso in cui non si utilizzi l'autoloader di Yii, l'autoloader del Composer pu\u00f2 ancora caricare automaticamente le classi di estensione.",
            "title": "Classe \"Autoloading\""
        },
        {
            "location": "/key-concepts/sub-autoloading-class/#classe-autoloading",
            "text": "Yii si basa sul meccanismo di autoloading della classe per individuare e includere tutti i file di classe richiesti. Fornisce un'autoloader di classe ad alte prestazioni conforme allo standard PSR-4. L'autoloader viene installato quando si include il file  Yii.php .   Warning  Per semplicit\u00e0 di descrizione, in questa sezione parleremo solo del caricamento automatico delle classi. Tuttavia, tieni presente che il contenuto che stiamo descrivendo qui si applica anche all'autoloading di interfacce e Traits.",
            "title": "Classe Autoloading"
        },
        {
            "location": "/key-concepts/sub-autoloading-class/#uso-dellautoloader-di-yii",
            "text": "Per utilizzare l'autoloader della classe Yii, \u00e8 necessario seguire due semplici regole durante la creazione e la denominazione delle classi:   Ogni classe deve essere in uno spazio dei nomi (ad esempio  foo\\bar\\MyClass\\ )   Ogni classe deve essere salvata in un singolo file il cui percorso \u00e8 determinato dal seguente algoritmo:  // $className is a fully qualified class name without the leading backslash\n$classFile = Yii::getAlias('@' . str_replace('\\', '/', $className) . '.php');    Ad esempio, se un nome di una classe e un namespace sono  foo\\bar\\MyClass , l' alias per il corrispondente percorso del file di classe sarebbe  @foo/bar/MyClass.php . Affinch\u00e9 questo alias sia risolvibile in un percorso file,  @foo  o  @foo/bar  deve essere un alias di root.  Quando si utilizza il modello progetto base di Yii, \u00e8 possibile mettere le classi sotto i namespace di livello superiore ad  app  in modo che possano essere autoloaded da Yii senza la necessit\u00e0 di definire un nuovo alias. Questo perch\u00e9  @app  \u00e8 un alias predefinito e un nome di classe come  app\\components\\MyClass  pu\u00f2 essere risolto nel file di classe  AppBasePath/components/MyClass.php , in base all'algoritmo appena descritto.  Nel modello di progetto avanzato, ogni livello ha il proprio alias di root. Ad esempio, il livello front-end ha un alias root  @frontend , mentre l'alias root del tier back-end \u00e8  @backend . Di conseguenza, puoi inserire le classi front-end sotto i namespace \"frontend\", mentre le classi back-end sono sotto \"backend\". Ci\u00f2 consentir\u00e0 a queste classi di essere autoloading dell'autoloader di Yii.  Per aggiungere un namespace personalizzato all'autoloader, \u00e8 necessario definire un alias per la directory base dei namespaces utilizzando  Yii :: setAlias() . Ad esempio, per caricare classi nel namespace  foo  che si trovano nella  path/to/foodirectory  che chiamerai  Yii::setAlias('@foo', 'path/to/foo') .",
            "title": "Uso dell'autoloader di Yii"
        },
        {
            "location": "/key-concepts/sub-autoloading-class/#class-map",
            "text": "L'autoloading della classe Yii supporta la funzione mapping delle classi, che associa i nomi delle classi ai percorsi dei file di classe corrispondenti. Quando l'autoloading sta caricando una classe, controller\u00e0 innanzitutto se la classe \u00e8 stata trovata nella mappa. In tal caso, il percorso del file corrispondente verr\u00e0 incluso direttamente senza ulteriori verifiche. Questo rende la classe autoloading super veloce. In effetti, tutte le classi Yii di base vengono caricate automaticamente in questo modo.  Puoi aggiungere una classe alla stessa mappa, memorizzata in  Yii::$classMap ,usando:  Yii::$classMap['foo\\bar\\MyClass'] = 'path/to/MyClass.php';  Gli alias possono essere utilizzati per specificare i percorsi dei file di classe. \u00c8 necessario impostare la mappa della classe nel processo di avvio automatico in modo che la mappa sia pronta prima di utilizzare le classi.",
            "title": "Class Map"
        },
        {
            "location": "/key-concepts/sub-autoloading-class/#uso-di-altri-autoloaders",
            "text": "Poich\u00e9 Yii include Composer come gestore delle dipendenze del pacchetto, si consiglia di installare anche l'autoloader Composer. Se si utilizzano librerie di terze parti con i propri caricatori automatici, \u00e8 necessario installarle.  Quando si utilizza l'autoloader Yii insieme ad altri caricatori automatici, \u00e8 necessario includere il file  Yii.php  dopo aver installato tutti gli altri caricatori automatici. Questo render\u00e0 l'autoloader di Yii il primo a rispondere a qualsiasi richiesta di autoloading della classe. Ad esempio, il codice seguente viene estratto dallo script di entrata del modello base del progetto di Yii. La prima riga installa l'autoloader Composer, mentre la seconda riga installa il l'autoloader Yii:  require __DIR__ . '/../vendor/autoload.php';\nrequire __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';  \u00c8 possibile utilizzare l'autoloader del Composer da solo senza l'autoloader di Yii. Tuttavia, cos\u00ec facendo, le prestazioni dell'autoloader della tua classe potrebbero essere ridotte, e devi seguire le regole impostate da Composer affinch\u00e9 le tue classi siano autoloadable.   Info  Se non si desidera utilizzare l'autoloader di Yii, \u00e8 necessario creare la propria versione del file di  Yii.php  e includerlo nell'entry script.",
            "title": "Uso di altri Autoloaders"
        },
        {
            "location": "/key-concepts/sub-autoloading-class/#estensione-della-classe-autoloading",
            "text": "L'autoloader di Yii \u00e8 in grado di caricare automaticamente le classi di estensione. L'unico requisito \u00e8 che un'estensione specifichi correttamente la sezione  autoload  nel suo file  composer.json .  Nel caso in cui non si utilizzi l'autoloader di Yii, l'autoloader del Composer pu\u00f2 ancora caricare automaticamente le classi di estensione.",
            "title": "Estensione della Classe Autoloading"
        },
        {
            "location": "/key-concepts/sub-service-locator/",
            "text": "Localizzatore di servizi (Service Locator)\n\n\nUn localizzatore di servizi (o service locator) \u00e8 un oggetto che sa come fornire tutti i tipi di servizi (o componenti) di cui un'applicazione potrebbe aver bisogno. All'interno di un localizzatore di servizi, ogni componente esiste come unica istanza, identificata univocamente da un ID. Si utilizza l'ID per recuperare un componente dal localizzatore di servizi.\n\n\nIn Yii, un localizzatore di servizi \u00e8 semplicemente un'istanza di \nyii \\ di \\ ServiceLocator\n o di una classe figlia.\n\n\nIl localizzatore di servizi pi\u00f9 utilizzato in Yii \u00e8 l' oggetto dell'applicazione a cui \u00e8 possibile accedere tramite \n\\Yii::$app\n. I servizi offerti sono chiamati componenti di applicazioni, come la \nrequest\n, \nresponse\ne i componenti \nurlManager\n. \u00c8 possibile configurare questi componenti, o addirittura sostituirli con le proprie implementazioni, attraverso la funzionalit\u00e0 fornita dal localizzatore di servizi.\n\n\nOltre all'oggetto dell'applicazione, ogni oggetto modulo \u00e8 anche un localizzatore di servizi. I moduli implementano l' attraversamento dell'albero .\n\n\nPer utilizzare un localizzatore di servizi, il primo passo \u00e8 registrare i componenti con esso. Un componente pu\u00f2 essere registrato tramite \nyii \\ di \\ ServiceLocator :: set()\n. Il seguente codice mostra diversi modi di registrare i componenti:\n\n\nuse yii\\di\\ServiceLocator;\nuse yii\\caching\\FileCache;\n\n$locator = new ServiceLocator;\n\n// register \"cache\" using a class name that can be used to create a component\n$locator-\nset('cache', 'yii\\caching\\ApcCache');\n\n// register \"db\" using a configuration array that can be used to create a component\n$locator-\nset('db', [\n    'class' =\n 'yii\\db\\Connection',\n    'dsn' =\n 'mysql:host=localhost;dbname=demo',\n    'username' =\n 'root',\n    'password' =\n '',\n]);\n\n// register \"search\" using an anonymous function that builds a component\n$locator-\nset('search', function () {\n    return new app\\components\\SolrService;\n});\n\n// register \"pageCache\" using a component\n$locator-\nset('pageCache', new FileCache);\n\n\n\nUna volta che un componente \u00e8 stato registrato, \u00e8 possibile accedervi utilizzando il suo ID, in uno dei due seguenti modi:\n\n\n$cache = $locator-\nget('cache');\n// or alternatively\n$cache = $locator-\ncache;\n\n\n\nCome mostrato sopra, \nyii \\ di \\ ServiceLocator\n consente di accedere a un componente come una propriet\u00e0, utilizzando l'ID del componente. Quando si accede a un componente per la prima volta, \nyii \\ di \\ ServiceLocator\n utilizzer\u00e0 le informazioni di registrazione del componente stesso per creare una sua nuova istanza.\nSuccessivamente, se si accede nuovamente al componente, il localizzatore di servizi restituir\u00e0 la stessa istanza.\n\n\n\u00c8 possibile utilizzare \nyii \\ di \\ ServiceLocator :: has()\n per verificare se un componente ID \u00e8 gi\u00e0 stato registrato. Se chiami \nyii \\ di \\ ServiceLocator :: get()\n con un ID non valido, verr\u00e0 generata un'eccezione.\n\n\nPoich\u00e9 i localizzatori di servizi vengono spesso creati con configurazioni , viene fornita una propriet\u00e0 scrivibile denominata \ncomponents\n. Ci\u00f2 consente di configurare e registrare pi\u00f9 componenti contemporaneamente. Il codice seguente mostra un array di configurazione che pu\u00f2 essere utilizzato per configurare un localizzatore di servizi (ad esempio un'applicazione ) con \ndb\n, \ncache\n, \ntz\n e componenti di \nsearch\n:\n\n\nreturn [\n    // ...\n    'components' =\n [\n        'db' =\n [\n            'class' =\n 'yii\\db\\Connection',\n            'dsn' =\n 'mysql:host=localhost;dbname=demo',\n            'username' =\n 'root',\n            'password' =\n '',\n        ],\n        'cache' =\n 'yii\\caching\\ApcCache',\n        'tz' =\n function() {\n            return new \\DateTimeZone(Yii::$app-\nformatter-\ndefaultTimeZone);\n        },\n        'search' =\n function () {\n            $solr = new app\\components\\SolrService('127.0.0.1');\n            // ... other initializations ...\n            return $solr;\n        },\n    ],\n];\n\n\n\nQuanto mostrato sopra, c'\u00e8 un modo alternativo per configurare il componente di \nsearch\n. Invece di scrivere direttamente un callback PHP che costruisce l'istanza \nSolrService\n, \u00e8 possibile utilizzare un metodo di classe statico per restituire tale callback, come mostrato di seguito:\n\n\nclass SolrServiceBuilder{\n\n    public static function build($ip){\n\n        return function () use ($ip) {\n            $solr = new app\\components\\SolrService($ip);\n            // ... other initializations ...\n            return $solr;\n        };\n    }\n}\n\nreturn [\n    // ...\n    'components' =\n [\n        // ...\n        'search' =\n SolrServiceBuilder::build('127.0.0.1'),\n    ],\n];\n\n\n\nQuesto approccio alternativo \u00e8  preferibile quando si rilascia un componente Yii che incapsula alcune librerie di terze parti non Yii. Si utilizza il metodo statico come mostrato sopra per rappresentare la complessa logica della creazione dell'oggetto di terze parti e l'utente del componente deve solo chiamare il metodo statico per configurare il componente.\n\n\nAttraversamento di alberi\n\n\nI moduli consentono l'annidamento arbitrario; un'applicazione Yii \u00e8 essenzialmente un albero di moduli. Poich\u00e9 ciascuno di questi moduli \u00e8 un localizzatore di servizi, ha senso che i bambini abbiano accesso ai loro genitori. Ci\u00f2 consente ai moduli di utilizzare \n$this-\nget('db')\n invece di fare riferimento al localizzatore del servizio di root \nYii::$app-\nget('db')\n. Il vantaggio aggiunto \u00e8 l'opzione per uno sviluppatore di sovrascrivere la configurazione in un modulo.\n\n\nQualsiasi richiesta di recupero di un servizio da un modulo verr\u00e0 passata al suo genitore nel caso in cui il modulo non sia in grado di soddisfarlo.",
            "title": "Localizzatore di servizi"
        },
        {
            "location": "/key-concepts/sub-service-locator/#localizzatore-di-servizi-service-locator",
            "text": "Un localizzatore di servizi (o service locator) \u00e8 un oggetto che sa come fornire tutti i tipi di servizi (o componenti) di cui un'applicazione potrebbe aver bisogno. All'interno di un localizzatore di servizi, ogni componente esiste come unica istanza, identificata univocamente da un ID. Si utilizza l'ID per recuperare un componente dal localizzatore di servizi.  In Yii, un localizzatore di servizi \u00e8 semplicemente un'istanza di  yii \\ di \\ ServiceLocator  o di una classe figlia.  Il localizzatore di servizi pi\u00f9 utilizzato in Yii \u00e8 l' oggetto dell'applicazione a cui \u00e8 possibile accedere tramite  \\Yii::$app . I servizi offerti sono chiamati componenti di applicazioni, come la  request ,  response e i componenti  urlManager . \u00c8 possibile configurare questi componenti, o addirittura sostituirli con le proprie implementazioni, attraverso la funzionalit\u00e0 fornita dal localizzatore di servizi.  Oltre all'oggetto dell'applicazione, ogni oggetto modulo \u00e8 anche un localizzatore di servizi. I moduli implementano l' attraversamento dell'albero .  Per utilizzare un localizzatore di servizi, il primo passo \u00e8 registrare i componenti con esso. Un componente pu\u00f2 essere registrato tramite  yii \\ di \\ ServiceLocator :: set() . Il seguente codice mostra diversi modi di registrare i componenti:  use yii\\di\\ServiceLocator;\nuse yii\\caching\\FileCache;\n\n$locator = new ServiceLocator;\n\n// register \"cache\" using a class name that can be used to create a component\n$locator- set('cache', 'yii\\caching\\ApcCache');\n\n// register \"db\" using a configuration array that can be used to create a component\n$locator- set('db', [\n    'class' =  'yii\\db\\Connection',\n    'dsn' =  'mysql:host=localhost;dbname=demo',\n    'username' =  'root',\n    'password' =  '',\n]);\n\n// register \"search\" using an anonymous function that builds a component\n$locator- set('search', function () {\n    return new app\\components\\SolrService;\n});\n\n// register \"pageCache\" using a component\n$locator- set('pageCache', new FileCache);  Una volta che un componente \u00e8 stato registrato, \u00e8 possibile accedervi utilizzando il suo ID, in uno dei due seguenti modi:  $cache = $locator- get('cache');\n// or alternatively\n$cache = $locator- cache;  Come mostrato sopra,  yii \\ di \\ ServiceLocator  consente di accedere a un componente come una propriet\u00e0, utilizzando l'ID del componente. Quando si accede a un componente per la prima volta,  yii \\ di \\ ServiceLocator  utilizzer\u00e0 le informazioni di registrazione del componente stesso per creare una sua nuova istanza.\nSuccessivamente, se si accede nuovamente al componente, il localizzatore di servizi restituir\u00e0 la stessa istanza.  \u00c8 possibile utilizzare  yii \\ di \\ ServiceLocator :: has()  per verificare se un componente ID \u00e8 gi\u00e0 stato registrato. Se chiami  yii \\ di \\ ServiceLocator :: get()  con un ID non valido, verr\u00e0 generata un'eccezione.  Poich\u00e9 i localizzatori di servizi vengono spesso creati con configurazioni , viene fornita una propriet\u00e0 scrivibile denominata  components . Ci\u00f2 consente di configurare e registrare pi\u00f9 componenti contemporaneamente. Il codice seguente mostra un array di configurazione che pu\u00f2 essere utilizzato per configurare un localizzatore di servizi (ad esempio un'applicazione ) con  db ,  cache ,  tz  e componenti di  search :  return [\n    // ...\n    'components' =  [\n        'db' =  [\n            'class' =  'yii\\db\\Connection',\n            'dsn' =  'mysql:host=localhost;dbname=demo',\n            'username' =  'root',\n            'password' =  '',\n        ],\n        'cache' =  'yii\\caching\\ApcCache',\n        'tz' =  function() {\n            return new \\DateTimeZone(Yii::$app- formatter- defaultTimeZone);\n        },\n        'search' =  function () {\n            $solr = new app\\components\\SolrService('127.0.0.1');\n            // ... other initializations ...\n            return $solr;\n        },\n    ],\n];  Quanto mostrato sopra, c'\u00e8 un modo alternativo per configurare il componente di  search . Invece di scrivere direttamente un callback PHP che costruisce l'istanza  SolrService , \u00e8 possibile utilizzare un metodo di classe statico per restituire tale callback, come mostrato di seguito:  class SolrServiceBuilder{\n\n    public static function build($ip){\n\n        return function () use ($ip) {\n            $solr = new app\\components\\SolrService($ip);\n            // ... other initializations ...\n            return $solr;\n        };\n    }\n}\n\nreturn [\n    // ...\n    'components' =  [\n        // ...\n        'search' =  SolrServiceBuilder::build('127.0.0.1'),\n    ],\n];  Questo approccio alternativo \u00e8  preferibile quando si rilascia un componente Yii che incapsula alcune librerie di terze parti non Yii. Si utilizza il metodo statico come mostrato sopra per rappresentare la complessa logica della creazione dell'oggetto di terze parti e l'utente del componente deve solo chiamare il metodo statico per configurare il componente.",
            "title": "Localizzatore di servizi (Service Locator)"
        },
        {
            "location": "/key-concepts/sub-service-locator/#attraversamento-di-alberi",
            "text": "I moduli consentono l'annidamento arbitrario; un'applicazione Yii \u00e8 essenzialmente un albero di moduli. Poich\u00e9 ciascuno di questi moduli \u00e8 un localizzatore di servizi, ha senso che i bambini abbiano accesso ai loro genitori. Ci\u00f2 consente ai moduli di utilizzare  $this- get('db')  invece di fare riferimento al localizzatore del servizio di root  Yii::$app- get('db') . Il vantaggio aggiunto \u00e8 l'opzione per uno sviluppatore di sovrascrivere la configurazione in un modulo.  Qualsiasi richiesta di recupero di un servizio da un modulo verr\u00e0 passata al suo genitore nel caso in cui il modulo non sia in grado di soddisfarlo.",
            "title": "Attraversamento di alberi"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/",
            "text": "Contenitore Dependency Injection\n\n\nUn contenitore DI (dependency injection) \u00e8 un oggetto che sa istanziare e configurare oggetti e tutti i loro oggetti dipendenti. Qui spiegheremo principalmente l'utilizzo del contenitore DI fornito da Yii.\n\n\nDependency Injection\n\n\nYii fornisce la funzione contenitore DI attraverso la classe \nyii \\ di \\ Container\n. Supporta i seguenti tipi di injection di dipendenza:\n\n\n\n\nCostructor Injection;\n\n\nMethod Injection;\n\n\nSetter e property injection;\n\n\nPHP callable injection;\n\n\n\n\nCostructor Injection\n\n\nIl contenitore DI supporta il costructor injection con l'aiuto del tipo \nhint\n per i parametri del costruttore. Gli hint del tipo indicano al contenitore quali classi o interfacce dipendono quando viene utilizzato per creare un nuovo oggetto. Il contenitore prover\u00e0 a ottenere le istanze delle classi o interfacce dipendenti e quindi le inserir\u00e0 nel nuovo oggetto tramite il costruttore. Per esempio,\n\n\nclass Foo{\n\n    public function __construct(Bar $bar){\n\n    }\n}\n\n$foo = $container-\nget('Foo');\n// which is equivalent to the following:\n$bar = new Bar;\n$foo = new Foo($bar);\n\n\n\nMethod Injection\n\n\nDi solito le dipendenze di una classe vengono passate al costruttore e sono disponibili all'interno della classe durante l'intero ciclo di vita. Con il Method Injection \u00e8 possibile fornire una dipendenza che \u00e8 necessaria solo per un singolo metodo della classe e passarla al costruttore, e potrebbe non essere possibile o potrebbe causare un sovraccarico nella maggior parte dei casi d'uso.\n\n\nUn metodo di classe pu\u00f2 essere definito come il metodo \ndoSomething()\n nel seguente esempio:\n\n\nclass MyClass extends \\yii\\base\\Component{\n\n    public function __construct(/*Some lightweight dependencies here*/, $config = []){\n\n        // ...\n    }\n\n    public function doSomething($param1, \\my\\heavy\\Dependency $something){\n\n        // do something with $something\n    }\n}\n\n\n\nPuoi chiamare quel metodo passando un'istanza di \n\\my\\heavy\\Dependencyt\n e stesso o usando \nyii \\ di \\ Container :: invoke()\n come segue:\n\n\n$obj = new MyClass(/*...*/);\nYii::$container-\ninvoke([$obj, 'doSomething'], ['param1' =\n 42]); // $something will be provided by the DI container\n\n\n\nSetter e Property Injection\n\n\nIl setter e il property injection sono supportati attraverso le configurazioni. Quando si registra una dipendenza o quando si crea un nuovo oggetto, \u00e8 possibile fornire una configurazione che verr\u00e0 utilizzata dal contenitore per iniettare le dipendenze tramite i setter o le propriet\u00e0 corrispondenti. Per esempio,\n\n\nuse yii\\base\\BaseObject;\n\nclass Foo extends BaseObject{\n\n    public $bar;\n\n    private $_qux;\n\n    public function getQux(){\n\n        return $this-\n_qux;\n    }\n\n    public function setQux(Qux $qux){\n\n        $this-\n_qux = $qux;\n    }\n}\n\n$container-\nget('Foo', [], [\n    'bar' =\n $container-\nget('Bar'),\n    'qux' =\n $container-\nget('Qux'),\n]);\n\n\n\n\n\nInfo\n\n\nIl metodo \nyii \\ di \\ Container :: get()\n accetta il suo terzo parametro come array di configurazione da applicare all'oggetto che si sta creando. Se la classe implementa l' interfaccia \nyii \\ base \\ Configurable\n (es. \nYii \\ base \\ BaseObject\n ), l'array di configurazione verr\u00e0 passato come ultimo parametro al costruttore della classe; in caso contrario, la configurazione verr\u00e0 applicata dopo la creazione dell'oggetto.\n\n\n\n\nPHP Callable Injection\n\n\nIn questo caso, il contenitore utilizzer\u00e0 un PHP registrato callable per creare nuove istanze di una classe. Ogni volta che viene chiamato \nyii \\ di \\ Container :: get()\n, verr\u00e0 richiamato il callable corrispondente. Il callable \u00e8 responsabile di risolvere le dipendenze e iniettarle in modo appropriato sugli oggetti appena creati. Per esempio,\n\n\n$container-\nset('Foo', function () {\n    $foo = new Foo(new Bar);\n    // ... other initializations ...\n    return $foo;\n});\n\n$foo = $container-\nget('Foo');\n\n\n\nPer nascondere la logica complessa per la costruzione di un nuovo oggetto, \u00e8 possibile utilizzare un metodo di classe statico come callable. Per esempio,\n\n\nclass FooBuilder{\n\n    public static function build(){\n\n        $foo = new Foo(new Bar);\n        // ... other initializations ...\n        return $foo;\n    }\n}\n\n$container-\nset('Foo', ['app\\helper\\FooBuilder', 'build']);\n\n$foo = $container-\nget('Foo');\n\n\n\nIn questo modo, la persona che desidera configurare la classe \nFoo\n non deve pi\u00f9 essere consapevole di come \u00e8 stata creata.\n\n\nRegistrazione delle dipendenze\n\n\n\u00c8 possibile utilizzare \nyii \\ di \\ Container :: set()\n per registrare le dipendenze. La registrazione richiede un nome di dipendenza e una definizione di dipendenza. Un nome di dipendenza pu\u00f2 essere un nome di classe, un nome di interfaccia o un nome di alias; e una definizione di dipendenza pu\u00f2 essere un nome di classe, un array di configurazione o un callable PHP.\n\n\n$container = new \\yii\\di\\Container;\n\n// register a class name as is. This can be skipped.\n$container-\nset('yii\\db\\Connection');\n\n// register an interface\n// When a class depends on the interface, the corresponding class\n// will be instantiated as the dependent object\n$container-\nset('yii\\mail\\MailInterface', 'yii\\swiftmailer\\Mailer');\n\n// register an alias name. You can use $container-\nget('foo')\n// to create an instance of Connection\n$container-\nset('foo', 'yii\\db\\Connection');\n\n// register a class with configuration. The configuration\n// will be applied when the class is instantiated by get()\n$container-\nset('yii\\db\\Connection', [\n    'dsn' =\n 'mysql:host=127.0.0.1;dbname=demo',\n    'username' =\n 'root',\n    'password' =\n '',\n    'charset' =\n 'utf8',\n]);\n\n// register an alias name with class configuration\n// In this case, a \"class\" element is required to specify the class\n$container-\nset('db', [\n    'class' =\n 'yii\\db\\Connection',\n    'dsn' =\n 'mysql:host=127.0.0.1;dbname=demo',\n    'username' =\n 'root',\n    'password' =\n '',\n    'charset' =\n 'utf8',\n]);\n\n// register a PHP callable\n// The callable will be executed each time when $container-\nget('db') is called\n$container-\nset('db', function ($container, $params, $config) {\n    return new \\yii\\db\\Connection($config);\n});\n\n// register a component instance\n// $container-\nget('pageCache') will return the same instance each time it is called\n$container-\nset('pageCache', new FileCache);\n\n\n\n\n\nTip\n\n\nSe il nome di una dipendenza \u00e8 uguale alla definizione di dipendenza corrispondente, non \u00e8 necessario registrarlo con il contenitore DI.\n\n\n\n\nUna dipendenza registrata tramite \nset()\n generer\u00e0 un'istanza ogni volta che \u00e8 necessaria la dipendenza. \u00c8 possibile utilizzare \nyii \\ di \\ Container :: setSingleton()\n per registrare una dipendenza che genera solo una singola istanza:\n\n\n$container-\nsetSingleton('yii\\db\\Connection', [\n    'dsn' =\n 'mysql:host=127.0.0.1;dbname=demo',\n    'username' =\n 'root',\n    'password' =\n '',\n    'charset' =\n 'utf8',\n]);\n\n\n\nRisolvere le dipendenze\n\n\nDopo aver registrato le dipendenze, \u00e8 possibile utilizzare il contenitore DI per creare nuovi oggetti e il contenitore risolver\u00e0 automaticamente le dipendenze istanziandole e inserendole negli oggetti appena creati. La risoluzione delle dipendenze \u00e8 ricorsiva, il che significa che se una dipendenza ha altre dipendenze, anche queste dipendenze verranno risolte automaticamente.\n\n\nPuoi usare \nget()\n per creare o ottenere istanze di oggetti. Il metodo accetta un nome di dipendenza, che pu\u00f2 essere un nome di classe, un nome di interfaccia o un nome alias. Il nome della dipendenza pu\u00f2 essere registrato tramite \nset()\n o \nsetSingleton()\n. Opzionalmente \u00e8 possibile fornire un elenco di parametri del costruttore della classe e una configurazione per configurare l'oggetto appena creato.\n\n\nPer esempio:\n\n\n// \"db\" is a previously registered alias name\n$db = $container-\nget('db');\n\n// equivalent to: $engine = new \\app\\components\\SearchEngine($apiKey, $apiSecret, ['type' =\n 1]);\n$engine = $container-\nget('app\\components\\SearchEngine', [$apiKey, $apiSecret], ['type' =\n 1]);\n\n\n\nDietro la scena, il contenitore DI fa molto pi\u00f9 lavoro rispetto alla semplice creazione di un nuovo oggetto. Il contenitore, prima ispezioner\u00e0 il costruttore della classe per scoprire i nomi di classe o interfaccia dipendenti, e dopo risolver\u00e0 automaticamente tali dipendenze in modo ricorsivo.\n\n\nIl seguente codice mostra un esempio pi\u00f9 sofisticato. La classe \nUserLister\n dipende da un oggetto che implementa l'interfaccia \nUserFinderInterface\n; la classe \nUserFinder\n implementa questa interfaccia e dipende da un oggetto \nConnection\n. Tutte queste dipendenze sono dichiarate tramite il suggerimento sul tipo dei parametri del costruttore della classe. Con la registrazione delle dipendenze delle propriet\u00e0, il contenitore DI \u00e8 in grado di risolvere automaticamente queste dipendenze e crea una nuova istanza \nUserLister\n con una semplice chiamata di \nget('userLister')\n.\n\n\nnamespace app\\models;\n\nuse yii\\base\\BaseObject;\nuse yii\\db\\Connection;\nuse yii\\di\\Container;\n\ninterface UserFinderInterface{\n\n    function findUser();\n}\n\nclass UserFinder extends BaseObject implements UserFinderInterface{\n\n    public $db;\n\n    public function __construct(Connection $db, $config = []){\n\n        $this-\ndb = $db;\n        parent::__construct($config);\n    }\n\n    public function findUser(){\n\n    }\n}\n\nclass UserLister extends BaseObject{\n\n    public $finder;\n\n    public function __construct(UserFinderInterface $finder, $config = []){\n\n        $this-\nfinder = $finder;\n        parent::__construct($config);\n    }\n}\n\n$container = new Container;\n$container-\nset('yii\\db\\Connection', [\n    'dsn' =\n '...',\n]);\n$container-\nset('app\\models\\UserFinderInterface', [\n    'class' =\n 'app\\models\\UserFinder',\n]);\n$container-\nset('userLister', 'app\\models\\UserLister');\n\n$lister = $container-\nget('userLister');\n\n// which is equivalent to:\n\n$db = new \\yii\\db\\Connection(['dsn' =\n '...']);\n$finder = new UserFinder($db);\n$lister = new UserLister($finder);\n\n\n\nUso pratico\n\n\nYii crea un contenitore DI quando si include il file \nYii.php\n nell'entry script della propria applicazione. Il contenitore DI \u00e8 accessibile tramite il contenitore \nYii :: $\n. Quando chiamate \nYii :: createObject()\n, il metodo chiamer\u00e0 effettivamente il metodo \nget()\n del contenitore per creare un nuovo oggetto. Come sopra indicato, il contenitore DI risolver\u00e0 automaticamente le dipendenze (se presenti) e le inietter\u00e0 nell'oggetto ottenuto. Poich\u00e9 Yii usa \nYii :: createObject()\n nella maggior parte del suo codice per creare nuovi oggetti, questo significa che puoi personalizzare gli oggetti globalmente trattando con \nYii :: $ container\n.\n\n\nAd esempio, personalizziamo globalmente il numero predefinito di pulsanti di impaginazione di \nyii \\ widgets \\ LinkPager\n.\n\n\n\\Yii::$container-\nset('yii\\widgets\\LinkPager', ['maxButtonCount' =\n 5]);\n\n\n\nOra se si utilizza il widget in una vista con il seguente codice, la propriet\u00e0 \nmaxButtonCount\n verr\u00e0 inizializzata come 5 invece del valore predefinito 10 come definito nella classe.\n\n\necho \\yii\\widgets\\LinkPager::widget();\n\n\n\nE' comunque possibile sovrascrivere il valore impostato tramite il contenitore DI, tuttavia:\n\n\necho \\yii\\widgets\\LinkPager::widget(['maxButtonCount' =\n 20]);\n\n\n\nUn altro esempio \u00e8 quello di sfruttare l'injection del costruttore in modo automatico. Supponiamo che la classe del controller dipenda da altri oggetti, come un servizio di prenotazione di un hotel. \u00c8 possibile dichiarare la dipendenza tramite un parametro del costruttore e lasciare che il contenitore DI lo risolva automaticamente.\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\nuse app\\components\\BookingInterface;\n\nclass HotelController extends Controller{\n\n    protected $bookingService;\n\n    public function __construct($id, $module, BookingInterface $bookingService, $config = []){\n\n        $this-\nbookingService = $bookingService;\n        parent::__construct($id, $module, $config);\n    }\n}\n\n\n\nSe accedi a questo controller dal browser, vedrai un errore \nBookingInterface\n che non pu\u00f2 essere istanziato. Questo perch\u00e9 \u00e8 necessario indicare al contenitore DI come gestire questa dipendenza:\n\n\n\\Yii::$container-\nset('app\\components\\BookingInterface', 'app\\components\\BookingService');\n\n\n\nOra, se si accede nuovamente al controller, \napp\\components\\BookingService\n verr\u00e0 creata e iniettata un'istanza come terzo parametro per il costruttore del controllore.\n\n\nUso pratico avanzato\n\n\nSupponiamo che lavoriamo sull'applicazione API e abbiamo:\n\n\n\n\nla classe \napp\\components\\Request\n che si estende \nyii\\web\\Request\n e fornisce funzionalit\u00e0 aggiuntive;\n\n\nla classe \napp\\components\\Response\n che si estende \nyii\\web\\Response\n e dovrebbe avere la propriet\u00e0 \nformat\n impostata \njson\n sulla creazione;\n\n\n\n\nle classi \napp\\storage\\FileStorage\n e \napp\\storage\\DocumentsReader\n che implementano alcune logiche sul lavoro con i documenti che si trovano in qualche archivio di file:\n\n\nclass FileStorage{\n\n\npublic function __construct($root) {\n    // whatever\n}\n\n\n\n}\n\n\nclass DocumentsReader{\n\n\npublic function __construct(FileStorage $fs) {\n    // whatever\n}\n\n\n\n}\n\n\n\n\n\n\n\u00c8 possibile configurare pi\u00f9 definizioni contemporaneamente, passando l'array di configurazione al metodo \nsetDefinitions()\n o \nsetSingletons()\n. Iterando sull'array di configurazione, i metodi chiameranno \nset()\n o \nsetSingleton()\n rispettivamente per ciascun elemento.\n\n\nIl formato dell'array di configurazione \u00e8:\n\n\n\n\nkey\n: nome della classe, nome dell'interfaccia o nome di un alias. La chiave verr\u00e0 passata al metodo \nset()\n come primo argomento \n$class\n.\n\n\nvalue\n: la definizione associata a \n$class\n. I valori possibili sono descritti nella documentazione \nset()\n per il parametro \n$definition\n. Sar\u00e0 passato al metodo \nset()\n come secondo argomento \n$definition\n.\n\n\n\n\nAd esempio, configuriamo il nostro contenitore per seguire i requisiti sopra citati:\n\n\n$container-\nsetDefinitions([\n    'yii\\web\\Request' =\n 'app\\components\\Request',\n    'yii\\web\\Response' =\n [\n        'class' =\n 'app\\components\\Response',\n        'format' =\n 'json'\n    ],\n    'app\\storage\\DocumentsReader' =\n function () {\n        $fs = new app\\storage\\FileStorage('/var/tempfiles');\n        return new app\\storage\\DocumentsReader($fs);\n    }\n]);\n\n$reader = $container-\nget('app\\storage\\DocumentsReader'); \n// Will create DocumentReader object with its dependencies as described in the config\n\n\n\n\n\nTip\n\n\nIl contenitore pu\u00f2 essere configurato in stile dichiarativo utilizzando la configurazione dell'applicazione dalla versione 2.0.11.\n\n\n\n\nTutto funziona, ma nel caso avessimo bisogno di creare una classe \nDocumentWriter\n, dovremmo copiare e incollare la linea che crea l'oggetto  \nFileStorage\n, che non \u00e8 il modo pi\u00f9 intelligente, ovviamente.\n\n\nCome descritto nella sottosezione Resolving Dependencies ,\nset()\n e \nsetSingleton()\n possono facoltativamente assumere i parametri del costruttore della dipendenza come terzo argomento. Per impostare i parametri del costruttore, \u00e8 possibile utilizzare il seguente formato di matrice di configurazione:\n\n\n\n\nkey\n: nome della classe, nome dell'interfaccia o nome di un alias. La chiave verr\u00e0 passata al metodo \nset()\n come primo argomento \n$class\n.\n\n\nvalue\n: array di due elementi. Il primo elemento sar\u00e0 passato al metodo \nset()\n come secondo argomento \n$definition\n, mentre il secondo sar\u00e0 \n$params\n.\n\n\n\n\nModifichiamo il nostro esempio:\n\n\n$container-\nsetDefinitions([\n    'tempFileStorage' =\n [ // we've created an alias for convenience\n        ['class' =\n 'app\\storage\\FileStorage'],\n        ['/var/tempfiles'] // could be extracted from some config files\n    ],\n    'app\\storage\\DocumentsReader' =\n [\n        ['class' =\n 'app\\storage\\DocumentsReader'],\n        [Instance::of('tempFileStorage')]\n    ],\n    'app\\storage\\DocumentsWriter' =\n [\n        ['class' =\n 'app\\storage\\DocumentsWriter'],\n        [Instance::of('tempFileStorage')]\n    ]\n]);\n\n$reader = $container-\nget('app\\storage\\DocumentsReader); \n// Will behave exactly the same as in the previous example.\n\n\n\nPotresti notare la notazione \nInstance::of('tempFileStorage')\n. Significa che il Container fornir\u00e0 implicitamente una dipendenza registrata con il nome \ntempFileStorage\n e la passer\u00e0 come primo argomento del costruttore \napp\\storage\\DocumentsWriter\n.\n\n\nUn altro passo sull'ottimizzazione della configurazione consiste nel registrare alcune dipendenze come singleton. Una dipendenza registrata tramite \nset()\n verr\u00e0 istanziata ogni volta che \u00e8 necessario. Alcune classi non cambiano lo stato durante il runtime, pertanto possono essere registrate come singleton per aumentare le prestazioni dell'applicazione.\n\n\nUn buon esempio potrebbe essere la classe \napp\\storage\\FileStorage\n, che esegue alcune operazioni sul file system con una semplice API (ad esempio \n$fs-\nread()\n, \n$fs-\nwrite()\n). Queste operazioni non cambiano lo stato della classe interna, quindi possiamo creare la sua istanza una volta e usarla pi\u00f9 volte.\n\n\n$container-\nsetSingletons([\n    'tempFileStorage' =\n [\n        ['class' =\n 'app\\storage\\FileStorage'],\n        ['/var/tempfiles']\n    ],\n]);\n\n$container-\nsetDefinitions([\n    'app\\storage\\DocumentsReader' =\n [\n        ['class' =\n 'app\\storage\\DocumentsReader'],\n        [Instance::of('tempFileStorage')]\n    ],\n    'app\\storage\\DocumentsWriter' =\n [\n        ['class' =\n 'app\\storage\\DocumentsWriter'],\n        [Instance::of('tempFileStorage')]\n    ]\n]);\n\n$reader = $container-\nget('app\\storage\\DocumentsReader');\n\n\n\nQuando registrare le dipendenze\n\n\nPoich\u00e9 le dipendenze sono necessarie quando vengono creati nuovi oggetti, la loro registrazione dovrebbe essere fatta il prima possibile. Le seguenti sono le pratiche raccomandate:\n\n\n\n\nSe sei lo sviluppatore di un'applicazione, puoi registrare le tue dipendenze usando la configurazione dell'applicazione.\n\n\nSe sei lo sviluppatore di un'estensione ridistribuibile , puoi registrare le dipendenze nella classe di avvio automatico dell'estensione.",
            "title": "Contenitore Dependency Injection"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#contenitore-dependency-injection",
            "text": "Un contenitore DI (dependency injection) \u00e8 un oggetto che sa istanziare e configurare oggetti e tutti i loro oggetti dipendenti. Qui spiegheremo principalmente l'utilizzo del contenitore DI fornito da Yii.",
            "title": "Contenitore Dependency Injection"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#dependency-injection",
            "text": "Yii fornisce la funzione contenitore DI attraverso la classe  yii \\ di \\ Container . Supporta i seguenti tipi di injection di dipendenza:   Costructor Injection;  Method Injection;  Setter e property injection;  PHP callable injection;",
            "title": "Dependency Injection"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#costructor-injection",
            "text": "Il contenitore DI supporta il costructor injection con l'aiuto del tipo  hint  per i parametri del costruttore. Gli hint del tipo indicano al contenitore quali classi o interfacce dipendono quando viene utilizzato per creare un nuovo oggetto. Il contenitore prover\u00e0 a ottenere le istanze delle classi o interfacce dipendenti e quindi le inserir\u00e0 nel nuovo oggetto tramite il costruttore. Per esempio,  class Foo{\n\n    public function __construct(Bar $bar){\n\n    }\n}\n\n$foo = $container- get('Foo');\n// which is equivalent to the following:\n$bar = new Bar;\n$foo = new Foo($bar);",
            "title": "Costructor Injection"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#method-injection",
            "text": "Di solito le dipendenze di una classe vengono passate al costruttore e sono disponibili all'interno della classe durante l'intero ciclo di vita. Con il Method Injection \u00e8 possibile fornire una dipendenza che \u00e8 necessaria solo per un singolo metodo della classe e passarla al costruttore, e potrebbe non essere possibile o potrebbe causare un sovraccarico nella maggior parte dei casi d'uso.  Un metodo di classe pu\u00f2 essere definito come il metodo  doSomething()  nel seguente esempio:  class MyClass extends \\yii\\base\\Component{\n\n    public function __construct(/*Some lightweight dependencies here*/, $config = []){\n\n        // ...\n    }\n\n    public function doSomething($param1, \\my\\heavy\\Dependency $something){\n\n        // do something with $something\n    }\n}  Puoi chiamare quel metodo passando un'istanza di  \\my\\heavy\\Dependencyt  e stesso o usando  yii \\ di \\ Container :: invoke()  come segue:  $obj = new MyClass(/*...*/);\nYii::$container- invoke([$obj, 'doSomething'], ['param1' =  42]); // $something will be provided by the DI container",
            "title": "Method Injection"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#setter-e-property-injection",
            "text": "Il setter e il property injection sono supportati attraverso le configurazioni. Quando si registra una dipendenza o quando si crea un nuovo oggetto, \u00e8 possibile fornire una configurazione che verr\u00e0 utilizzata dal contenitore per iniettare le dipendenze tramite i setter o le propriet\u00e0 corrispondenti. Per esempio,  use yii\\base\\BaseObject;\n\nclass Foo extends BaseObject{\n\n    public $bar;\n\n    private $_qux;\n\n    public function getQux(){\n\n        return $this- _qux;\n    }\n\n    public function setQux(Qux $qux){\n\n        $this- _qux = $qux;\n    }\n}\n\n$container- get('Foo', [], [\n    'bar' =  $container- get('Bar'),\n    'qux' =  $container- get('Qux'),\n]);   Info  Il metodo  yii \\ di \\ Container :: get()  accetta il suo terzo parametro come array di configurazione da applicare all'oggetto che si sta creando. Se la classe implementa l' interfaccia  yii \\ base \\ Configurable  (es.  Yii \\ base \\ BaseObject  ), l'array di configurazione verr\u00e0 passato come ultimo parametro al costruttore della classe; in caso contrario, la configurazione verr\u00e0 applicata dopo la creazione dell'oggetto.",
            "title": "Setter e Property Injection"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#php-callable-injection",
            "text": "In questo caso, il contenitore utilizzer\u00e0 un PHP registrato callable per creare nuove istanze di una classe. Ogni volta che viene chiamato  yii \\ di \\ Container :: get() , verr\u00e0 richiamato il callable corrispondente. Il callable \u00e8 responsabile di risolvere le dipendenze e iniettarle in modo appropriato sugli oggetti appena creati. Per esempio,  $container- set('Foo', function () {\n    $foo = new Foo(new Bar);\n    // ... other initializations ...\n    return $foo;\n});\n\n$foo = $container- get('Foo');  Per nascondere la logica complessa per la costruzione di un nuovo oggetto, \u00e8 possibile utilizzare un metodo di classe statico come callable. Per esempio,  class FooBuilder{\n\n    public static function build(){\n\n        $foo = new Foo(new Bar);\n        // ... other initializations ...\n        return $foo;\n    }\n}\n\n$container- set('Foo', ['app\\helper\\FooBuilder', 'build']);\n\n$foo = $container- get('Foo');  In questo modo, la persona che desidera configurare la classe  Foo  non deve pi\u00f9 essere consapevole di come \u00e8 stata creata.",
            "title": "PHP Callable Injection"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#registrazione-delle-dipendenze",
            "text": "\u00c8 possibile utilizzare  yii \\ di \\ Container :: set()  per registrare le dipendenze. La registrazione richiede un nome di dipendenza e una definizione di dipendenza. Un nome di dipendenza pu\u00f2 essere un nome di classe, un nome di interfaccia o un nome di alias; e una definizione di dipendenza pu\u00f2 essere un nome di classe, un array di configurazione o un callable PHP.  $container = new \\yii\\di\\Container;\n\n// register a class name as is. This can be skipped.\n$container- set('yii\\db\\Connection');\n\n// register an interface\n// When a class depends on the interface, the corresponding class\n// will be instantiated as the dependent object\n$container- set('yii\\mail\\MailInterface', 'yii\\swiftmailer\\Mailer');\n\n// register an alias name. You can use $container- get('foo')\n// to create an instance of Connection\n$container- set('foo', 'yii\\db\\Connection');\n\n// register a class with configuration. The configuration\n// will be applied when the class is instantiated by get()\n$container- set('yii\\db\\Connection', [\n    'dsn' =  'mysql:host=127.0.0.1;dbname=demo',\n    'username' =  'root',\n    'password' =  '',\n    'charset' =  'utf8',\n]);\n\n// register an alias name with class configuration\n// In this case, a \"class\" element is required to specify the class\n$container- set('db', [\n    'class' =  'yii\\db\\Connection',\n    'dsn' =  'mysql:host=127.0.0.1;dbname=demo',\n    'username' =  'root',\n    'password' =  '',\n    'charset' =  'utf8',\n]);\n\n// register a PHP callable\n// The callable will be executed each time when $container- get('db') is called\n$container- set('db', function ($container, $params, $config) {\n    return new \\yii\\db\\Connection($config);\n});\n\n// register a component instance\n// $container- get('pageCache') will return the same instance each time it is called\n$container- set('pageCache', new FileCache);   Tip  Se il nome di una dipendenza \u00e8 uguale alla definizione di dipendenza corrispondente, non \u00e8 necessario registrarlo con il contenitore DI.   Una dipendenza registrata tramite  set()  generer\u00e0 un'istanza ogni volta che \u00e8 necessaria la dipendenza. \u00c8 possibile utilizzare  yii \\ di \\ Container :: setSingleton()  per registrare una dipendenza che genera solo una singola istanza:  $container- setSingleton('yii\\db\\Connection', [\n    'dsn' =  'mysql:host=127.0.0.1;dbname=demo',\n    'username' =  'root',\n    'password' =  '',\n    'charset' =  'utf8',\n]);",
            "title": "Registrazione delle dipendenze"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#risolvere-le-dipendenze",
            "text": "Dopo aver registrato le dipendenze, \u00e8 possibile utilizzare il contenitore DI per creare nuovi oggetti e il contenitore risolver\u00e0 automaticamente le dipendenze istanziandole e inserendole negli oggetti appena creati. La risoluzione delle dipendenze \u00e8 ricorsiva, il che significa che se una dipendenza ha altre dipendenze, anche queste dipendenze verranno risolte automaticamente.  Puoi usare  get()  per creare o ottenere istanze di oggetti. Il metodo accetta un nome di dipendenza, che pu\u00f2 essere un nome di classe, un nome di interfaccia o un nome alias. Il nome della dipendenza pu\u00f2 essere registrato tramite  set()  o  setSingleton() . Opzionalmente \u00e8 possibile fornire un elenco di parametri del costruttore della classe e una configurazione per configurare l'oggetto appena creato.  Per esempio:  // \"db\" is a previously registered alias name\n$db = $container- get('db');\n\n// equivalent to: $engine = new \\app\\components\\SearchEngine($apiKey, $apiSecret, ['type' =  1]);\n$engine = $container- get('app\\components\\SearchEngine', [$apiKey, $apiSecret], ['type' =  1]);  Dietro la scena, il contenitore DI fa molto pi\u00f9 lavoro rispetto alla semplice creazione di un nuovo oggetto. Il contenitore, prima ispezioner\u00e0 il costruttore della classe per scoprire i nomi di classe o interfaccia dipendenti, e dopo risolver\u00e0 automaticamente tali dipendenze in modo ricorsivo.  Il seguente codice mostra un esempio pi\u00f9 sofisticato. La classe  UserLister  dipende da un oggetto che implementa l'interfaccia  UserFinderInterface ; la classe  UserFinder  implementa questa interfaccia e dipende da un oggetto  Connection . Tutte queste dipendenze sono dichiarate tramite il suggerimento sul tipo dei parametri del costruttore della classe. Con la registrazione delle dipendenze delle propriet\u00e0, il contenitore DI \u00e8 in grado di risolvere automaticamente queste dipendenze e crea una nuova istanza  UserLister  con una semplice chiamata di  get('userLister') .  namespace app\\models;\n\nuse yii\\base\\BaseObject;\nuse yii\\db\\Connection;\nuse yii\\di\\Container;\n\ninterface UserFinderInterface{\n\n    function findUser();\n}\n\nclass UserFinder extends BaseObject implements UserFinderInterface{\n\n    public $db;\n\n    public function __construct(Connection $db, $config = []){\n\n        $this- db = $db;\n        parent::__construct($config);\n    }\n\n    public function findUser(){\n\n    }\n}\n\nclass UserLister extends BaseObject{\n\n    public $finder;\n\n    public function __construct(UserFinderInterface $finder, $config = []){\n\n        $this- finder = $finder;\n        parent::__construct($config);\n    }\n}\n\n$container = new Container;\n$container- set('yii\\db\\Connection', [\n    'dsn' =  '...',\n]);\n$container- set('app\\models\\UserFinderInterface', [\n    'class' =  'app\\models\\UserFinder',\n]);\n$container- set('userLister', 'app\\models\\UserLister');\n\n$lister = $container- get('userLister');\n\n// which is equivalent to:\n\n$db = new \\yii\\db\\Connection(['dsn' =  '...']);\n$finder = new UserFinder($db);\n$lister = new UserLister($finder);",
            "title": "Risolvere le dipendenze"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#uso-pratico",
            "text": "Yii crea un contenitore DI quando si include il file  Yii.php  nell'entry script della propria applicazione. Il contenitore DI \u00e8 accessibile tramite il contenitore  Yii :: $ . Quando chiamate  Yii :: createObject() , il metodo chiamer\u00e0 effettivamente il metodo  get()  del contenitore per creare un nuovo oggetto. Come sopra indicato, il contenitore DI risolver\u00e0 automaticamente le dipendenze (se presenti) e le inietter\u00e0 nell'oggetto ottenuto. Poich\u00e9 Yii usa  Yii :: createObject()  nella maggior parte del suo codice per creare nuovi oggetti, questo significa che puoi personalizzare gli oggetti globalmente trattando con  Yii :: $ container .  Ad esempio, personalizziamo globalmente il numero predefinito di pulsanti di impaginazione di  yii \\ widgets \\ LinkPager .  \\Yii::$container- set('yii\\widgets\\LinkPager', ['maxButtonCount' =  5]);  Ora se si utilizza il widget in una vista con il seguente codice, la propriet\u00e0  maxButtonCount  verr\u00e0 inizializzata come 5 invece del valore predefinito 10 come definito nella classe.  echo \\yii\\widgets\\LinkPager::widget();  E' comunque possibile sovrascrivere il valore impostato tramite il contenitore DI, tuttavia:  echo \\yii\\widgets\\LinkPager::widget(['maxButtonCount' =  20]);  Un altro esempio \u00e8 quello di sfruttare l'injection del costruttore in modo automatico. Supponiamo che la classe del controller dipenda da altri oggetti, come un servizio di prenotazione di un hotel. \u00c8 possibile dichiarare la dipendenza tramite un parametro del costruttore e lasciare che il contenitore DI lo risolva automaticamente.  namespace app\\controllers;\n\nuse yii\\web\\Controller;\nuse app\\components\\BookingInterface;\n\nclass HotelController extends Controller{\n\n    protected $bookingService;\n\n    public function __construct($id, $module, BookingInterface $bookingService, $config = []){\n\n        $this- bookingService = $bookingService;\n        parent::__construct($id, $module, $config);\n    }\n}  Se accedi a questo controller dal browser, vedrai un errore  BookingInterface  che non pu\u00f2 essere istanziato. Questo perch\u00e9 \u00e8 necessario indicare al contenitore DI come gestire questa dipendenza:  \\Yii::$container- set('app\\components\\BookingInterface', 'app\\components\\BookingService');  Ora, se si accede nuovamente al controller,  app\\components\\BookingService  verr\u00e0 creata e iniettata un'istanza come terzo parametro per il costruttore del controllore.",
            "title": "Uso pratico"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#uso-pratico-avanzato",
            "text": "Supponiamo che lavoriamo sull'applicazione API e abbiamo:   la classe  app\\components\\Request  che si estende  yii\\web\\Request  e fornisce funzionalit\u00e0 aggiuntive;  la classe  app\\components\\Response  che si estende  yii\\web\\Response  e dovrebbe avere la propriet\u00e0  format  impostata  json  sulla creazione;   le classi  app\\storage\\FileStorage  e  app\\storage\\DocumentsReader  che implementano alcune logiche sul lavoro con i documenti che si trovano in qualche archivio di file:  class FileStorage{  public function __construct($root) {\n    // whatever\n}  }  class DocumentsReader{  public function __construct(FileStorage $fs) {\n    // whatever\n}  }    \u00c8 possibile configurare pi\u00f9 definizioni contemporaneamente, passando l'array di configurazione al metodo  setDefinitions()  o  setSingletons() . Iterando sull'array di configurazione, i metodi chiameranno  set()  o  setSingleton()  rispettivamente per ciascun elemento.  Il formato dell'array di configurazione \u00e8:   key : nome della classe, nome dell'interfaccia o nome di un alias. La chiave verr\u00e0 passata al metodo  set()  come primo argomento  $class .  value : la definizione associata a  $class . I valori possibili sono descritti nella documentazione  set()  per il parametro  $definition . Sar\u00e0 passato al metodo  set()  come secondo argomento  $definition .   Ad esempio, configuriamo il nostro contenitore per seguire i requisiti sopra citati:  $container- setDefinitions([\n    'yii\\web\\Request' =  'app\\components\\Request',\n    'yii\\web\\Response' =  [\n        'class' =  'app\\components\\Response',\n        'format' =  'json'\n    ],\n    'app\\storage\\DocumentsReader' =  function () {\n        $fs = new app\\storage\\FileStorage('/var/tempfiles');\n        return new app\\storage\\DocumentsReader($fs);\n    }\n]);\n\n$reader = $container- get('app\\storage\\DocumentsReader'); \n// Will create DocumentReader object with its dependencies as described in the config   Tip  Il contenitore pu\u00f2 essere configurato in stile dichiarativo utilizzando la configurazione dell'applicazione dalla versione 2.0.11.   Tutto funziona, ma nel caso avessimo bisogno di creare una classe  DocumentWriter , dovremmo copiare e incollare la linea che crea l'oggetto   FileStorage , che non \u00e8 il modo pi\u00f9 intelligente, ovviamente.  Come descritto nella sottosezione Resolving Dependencies , set()  e  setSingleton()  possono facoltativamente assumere i parametri del costruttore della dipendenza come terzo argomento. Per impostare i parametri del costruttore, \u00e8 possibile utilizzare il seguente formato di matrice di configurazione:   key : nome della classe, nome dell'interfaccia o nome di un alias. La chiave verr\u00e0 passata al metodo  set()  come primo argomento  $class .  value : array di due elementi. Il primo elemento sar\u00e0 passato al metodo  set()  come secondo argomento  $definition , mentre il secondo sar\u00e0  $params .   Modifichiamo il nostro esempio:  $container- setDefinitions([\n    'tempFileStorage' =  [ // we've created an alias for convenience\n        ['class' =  'app\\storage\\FileStorage'],\n        ['/var/tempfiles'] // could be extracted from some config files\n    ],\n    'app\\storage\\DocumentsReader' =  [\n        ['class' =  'app\\storage\\DocumentsReader'],\n        [Instance::of('tempFileStorage')]\n    ],\n    'app\\storage\\DocumentsWriter' =  [\n        ['class' =  'app\\storage\\DocumentsWriter'],\n        [Instance::of('tempFileStorage')]\n    ]\n]);\n\n$reader = $container- get('app\\storage\\DocumentsReader); \n// Will behave exactly the same as in the previous example.  Potresti notare la notazione  Instance::of('tempFileStorage') . Significa che il Container fornir\u00e0 implicitamente una dipendenza registrata con il nome  tempFileStorage  e la passer\u00e0 come primo argomento del costruttore  app\\storage\\DocumentsWriter .  Un altro passo sull'ottimizzazione della configurazione consiste nel registrare alcune dipendenze come singleton. Una dipendenza registrata tramite  set()  verr\u00e0 istanziata ogni volta che \u00e8 necessario. Alcune classi non cambiano lo stato durante il runtime, pertanto possono essere registrate come singleton per aumentare le prestazioni dell'applicazione.  Un buon esempio potrebbe essere la classe  app\\storage\\FileStorage , che esegue alcune operazioni sul file system con una semplice API (ad esempio  $fs- read() ,  $fs- write() ). Queste operazioni non cambiano lo stato della classe interna, quindi possiamo creare la sua istanza una volta e usarla pi\u00f9 volte.  $container- setSingletons([\n    'tempFileStorage' =  [\n        ['class' =  'app\\storage\\FileStorage'],\n        ['/var/tempfiles']\n    ],\n]);\n\n$container- setDefinitions([\n    'app\\storage\\DocumentsReader' =  [\n        ['class' =  'app\\storage\\DocumentsReader'],\n        [Instance::of('tempFileStorage')]\n    ],\n    'app\\storage\\DocumentsWriter' =  [\n        ['class' =  'app\\storage\\DocumentsWriter'],\n        [Instance::of('tempFileStorage')]\n    ]\n]);\n\n$reader = $container- get('app\\storage\\DocumentsReader');",
            "title": "Uso pratico avanzato"
        },
        {
            "location": "/key-concepts/sub-dependency-injection-container/#quando-registrare-le-dipendenze",
            "text": "Poich\u00e9 le dipendenze sono necessarie quando vengono creati nuovi oggetti, la loro registrazione dovrebbe essere fatta il prima possibile. Le seguenti sono le pratiche raccomandate:   Se sei lo sviluppatore di un'applicazione, puoi registrare le tue dipendenze usando la configurazione dell'applicazione.  Se sei lo sviluppatore di un'estensione ridistribuibile , puoi registrare le dipendenze nella classe di avvio automatico dell'estensione.",
            "title": "Quando registrare le dipendenze"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/",
            "text": "Accesso ai dati tramite oggetti\n\n\nCostruito su PDO , Yii DAO (Database Access Objects) fornisce un'API orientata agli oggetti per l'accesso ai database relazionali. \u00c8 la base per altri metodi di accesso al database pi\u00f9 avanzati, tra cui il generatore di query e l'Active Record.\n\n\nQuando si utilizza Yii DAO, si ha principalmente bisogno di gestire semplici SQL e array PHP. Di conseguenza, \u00e8 il modo pi\u00f9 efficiente per accedere ai database. Tuttavia, poich\u00e9 la sintassi SQL pu\u00f2 variare per diversi database, l'uso di Yii DAO significa anche che \u00e8 necessario uno sforzo maggiore per creare un'applicazione indipendente dal database.\n\n\nYii DAO supporta i seguenti database:\n\n\n\n\nMySQL\n\n\nMariaDB\n\n\nSQLite\n\n\nPostgreSQL: versione 8.4 o superiore\n\n\nCUBRID: verisone 9.3 o superiore\n\n\nOracle\n\n\nMSSQL: versione 2008 o superiore\n\n\n\n\n\n\nNota\n\n\nLa nuova versione di pdo_oci per PHP 7 attualmente esiste solo come codice sorgente. Seguire le istruzioni fornite dalla comunit\u00e0 per compilarlo o utilizzare il livello di emulazione PDO.\n\n\n\n\nCreazione di connesisoni DB\n\n\nPer accedere a un database, \u00e8 innanzitutto necessario connettersi ad esso creano un'istanza di \nyii \\ db \\ Connection ::\n:\n\n\n$db = new yii\\db\\Connection([\n    'dsn' =\n 'mysql:host=localhost;dbname=example',\n    'username' =\n 'root',\n    'password' =\n '',\n    'charset' =\n 'utf8',\n]);\n\n\n\nPoich\u00e8 \u00e8 spesso necessario accedere a una connessione DB in luoghi diversi del nostro progetto, \u00e8 prassi comune configurarla in termini di un componente dell'applicazione, come il seguente:\n\n\nreturn [\n    // ...\n    'components' =\n [\n        // ...\n        'db' =\n [\n            'class' =\n 'yii\\db\\Connection',\n            'dsn' =\n 'mysql:host=localhost;dbname=example',\n            'username' =\n 'root',\n            'password' =\n '',\n            'charset' =\n 'utf8',\n        ],\n    ],\n    // ...\n];\n\n\n\nE' quindi possibile accedere alla connessione DB tramite l'espressione \nYii::$app-\ndb\n.\n\n\n\n\nTip\n\n\nE' possibile configurare pi\u00f9 componenti dell'applicazione DB se l'applicazione deve accedere a pi\u00f9 database.\n\n\n\n\nQuando si configura una connessione DB, \u00e8 necessario specificare sempre il suo Database Source Name (DSN) tramite la propriet\u00e0 \ndsn\n. Il formato di DSN varia per diversi database. Di seguito sono riportati alcuni esempi:\n\n\n\n\nMySQL, MariaDB: \nmysql:host=localhost;dbname=mydatabase\n\n\nSQLite: \nsqlite:/path/to/database/file\n\n\nPostgreSQL: \npgsql:host=localhost;port=5432;dbname=mydatabase\n\n\ncubrid: \ncubrid:dbname=demodb;host=localhost;port=33000\n\n\nMS SQL Server (tramite driver sqlsrv): \nsqlsrv:Server=localhost;Database=mydatabase\n\n\nMS SQL Server (tramite driver dblib): \ndblib:host=localhost;dbname=mydatabase\n\n\nMS SQL Server (tramite driver mssql): \nmssql:host=localhost;dbname=mydatabase\n\n\nOracle: \noci:dbname=//localhost:1521/mydatabase\n\n\n\n\nSi noti che se ci si connette a un database tramite ODBC, \u00e8 necessario configurare la propriet\u00e0 \nyii \\ db \\ Connection :: driverName\n in modo che Yii possa conoscere il tipo di database effettivo. Per esempio,\n\n\n'db' =\n [\n    'class' =\n 'yii\\db\\Connection',\n    'driverName' =\n 'mysql',\n    'dsn' =\n 'odbc:Driver={MySQL};Server=localhost;Database=test',\n    'username' =\n 'root',\n    'password' =\n '',\n],\n\n\n\nOltre alla prorpiet\u00e0 \ndsn\n, \u00e8 spesso necessario configurare nome utente e password per accedervi.\n\n\n\n\nTip\n\n\nA volte potresti voler eseguire alcune query subito dopo aver stabilito la connessione al database per inizializzare alcune variabili di ambiente (ad esempio, per impostare il fuso orario o il set di caratteri). \u00c8 possibile farlo registrando un gestore di eventi per l' evento \nafterOpen\n nella connessione al database. Puoi registrare il gestore direttamente nella configurazione dell'applicazione in questo modo:\n\n\n'db' =\n [\n    // ...\n    'on afterOpen' =\n function($event) {\n        // $event-\nsender refers to the DB connection\n        $event-\nsender-\ncreateCommand(\"SET time_zone = 'UTC'\")-\nexecute();\n    }\n],\n\n\n\n\n\nEsecuzione di query SQL\n\n\nUna volta che si dispone di un'istanza di connessione al database, \u00e8 possibile eseguire una query SQL effettuando le seguenti operazioni:\n\n\n\n\nCreare un comando \n yii \\ db\n con una semplice query SQL;\n\n\nParametri di binding (opzionale)\n\n\nChiama uno dei metodi di esecuzione SQL in \n yii \\ db \\ Command \n.\n\n\n\n\nL'esempio seguente mostra vari modi di recuperare i dati da un database:\n\n\n// return a set of rows. each row is an associative array of column names and values.\n// an empty array is returned if the query returned no results\n$posts = Yii::$app-\ndb-\ncreateCommand('SELECT * FROM post')\n            -\nqueryAll();\n\n// return a single row (the first row)\n// false is returned if the query has no result\n$post = Yii::$app-\ndb-\ncreateCommand('SELECT * FROM post WHERE id=1')\n           -\nqueryOne();\n\n// return a single column (the first column)\n// an empty array is returned if the query returned no results\n$titles = Yii::$app-\ndb-\ncreateCommand('SELECT title FROM post')\n             -\nqueryColumn();\n\n// return a scalar value\n// false is returned if the query has no result\n$count = Yii::$app-\ndb-\ncreateCommand('SELECT COUNT(*) FROM post')\n             -\nqueryScalar();\n\n\n\nParametri Bindings\n\n\nQuando si crea un comando DB da un SQL con parametri, si dovrebbe quasi sempre utilizzare l'approccio dei parametri di binding per prevenire attacchi di SQL injection. Per esempio,\n\n\n$post = Yii::$app-\ndb-\ncreateCommand('SELECT * FROM post WHERE id=:id AND status=:status')\n           -\nbindValue(':id', $_GET['id'])\n           -\nbindValue(':status', 1)\n           -\nqueryOne();\n\n\n\nNell'istruzione SQL, \u00e8 possibile incorporare uno o pi\u00f9 segnaposti dei parametri (ad esempio :\nid\n nell'esempio precedente). Un segnaposto di parametro dovrebbe essere una stringa che inizia con due punti. \u00c8 quindi possibile chiamare uno dei seguenti metodi di associazione dei parametri per associare i valori dei parametri:\n\n\n\n\nbindValue()\n: associa un valore di parametro singolo\n\n\nbindValues()\n: associa pi\u00f9 valori di parametro in una chiamata\n\n\nbindParam()\n: simile a \nbinadValue()\n ma supporta anche i riferimenti ai parametri di bind.\n\n\n\n\nL'esempio seguente mostra metodi alternativi per i parametri di binding:\n\n\n$params = [':id' =\n $_GET['id'], ':status' =\n 1];\n\n$post = Yii::$app-\ndb-\ncreateCommand('SELECT * FROM post WHERE id=:id AND status=:status')\n           -\nbindValues($params)\n           -\nqueryOne();\n\n$post = Yii::$app-\ndb-\ncreateCommand('SELECT * FROM post WHERE id=:id AND status=:status', $params)\n\n\n\nIl binding dei parametri viene implementato tramite dichiarazioni preparate. Oltre a prevenire attacchi di SQL injection, pu\u00f2 anche migliorare le prestazioni preparando una dichiarazione SQL una volta e eseguendola pi\u00f9 volte con parametri diversi. Per esempio,\n\n\n$command = Yii::$app-\ndb-\ncreateCommand('SELECT * FROM post WHERE id=:id');\n\n$post1 = $command-\nbindValue(':id', 1)-\nqueryOne(); \n$post2 = $command-\nbindValue(':id', 2)-\nqueryOne();\n// ...\n\n\n\nPoich\u00e8 \nbindParam()\n supporta i parametri di associazione per riferimento, il codice precedente pu\u00f2 anche essere scritto come segue:\n\n\n$command = Yii::$app-\ndb-\ncreateCommand('SELECT * FROM post WHERE id=:id')\n              -\nbindParam(':id', $id);\n\n$id = 1;\n$post1 = $command-\nqueryOne();\n\n$id = 2;\n$post2 = $command-\nqueryOne();\n// ...\n\n\n\nSi noti che si lega il segnaposto alla variabile \n$id\n prima dell'esecuzione e quindi si modifica il valore di tale variabile prima di ogni esecuzione successiva (spesso con loop). L'esecuzione di query in questo modo pu\u00f2 essere notevolmente pi\u00f9 efficiente rispetto all'esecuzione di una nuova query per ogni valore di parametro diverso.\n\n\n\n\nInfo\n\n\nIl collegamento dei parametri viene utilizzato solo in luoghi in cui \u00e8 necessario inserire valori in stringhe che contengono SQL semplice. In molti posti in livelli di astrazione pi\u00f9 alti, come il generatore di query e l'Active Record, si specifica spesso una serie di valori che verranno trasformati in SQL. In questi punti il \u200b\u200bbinding dei parametri viene eseguito internamente da Yii, quindi non \u00e8 necessario specificare i parametri manualmente.\n\n\n\n\nEsecuzione di query non SELECT\n\n\nI metodi \nqueryXyz()\n introdotti nelle sezioni precedenti riguardano tutti le query SELECT che prelevano i dati dai database. Per le query che non restituiscono dati, \u00e8 necessario chiamare invece il metodo \nyii \\ db \\ Command :: execute()\n. Per esempio,\n\n\nYii::$app-\ndb-\ncreateCommand('UPDATE post SET status=1 WHERE id=1')\n-\nexecute();\n\n\n\nIl metodo \nyii \\ db \\ Command :: execute()\n restituisce il numero di righe interessate dall'esecuzione SQL.\n\n\nPer le query INSERT, UPDATE e DELETE, invece di scrivere semplici SQL, \u00e8 possibile chiamare \ninsert()\n, \nupdate()\n , \ndelete()\n, per creare gli SQL corrispondenti. Questi metodi indicheranno correttamente i nomi di tabelle e colonne e i valori dei parametri di bind. Per esempio,\n\n\n// INSERT (table name, column values)\nYii::$app-\ndb-\ncreateCommand()-\ninsert('user', [\n    'name' =\n 'Sam',\n    'age' =\n 30,\n])-\nexecute();\n\n// UPDATE (table name, column values, condition)\nYii::$app-\ndb-\ncreateCommand()-\nupdate('user', ['status' =\n 1], 'age \n 30')-\nexecute();\n\n// DELETE (table name, condition)\nYii::$app-\ndb-\ncreateCommand()-\ndelete('user', 'status = 0')-\nexecute();\n\n\n\nPuoi anche chiamare \nbatchInsert()\n per inserire pi\u00f9 righe in un colpo, che \u00e8 molto pi\u00f9 efficiente dell'inserimento di una riga per volta:\n\n\n// table name, column names, column values\nYii::$app-\ndb-\ncreateCommand()-\nbatchInsert('user', ['name', 'age'], [\n    ['Tom', 30],\n    ['Jane', 20],\n    ['Linda', 25],\n])-\nexecute();\n\n\n\nNota che i metodi sopra menzionati creano solo la query e devi sempre richiamare il metodo \nexecute()\n per eseguirli.\n\n\nCitazione dei noim relativi a tabelle e colonne\n\n\nDurante la scrittura di codice indipendente dal database, la citazione corretta dei nomi di tabelle e colonne \u00e8 spesso un problema perch\u00e9 diversi database hanno regole di quoting diverse. Per superare questo problema, \u00e8 possibile utilizzare la seguente sintassi di citazione introdotta da Yii:\n\n\n\n\n[[column name]]\n: racchiude il nome di una colonna da citare tra parentesi quadre;\n\n\n{{table name}}\n: racchiude il nome di una tabella da quotare tra parentesi graffe doppie.\n\n\n\n\nYii DAO convertir\u00e0 automaticamente tali costrutti nella colonna o nei nomi di tabella citati corrispondenti, utilizzando la sintassi specifica DBMS. Per esempio,\n\n\n// executes this SQL for MySQL: SELECT COUNT(`id`) FROM `employee`\n$count = Yii::$app-\ndb-\ncreateCommand(\"SELECT COUNT([[id]]) FROM {{employee}}\")\n            -\nqueryScalar();\n\n\n\nUtilizzo del prefisso tabella\n\n\nSe la maggior parte dei nomi delle tabelle DB condivide un prefisso comune, \u00e8 possibile utilizzare la funzione \ntablePrefix\n fornita da Yii DAO.\n\n\nPer prima cosa, specifica il prefisso della tabella tramite la propriet\u00e0 \nyii \\ db \\ Connection :: $ tablePrefix\n nella configurazione dell'applicazione:\n\n\nreturn [\n    // ...\n    'components' =\n [\n        // ...\n        'db' =\n [\n            // ...\n            'tablePrefix' =\n 'tbl_',\n        ],\n    ],\n];\n\n\n\nQuindi nel codice, ogni volta che \u00e8 necessario fare riferimento a una tabella il cui nome contiene tale prefisso, utilizzare la sintassi \n{{%table_name}}\n. Il carattere percentuale verr\u00e0 automaticamente sostituito con il prefisso tabella specificato durante la configurazione della connessione DB. Per esempio,\n\n\n// executes this SQL for MySQL: SELECT COUNT(`id`) FROM `tbl_employee`\n$count = Yii::$app-\ndb-\ncreateCommand(\"SELECT COUNT([[id]]) FROM {{%employee}}\")\n            -\nqueryScalar();\n\n\n\nEsecuzione di transazioni\n\n\nQuando si eseguono pi\u00f9 query correlate in una sequenza, potrebbe essere necessario includerle in una transazione per garantire l'integrit\u00e0 e la coerenza del database. Se una qualsiasi delle query non riesce, il database verr\u00e0 riportato allo stato come se nessuna di queste query fosse stata eseguita.\n\n\nIl codice seguente mostra un modo tipico di utilizzare le transazioni:\n\n\nYii::$app-\ndb-\ntransaction(function($db) {\n    $db-\ncreateCommand($sql1)-\nexecute();\n    $db-\ncreateCommand($sql2)-\nexecute();\n    // ... executing other SQL statements ...\n});\n\n\n\nIl codice riportato sopra \u00e8 equivalente al seguente, che offre un maggior controllo sul codice gestendo gli errori:\n\n\n$db = Yii::$app-\ndb;\n$transaction = $db-\nbeginTransaction();\ntry {\n    $db-\ncreateCommand($sql1)-\nexecute();\n    $db-\ncreateCommand($sql2)-\nexecute();\n    // ... executing other SQL statements ...\n\n    $transaction-\ncommit();\n} catch(\\Exception $e) {\n    $transaction-\nrollBack();\n    throw $e;\n} catch(\\Throwable $e) {\n    $transaction-\nrollBack();\n    throw $e;\n}\n\n\n\nChiamando il metodo \nbeginTransaction()\n, viene avviata una nuova transazione. La transazione \u00e8 rappresentata come un oggetto \nyii \\ db \\ Transaction\n memorizzato nella variabile \n$transaction\n. Quindi, le query eseguite sono racchiuse in un blocco \ntry...catch...\n. Se tutte le query vengono eseguite correttamente, il metodo \ncommit()\n viene chiamato per eseguire il commit della transazione. Altrimenti, se verr\u00e0 attivata e rilevata un'eccezione , viene chiamato il metodo \nrollBack()\n per eseguire il rollback delle modifiche apportate dalle query prima di quella query non riuscita nella transazione \nthrow $\n. Quindi rilanciamo l'eccezione come se non l'avessimo catturata, e a questo punto il normale processo di gestione degli errori si prender\u00e0 cura di esso.\n\n\n\n\nWarning\n\n\nNel codice precedente abbiamo due blocchi di cattura per la compatibilit\u00e0 con PHP 5.x e PHP 7.x. \n\\Exception\n implementa l'interfaccia \n\\Throwable\n da PHP 7.0, quindi puoi saltare la parte \n\\Exceptions\n e la tua app utilizza solo PHP 7.0 e versioni successive.\n\n\n\n\nSpecifica dei livelli di isolamento\n\n\nYii supporta anche l'impostazione dei livelli di isolamento per le tue transazioni. Per impostazione predefinita, quando si avvia una nuova transazione, verr\u00e0 utilizzato il livello di isolamento predefinito impostato dal sistema di database. \u00c8 possibile sovrascrivere il livello di isolamento predefinito come segue,\n\n\n$isolationLevel = \\yii\\db\\Transaction::REPEATABLE_READ;\n\nYii::$app-\ndb-\ntransaction(function ($db) {\n    ....\n}, $isolationLevel);\n\n// or alternatively\n\n$transaction = Yii::$app-\ndb-\nbeginTransaction($isolationLevel);\n\n\n\nYii fornisce quattro costranti per i livelli di isolamento pi\u00f9 comuni:\n\n\n\n\nyii \\ db \\ Transaction :: READ_UNCOMMITTED\n - il livello pi\u00f9 debole. Possono esserci letture sporche o letture non ripetibili.\n\n\nyii \\ db \\ Transaction ::READ_COMMITTED\n - evita le letture sporche.\n\n\nyii \\ db \\ Transaction :: REPETABLE_READ\n - evita le letture sporche e letture non ripetibili.\n\n\nyii \\ db \\ Transction :: SERIALIZABLE\n - il livello pi\u00f9 forte, evita tutti i problemi sopra citati.\n\n\n\n\nOltre a utilizzare le costanti sopra indicate per specificre i livelli di isolamento, \u00e8 possibile utilizzare anche stringhe con una sintassi valida supportata dal DBMS che si sta utilizzando. Ad esempio, in PostgreSQL, puoi usare \n\"SERIALIZABLE READ ONLY DEFERRABLE\"\n.\n\n\nSi noti che alcuni DBMS consentono di impostare il livello di isolamento solo per l'intera connessione. Qualsiasi transazione successiva otterr\u00e0 lo stesso livello di isolamento anche se non ne specifichiamo altre. Quando si utilizza questa funzione, potrebbe essere necessario impostare il livello di isolamento per tutte le transazioni in modo esplicito per evitare impostazioni in conflitto. Al momento della stesura di questo limite, solo MSSQL e SQLite sono interessati da questa limitazione.\n\n\n\n\nWarning\n\n\nSQLite supporta solo due livelli di isolamento, quindi \u00e8 possibile utilizzare solo \nREAD UNCOMMITTED\n e \nSERIALIZABLE\n. L'utilizzo di altri livelli si tradurr\u00e0 in un'eccezione generata.\n\n\n\n\n\n\nNota\n\n\nPostgreSQL non consente di impostare il livello di isolamento prima dell'inizio della transazione, quindi non \u00e8 possibile specificare direttamente il livello di isolamento quando si avvia la transazione. Devi chiamare \nyii \\ db \\ Transaction :: setIsolationLevel()\n in questo caso dopo l'avvio della transazione.\n\n\n\n\nAnnidamento delle transazioni\n\n\nSe il DBMS supporta Savepoint, \u00e8 possibile nidificare pi\u00f9 transazioni come le seguenti:\n\n\nYii::$app-\ndb-\ntransaction(function ($db) {\n    // outer transaction\n\n    $db-\ntransaction(function ($db) {\n        // inner transaction\n    });\n});\n\n\n\nO in alternativa,\n\n\n$db = Yii::$app-\ndb;\n$outerTransaction = $db-\nbeginTransaction();\ntry {\n    $db-\ncreateCommand($sql1)-\nexecute();\n\n    $innerTransaction = $db-\nbeginTransaction();\n    try {\n        $db-\ncreateCommand($sql2)-\nexecute();\n        $innerTransaction-\ncommit();\n    } catch (\\Exception $e) {\n        $innerTransaction-\nrollBack();\n        throw $e;\n    } catch (\\Throwable $e) {\n        $innerTransaction-\nrollBack();\n        throw $e;\n    }\n\n    $outerTransaction-\ncommit();\n} catch (\\Exception $e) {\n    $outerTransaction-\nrollBack();\n    throw $e;\n} catch (\\Throwable $e) {\n    $outerTransaction-\nrollBack();\n    throw $e;\n\n\n\nDuplicazione e divisione tra lettura / scrittura\n\n\nMolti DBMS supportano la replica del database per ottenere una migliore disponibilit\u00e0 del database e tempi di risposta del server pi\u00f9 rapidi. Con la replica del database, i dati vengono replicati dai cosiddetti server master ai server slave . Tutte le scritture e gli aggiornamenti devono essere eseguiti sui server master, mentre le letture possono anche avvenire sui server slave.\n\n\nPer sfruttare la replica del database e ottenere la divisione read-write, \u00e8 possibile configurare un componente \nyii \\ db \\ Connection\n come il seguente:\n\n\n[\n    'class' =\n 'yii\\db\\Connection',\n\n    // configuration for the master\n    'dsn' =\n 'dsn for master server',\n    'username' =\n 'master',\n    'password' =\n '',\n\n    // common configuration for slaves\n    'slaveConfig' =\n [\n        'username' =\n 'slave',\n        'password' =\n '',\n        'attributes' =\n [\n            // use a smaller connection timeout\n            PDO::ATTR_TIMEOUT =\n 10,\n        ],\n    ],\n\n    // list of slave configurations\n    'slaves' =\n [\n        ['dsn' =\n 'dsn for slave server 1'],\n        ['dsn' =\n 'dsn for slave server 2'],\n        ['dsn' =\n 'dsn for slave server 3'],\n        ['dsn' =\n 'dsn for slave server 4'],\n    ],\n]\n\n\n\nLa configurazione scritta sopra, specifica un'impostazione con un singolo master e pi\u00f9 slave. Uno degli slave verr\u00e0 connesso e utilizzato per eseguire query di lettura, mentre il master verr\u00e0 utilizzato per eseguire query di scrittura. Tale suddivisione in lettura-scrittura viene eseguita automaticamente con questa configurazione. Per esempio,\n\n\n// create a Connection instance using the above configuration\nYii::$app-\ndb = Yii::createObject($config);\n\n// query against one of the slaves\n$rows = Yii::$app-\ndb-\ncreateCommand('SELECT * FROM user LIMIT 10')-\nqueryAll();\n\n// query against the master\nYii::$app-\ndb-\ncreateCommand(\"UPDATE user SET username='demo' WHERE id=1\")-\nexecute();\n\n\n\n\n\nInfo\n\n\nLe query eseguite chiamando \nyii \\ db \\ Command :: execute()\n sono considerate query di scrittura, mentre tutte le altre query eseguite tramite uno dei metodi \"query\" di \nyii \\ db \\ Command\n sono query di lettura. \u00c8 possibile ottenere la connessione slave attualmente attiva tramite \nYii::$app-\ndb-\nslave\n.\n\n\n\n\nIl componente \nConnection\n supporta il bilanciamento del carico e il failover tra slave. Quando si esegue una query di lettura per la prima volta, il componente \nConnection\n sceglier\u00e0 in modo casuale uno slave e prova a connettersi ad esso. Se lo slave viene trovato \"morto\" (cio\u00e8 non d\u00e0 nessuna risposta), ne prova un altro. Se nessuno degli slave \u00e8 disponibile, si collegher\u00e0 al master. Configurando una cache di stato del server, un server \"morto\" pu\u00f2 essere ricordato in modo che non venga pi\u00f9 provato durante un certo periodo di tempo .\n\n\nE' inoltre possibile configurare pi\u00f9 master con pi\u00f9 slave. Per esempio:\n\n\n[\n    'class' =\n 'yii\\db\\Connection',\n\n    // common configuration for masters\n    'masterConfig' =\n [\n        'username' =\n 'master',\n        'password' =\n '',\n        'attributes' =\n [\n            // use a smaller connection timeout\n            PDO::ATTR_TIMEOUT =\n 10,\n        ],\n    ],\n\n    // list of master configurations\n    'masters' =\n [\n        ['dsn' =\n 'dsn for master server 1'],\n        ['dsn' =\n 'dsn for master server 2'],\n    ],\n\n    // common configuration for slaves\n    'slaveConfig' =\n [\n        'username' =\n 'slave',\n        'password' =\n '',\n        'attributes' =\n [\n            // use a smaller connection timeout\n            PDO::ATTR_TIMEOUT =\n 10,\n        ],\n    ],\n\n    // list of slave configurations\n    'slaves' =\n [\n        ['dsn' =\n 'dsn for slave server 1'],\n        ['dsn' =\n 'dsn for slave server 2'],\n        ['dsn' =\n 'dsn for slave server 3'],\n        ['dsn' =\n 'dsn for slave server 4'],\n    ],\n\n\n\nLa configurazione soprastante specifica due master e quattro slave. Il componente \nConnection\n supporta anche il bilanciamento del carico e il failover tra i master esattamente come avviene tra gli slave. Una differenza \u00e8 che quando nessuno dei master \u00e8 disponibile viene lanciata un'eccezione.\n\n\n\n\nWarning\n\n\nQuando si utilizza le propriet\u00e0 per configurare uno o pi\u00f9 master, tutte le altre propriet\u00e0 per la specifica di una connessione al database (ad esempio dsn, username, password) con l'oggetto stesso \nConnection\n verr\u00e0 ignorato.\n\n\n\n\nPer impostazione predefinita, le transazioni utilizzano la connessione principale. E all'interno di una transazione, tutte le operazioni DB utilizzeranno la connessione principale. Per esempio,\n\n\n$db = Yii::$app-\ndb;\n// the transaction is started on the master connection\n$transaction = $db-\nbeginTransaction();\n\ntry {\n    // both queries are performed against the master\n    $rows = $db-\ncreateCommand('SELECT * FROM user LIMIT 10')-\nqueryAll();\n    $db-\ncreateCommand(\"UPDATE user SET username='demo' WHERE id=1\")-\nexecute();\n\n    $transaction-\ncommit();\n} catch(\\Exception $e) {\n    $transaction-\nrollBack();\n    throw $e;\n} catch(\\Throwable $e) {\n    $transaction-\nrollBack();\n    throw $e;\n}\n\n\n\nSe si desidera avviare una transazione con la connessione slave, \u00e8 necessario farlo in modo esplicito. Come il seguente:\n\n\n$transaction = Yii::$app-\ndb-\nslave-\nbeginTransaction();\n\n\n\nA volte, potresti voler forzare l'uso della connessione principale per eseguire una query di lettura. Questo pu\u00f2 essere ottenuto con il metodo \nuseMaster()\n:\n\n\n$rows = Yii::$app-\ndb-\nuseMaster(function ($db) {\n    return $db-\ncreateCommand('SELECT * FROM user LIMIT 10')-\nqueryAll();\n});\n\n\n\nSi pu\u00f2 anche impostare direttamente \nYii::$app-\ndb.\nenableSlaves\n di essere a \nfalse\n a indirizzare tutte le query al collegamento master.\n\n\nLavorare con lo schema del proprio database\n\n\nYii DAO fornisce un intero set di metodi per consentire la manipolazione dello schema del database, come la creazione di nuove tabelle, il rilascio di una colonna da una tabella, ecc. Questi metodi sono elencati come segue:\n\n\n\n\ncreateTable()\n: creazione di una tabella;\n\n\nrenameTable()\n: rinomina una tabella;\n\n\ndropTable()\n: rimozione di una tabella;\n\n\ntruncateTable()\n: rimuove tutte le righe in una tabella;\n\n\naddColumn()\n: aggiunta di una colonna;\n\n\nrenameColumn()\n: rinomina una colonna;\n\n\ndropColumn()\n: rimuovendo una colonna;\n\n\nalterColumn()\n: modifica di una colonna;\n\n\naddPrimaryKey()\n: aggiunta di una chiave primaria;\n\n\ndropPrimaryKey()\n: rimozione di una chiave primaria;\n\n\naddForeignKey()\n: aggiunta di una chiave esterna;\n\n\ndropForeignKey()\n: rimozione di una chiave esterna;\n\n\ncreateIndex()\n: creazione di un indice;\n\n\ndropIndex()\n: rimozione di un indice.\n\n\n\n\nQuesti metodi possono essere utilizzati come i seguenti:\n\n\n// CREATE TABLE\nYii::$app-\ndb-\ncreateCommand()-\ncreateTable('post', [\n    'id' =\n 'pk',\n    'title' =\n 'string',\n    'text' =\n 'text',\n]);\n\n\n\nL'array sopra descritto descrive il nome e i tipi delle colonne da creare. Per i tipi di colonna, Yii fornisce un set di tipi di dati astratti, che consentono di definire uno schema agnostico del database. Questi vengono convertiti in definizioni accessibili dal DBMS dipendente dal database.\n\n\nOltre a modificare lo schema del database, \u00e8 anche possibile recuperare le informazioni sulla definizione di una tabella tramite il metodo \ngetTableSchema()\n di una connessione DB. Per esempio,\n\n\n$table = Yii::$app-\ndb-\ngetTableSchema('post');\n\n\n\nIl metodo restituisce un oggetto \nyii \\ db \\ TableSchema\n che contiene le informazioni sulle colonne della tabella, le chiavi primarie, le chiavi esterne e cos\u00ec via. Tutte queste informazioni sono principalmente utilizzate dal generatore di query e dall'Active Record per consentire la scrittura del codice agnostico del database.",
            "title": "Accesso ai dati tramite oggetti"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#accesso-ai-dati-tramite-oggetti",
            "text": "Costruito su PDO , Yii DAO (Database Access Objects) fornisce un'API orientata agli oggetti per l'accesso ai database relazionali. \u00c8 la base per altri metodi di accesso al database pi\u00f9 avanzati, tra cui il generatore di query e l'Active Record.  Quando si utilizza Yii DAO, si ha principalmente bisogno di gestire semplici SQL e array PHP. Di conseguenza, \u00e8 il modo pi\u00f9 efficiente per accedere ai database. Tuttavia, poich\u00e9 la sintassi SQL pu\u00f2 variare per diversi database, l'uso di Yii DAO significa anche che \u00e8 necessario uno sforzo maggiore per creare un'applicazione indipendente dal database.  Yii DAO supporta i seguenti database:   MySQL  MariaDB  SQLite  PostgreSQL: versione 8.4 o superiore  CUBRID: verisone 9.3 o superiore  Oracle  MSSQL: versione 2008 o superiore    Nota  La nuova versione di pdo_oci per PHP 7 attualmente esiste solo come codice sorgente. Seguire le istruzioni fornite dalla comunit\u00e0 per compilarlo o utilizzare il livello di emulazione PDO.",
            "title": "Accesso ai dati tramite oggetti"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#creazione-di-connesisoni-db",
            "text": "Per accedere a un database, \u00e8 innanzitutto necessario connettersi ad esso creano un'istanza di  yii \\ db \\ Connection :: :  $db = new yii\\db\\Connection([\n    'dsn' =  'mysql:host=localhost;dbname=example',\n    'username' =  'root',\n    'password' =  '',\n    'charset' =  'utf8',\n]);  Poich\u00e8 \u00e8 spesso necessario accedere a una connessione DB in luoghi diversi del nostro progetto, \u00e8 prassi comune configurarla in termini di un componente dell'applicazione, come il seguente:  return [\n    // ...\n    'components' =  [\n        // ...\n        'db' =  [\n            'class' =  'yii\\db\\Connection',\n            'dsn' =  'mysql:host=localhost;dbname=example',\n            'username' =  'root',\n            'password' =  '',\n            'charset' =  'utf8',\n        ],\n    ],\n    // ...\n];  E' quindi possibile accedere alla connessione DB tramite l'espressione  Yii::$app- db .   Tip  E' possibile configurare pi\u00f9 componenti dell'applicazione DB se l'applicazione deve accedere a pi\u00f9 database.   Quando si configura una connessione DB, \u00e8 necessario specificare sempre il suo Database Source Name (DSN) tramite la propriet\u00e0  dsn . Il formato di DSN varia per diversi database. Di seguito sono riportati alcuni esempi:   MySQL, MariaDB:  mysql:host=localhost;dbname=mydatabase  SQLite:  sqlite:/path/to/database/file  PostgreSQL:  pgsql:host=localhost;port=5432;dbname=mydatabase  cubrid:  cubrid:dbname=demodb;host=localhost;port=33000  MS SQL Server (tramite driver sqlsrv):  sqlsrv:Server=localhost;Database=mydatabase  MS SQL Server (tramite driver dblib):  dblib:host=localhost;dbname=mydatabase  MS SQL Server (tramite driver mssql):  mssql:host=localhost;dbname=mydatabase  Oracle:  oci:dbname=//localhost:1521/mydatabase   Si noti che se ci si connette a un database tramite ODBC, \u00e8 necessario configurare la propriet\u00e0  yii \\ db \\ Connection :: driverName  in modo che Yii possa conoscere il tipo di database effettivo. Per esempio,  'db' =  [\n    'class' =  'yii\\db\\Connection',\n    'driverName' =  'mysql',\n    'dsn' =  'odbc:Driver={MySQL};Server=localhost;Database=test',\n    'username' =  'root',\n    'password' =  '',\n],  Oltre alla prorpiet\u00e0  dsn , \u00e8 spesso necessario configurare nome utente e password per accedervi.   Tip  A volte potresti voler eseguire alcune query subito dopo aver stabilito la connessione al database per inizializzare alcune variabili di ambiente (ad esempio, per impostare il fuso orario o il set di caratteri). \u00c8 possibile farlo registrando un gestore di eventi per l' evento  afterOpen  nella connessione al database. Puoi registrare il gestore direttamente nella configurazione dell'applicazione in questo modo:  'db' =  [\n    // ...\n    'on afterOpen' =  function($event) {\n        // $event- sender refers to the DB connection\n        $event- sender- createCommand(\"SET time_zone = 'UTC'\")- execute();\n    }\n],",
            "title": "Creazione di connesisoni DB"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#esecuzione-di-query-sql",
            "text": "Una volta che si dispone di un'istanza di connessione al database, \u00e8 possibile eseguire una query SQL effettuando le seguenti operazioni:   Creare un comando   yii \\ db  con una semplice query SQL;  Parametri di binding (opzionale)  Chiama uno dei metodi di esecuzione SQL in   yii \\ db \\ Command  .   L'esempio seguente mostra vari modi di recuperare i dati da un database:  // return a set of rows. each row is an associative array of column names and values.\n// an empty array is returned if the query returned no results\n$posts = Yii::$app- db- createCommand('SELECT * FROM post')\n            - queryAll();\n\n// return a single row (the first row)\n// false is returned if the query has no result\n$post = Yii::$app- db- createCommand('SELECT * FROM post WHERE id=1')\n           - queryOne();\n\n// return a single column (the first column)\n// an empty array is returned if the query returned no results\n$titles = Yii::$app- db- createCommand('SELECT title FROM post')\n             - queryColumn();\n\n// return a scalar value\n// false is returned if the query has no result\n$count = Yii::$app- db- createCommand('SELECT COUNT(*) FROM post')\n             - queryScalar();",
            "title": "Esecuzione di query SQL"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#parametri-bindings",
            "text": "Quando si crea un comando DB da un SQL con parametri, si dovrebbe quasi sempre utilizzare l'approccio dei parametri di binding per prevenire attacchi di SQL injection. Per esempio,  $post = Yii::$app- db- createCommand('SELECT * FROM post WHERE id=:id AND status=:status')\n           - bindValue(':id', $_GET['id'])\n           - bindValue(':status', 1)\n           - queryOne();  Nell'istruzione SQL, \u00e8 possibile incorporare uno o pi\u00f9 segnaposti dei parametri (ad esempio : id  nell'esempio precedente). Un segnaposto di parametro dovrebbe essere una stringa che inizia con due punti. \u00c8 quindi possibile chiamare uno dei seguenti metodi di associazione dei parametri per associare i valori dei parametri:   bindValue() : associa un valore di parametro singolo  bindValues() : associa pi\u00f9 valori di parametro in una chiamata  bindParam() : simile a  binadValue()  ma supporta anche i riferimenti ai parametri di bind.   L'esempio seguente mostra metodi alternativi per i parametri di binding:  $params = [':id' =  $_GET['id'], ':status' =  1];\n\n$post = Yii::$app- db- createCommand('SELECT * FROM post WHERE id=:id AND status=:status')\n           - bindValues($params)\n           - queryOne();\n\n$post = Yii::$app- db- createCommand('SELECT * FROM post WHERE id=:id AND status=:status', $params)  Il binding dei parametri viene implementato tramite dichiarazioni preparate. Oltre a prevenire attacchi di SQL injection, pu\u00f2 anche migliorare le prestazioni preparando una dichiarazione SQL una volta e eseguendola pi\u00f9 volte con parametri diversi. Per esempio,  $command = Yii::$app- db- createCommand('SELECT * FROM post WHERE id=:id');\n\n$post1 = $command- bindValue(':id', 1)- queryOne(); \n$post2 = $command- bindValue(':id', 2)- queryOne();\n// ...  Poich\u00e8  bindParam()  supporta i parametri di associazione per riferimento, il codice precedente pu\u00f2 anche essere scritto come segue:  $command = Yii::$app- db- createCommand('SELECT * FROM post WHERE id=:id')\n              - bindParam(':id', $id);\n\n$id = 1;\n$post1 = $command- queryOne();\n\n$id = 2;\n$post2 = $command- queryOne();\n// ...  Si noti che si lega il segnaposto alla variabile  $id  prima dell'esecuzione e quindi si modifica il valore di tale variabile prima di ogni esecuzione successiva (spesso con loop). L'esecuzione di query in questo modo pu\u00f2 essere notevolmente pi\u00f9 efficiente rispetto all'esecuzione di una nuova query per ogni valore di parametro diverso.   Info  Il collegamento dei parametri viene utilizzato solo in luoghi in cui \u00e8 necessario inserire valori in stringhe che contengono SQL semplice. In molti posti in livelli di astrazione pi\u00f9 alti, come il generatore di query e l'Active Record, si specifica spesso una serie di valori che verranno trasformati in SQL. In questi punti il \u200b\u200bbinding dei parametri viene eseguito internamente da Yii, quindi non \u00e8 necessario specificare i parametri manualmente.",
            "title": "Parametri Bindings"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#esecuzione-di-query-non-select",
            "text": "I metodi  queryXyz()  introdotti nelle sezioni precedenti riguardano tutti le query SELECT che prelevano i dati dai database. Per le query che non restituiscono dati, \u00e8 necessario chiamare invece il metodo  yii \\ db \\ Command :: execute() . Per esempio,  Yii::$app- db- createCommand('UPDATE post SET status=1 WHERE id=1')\n- execute();  Il metodo  yii \\ db \\ Command :: execute()  restituisce il numero di righe interessate dall'esecuzione SQL.  Per le query INSERT, UPDATE e DELETE, invece di scrivere semplici SQL, \u00e8 possibile chiamare  insert() ,  update()  ,  delete() , per creare gli SQL corrispondenti. Questi metodi indicheranno correttamente i nomi di tabelle e colonne e i valori dei parametri di bind. Per esempio,  // INSERT (table name, column values)\nYii::$app- db- createCommand()- insert('user', [\n    'name' =  'Sam',\n    'age' =  30,\n])- execute();\n\n// UPDATE (table name, column values, condition)\nYii::$app- db- createCommand()- update('user', ['status' =  1], 'age   30')- execute();\n\n// DELETE (table name, condition)\nYii::$app- db- createCommand()- delete('user', 'status = 0')- execute();  Puoi anche chiamare  batchInsert()  per inserire pi\u00f9 righe in un colpo, che \u00e8 molto pi\u00f9 efficiente dell'inserimento di una riga per volta:  // table name, column names, column values\nYii::$app- db- createCommand()- batchInsert('user', ['name', 'age'], [\n    ['Tom', 30],\n    ['Jane', 20],\n    ['Linda', 25],\n])- execute();  Nota che i metodi sopra menzionati creano solo la query e devi sempre richiamare il metodo  execute()  per eseguirli.",
            "title": "Esecuzione di query non SELECT"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#citazione-dei-noim-relativi-a-tabelle-e-colonne",
            "text": "Durante la scrittura di codice indipendente dal database, la citazione corretta dei nomi di tabelle e colonne \u00e8 spesso un problema perch\u00e9 diversi database hanno regole di quoting diverse. Per superare questo problema, \u00e8 possibile utilizzare la seguente sintassi di citazione introdotta da Yii:   [[column name]] : racchiude il nome di una colonna da citare tra parentesi quadre;  {{table name}} : racchiude il nome di una tabella da quotare tra parentesi graffe doppie.   Yii DAO convertir\u00e0 automaticamente tali costrutti nella colonna o nei nomi di tabella citati corrispondenti, utilizzando la sintassi specifica DBMS. Per esempio,  // executes this SQL for MySQL: SELECT COUNT(`id`) FROM `employee`\n$count = Yii::$app- db- createCommand(\"SELECT COUNT([[id]]) FROM {{employee}}\")\n            - queryScalar();",
            "title": "Citazione dei noim relativi a tabelle e colonne"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#utilizzo-del-prefisso-tabella",
            "text": "Se la maggior parte dei nomi delle tabelle DB condivide un prefisso comune, \u00e8 possibile utilizzare la funzione  tablePrefix  fornita da Yii DAO.  Per prima cosa, specifica il prefisso della tabella tramite la propriet\u00e0  yii \\ db \\ Connection :: $ tablePrefix  nella configurazione dell'applicazione:  return [\n    // ...\n    'components' =  [\n        // ...\n        'db' =  [\n            // ...\n            'tablePrefix' =  'tbl_',\n        ],\n    ],\n];  Quindi nel codice, ogni volta che \u00e8 necessario fare riferimento a una tabella il cui nome contiene tale prefisso, utilizzare la sintassi  {{%table_name}} . Il carattere percentuale verr\u00e0 automaticamente sostituito con il prefisso tabella specificato durante la configurazione della connessione DB. Per esempio,  // executes this SQL for MySQL: SELECT COUNT(`id`) FROM `tbl_employee`\n$count = Yii::$app- db- createCommand(\"SELECT COUNT([[id]]) FROM {{%employee}}\")\n            - queryScalar();",
            "title": "Utilizzo del prefisso tabella"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#esecuzione-di-transazioni",
            "text": "Quando si eseguono pi\u00f9 query correlate in una sequenza, potrebbe essere necessario includerle in una transazione per garantire l'integrit\u00e0 e la coerenza del database. Se una qualsiasi delle query non riesce, il database verr\u00e0 riportato allo stato come se nessuna di queste query fosse stata eseguita.  Il codice seguente mostra un modo tipico di utilizzare le transazioni:  Yii::$app- db- transaction(function($db) {\n    $db- createCommand($sql1)- execute();\n    $db- createCommand($sql2)- execute();\n    // ... executing other SQL statements ...\n});  Il codice riportato sopra \u00e8 equivalente al seguente, che offre un maggior controllo sul codice gestendo gli errori:  $db = Yii::$app- db;\n$transaction = $db- beginTransaction();\ntry {\n    $db- createCommand($sql1)- execute();\n    $db- createCommand($sql2)- execute();\n    // ... executing other SQL statements ...\n\n    $transaction- commit();\n} catch(\\Exception $e) {\n    $transaction- rollBack();\n    throw $e;\n} catch(\\Throwable $e) {\n    $transaction- rollBack();\n    throw $e;\n}  Chiamando il metodo  beginTransaction() , viene avviata una nuova transazione. La transazione \u00e8 rappresentata come un oggetto  yii \\ db \\ Transaction  memorizzato nella variabile  $transaction . Quindi, le query eseguite sono racchiuse in un blocco  try...catch... . Se tutte le query vengono eseguite correttamente, il metodo  commit()  viene chiamato per eseguire il commit della transazione. Altrimenti, se verr\u00e0 attivata e rilevata un'eccezione , viene chiamato il metodo  rollBack()  per eseguire il rollback delle modifiche apportate dalle query prima di quella query non riuscita nella transazione  throw $ . Quindi rilanciamo l'eccezione come se non l'avessimo catturata, e a questo punto il normale processo di gestione degli errori si prender\u00e0 cura di esso.   Warning  Nel codice precedente abbiamo due blocchi di cattura per la compatibilit\u00e0 con PHP 5.x e PHP 7.x.  \\Exception  implementa l'interfaccia  \\Throwable  da PHP 7.0, quindi puoi saltare la parte  \\Exceptions  e la tua app utilizza solo PHP 7.0 e versioni successive.",
            "title": "Esecuzione di transazioni"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#specifica-dei-livelli-di-isolamento",
            "text": "Yii supporta anche l'impostazione dei livelli di isolamento per le tue transazioni. Per impostazione predefinita, quando si avvia una nuova transazione, verr\u00e0 utilizzato il livello di isolamento predefinito impostato dal sistema di database. \u00c8 possibile sovrascrivere il livello di isolamento predefinito come segue,  $isolationLevel = \\yii\\db\\Transaction::REPEATABLE_READ;\n\nYii::$app- db- transaction(function ($db) {\n    ....\n}, $isolationLevel);\n\n// or alternatively\n\n$transaction = Yii::$app- db- beginTransaction($isolationLevel);  Yii fornisce quattro costranti per i livelli di isolamento pi\u00f9 comuni:   yii \\ db \\ Transaction :: READ_UNCOMMITTED  - il livello pi\u00f9 debole. Possono esserci letture sporche o letture non ripetibili.  yii \\ db \\ Transaction ::READ_COMMITTED  - evita le letture sporche.  yii \\ db \\ Transaction :: REPETABLE_READ  - evita le letture sporche e letture non ripetibili.  yii \\ db \\ Transction :: SERIALIZABLE  - il livello pi\u00f9 forte, evita tutti i problemi sopra citati.   Oltre a utilizzare le costanti sopra indicate per specificre i livelli di isolamento, \u00e8 possibile utilizzare anche stringhe con una sintassi valida supportata dal DBMS che si sta utilizzando. Ad esempio, in PostgreSQL, puoi usare  \"SERIALIZABLE READ ONLY DEFERRABLE\" .  Si noti che alcuni DBMS consentono di impostare il livello di isolamento solo per l'intera connessione. Qualsiasi transazione successiva otterr\u00e0 lo stesso livello di isolamento anche se non ne specifichiamo altre. Quando si utilizza questa funzione, potrebbe essere necessario impostare il livello di isolamento per tutte le transazioni in modo esplicito per evitare impostazioni in conflitto. Al momento della stesura di questo limite, solo MSSQL e SQLite sono interessati da questa limitazione.   Warning  SQLite supporta solo due livelli di isolamento, quindi \u00e8 possibile utilizzare solo  READ UNCOMMITTED  e  SERIALIZABLE . L'utilizzo di altri livelli si tradurr\u00e0 in un'eccezione generata.    Nota  PostgreSQL non consente di impostare il livello di isolamento prima dell'inizio della transazione, quindi non \u00e8 possibile specificare direttamente il livello di isolamento quando si avvia la transazione. Devi chiamare  yii \\ db \\ Transaction :: setIsolationLevel()  in questo caso dopo l'avvio della transazione.",
            "title": "Specifica dei livelli di isolamento"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#annidamento-delle-transazioni",
            "text": "Se il DBMS supporta Savepoint, \u00e8 possibile nidificare pi\u00f9 transazioni come le seguenti:  Yii::$app- db- transaction(function ($db) {\n    // outer transaction\n\n    $db- transaction(function ($db) {\n        // inner transaction\n    });\n});  O in alternativa,  $db = Yii::$app- db;\n$outerTransaction = $db- beginTransaction();\ntry {\n    $db- createCommand($sql1)- execute();\n\n    $innerTransaction = $db- beginTransaction();\n    try {\n        $db- createCommand($sql2)- execute();\n        $innerTransaction- commit();\n    } catch (\\Exception $e) {\n        $innerTransaction- rollBack();\n        throw $e;\n    } catch (\\Throwable $e) {\n        $innerTransaction- rollBack();\n        throw $e;\n    }\n\n    $outerTransaction- commit();\n} catch (\\Exception $e) {\n    $outerTransaction- rollBack();\n    throw $e;\n} catch (\\Throwable $e) {\n    $outerTransaction- rollBack();\n    throw $e;",
            "title": "Annidamento delle transazioni"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#duplicazione-e-divisione-tra-lettura-scrittura",
            "text": "Molti DBMS supportano la replica del database per ottenere una migliore disponibilit\u00e0 del database e tempi di risposta del server pi\u00f9 rapidi. Con la replica del database, i dati vengono replicati dai cosiddetti server master ai server slave . Tutte le scritture e gli aggiornamenti devono essere eseguiti sui server master, mentre le letture possono anche avvenire sui server slave.  Per sfruttare la replica del database e ottenere la divisione read-write, \u00e8 possibile configurare un componente  yii \\ db \\ Connection  come il seguente:  [\n    'class' =  'yii\\db\\Connection',\n\n    // configuration for the master\n    'dsn' =  'dsn for master server',\n    'username' =  'master',\n    'password' =  '',\n\n    // common configuration for slaves\n    'slaveConfig' =  [\n        'username' =  'slave',\n        'password' =  '',\n        'attributes' =  [\n            // use a smaller connection timeout\n            PDO::ATTR_TIMEOUT =  10,\n        ],\n    ],\n\n    // list of slave configurations\n    'slaves' =  [\n        ['dsn' =  'dsn for slave server 1'],\n        ['dsn' =  'dsn for slave server 2'],\n        ['dsn' =  'dsn for slave server 3'],\n        ['dsn' =  'dsn for slave server 4'],\n    ],\n]  La configurazione scritta sopra, specifica un'impostazione con un singolo master e pi\u00f9 slave. Uno degli slave verr\u00e0 connesso e utilizzato per eseguire query di lettura, mentre il master verr\u00e0 utilizzato per eseguire query di scrittura. Tale suddivisione in lettura-scrittura viene eseguita automaticamente con questa configurazione. Per esempio,  // create a Connection instance using the above configuration\nYii::$app- db = Yii::createObject($config);\n\n// query against one of the slaves\n$rows = Yii::$app- db- createCommand('SELECT * FROM user LIMIT 10')- queryAll();\n\n// query against the master\nYii::$app- db- createCommand(\"UPDATE user SET username='demo' WHERE id=1\")- execute();   Info  Le query eseguite chiamando  yii \\ db \\ Command :: execute()  sono considerate query di scrittura, mentre tutte le altre query eseguite tramite uno dei metodi \"query\" di  yii \\ db \\ Command  sono query di lettura. \u00c8 possibile ottenere la connessione slave attualmente attiva tramite  Yii::$app- db- slave .   Il componente  Connection  supporta il bilanciamento del carico e il failover tra slave. Quando si esegue una query di lettura per la prima volta, il componente  Connection  sceglier\u00e0 in modo casuale uno slave e prova a connettersi ad esso. Se lo slave viene trovato \"morto\" (cio\u00e8 non d\u00e0 nessuna risposta), ne prova un altro. Se nessuno degli slave \u00e8 disponibile, si collegher\u00e0 al master. Configurando una cache di stato del server, un server \"morto\" pu\u00f2 essere ricordato in modo che non venga pi\u00f9 provato durante un certo periodo di tempo .  E' inoltre possibile configurare pi\u00f9 master con pi\u00f9 slave. Per esempio:  [\n    'class' =  'yii\\db\\Connection',\n\n    // common configuration for masters\n    'masterConfig' =  [\n        'username' =  'master',\n        'password' =  '',\n        'attributes' =  [\n            // use a smaller connection timeout\n            PDO::ATTR_TIMEOUT =  10,\n        ],\n    ],\n\n    // list of master configurations\n    'masters' =  [\n        ['dsn' =  'dsn for master server 1'],\n        ['dsn' =  'dsn for master server 2'],\n    ],\n\n    // common configuration for slaves\n    'slaveConfig' =  [\n        'username' =  'slave',\n        'password' =  '',\n        'attributes' =  [\n            // use a smaller connection timeout\n            PDO::ATTR_TIMEOUT =  10,\n        ],\n    ],\n\n    // list of slave configurations\n    'slaves' =  [\n        ['dsn' =  'dsn for slave server 1'],\n        ['dsn' =  'dsn for slave server 2'],\n        ['dsn' =  'dsn for slave server 3'],\n        ['dsn' =  'dsn for slave server 4'],\n    ],  La configurazione soprastante specifica due master e quattro slave. Il componente  Connection  supporta anche il bilanciamento del carico e il failover tra i master esattamente come avviene tra gli slave. Una differenza \u00e8 che quando nessuno dei master \u00e8 disponibile viene lanciata un'eccezione.   Warning  Quando si utilizza le propriet\u00e0 per configurare uno o pi\u00f9 master, tutte le altre propriet\u00e0 per la specifica di una connessione al database (ad esempio dsn, username, password) con l'oggetto stesso  Connection  verr\u00e0 ignorato.   Per impostazione predefinita, le transazioni utilizzano la connessione principale. E all'interno di una transazione, tutte le operazioni DB utilizzeranno la connessione principale. Per esempio,  $db = Yii::$app- db;\n// the transaction is started on the master connection\n$transaction = $db- beginTransaction();\n\ntry {\n    // both queries are performed against the master\n    $rows = $db- createCommand('SELECT * FROM user LIMIT 10')- queryAll();\n    $db- createCommand(\"UPDATE user SET username='demo' WHERE id=1\")- execute();\n\n    $transaction- commit();\n} catch(\\Exception $e) {\n    $transaction- rollBack();\n    throw $e;\n} catch(\\Throwable $e) {\n    $transaction- rollBack();\n    throw $e;\n}  Se si desidera avviare una transazione con la connessione slave, \u00e8 necessario farlo in modo esplicito. Come il seguente:  $transaction = Yii::$app- db- slave- beginTransaction();  A volte, potresti voler forzare l'uso della connessione principale per eseguire una query di lettura. Questo pu\u00f2 essere ottenuto con il metodo  useMaster() :  $rows = Yii::$app- db- useMaster(function ($db) {\n    return $db- createCommand('SELECT * FROM user LIMIT 10')- queryAll();\n});  Si pu\u00f2 anche impostare direttamente  Yii::$app- db. enableSlaves  di essere a  false  a indirizzare tutte le query al collegamento master.",
            "title": "Duplicazione e divisione tra lettura / scrittura"
        },
        {
            "location": "/working-with-databases/sub-data-access-object/#lavorare-con-lo-schema-del-proprio-database",
            "text": "Yii DAO fornisce un intero set di metodi per consentire la manipolazione dello schema del database, come la creazione di nuove tabelle, il rilascio di una colonna da una tabella, ecc. Questi metodi sono elencati come segue:   createTable() : creazione di una tabella;  renameTable() : rinomina una tabella;  dropTable() : rimozione di una tabella;  truncateTable() : rimuove tutte le righe in una tabella;  addColumn() : aggiunta di una colonna;  renameColumn() : rinomina una colonna;  dropColumn() : rimuovendo una colonna;  alterColumn() : modifica di una colonna;  addPrimaryKey() : aggiunta di una chiave primaria;  dropPrimaryKey() : rimozione di una chiave primaria;  addForeignKey() : aggiunta di una chiave esterna;  dropForeignKey() : rimozione di una chiave esterna;  createIndex() : creazione di un indice;  dropIndex() : rimozione di un indice.   Questi metodi possono essere utilizzati come i seguenti:  // CREATE TABLE\nYii::$app- db- createCommand()- createTable('post', [\n    'id' =  'pk',\n    'title' =  'string',\n    'text' =  'text',\n]);  L'array sopra descritto descrive il nome e i tipi delle colonne da creare. Per i tipi di colonna, Yii fornisce un set di tipi di dati astratti, che consentono di definire uno schema agnostico del database. Questi vengono convertiti in definizioni accessibili dal DBMS dipendente dal database.  Oltre a modificare lo schema del database, \u00e8 anche possibile recuperare le informazioni sulla definizione di una tabella tramite il metodo  getTableSchema()  di una connessione DB. Per esempio,  $table = Yii::$app- db- getTableSchema('post');  Il metodo restituisce un oggetto  yii \\ db \\ TableSchema  che contiene le informazioni sulle colonne della tabella, le chiavi primarie, le chiavi esterne e cos\u00ec via. Tutte queste informazioni sono principalmente utilizzate dal generatore di query e dall'Active Record per consentire la scrittura del codice agnostico del database.",
            "title": "Lavorare con lo schema del proprio database"
        },
        {
            "location": "/working-with-databases/sub-query-builder/",
            "text": "Generatore di Query (Query Builder)\n\n\nBasato sul DBO (Database Access Objects), il generatore di query consente di costruire una query SQL in modo programmatico e indipendente dal DBMS. Rispetto alla scrittura di istruzioni SQL non elaborate, l'utilizzo del query builder consente di scrivere codice SQL pi\u00f9 leggibile e generare istruzioni SQL pi\u00f9 sicure.\n\n\nL'utilizzo di Generatore di query prevede in genere due passaggi:\n\n\n\n\nCostruisci un oggetto \nyii \\ db \\ Query\n per rappresentare parti diverse (ad es SELECT. FROM) di un'istruzione SELECT SQL.\n\n\nEsegui un metodo di query (es. \nall()\n) di \nyii \\ db \\ Query\n per recuperare i dati dal database.\n\n\n\n\nIl codice seguente mostra un modo tipico di utilizzare il generatore di query:\n\n\n$rows = (new \\yii\\db\\Query())\n    -\nselect(['id', 'email'])\n    -\nfrom('user')\n    -\nwhere(['last_name' =\n 'Smith'])\n    -\nlimit(10)\n    -\nall();\n\n\n\nIl codice precedente genera ed esegue la seguente query SQL, in cui il parametro \n:last_name\n \u00e8 associato alla stringa \n'Smith'\n.\n\n\nSELECT `id`, `email` \nFROM `user`\nWHERE `last_name` = :last_name\nLIMIT 10\n\n\n\n\n\nInfo\n\n\nDi solito si lavora principalmente con \nyii \\ db \\ Query\n invece di \nyii \\ db \\ QueryBuilder\n. Quest'ultimo viene invocato dal primo implicitamente quando si chiama uno dei metodi di query. \nyii \\ db \\ QueryBuilder\n \u00e8 la classe responsabile della generazione di istruzioni SQL dipendenti da DBMS (ad esempio, citando in modo diverso nomi di tabelle / colonne) da oggetti \nyii \\ db \\ Query\n indipendenti da DBMS.\n\n\n\n\nCostruzione di una query\n\n\nPer costruire un oggetto \nyii \\ db \\ Query\n, si chiamano diversi metodi di creazione per specificare parti diverse di una query SQL. I nomi di questi metodi sono simili alle parole chiave SQL utilizzate nelle parti corrispondenti dell'istruzione. Ad esempio, per specificare la parte \nFROM\n di una query SQL, dobbiamo chiamare il metodo \nfrom()\n. Tutti i metodi di creazione query restituiscono l'oggetto query stesso, che consente di concatenare pi\u00f9 chiamate contemporaneamente.\n\n\nDi seguito, descriveremo l'utilizzo di ciascun metodo di creazione di query.\n\n\nSELECT()\n\n\nIl metodo \nselect()\n specifica il frammentro \nSELECT\n di un'istruzione SQL. \u00c8 possibile specificare le colonne da selezionare in una matrice o in una stringa, come nell'esempio seguente. I nomi delle colonne selezionati verranno automaticamente quotati quando l'istruzione SQL viene generata da un oggetto query.\n\n\n$query-\nselect(['id', 'email']);\n\n// equivalent to:\n\n$query-\nselect('id, email');\n\n\n\nI nomi delle colonne selezionate possono includere prefissi di tabelle e / o alias di colonne, come quando si scrivono query SQL non elaborate. Per esempio,\n\n\n$query-\nselect(['user.id AS user_id', 'email']);\n\n// equivalent to:\n\n$query-\nselect('user.id AS user_id, email');\n\n\n\nSe si utilizza il formato della matrice per specificare le colonne, \u00e8 anche possibile utilizzare i tasti della matrice per specificare gli alias di colonna. Ad esempio, il codice sopra riportato pu\u00f2 essere riscritto come segue,\n\n\n$query-\nselect(['user_id' =\n 'user.id', 'email']);\n\n\n\nSe non si chiama il metodo \nselect()\n durante la creazione di una query, con \n*\n verranno selezionate tutte le colonne.\n\n\nOltre ai nomi delle colonne, \u00e8 anche possibile selezionare le espressioni DB. \u00c8 necessario utilizzare il formato di matrice quando si seleziona un'espressione DB che contiene virgole, per evitare virgolette automatiche errate. Per esempio,\n\n\n$query-\nselect([\"CONCAT(first_name, ' ', last_name) AS full_name\", 'email']);\n\n\n\nCome per tutti i punti in cui \u00e8 coinvolto l'SQL non elaborato, \u00e8 possibile utilizzare \nDBMS agnostic quoting syntax\n per i nomi di tabelle e colonne quando si scrivono espressioni DB in select.\n\n\nA partire dalla versione 2.0.1, \u00e8 possibile selezionare anche le sottoquery. \u00c8 necessario specificare ogni sottoquery in termini di un oggetto \nyii \\ db \\ Query\n. Per esempio,\n\n\n$subQuery = (new Query())-\nselect('COUNT(*)')-\nfrom('user');\n\n// SELECT `id`, (SELECT COUNT(*) FROM `user`) AS `count` FROM `post`\n$query = (new Query())-\nselect(['id', 'count' =\n $subQuery])-\nfrom('post');\n\n\n\nPer selezionare righe distinte, puoi chiamare il metodo \ndistinct()\n , come il seguente:\n\n\n// SELECT DISTINCT `user_id` ...\n$query-\nselect('user_id')-\ndistinct();\n\n\n\nPuoi chiamare \naddSelect()\n per selezionare colonne aggiuntive. Per esempio,\n\n\n$query-\nselect(['id', 'username'])\n    -\naddSelect(['email']);\n\n\n\nFROM()\n\n\nIl metodo \nfrom()\n specifica il frammento \nFROM\n di un'istruzione SQL. Per esempio,\n\n\n// SELECT * FROM `user`\n$query-\nfrom('user');\n\n\n\n\u00c8 possibile specificare la / le tabella / i selezionata / i in una stringa o in una matrice. I nomi delle tabelle possono contenere prefissi dello schema e / o alias di tabelle, come quando si scrivono istruzioni SQL non elaborate. Per esempio,\n\n\n$query-\nfrom(['public.user u', 'public.post p']);\n\n// equivalent to:\n\n$query-\nfrom('public.user u, public.post p');\n\n\n\nSe si utilizza il formato di matrice, \u00e8 anche possibile utilizzare le chiavi della matrice per specificare gli alias di tabella, come i seguenti:\n\n\n$query-\nfrom(['u' =\n 'public.user', 'p' =\n 'public.post']);\n\n\n\nOltre ai nomi delle tabelle, \u00e8 anche possibile selezionare delle subquery specificandole in termini di oggetti \nyii \\ db \\ Query\n. Per esempio,\n\n\n$subQuery = (new Query())-\nselect('id')-\nfrom('user')-\nwhere('status=1');\n\n// SELECT * FROM (SELECT `id` FROM `user` WHERE status=1) u \n$query-\nfrom(['u' =\n $subQuery]);\n\n\n\nWHERE()\n\n\nIl metodo \nwhere()\n specifica il frammento \nWHERE\n di una query SQL. \u00c8 possibile utilizzare uno dei tre formati per specificare una WHEREcondizione:\n\n\n\n\nformato stringa, ad es. \n'status=1'\n\n\nformato hash, ad es \n['status' =\n 1, 'type' =\n 2]\n\n\nformato operatore, ad es \n['like', 'name', 'test']\n\n\n\n\nFormato della stringa\n\n\nIl formato stringa \u00e8 il modo migliore per specificare condizioni molto semplici o se \u00e8 necessario utilizzare le funzioni integrate del DBMS. Funziona come se si stesse scrivendo un SQL raw. Per esempio,\n\n\n$query-\nwhere('status=1');\n\n// or use parameter binding to bind dynamic parameter values\n$query-\nwhere('status=:status', [':status' =\n $status]);\n\n// raw SQL using MySQL YEAR() function on a date field\n$query-\nwhere('YEAR(somedate) = 2015');\n\n\n\nNON incorporare le variabili direttamente nella condizione come le seguenti, soprattutto se i valori delle variabili provengono da input dell'utente finale, poich\u00e9 ci\u00f2 render\u00e0 l'applicazione soggetta agli attacchi di SQL injection.\n\n\n// Dangerous! Do NOT do this unless you are very certain $status must be an integer.\n$query-\nwhere(\"status=$status\");\n\n\n\nQuando si utilizza l'associazione dei parametri, \u00e8 possibile chiamare il metodo \nparams()\n o \naddParams()\n per specificare i parametri separatamente.\n\n\n$query-\nwhere('status=:status')\n    -\naddParams([':status' =\n $status]);\n\n\n\nCome per tutti i punti in cui \u00e8 coinvolto l'SQL non elaborato, \u00e8 possibile utilizzare la \"DBMS agnostic quoting syntax\" per i nomi di tabelle e colonne quando si scrivono le condizioni nel formato stringa.\n\n\nFormato hash\n\n\nIl formato hash viene utilizzato per specificare le sotto-condizioni concatenate come \nAND\n, ognuna delle quali \u00e8 una semplice affermazione di uguaglianza. \u00c8 scritto come un array le cui chiavi sono nomi di colonne e valori i valori corrispondenti che dovrebbero essere le colonne. Per esempio,\n\n\n// ...WHERE (`status` = 10) AND (`type` IS NULL) AND (`id` IN (4, 8, 15))\n$query-\nwhere([\n    'status' =\n 10,\n    'type' =\n null,\n    'id' =\n [4, 8, 15],\n]);\n\n\n\nCome puoi vedere, il generatore di query \u00e8 abbastanza intelligente da gestire correttamente i valori null o array.\n\n\nPuoi anche utilizzare sottoquery con formato hash come il seguente:\n\n\n$userQuery = (new Query())-\nselect('id')-\nfrom('user');\n\n// ...WHERE `id` IN (SELECT `id` FROM `user`)\n$query-\nwhere(['id' =\n $userQuery]);\n\n\n\nUsando il formato hash, Yii usa internamente il binding dei parametri, quindi in contrasto con il formato stringa. In questo caso non devi aggiungere parametri manualmente.\n\n\nFormato dell'operatore\n\n\nIl formato operatore consente di specificare condizioni arbitrarie in modo programmatico. Prende il seguente formato:\n\n\n[operator, operand1, operand2, ...]\n\n\n\ndove gli operandi possono essere specificati ciascuno in formato stringa, formato hash o formato operatore in modo ricorsivo, mentre l'operatore pu\u00f2 essere uno dei seguenti:\n\n\n\n\n\n\nand\n: gli operandi dovrebbero essere concatenati insieme usando \nAND\n. Ad esempio, \n['and', 'id=1', 'id=2']\n generer\u00e0 \nid=1 AND id=2\n. Se un operando \u00e8 un array, verr\u00e0 convertito in una stringa usando le regole descritte qui. Ad esempio,\n['and', 'type=1', ['or', 'id=1', 'id=2']]\n generer\u00e0 \ntype=1 AND (id=1 OR id=2)\n. Il metodo NON far\u00e0 alcuna citazione o fuga.\n\n\n\n\n\n\nor\n: simile all'operatore \nand\n tranne per il fatto che gli operandi sono concatenati usando \nOR\n.\n\n\n\n\n\n\nnot\n: richiede solo l'operando 1, che verr\u00e0 incluso con \nNOT()\n. Ad esempio, \n['not', 'id=1']generer\u00e0 NOT (id=1)\n. Operando 1 pu\u00f2 anche essere una matrice per descrivere pi\u00f9 espressioni. Ad esempio \n['not', ['status' =\n 'draft', 'name' =\n 'example']]\n generer\u00e0 \nNOT ((status='draft') AND (name='example'))\n.\n\n\n\n\n\n\nbetween\n: l'operando 1 dovrebbe essere il nome della colonna e l'operando 2 e 3 dovrebbe essere il valore iniziale e finale dell'intervallo in cui si trova la colonna. Ad esempio, \n['between', 'id', 1, 10]\n generer\u00e0 \nid BETWEEN 1 AND 10\n.\n\n\n\n\n\n\nnot between\n: simile a \nbetween\ntranne che \nBETWEEN\n viene sostituito con \nNOT BETWEEN\n nella condizione generata.\n\n\n\n\n\n\nin\n: l'operando 1 dovrebbe essere una colonna o un'espressione DB. L' operando 2 pu\u00f2 essere un array o un oggetto \nQuery\n. Generer\u00e0 una condizione \nIN\n se l'operando 2 \u00e8 una matrice, rappresenter\u00e0 l'intervallo dei valori che dovrebbe essere la colonna o l'espressione DB; se l'operando 2 \u00e8 un oggetto \nQuery\n, verr\u00e0 generata una sottoquery e utilizzata come intervallo della colonna o dell'espressione DB. Ad esempio, \n['in', 'id', [1, 2, 3]]\n generer\u00e0 \nid IN (1, 2, 3)\n. Il metodo citer\u00e0 correttamente il nome della colonna e i valori di escape nell'intervallo. L'operatore \nin\n supporta anche colonne composite. In questo caso, l'operando 1 dovrebbe essere una matrice delle colonne, mentre l'operando 2 dovrebbe essere una matrice di matrici o un oggetto \nQuery\n che rappresenta l'intervallo delle colonne.\n\n\n\n\n\n\nnot in\n: simile all'operatore \nin\n tranne che \nIN\n viene sostituito con \nNOT IN\n nella condizione generata.\n\n\n\n\n\n\nlike\n: l'operando 1 deve essere una colonna o un'espressione DB e l'operando 2 deve essere una stringa o una matrice che rappresenta i valori che la colonna o l'espressione DB deve avere. Ad esempio, \n['like', 'name', 'tester']\n generer\u00e0 \nname LIKE '%tester%'\n. Quando l'intervallo di valori viene fornito come matrice, i \nLIKE\n saranno di pi\u00f9 e verranno concatenati utilizzando \nAND\n. Ad esempio, \n['like', 'name', ['test', 'sample']]\n generer\u00e0 \nname LIKE '%test%' AND name LIKE '%sample%'\n. \u00c8 anche possibile fornire un terzo operando opzionale per specificare come evitare caratteri speciali nei valori. L'operando dovrebbe essere una matrice di mapping dai caratteri speciali alle loro controparti fuggite. Se questo operando non viene fornito, verr\u00e0 utilizzata una mappatura di escape predefinita. Puoi usare il valore \nfalse\n o una matrice vuota per indicare che i valori sono gi\u00e0 stati presi e che non \u00e8 necessario applicare alcuna escape. Si noti che quando si utilizza una mappatura di escape (o il terzo operando non \u00e8 fornito), i valori saranno automaticamente racchiusi all'interno di una coppia di caratteri percentuali.\n\n\n\n\n\n\n\n\nNota\n\n\nQuando si utilizza PostgreSQL \u00e8 possibile utilizzare \nilike\n al posto della corrispondenza \nlike\n senza distinzione tra maiuscole e minuscole.\n\n\n\n\n\n\n\n\nor like\n: simile all'operatore \nlike\n tranne che \nOR\n \u00e8 usato per concatenare i \nLIKE\n predicati quando l'operando 2 \u00e8 una matrice.\n\n\n\n\n\n\nnot like\n: simile all'operatore \nlik\n tranne che \nLIKE\n viene sostituito con \nNOT LIKE\n nella condizione generata.\n\n\n\n\n\n\nor not like\n: simile all'operatore \nnot like\n tranne che \nOR\n \u00e8 usato per concatenare i predicati \nNOT LIKE\n.\n\n\n\n\n\n\nexists\n: richiede un operando che deve essere un'istanza di \nyii \\ db \\ Query\n che rappresenta la sottoquery. Costruir\u00e0 un'espressione \nEXISTS (sub-query)\n.\n\n\n\n\n\n\nnot exists\n: simile all'operatore \nexists\n e crea un'espressione \nNOT EXISTS (sub-query)\n.\n\n\n\n\n\n\n, \n=\n o qualsiasi altro operatore DB valido che accetta due operandi: il primo operando deve essere un nome di colonna mentre il secondo operando un valore. Ad esempio, \n['\n', 'age', 10]\n generer\u00e0 \nage\n10\n.\n\n\n\n\n\n\nUtilizzando il formato operatore, Yii utilizza internamente il binding dei parametri, in contrasto con il formato stringa , in questo caso non \u00e8 necessario aggiungere parametri manualmente.\n\n\nAggiunta delle condizioni\n\n\n\u00c8 possibile utilizzare \nandWhere()\n o \norWhere()\n per aggiungere condizioni aggiuntive a una esistente. Puoi chiamarli pi\u00f9 volte per aggiungere pi\u00f9 condizioni separatamente. Per esempio,\n\n\n$status = 10;\n$search = 'yii';\n\n$query-\nwhere(['status' =\n $status]);\n\nif (!empty($search)) {\n    $query-\nandWhere(['like', 'title', $search]);\n}\n\n\n\nSe \n$search\n non \u00e8 vuoto, dalla propriet\u00e0 \nWHERE\n verr\u00e0 generata la seguente condizione:\n\n\nWHERE (`status` = 10) AND (`title` LIKE '%yii%')\n\n\n\nCondizioni associati ai filtri\n\n\nQuando si costruiscono le condizioni \nWHERE\n in base all'input degli utenti finali, in genere si desidera ignorare quei valori di input, che sono vuoti. Ad esempio, in un modulo di ricerca che consente di effettuare ricerche per nome utente ed e-mail, si desidera ignorare la condizione se l'utente non inserisce nulla nel campo di inserimento nome utente / email. \u00c8 possibile raggiungere questo obiettivo utilizzando il metodo \nfilterWhere()\n:\n\n\n// $username and $email are from user inputs\n$query-\nfilterWhere([\n    'username' =\n $username,\n    'email' =\n $email,\n]);\n\n\n\nL'unica differenza tra \nfilterWhere()\n e \nwhere()\n \u00e8 che il primo ignorer\u00e0 i valori vuoti forniti nella condizione in formato hash. Quindi se \n$email\n \u00e8 vuoto mentre \n$username\n non lo \u00e8, il codice sopra comporter\u00e0 la condizione \nSQL WHERE username=:username\n.\n\n\n\n\nInfo\n\n\n\n\nUn valore \u00e8 considerato vuoto se ha come valore \nnull\n, un array vuoto, una stringa vuota o una stringa composta solo da spazi bianchi.\n\n\nCome \nandWhere()\n e \norWhere()\n, \u00e8 possibile utilizzare i metodi \nandFilterWhere()\n e \norFilterWhere()\n per aggiungere condizioni di filtro aggiuntive a quella esistente.\nInoltre, vi \u00e8 \nyii \\ db \\ Query :: andFilterCompare()\n che pu\u00f2 determinare in modo intelligente l'operatore in base a cosa c'\u00e8 nel valore:\n\n\n$query-\nandFilterCompare('name', 'John Doe');\n$query-\nandFilterCompare('rating', '\n9');\n$query-\nandFilterCompare('value', '\n=100');\n\n\n\nPuoi anche specificare esplicitamente l'operatore:\n\n\n$query-\nandFilterCompare('name', 'Doe', 'like');\n\n\n\nYii 2.0.11 offre metodi simili per la condzione \nHAVING\n:\n\n\n\n\nfilterHaving()\n\n\nandFilterHaving()\n\n\norFilterHaving()\n\n\n\n\nOrderBy()\n\n\nIl metodo \norderBy()\n specifica il frammento \nORDER BY\n di una query SQL. Per esempio,\n\n\n// ... ORDER BY `id` ASC, `name` DESC\n$query-\norderBy([\n    'id' =\n SORT_ASC,\n    'name' =\n SORT_DESC,\n]);\n\n\n\nNel codice precedente, le chiavi dell'array sono nomi di colonne, mentre i valori dell'array sono l'ordine corrispondente per direzioni. La costante PHP \nSORT_ASC\n specifica l'ordinamento crescente, mentre la costante \nSORT_DESC\n specifica quello decrescente.\n\n\nSe \nORDER BY\n riguarda solo nomi di colonne semplici, \u00e8 possibile specificarlo utilizzando una stringa, proprio come quando si scrivono istruzioni SQL non elaborate. Per esempio,\n\n\n$query-\norderBy('id ASC, name DESC');\n\n\n\n\n\nNota\n\n\nE' necessario utilizzare il formato dell'array se \nORDER BY\n include alcune espressioni DB.\n\n\n\n\nPuoi chiamare il metodo \naddOrderBy()\n per aggiungere ulteriori colonne al frammento \nORDER BY\n. Per esempio,\n\n\n$query-\norderBy('id ASC')\n    -\naddOrderBy('name DESC');\n\n\n\nGroupBy()\n\n\nIl metodo \ngroupBy()\n specifica il frammento \nGROUP BY\n di una query SQL. Per esempio,\n\n\n// ... GROUP BY `id`, `status`\n$query-\ngroupBy(['id', 'status']);\n\n\n\nSe \nGROUP BY\n riguarda solo nomi di colonne semplici, \u00e8 possibile specificarlo utilizzando una stringa, proprio come quando si scrivono istruzioni SQL non elaborate. Per esempio,\n\n\n$query-\ngroupBy('id, status');\n\n\n\n\n\nNota\n\n\nE' necessario utilizzare il formato dell'array se \nGROUP BY\n include alcune espressioni DB.\n\n\n\n\n\u00c8 possibile chiamare il metodo \naddGroupBy()\n per aggiungere ulteriori colonne al frammento \nGROUP BY\n. Per esempio,\n\n\n$query-\ngroupBy(['id', 'status'])\n    -\naddGroupBy('age');\n\n\n\nHaving()\n\n\nIl metodo \nhaving()\n specifica il frammento \nHAVING\n di una query SQL. Prende una condizione che pu\u00f2 essere specificata al solito modo di \nwhere()\n. Per esempio,\n\n\n// ... HAVING `status` = 1\n$query-\nhaving(['status' =\n 1]);\n\n\n\nFare riferimento alla documentazione di where () per ulteriori dettagli su come specificare una condizione.\n\n\n\u00c8 possibile chiamare i metodi \nandHaving()\n o \norHaving()\n per aggiungere condizioni aggiuntive al frammento \nHAVING\n. Per esempio,\n\n\n// ... HAVING (`status` = 1) AND (`age` \n 30)\n$query-\nhaving(['status' =\n 1])\n\n\n\nLimit() e Offset()\n\n\nI metodi \nlimit()\n e \noffset()\n specificano i frammenti \nLIMIT\n e \nOFFSET\n di una query SQL. Per esempio,\n\n\n// ... LIMIT 10 OFFSET 20\n$query-\nlimit(10)-\noffset(20);\n\n\n\nSe si specifica un limite o offset non valido (ad es. Un valore negativo), verr\u00e0 ignorato.\n\n\n\n\nInfo\n\n\nPer DBMS che non supportano questi due frammenti (ad esempio MSSQL), il generatore di query generer\u00e0 un'istruzione SQL che emula il comportamento di \nLIMIT/ OFFSET\n.\n\n\n\n\nJoin()\n\n\nIl metodo \njoin()\n specifica il frammento \nJOIN\n di una query SQL. Per esempio,\n\n\n// ... LEFT JOIN `post` ON `post`.`user_id` = `user`.`id`\n$query-\njoin('LEFT JOIN', 'post', 'post.user_id = user.id');\n\n\n\nIl metodo \njoin()\n accetta quattro parametri:\n\n\n\n\n$type\n: indica tipo di join, ad es . \n'INNER JOIN'\n, \n'LEFT JOIN'\n.\n\n\n$table\n: indica il nome del table da usare nella join.\n\n\n$on\n: (facoltativo), indica la condizione di join, ovvero il frammento \nON\n. Si prega di fare riferimento a \nwhere()\n per i dettagli su come specificare una condizione. Si noti che la sintassi dell'array non funziona per specificare una condizione basata su colonne, ad es. \n['user.id' =\n 'comment.userId']\n. Si verificher\u00e0 una condizione in cui l'id dell'utente deve essere uguale alla stringa \n'comment.userId'\n. Dovresti invece utilizzare la sintassi della stringa e specificare la condizione come \n'user.id = comment.userId'\n.\n\n\n$params\n: (facoltativo), indica i parametri da associare alla condizione di join.\n\n\n\n\n\u00c8 possibile utilizzare i seguenti metodi di scelta rapida per specificare \nINNER JOIN\n, \nLEFT JOIN\n e \nRIGHT JOIN\n.\n\n\n\n\ninnerJoin()\n\n\nleftJoin()\n\n\nrightJoin()\n\n\n\n\nPer esempio,\n\n\n$query-\nleftJoin('post', 'post.user_id = user.id');\n\n\n\nPer unire pi\u00f9 tabelle, chiama pi\u00f9 volte i metodi join, una volta per ogni tabella.\n\n\nOltre a unirti alle tabelle, puoi anche unirti alle sottoquery. Per fare ci\u00f2, specificare le sottoquery da unire come oggetti di \nyii \\ db \\ Query\n. Per esempio,\n\n\n$subQuery = (new \\yii\\db\\Query())-\nfrom('post');\n$query-\nleftJoin(['u' =\n $subQuery], 'u.id = author_id');\n\n\n\nIn questo caso, \u00e8 necessario inserire la sottoquery in una matrice e utilizzare la chiave dell'array per specificare l'alias.\n\n\nUnion()\n\n\nIl metodo \nunion()\n specifica il frammento \nUNION\n di una query SQL. Per esempio,\n\n\n$query1 = (new \\yii\\db\\Query())\n    -\nselect(\"id, category_id AS type, name\")\n    -\nfrom('post')\n    -\nlimit(10);\n\n$query2 = (new \\yii\\db\\Query())\n    -\nselect('id, type, name')\n    -\nfrom('user')\n    -\nlimit(10);\n\n$query1-\nunion($query2);\n\n\n\nPuoi chiamare il metodo \nunion()\n pi\u00f9 volte per aggiungere altri frammneti \nUNION\n.\n\n\nMetodi di ricerca\n\n\nyii \\ db \\ Query\n fornisce un insieme completo di metodi per diversi scopi di ricerca:\n\n\n\n\nall()\n: restituisce una matrice di righe dove ogni riga \u00e8 vista come una matrice associativa di coppie nome-valore.\n\n\none()\n: restituisce la prima riga del risultato.\n\n\ncolumn()\n: restituisce la prima colonna del risultato.\n\n\nscalar()\n: restituisce un valore scalare situato nella prima riga e nella prima colonna del risultato.\n\n\nexists()\n: restituisce un valore che ci permette di capire se il valore della query esiste o meno.\n\n\ncount()\n: restituisce il risultato di una query \nCOUNT\n.\n\n\n\n\nAltri metodi di aggregazione, tra cui \nsomma($ q)\n , \nmedia($ q)\n , \nmax($ q)\n , \nmin($ q)\n . Il parametro \n$q\n \u00e8 obbligatorio per questi metodi e pu\u00f2 essere un nome di colonna o un'espressione DB.\nPer esempio,\n\n\n// SELECT `id`, `email` FROM `user`\n$rows = (new \\yii\\db\\Query())\n    -\nselect(['id', 'email'])\n    -\nfrom('user')\n    -\nall();\n\n// SELECT * FROM `user` WHERE `username` LIKE `%test%`\n$row = (new \\yii\\db\\Query())\n    -\nfrom('user')\n    -\nwhere(['like', 'username', 'test'])\n    -\none();\n\n\n\n\n\nNota\n\n\nIl metodo \none()\n restituisce solo la prima riga del risultato della query. NON aggiunge \nLIMIT 1\n all'istruzione SQL generata. Questo va bene ed \u00e8 preferito se sai che la query restituir\u00e0 solo una o poche righe di dati (ad esempio se stai interrogando con alcune chiavi primarie). Tuttavia, se la query potrebbe potenzialmente generare molte righe di dati, \u00e8 necessario chiamare in modo esplicito \nlimit(1)\n per migliorare le prestazioni, ad es \n(new \\yii\\db\\Query())-\nfrom('user')-\nlimit(1)-\none()\n.\n\n\n\n\nTutti questi metodi di interrogazione richiedono un parametro \n$db\n facoltativo che rappresenta la connessione DB da utilizzare per eseguire una query DB. Se si omette questo parametro, il componente db dell'applicazione verr\u00e0 utilizzato come connessione DB. Di seguito \u00e8 riportato un altro esempio che utilizza il metodo di query \ncount()\n:\n\n\n// executes SQL: SELECT COUNT(*) FROM `user` WHERE `last_name`=:last_name\n$count = (new \\yii\\db\\Query())\n    -\nfrom('user')\n    -\nwhere(['last_name' =\n 'Smith'])\n    -\ncount();\n\n\n\nQuando si chiama un metodo di query di \nyii \\ db \\ Query\n, in realt\u00e0 esegue internamente il seguente lavoro:\n\n\n\n\nChiamare \nyii \\ db \\ QueryBuilder\n per generare un'istruzione SQL in base al costrutto corrente di \nyii \\ db \\ Query\n;\n\n\nCreare un oggetto \nyii \\ db \\ Command\n con l'istruzione SQL generata;\n\n\nChiamare un metodo di query (ad es. \nQueryAll()\n ) di \nyii \\ db \\ Command\n per eseguire l'istruzione SQL e recuperare i dati.\n\n\n\n\nA volte, potresti voler esaminare o usare l'istruzione SQL creata da un oggetto \nyii \\ db \\ Query\n. \u00c8 possibile raggiungere questo obiettivo con il seguente codice:\n\n\n$command = (new \\yii\\db\\Query())\n    -\nselect(['id', 'email'])\n    -\nfrom('user')\n    -\nwhere(['last_name' =\n 'Smith'])\n    -\nlimit(10)\n    -\ncreateCommand();\n\n// show the SQL statement\necho $command-\nsql;\n// show the parameters to be bound\nprint_r($command-\nparams);\n\n// returns all rows of the query result\n$rows = $command-\nqueryAll();\n\n\n\nRisultati di una query da indicizzare\n\n\nQuando si chiama il metodo \nall()\n, verr\u00e0 restituita una matrice di righe che sono indicizzate da numeri interi consecutivi. A volte potresti voler indicizzarli in modo diverso, come l'indicizzazione di una particolare colonna o valori di espressione. \u00c8 possibile raggiungere questo obiettivo chiamando \nindexBy()\n prima di all() . Per esempio,\n\n\n// returns [100 =\n ['id' =\n 100, 'username' =\n '...', ...], 101 =\n [...], 103 =\n [...], ...]\n$query = (new \\yii\\db\\Query())\n    -\nfrom('user')\n    -\nlimit(10)\n    -\nindexBy('id')\n    -\nall();\n\n\n\nPer indicizzare per valori di espressione, passare una funzione anonima al metodo \nindexBy()\n:\n\n\n$query = (new \\yii\\db\\Query())\n    -\nfrom('user')\n    -\nindexBy(function ($row) {\n        return $row['id'] . $row['username'];\n    })-\nall();\n\n\n\nLa funzione anonima accetta un parametro \n$row\n che contiene i dati della riga corrente e deve restituire un valore scalare che verr\u00e0 utilizzato come valore di indice.\n\n\n\n\nWarning\n\n\nContrariamente ai metodi di query come \ngroupBy()\n o \norderBy()\n che vengono convertiti in SQL e fanno parte della query, questo metodo funziona dopo che i dati sono stati recuperati dal database. Ci\u00f2 significa che possono essere utilizzati solo i nomi di colonna che sono stati parte di \nSELECT\n nella query. Inoltre, se hai selezionato una colonna con prefisso tabella, ad esempio \ncustomer.id\n, il set di risultati conterr\u00e0 solo \nid\n, cos\u00ec che bisogna chiamare \n-\nindexBy('id')\n senza prefisso tabella.\n\n\n\n\nBatch Query\n\n\nQuando si lavora con grandi quantit\u00e0 di dati, metodi come \nyii \\ db \\ Query :: all()\n non sono adatti perch\u00e9 richiedono il caricamento dell'intero risultato della query nella memoria del client. Per risolvere questo problema, Yii fornisce supporto per query in batch. Il server mantiene il risultato della query e il client utilizza un cursore per scorrere il set di risultati un batch alla volta.\n\n\n\n\nWarning\n\n\nEsistono limiti noti e soluzioni alternative per l'implementazione MySQL di query batch. Vedi sotto.\n\n\n\n\nLa query batch pu\u00f2 essere utilizzata come la seguente:\n\n\nuse yii\\db\\Query;\n\n$query = (new Query())\n    -\nfrom('user')\n    -\norderBy('id');\n\nforeach ($query-\nbatch() as $users) {\n    // $users is an array of 100 or fewer rows from the user table\n}\n\n// or to iterate the row one by one\nforeach ($query-\neach() as $user) {\n    // data is being fetched from the server in batches of 100,\n    // but $user represents one row of data from the user table\n}\n\n\n\nIl metodo \nyii \\ db \\ Query :: batch()\n e \nyii \\ db \\ Query :: each()\n restituiscono un oggetto \nyii \\ db \\ BatchQueryResult\n che implementa l'interfaccia \nIterator\n e quindi pu\u00f2 essere utilizzato nel costrutto \nforeach\n. Durante la prima iterazione, viene eseguita una query SQL sul database. I dati vengono quindi recuperati in lotti nelle restanti iterazioni. Per impostazione predefinita, la dimensione del batch \u00e8 100, ovvero 100 file di dati vengono recuperati in ogni batch. \u00c8 possibile modificare le dimensioni del batch passando il primo parametro al metodo \nbatch()\n o \neach()\n.\n\n\nRispetto a \nyii \\ db \\ Query :: all()\n, la query batch carica solo 100 righe di dati alla volta nella memoria.\n\n\nSe si specifica il risultato della query da indicizzare per alcune colonne tramite yii \\ db \\ Query :: indexBy () , la query batch manterr\u00e0 comunque l'indice corretto.\n\n\nPer esempio:\n\n\n$query = (new \\yii\\db\\Query())\n    -\nfrom('user')\n    -\nindexBy('username');\n\nforeach ($query-\nbatch() as $users) {\n    // $users is indexed by the \"username\" column\n}\n\nforeach ($query-\neach() as $username =\n $user) {\n    // ...\n}\n\n\n\nLimitazioni della query batch in MySQL\n\n\nL'implementazione MySQL di query batch si basa sulla libreria di driver PDO. Per impostazione predefinita, le query MySQL sono \nbuffered\n. Ci\u00f2 elimina lo scopo di utilizzare il cursore per ottenere i dati, poich\u00e9 non impedisce che l'intero set di risultati venga caricato nella memoria del client dal driver.\n\n\n\n\nWarning\n\n\nQuando \nlibmysqlclient\n viene utilizzato (tipico di PHP5), il limite di memoria di PHP non conter\u00e0 la memoria utilizzata per i set di risultati. Potrebbe sembrare che le query batch funzionino correttamente, ma in realt\u00e0 l'intero set di dati viene caricato nella memoria del client e ha il potenziale per utilizzarlo.\n\n\n\n\nPer disabilitare il buffering e ridurre i requisiti di memoria del client, \u00e8 necessario impostare la propriet\u00e0 di connessione PDO \nPDO::MYSQL_ATTR_USE_BUFFERED_QUERY\n al valore di \nfalse\n. Tuttavia, fino a quando non viene recuperato l'intero set di dati, non \u00e8 possibile effettuare altre query tramite la stessa connessione. Ci\u00f2 potrebbe impedire all'ActiveRecord di creare una query per ottenere lo schema della tabella quando necessario. Se questo non \u00e8 un problema (lo schema della tabella \u00e8 gi\u00e0 memorizzato nella cache), \u00e8 possibile passare la connessione originale in modalit\u00e0 \nunbuffered\n e quindi eseguire il rollback al termine della query batch.\n\n\nYii::$app-\ndb-\npdo-\nsetAttribute(\\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);\n\n// Do batch query\n\nYii::$app-\ndb-\npdo-\nsetAttribute(\\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);\n\n\n\n\n\nNota\n\n\nNel caso di MyISAM, per la durata della query batch, la tabella potrebbe bloccarsi, ritardare o negare l'accesso in scrittura per altre connessioni. Quando si utilizzano query senza buffer, provare a mantenere il cursore aperto per il minor tempo possibile.\n\n\n\n\nSe lo schema non \u00e8 memorizzato nella cache o \u00e8 necessario eseguire altre query mentre viene elaborata la query batch, \u00e8 possibile creare una connessione unbuffered separata al database:\n\n\n$unbufferedDb = new \\yii\\db\\Connection([\n    'dsn' =\n Yii::$app-\ndb-\ndsn,\n    'username' =\n Yii::$app-\ndb-\nusername,\n    'password' =\n Yii::$app-\ndb-\npassword,\n    'charset' =\n Yii::$app-\ndb-\ncharset,\n]);\n$unbufferedDb-\nopen();\n$unbufferedDb-\npdo-\nsetAttribute(\\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);\n\n\n\nSe vuoi assicurarti che \n$unbufferedDb\n abbia esattamente gli stessi attributi PDO come il buffer originale, il valore di \nPDO::MYSQL_ATTR_USE_BUFFERED_QUERY\n deve essere \nfalse\n.\n\n\nQuindi, le query vengono create normalmente. La nuova connessione viene utilizzata per eseguire query batch e recuperare i risultati in batch o uno per uno:\n\n\n// getting data in batches of 1000\nforeach ($query-\nbatch(1000, $unbufferedDb) as $users) {\n    // ...\n}\n\n// data is fetched from server in batches of 1000, but is iterated one by one \nforeach ($query-\neach(1000, $unbufferedDb) as $user) {\n    // ...\n}\n\n\n\nQuando la connessione non \u00e8 pi\u00f9 necessaria e il set di risultati \u00e8 stato recuperato, pu\u00f2 essere chiuso:\n\n\n$unbufferedDb-\nclose();\n\n\n\n\n\nNota\n\n\nLa query senza buffer utilizza meno memoria sul lato PHP, ma pu\u00f2 aumentare il carico sul server MySQL. Si consiglia di progettare il proprio codice con la propria pratica di produzione per ottenere dati straordinari.",
            "title": "Generatore di Query"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#generatore-di-query-query-builder",
            "text": "Basato sul DBO (Database Access Objects), il generatore di query consente di costruire una query SQL in modo programmatico e indipendente dal DBMS. Rispetto alla scrittura di istruzioni SQL non elaborate, l'utilizzo del query builder consente di scrivere codice SQL pi\u00f9 leggibile e generare istruzioni SQL pi\u00f9 sicure.  L'utilizzo di Generatore di query prevede in genere due passaggi:   Costruisci un oggetto  yii \\ db \\ Query  per rappresentare parti diverse (ad es SELECT. FROM) di un'istruzione SELECT SQL.  Esegui un metodo di query (es.  all() ) di  yii \\ db \\ Query  per recuperare i dati dal database.   Il codice seguente mostra un modo tipico di utilizzare il generatore di query:  $rows = (new \\yii\\db\\Query())\n    - select(['id', 'email'])\n    - from('user')\n    - where(['last_name' =  'Smith'])\n    - limit(10)\n    - all();  Il codice precedente genera ed esegue la seguente query SQL, in cui il parametro  :last_name  \u00e8 associato alla stringa  'Smith' .  SELECT `id`, `email` \nFROM `user`\nWHERE `last_name` = :last_name\nLIMIT 10   Info  Di solito si lavora principalmente con  yii \\ db \\ Query  invece di  yii \\ db \\ QueryBuilder . Quest'ultimo viene invocato dal primo implicitamente quando si chiama uno dei metodi di query.  yii \\ db \\ QueryBuilder  \u00e8 la classe responsabile della generazione di istruzioni SQL dipendenti da DBMS (ad esempio, citando in modo diverso nomi di tabelle / colonne) da oggetti  yii \\ db \\ Query  indipendenti da DBMS.",
            "title": "Generatore di Query (Query Builder)"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#costruzione-di-una-query",
            "text": "Per costruire un oggetto  yii \\ db \\ Query , si chiamano diversi metodi di creazione per specificare parti diverse di una query SQL. I nomi di questi metodi sono simili alle parole chiave SQL utilizzate nelle parti corrispondenti dell'istruzione. Ad esempio, per specificare la parte  FROM  di una query SQL, dobbiamo chiamare il metodo  from() . Tutti i metodi di creazione query restituiscono l'oggetto query stesso, che consente di concatenare pi\u00f9 chiamate contemporaneamente.  Di seguito, descriveremo l'utilizzo di ciascun metodo di creazione di query.",
            "title": "Costruzione di una query"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#select",
            "text": "Il metodo  select()  specifica il frammentro  SELECT  di un'istruzione SQL. \u00c8 possibile specificare le colonne da selezionare in una matrice o in una stringa, come nell'esempio seguente. I nomi delle colonne selezionati verranno automaticamente quotati quando l'istruzione SQL viene generata da un oggetto query.  $query- select(['id', 'email']);\n\n// equivalent to:\n\n$query- select('id, email');  I nomi delle colonne selezionate possono includere prefissi di tabelle e / o alias di colonne, come quando si scrivono query SQL non elaborate. Per esempio,  $query- select(['user.id AS user_id', 'email']);\n\n// equivalent to:\n\n$query- select('user.id AS user_id, email');  Se si utilizza il formato della matrice per specificare le colonne, \u00e8 anche possibile utilizzare i tasti della matrice per specificare gli alias di colonna. Ad esempio, il codice sopra riportato pu\u00f2 essere riscritto come segue,  $query- select(['user_id' =  'user.id', 'email']);  Se non si chiama il metodo  select()  durante la creazione di una query, con  *  verranno selezionate tutte le colonne.  Oltre ai nomi delle colonne, \u00e8 anche possibile selezionare le espressioni DB. \u00c8 necessario utilizzare il formato di matrice quando si seleziona un'espressione DB che contiene virgole, per evitare virgolette automatiche errate. Per esempio,  $query- select([\"CONCAT(first_name, ' ', last_name) AS full_name\", 'email']);  Come per tutti i punti in cui \u00e8 coinvolto l'SQL non elaborato, \u00e8 possibile utilizzare  DBMS agnostic quoting syntax  per i nomi di tabelle e colonne quando si scrivono espressioni DB in select.  A partire dalla versione 2.0.1, \u00e8 possibile selezionare anche le sottoquery. \u00c8 necessario specificare ogni sottoquery in termini di un oggetto  yii \\ db \\ Query . Per esempio,  $subQuery = (new Query())- select('COUNT(*)')- from('user');\n\n// SELECT `id`, (SELECT COUNT(*) FROM `user`) AS `count` FROM `post`\n$query = (new Query())- select(['id', 'count' =  $subQuery])- from('post');  Per selezionare righe distinte, puoi chiamare il metodo  distinct()  , come il seguente:  // SELECT DISTINCT `user_id` ...\n$query- select('user_id')- distinct();  Puoi chiamare  addSelect()  per selezionare colonne aggiuntive. Per esempio,  $query- select(['id', 'username'])\n    - addSelect(['email']);",
            "title": "SELECT()"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#from",
            "text": "Il metodo  from()  specifica il frammento  FROM  di un'istruzione SQL. Per esempio,  // SELECT * FROM `user`\n$query- from('user');  \u00c8 possibile specificare la / le tabella / i selezionata / i in una stringa o in una matrice. I nomi delle tabelle possono contenere prefissi dello schema e / o alias di tabelle, come quando si scrivono istruzioni SQL non elaborate. Per esempio,  $query- from(['public.user u', 'public.post p']);\n\n// equivalent to:\n\n$query- from('public.user u, public.post p');  Se si utilizza il formato di matrice, \u00e8 anche possibile utilizzare le chiavi della matrice per specificare gli alias di tabella, come i seguenti:  $query- from(['u' =  'public.user', 'p' =  'public.post']);  Oltre ai nomi delle tabelle, \u00e8 anche possibile selezionare delle subquery specificandole in termini di oggetti  yii \\ db \\ Query . Per esempio,  $subQuery = (new Query())- select('id')- from('user')- where('status=1');\n\n// SELECT * FROM (SELECT `id` FROM `user` WHERE status=1) u \n$query- from(['u' =  $subQuery]);",
            "title": "FROM()"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#where",
            "text": "Il metodo  where()  specifica il frammento  WHERE  di una query SQL. \u00c8 possibile utilizzare uno dei tre formati per specificare una WHEREcondizione:   formato stringa, ad es.  'status=1'  formato hash, ad es  ['status' =  1, 'type' =  2]  formato operatore, ad es  ['like', 'name', 'test']   Formato della stringa  Il formato stringa \u00e8 il modo migliore per specificare condizioni molto semplici o se \u00e8 necessario utilizzare le funzioni integrate del DBMS. Funziona come se si stesse scrivendo un SQL raw. Per esempio,  $query- where('status=1');\n\n// or use parameter binding to bind dynamic parameter values\n$query- where('status=:status', [':status' =  $status]);\n\n// raw SQL using MySQL YEAR() function on a date field\n$query- where('YEAR(somedate) = 2015');  NON incorporare le variabili direttamente nella condizione come le seguenti, soprattutto se i valori delle variabili provengono da input dell'utente finale, poich\u00e9 ci\u00f2 render\u00e0 l'applicazione soggetta agli attacchi di SQL injection.  // Dangerous! Do NOT do this unless you are very certain $status must be an integer.\n$query- where(\"status=$status\");  Quando si utilizza l'associazione dei parametri, \u00e8 possibile chiamare il metodo  params()  o  addParams()  per specificare i parametri separatamente.  $query- where('status=:status')\n    - addParams([':status' =  $status]);  Come per tutti i punti in cui \u00e8 coinvolto l'SQL non elaborato, \u00e8 possibile utilizzare la \"DBMS agnostic quoting syntax\" per i nomi di tabelle e colonne quando si scrivono le condizioni nel formato stringa.  Formato hash  Il formato hash viene utilizzato per specificare le sotto-condizioni concatenate come  AND , ognuna delle quali \u00e8 una semplice affermazione di uguaglianza. \u00c8 scritto come un array le cui chiavi sono nomi di colonne e valori i valori corrispondenti che dovrebbero essere le colonne. Per esempio,  // ...WHERE (`status` = 10) AND (`type` IS NULL) AND (`id` IN (4, 8, 15))\n$query- where([\n    'status' =  10,\n    'type' =  null,\n    'id' =  [4, 8, 15],\n]);  Come puoi vedere, il generatore di query \u00e8 abbastanza intelligente da gestire correttamente i valori null o array.  Puoi anche utilizzare sottoquery con formato hash come il seguente:  $userQuery = (new Query())- select('id')- from('user');\n\n// ...WHERE `id` IN (SELECT `id` FROM `user`)\n$query- where(['id' =  $userQuery]);  Usando il formato hash, Yii usa internamente il binding dei parametri, quindi in contrasto con il formato stringa. In questo caso non devi aggiungere parametri manualmente.  Formato dell'operatore  Il formato operatore consente di specificare condizioni arbitrarie in modo programmatico. Prende il seguente formato:  [operator, operand1, operand2, ...]  dove gli operandi possono essere specificati ciascuno in formato stringa, formato hash o formato operatore in modo ricorsivo, mentre l'operatore pu\u00f2 essere uno dei seguenti:    and : gli operandi dovrebbero essere concatenati insieme usando  AND . Ad esempio,  ['and', 'id=1', 'id=2']  generer\u00e0  id=1 AND id=2 . Se un operando \u00e8 un array, verr\u00e0 convertito in una stringa usando le regole descritte qui. Ad esempio, ['and', 'type=1', ['or', 'id=1', 'id=2']]  generer\u00e0  type=1 AND (id=1 OR id=2) . Il metodo NON far\u00e0 alcuna citazione o fuga.    or : simile all'operatore  and  tranne per il fatto che gli operandi sono concatenati usando  OR .    not : richiede solo l'operando 1, che verr\u00e0 incluso con  NOT() . Ad esempio,  ['not', 'id=1']generer\u00e0 NOT (id=1) . Operando 1 pu\u00f2 anche essere una matrice per descrivere pi\u00f9 espressioni. Ad esempio  ['not', ['status' =  'draft', 'name' =  'example']]  generer\u00e0  NOT ((status='draft') AND (name='example')) .    between : l'operando 1 dovrebbe essere il nome della colonna e l'operando 2 e 3 dovrebbe essere il valore iniziale e finale dell'intervallo in cui si trova la colonna. Ad esempio,  ['between', 'id', 1, 10]  generer\u00e0  id BETWEEN 1 AND 10 .    not between : simile a  between tranne che  BETWEEN  viene sostituito con  NOT BETWEEN  nella condizione generata.    in : l'operando 1 dovrebbe essere una colonna o un'espressione DB. L' operando 2 pu\u00f2 essere un array o un oggetto  Query . Generer\u00e0 una condizione  IN  se l'operando 2 \u00e8 una matrice, rappresenter\u00e0 l'intervallo dei valori che dovrebbe essere la colonna o l'espressione DB; se l'operando 2 \u00e8 un oggetto  Query , verr\u00e0 generata una sottoquery e utilizzata come intervallo della colonna o dell'espressione DB. Ad esempio,  ['in', 'id', [1, 2, 3]]  generer\u00e0  id IN (1, 2, 3) . Il metodo citer\u00e0 correttamente il nome della colonna e i valori di escape nell'intervallo. L'operatore  in  supporta anche colonne composite. In questo caso, l'operando 1 dovrebbe essere una matrice delle colonne, mentre l'operando 2 dovrebbe essere una matrice di matrici o un oggetto  Query  che rappresenta l'intervallo delle colonne.    not in : simile all'operatore  in  tranne che  IN  viene sostituito con  NOT IN  nella condizione generata.    like : l'operando 1 deve essere una colonna o un'espressione DB e l'operando 2 deve essere una stringa o una matrice che rappresenta i valori che la colonna o l'espressione DB deve avere. Ad esempio,  ['like', 'name', 'tester']  generer\u00e0  name LIKE '%tester%' . Quando l'intervallo di valori viene fornito come matrice, i  LIKE  saranno di pi\u00f9 e verranno concatenati utilizzando  AND . Ad esempio,  ['like', 'name', ['test', 'sample']]  generer\u00e0  name LIKE '%test%' AND name LIKE '%sample%' . \u00c8 anche possibile fornire un terzo operando opzionale per specificare come evitare caratteri speciali nei valori. L'operando dovrebbe essere una matrice di mapping dai caratteri speciali alle loro controparti fuggite. Se questo operando non viene fornito, verr\u00e0 utilizzata una mappatura di escape predefinita. Puoi usare il valore  false  o una matrice vuota per indicare che i valori sono gi\u00e0 stati presi e che non \u00e8 necessario applicare alcuna escape. Si noti che quando si utilizza una mappatura di escape (o il terzo operando non \u00e8 fornito), i valori saranno automaticamente racchiusi all'interno di una coppia di caratteri percentuali.     Nota  Quando si utilizza PostgreSQL \u00e8 possibile utilizzare  ilike  al posto della corrispondenza  like  senza distinzione tra maiuscole e minuscole.     or like : simile all'operatore  like  tranne che  OR  \u00e8 usato per concatenare i  LIKE  predicati quando l'operando 2 \u00e8 una matrice.    not like : simile all'operatore  lik  tranne che  LIKE  viene sostituito con  NOT LIKE  nella condizione generata.    or not like : simile all'operatore  not like  tranne che  OR  \u00e8 usato per concatenare i predicati  NOT LIKE .    exists : richiede un operando che deve essere un'istanza di  yii \\ db \\ Query  che rappresenta la sottoquery. Costruir\u00e0 un'espressione  EXISTS (sub-query) .    not exists : simile all'operatore  exists  e crea un'espressione  NOT EXISTS (sub-query) .    ,  =  o qualsiasi altro operatore DB valido che accetta due operandi: il primo operando deve essere un nome di colonna mentre il secondo operando un valore. Ad esempio,  [' ', 'age', 10]  generer\u00e0  age 10 .    Utilizzando il formato operatore, Yii utilizza internamente il binding dei parametri, in contrasto con il formato stringa , in questo caso non \u00e8 necessario aggiungere parametri manualmente.  Aggiunta delle condizioni  \u00c8 possibile utilizzare  andWhere()  o  orWhere()  per aggiungere condizioni aggiuntive a una esistente. Puoi chiamarli pi\u00f9 volte per aggiungere pi\u00f9 condizioni separatamente. Per esempio,  $status = 10;\n$search = 'yii';\n\n$query- where(['status' =  $status]);\n\nif (!empty($search)) {\n    $query- andWhere(['like', 'title', $search]);\n}  Se  $search  non \u00e8 vuoto, dalla propriet\u00e0  WHERE  verr\u00e0 generata la seguente condizione:  WHERE (`status` = 10) AND (`title` LIKE '%yii%')  Condizioni associati ai filtri  Quando si costruiscono le condizioni  WHERE  in base all'input degli utenti finali, in genere si desidera ignorare quei valori di input, che sono vuoti. Ad esempio, in un modulo di ricerca che consente di effettuare ricerche per nome utente ed e-mail, si desidera ignorare la condizione se l'utente non inserisce nulla nel campo di inserimento nome utente / email. \u00c8 possibile raggiungere questo obiettivo utilizzando il metodo  filterWhere() :  // $username and $email are from user inputs\n$query- filterWhere([\n    'username' =  $username,\n    'email' =  $email,\n]);  L'unica differenza tra  filterWhere()  e  where()  \u00e8 che il primo ignorer\u00e0 i valori vuoti forniti nella condizione in formato hash. Quindi se  $email  \u00e8 vuoto mentre  $username  non lo \u00e8, il codice sopra comporter\u00e0 la condizione  SQL WHERE username=:username .   Info   Un valore \u00e8 considerato vuoto se ha come valore  null , un array vuoto, una stringa vuota o una stringa composta solo da spazi bianchi.  Come  andWhere()  e  orWhere() , \u00e8 possibile utilizzare i metodi  andFilterWhere()  e  orFilterWhere()  per aggiungere condizioni di filtro aggiuntive a quella esistente.\nInoltre, vi \u00e8  yii \\ db \\ Query :: andFilterCompare()  che pu\u00f2 determinare in modo intelligente l'operatore in base a cosa c'\u00e8 nel valore:  $query- andFilterCompare('name', 'John Doe');\n$query- andFilterCompare('rating', ' 9');\n$query- andFilterCompare('value', ' =100');  Puoi anche specificare esplicitamente l'operatore:  $query- andFilterCompare('name', 'Doe', 'like');  Yii 2.0.11 offre metodi simili per la condzione  HAVING :   filterHaving()  andFilterHaving()  orFilterHaving()",
            "title": "WHERE()"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#orderby",
            "text": "Il metodo  orderBy()  specifica il frammento  ORDER BY  di una query SQL. Per esempio,  // ... ORDER BY `id` ASC, `name` DESC\n$query- orderBy([\n    'id' =  SORT_ASC,\n    'name' =  SORT_DESC,\n]);  Nel codice precedente, le chiavi dell'array sono nomi di colonne, mentre i valori dell'array sono l'ordine corrispondente per direzioni. La costante PHP  SORT_ASC  specifica l'ordinamento crescente, mentre la costante  SORT_DESC  specifica quello decrescente.  Se  ORDER BY  riguarda solo nomi di colonne semplici, \u00e8 possibile specificarlo utilizzando una stringa, proprio come quando si scrivono istruzioni SQL non elaborate. Per esempio,  $query- orderBy('id ASC, name DESC');   Nota  E' necessario utilizzare il formato dell'array se  ORDER BY  include alcune espressioni DB.   Puoi chiamare il metodo  addOrderBy()  per aggiungere ulteriori colonne al frammento  ORDER BY . Per esempio,  $query- orderBy('id ASC')\n    - addOrderBy('name DESC');",
            "title": "OrderBy()"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#groupby",
            "text": "Il metodo  groupBy()  specifica il frammento  GROUP BY  di una query SQL. Per esempio,  // ... GROUP BY `id`, `status`\n$query- groupBy(['id', 'status']);  Se  GROUP BY  riguarda solo nomi di colonne semplici, \u00e8 possibile specificarlo utilizzando una stringa, proprio come quando si scrivono istruzioni SQL non elaborate. Per esempio,  $query- groupBy('id, status');   Nota  E' necessario utilizzare il formato dell'array se  GROUP BY  include alcune espressioni DB.   \u00c8 possibile chiamare il metodo  addGroupBy()  per aggiungere ulteriori colonne al frammento  GROUP BY . Per esempio,  $query- groupBy(['id', 'status'])\n    - addGroupBy('age');",
            "title": "GroupBy()"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#having",
            "text": "Il metodo  having()  specifica il frammento  HAVING  di una query SQL. Prende una condizione che pu\u00f2 essere specificata al solito modo di  where() . Per esempio,  // ... HAVING `status` = 1\n$query- having(['status' =  1]);  Fare riferimento alla documentazione di where () per ulteriori dettagli su come specificare una condizione.  \u00c8 possibile chiamare i metodi  andHaving()  o  orHaving()  per aggiungere condizioni aggiuntive al frammento  HAVING . Per esempio,  // ... HAVING (`status` = 1) AND (`age`   30)\n$query- having(['status' =  1])",
            "title": "Having()"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#limit-e-offset",
            "text": "I metodi  limit()  e  offset()  specificano i frammenti  LIMIT  e  OFFSET  di una query SQL. Per esempio,  // ... LIMIT 10 OFFSET 20\n$query- limit(10)- offset(20);  Se si specifica un limite o offset non valido (ad es. Un valore negativo), verr\u00e0 ignorato.   Info  Per DBMS che non supportano questi due frammenti (ad esempio MSSQL), il generatore di query generer\u00e0 un'istruzione SQL che emula il comportamento di  LIMIT/ OFFSET .",
            "title": "Limit() e Offset()"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#join",
            "text": "Il metodo  join()  specifica il frammento  JOIN  di una query SQL. Per esempio,  // ... LEFT JOIN `post` ON `post`.`user_id` = `user`.`id`\n$query- join('LEFT JOIN', 'post', 'post.user_id = user.id');  Il metodo  join()  accetta quattro parametri:   $type : indica tipo di join, ad es .  'INNER JOIN' ,  'LEFT JOIN' .  $table : indica il nome del table da usare nella join.  $on : (facoltativo), indica la condizione di join, ovvero il frammento  ON . Si prega di fare riferimento a  where()  per i dettagli su come specificare una condizione. Si noti che la sintassi dell'array non funziona per specificare una condizione basata su colonne, ad es.  ['user.id' =  'comment.userId'] . Si verificher\u00e0 una condizione in cui l'id dell'utente deve essere uguale alla stringa  'comment.userId' . Dovresti invece utilizzare la sintassi della stringa e specificare la condizione come  'user.id = comment.userId' .  $params : (facoltativo), indica i parametri da associare alla condizione di join.   \u00c8 possibile utilizzare i seguenti metodi di scelta rapida per specificare  INNER JOIN ,  LEFT JOIN  e  RIGHT JOIN .   innerJoin()  leftJoin()  rightJoin()   Per esempio,  $query- leftJoin('post', 'post.user_id = user.id');  Per unire pi\u00f9 tabelle, chiama pi\u00f9 volte i metodi join, una volta per ogni tabella.  Oltre a unirti alle tabelle, puoi anche unirti alle sottoquery. Per fare ci\u00f2, specificare le sottoquery da unire come oggetti di  yii \\ db \\ Query . Per esempio,  $subQuery = (new \\yii\\db\\Query())- from('post');\n$query- leftJoin(['u' =  $subQuery], 'u.id = author_id');  In questo caso, \u00e8 necessario inserire la sottoquery in una matrice e utilizzare la chiave dell'array per specificare l'alias.",
            "title": "Join()"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#union",
            "text": "Il metodo  union()  specifica il frammento  UNION  di una query SQL. Per esempio,  $query1 = (new \\yii\\db\\Query())\n    - select(\"id, category_id AS type, name\")\n    - from('post')\n    - limit(10);\n\n$query2 = (new \\yii\\db\\Query())\n    - select('id, type, name')\n    - from('user')\n    - limit(10);\n\n$query1- union($query2);  Puoi chiamare il metodo  union()  pi\u00f9 volte per aggiungere altri frammneti  UNION .",
            "title": "Union()"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#metodi-di-ricerca",
            "text": "yii \\ db \\ Query  fornisce un insieme completo di metodi per diversi scopi di ricerca:   all() : restituisce una matrice di righe dove ogni riga \u00e8 vista come una matrice associativa di coppie nome-valore.  one() : restituisce la prima riga del risultato.  column() : restituisce la prima colonna del risultato.  scalar() : restituisce un valore scalare situato nella prima riga e nella prima colonna del risultato.  exists() : restituisce un valore che ci permette di capire se il valore della query esiste o meno.  count() : restituisce il risultato di una query  COUNT .   Altri metodi di aggregazione, tra cui  somma($ q)  ,  media($ q)  ,  max($ q)  ,  min($ q)  . Il parametro  $q  \u00e8 obbligatorio per questi metodi e pu\u00f2 essere un nome di colonna o un'espressione DB.\nPer esempio,  // SELECT `id`, `email` FROM `user`\n$rows = (new \\yii\\db\\Query())\n    - select(['id', 'email'])\n    - from('user')\n    - all();\n\n// SELECT * FROM `user` WHERE `username` LIKE `%test%`\n$row = (new \\yii\\db\\Query())\n    - from('user')\n    - where(['like', 'username', 'test'])\n    - one();   Nota  Il metodo  one()  restituisce solo la prima riga del risultato della query. NON aggiunge  LIMIT 1  all'istruzione SQL generata. Questo va bene ed \u00e8 preferito se sai che la query restituir\u00e0 solo una o poche righe di dati (ad esempio se stai interrogando con alcune chiavi primarie). Tuttavia, se la query potrebbe potenzialmente generare molte righe di dati, \u00e8 necessario chiamare in modo esplicito  limit(1)  per migliorare le prestazioni, ad es  (new \\yii\\db\\Query())- from('user')- limit(1)- one() .   Tutti questi metodi di interrogazione richiedono un parametro  $db  facoltativo che rappresenta la connessione DB da utilizzare per eseguire una query DB. Se si omette questo parametro, il componente db dell'applicazione verr\u00e0 utilizzato come connessione DB. Di seguito \u00e8 riportato un altro esempio che utilizza il metodo di query  count() :  // executes SQL: SELECT COUNT(*) FROM `user` WHERE `last_name`=:last_name\n$count = (new \\yii\\db\\Query())\n    - from('user')\n    - where(['last_name' =  'Smith'])\n    - count();  Quando si chiama un metodo di query di  yii \\ db \\ Query , in realt\u00e0 esegue internamente il seguente lavoro:   Chiamare  yii \\ db \\ QueryBuilder  per generare un'istruzione SQL in base al costrutto corrente di  yii \\ db \\ Query ;  Creare un oggetto  yii \\ db \\ Command  con l'istruzione SQL generata;  Chiamare un metodo di query (ad es.  QueryAll()  ) di  yii \\ db \\ Command  per eseguire l'istruzione SQL e recuperare i dati.   A volte, potresti voler esaminare o usare l'istruzione SQL creata da un oggetto  yii \\ db \\ Query . \u00c8 possibile raggiungere questo obiettivo con il seguente codice:  $command = (new \\yii\\db\\Query())\n    - select(['id', 'email'])\n    - from('user')\n    - where(['last_name' =  'Smith'])\n    - limit(10)\n    - createCommand();\n\n// show the SQL statement\necho $command- sql;\n// show the parameters to be bound\nprint_r($command- params);\n\n// returns all rows of the query result\n$rows = $command- queryAll();",
            "title": "Metodi di ricerca"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#risultati-di-una-query-da-indicizzare",
            "text": "Quando si chiama il metodo  all() , verr\u00e0 restituita una matrice di righe che sono indicizzate da numeri interi consecutivi. A volte potresti voler indicizzarli in modo diverso, come l'indicizzazione di una particolare colonna o valori di espressione. \u00c8 possibile raggiungere questo obiettivo chiamando  indexBy()  prima di all() . Per esempio,  // returns [100 =  ['id' =  100, 'username' =  '...', ...], 101 =  [...], 103 =  [...], ...]\n$query = (new \\yii\\db\\Query())\n    - from('user')\n    - limit(10)\n    - indexBy('id')\n    - all();  Per indicizzare per valori di espressione, passare una funzione anonima al metodo  indexBy() :  $query = (new \\yii\\db\\Query())\n    - from('user')\n    - indexBy(function ($row) {\n        return $row['id'] . $row['username'];\n    })- all();  La funzione anonima accetta un parametro  $row  che contiene i dati della riga corrente e deve restituire un valore scalare che verr\u00e0 utilizzato come valore di indice.   Warning  Contrariamente ai metodi di query come  groupBy()  o  orderBy()  che vengono convertiti in SQL e fanno parte della query, questo metodo funziona dopo che i dati sono stati recuperati dal database. Ci\u00f2 significa che possono essere utilizzati solo i nomi di colonna che sono stati parte di  SELECT  nella query. Inoltre, se hai selezionato una colonna con prefisso tabella, ad esempio  customer.id , il set di risultati conterr\u00e0 solo  id , cos\u00ec che bisogna chiamare  - indexBy('id')  senza prefisso tabella.",
            "title": "Risultati di una query da indicizzare"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#batch-query",
            "text": "Quando si lavora con grandi quantit\u00e0 di dati, metodi come  yii \\ db \\ Query :: all()  non sono adatti perch\u00e9 richiedono il caricamento dell'intero risultato della query nella memoria del client. Per risolvere questo problema, Yii fornisce supporto per query in batch. Il server mantiene il risultato della query e il client utilizza un cursore per scorrere il set di risultati un batch alla volta.   Warning  Esistono limiti noti e soluzioni alternative per l'implementazione MySQL di query batch. Vedi sotto.   La query batch pu\u00f2 essere utilizzata come la seguente:  use yii\\db\\Query;\n\n$query = (new Query())\n    - from('user')\n    - orderBy('id');\n\nforeach ($query- batch() as $users) {\n    // $users is an array of 100 or fewer rows from the user table\n}\n\n// or to iterate the row one by one\nforeach ($query- each() as $user) {\n    // data is being fetched from the server in batches of 100,\n    // but $user represents one row of data from the user table\n}  Il metodo  yii \\ db \\ Query :: batch()  e  yii \\ db \\ Query :: each()  restituiscono un oggetto  yii \\ db \\ BatchQueryResult  che implementa l'interfaccia  Iterator  e quindi pu\u00f2 essere utilizzato nel costrutto  foreach . Durante la prima iterazione, viene eseguita una query SQL sul database. I dati vengono quindi recuperati in lotti nelle restanti iterazioni. Per impostazione predefinita, la dimensione del batch \u00e8 100, ovvero 100 file di dati vengono recuperati in ogni batch. \u00c8 possibile modificare le dimensioni del batch passando il primo parametro al metodo  batch()  o  each() .  Rispetto a  yii \\ db \\ Query :: all() , la query batch carica solo 100 righe di dati alla volta nella memoria.  Se si specifica il risultato della query da indicizzare per alcune colonne tramite yii \\ db \\ Query :: indexBy () , la query batch manterr\u00e0 comunque l'indice corretto.  Per esempio:  $query = (new \\yii\\db\\Query())\n    - from('user')\n    - indexBy('username');\n\nforeach ($query- batch() as $users) {\n    // $users is indexed by the \"username\" column\n}\n\nforeach ($query- each() as $username =  $user) {\n    // ...\n}",
            "title": "Batch Query"
        },
        {
            "location": "/working-with-databases/sub-query-builder/#limitazioni-della-query-batch-in-mysql",
            "text": "L'implementazione MySQL di query batch si basa sulla libreria di driver PDO. Per impostazione predefinita, le query MySQL sono  buffered . Ci\u00f2 elimina lo scopo di utilizzare il cursore per ottenere i dati, poich\u00e9 non impedisce che l'intero set di risultati venga caricato nella memoria del client dal driver.   Warning  Quando  libmysqlclient  viene utilizzato (tipico di PHP5), il limite di memoria di PHP non conter\u00e0 la memoria utilizzata per i set di risultati. Potrebbe sembrare che le query batch funzionino correttamente, ma in realt\u00e0 l'intero set di dati viene caricato nella memoria del client e ha il potenziale per utilizzarlo.   Per disabilitare il buffering e ridurre i requisiti di memoria del client, \u00e8 necessario impostare la propriet\u00e0 di connessione PDO  PDO::MYSQL_ATTR_USE_BUFFERED_QUERY  al valore di  false . Tuttavia, fino a quando non viene recuperato l'intero set di dati, non \u00e8 possibile effettuare altre query tramite la stessa connessione. Ci\u00f2 potrebbe impedire all'ActiveRecord di creare una query per ottenere lo schema della tabella quando necessario. Se questo non \u00e8 un problema (lo schema della tabella \u00e8 gi\u00e0 memorizzato nella cache), \u00e8 possibile passare la connessione originale in modalit\u00e0  unbuffered  e quindi eseguire il rollback al termine della query batch.  Yii::$app- db- pdo- setAttribute(\\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);\n\n// Do batch query\n\nYii::$app- db- pdo- setAttribute(\\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);   Nota  Nel caso di MyISAM, per la durata della query batch, la tabella potrebbe bloccarsi, ritardare o negare l'accesso in scrittura per altre connessioni. Quando si utilizzano query senza buffer, provare a mantenere il cursore aperto per il minor tempo possibile.   Se lo schema non \u00e8 memorizzato nella cache o \u00e8 necessario eseguire altre query mentre viene elaborata la query batch, \u00e8 possibile creare una connessione unbuffered separata al database:  $unbufferedDb = new \\yii\\db\\Connection([\n    'dsn' =  Yii::$app- db- dsn,\n    'username' =  Yii::$app- db- username,\n    'password' =  Yii::$app- db- password,\n    'charset' =  Yii::$app- db- charset,\n]);\n$unbufferedDb- open();\n$unbufferedDb- pdo- setAttribute(\\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);  Se vuoi assicurarti che  $unbufferedDb  abbia esattamente gli stessi attributi PDO come il buffer originale, il valore di  PDO::MYSQL_ATTR_USE_BUFFERED_QUERY  deve essere  false .  Quindi, le query vengono create normalmente. La nuova connessione viene utilizzata per eseguire query batch e recuperare i risultati in batch o uno per uno:  // getting data in batches of 1000\nforeach ($query- batch(1000, $unbufferedDb) as $users) {\n    // ...\n}\n\n// data is fetched from server in batches of 1000, but is iterated one by one \nforeach ($query- each(1000, $unbufferedDb) as $user) {\n    // ...\n}  Quando la connessione non \u00e8 pi\u00f9 necessaria e il set di risultati \u00e8 stato recuperato, pu\u00f2 essere chiuso:  $unbufferedDb- close();   Nota  La query senza buffer utilizza meno memoria sul lato PHP, ma pu\u00f2 aumentare il carico sul server MySQL. Si consiglia di progettare il proprio codice con la propria pratica di produzione per ottenere dati straordinari.",
            "title": "Limitazioni della query batch in MySQL"
        },
        {
            "location": "/working-with-databases/sub-active-record/",
            "text": "Active Record\n\n\nActive Record fornisce un'interfaccia orientata agli oggetti per l'accesso e la manipolazione dei dati memorizzati nei database. Una classe di Active Record \u00e8 associata a una tabella di database, un'istanza di Active Record corrisponde a una riga di tale tabella e un attributo di un'istanza di Active Record, rappresenta il valore di una determinata colonna in tale riga. Invece di scrivere istruzioni SQL non elaborate, \u00e8 necessario accedere agli attributi di Active Record e chiamare i metodi per accedere e manipolare i dati memorizzati nelle tabelle del database.\n\n\nAd esempio, supponiamo che \nCustomer\n sia una classe Active Record associata alla tabella \ncustomer\n e \nname\n sia una colonna della tabelle \ncustomer\n. Puoi scrivere il seguente codice per inserire una nuova riga nella tabelle \ncustomer\n:\n\n\n$customer = new Customer();\n$customer-\nname = 'Qiang';\n$customer-\nsave();\n\n\n\nIl codice precedente equivale a utilizzare la seguente istruzione SQL raw per MySQL, che \u00e8 meno intuitiva, pi\u00f9 incline agli errori e potrebbe persino presentare problemi di compatibilit\u00e0 se si utilizza un tipo diverso di database:\n\n\n$db-\ncreateCommand('INSERT INTO `customer` (`name`) VALUES (:name)', [\n    ':name' =\n 'Qiang',\n])-\nexecute();\n\n\n\nYii fornisce il supporto Active Record per i seguenti database relazionali:\n\n\n\n\nMySQL 4.1 o versioni successive: tramite \nyii \\ db \\ ActiveRecord\n\n\nPostgreSQL 7.3 o successivo: tramite \nyii \\ db \\ ActiveRecord\n\n\nSQLite 2 e 3: tramite \nyii \\ db \\ ActiveRecord\n\n\nMicrosoft SQL Server 2008 o versioni successive: tramite \nyii \\ db \\ ActiveRecord\n\n\nOracle: tramite \nyii \\ db \\ ActiveRecord\n\n\nCUBRID 9.3 o successivo: tramite \nyii \\ db \\ ActiveRecord\n (si noti che a causa di un bug nell'estensione PDO cubrid, la citazione dei valori non funzioner\u00e0, quindi \u00e8 necessario CUBRID 9.3 come client e server)\n\n\nSfinge: tramite \nyii \\ sphinx \\ ActiveRecord\n , richiede l'estensione \nyii2-sphinx\n\n\nElasticSearch: tramite \nyii \\ elasticsearch \\ ActiveRecord\n, richiede l'estensione \nyii2-elasticsearch\n\n\n\n\nInoltre, Yii supporta anche l'uso di Active Record con i seguenti database NoSQL:\n\n\n\n\nRedis 2.6.12 o successivo: tramite \nyii \\ redis \\ ActiveRecord\n, richiede l'estensione \nyii2-redis\n\n\nMongoDB 1.3.0 o versioni successive: tramite \nyii \\ mongodb \\ ActiveRecord\n, richiede l'estensione \nyii2-mongodb\n\n\n\n\nIn questo tutorial, descriveremo principalmente l'utilizzo di Active Record per i database relazionali. Tuttavia, la maggior parte dei contenuti descritti qui sono applicabili anche a Active Record per database NoSQL.\n\n\nDichiarazione di classi di Active Record\n\n\nPer iniziare, dobbiamo dichiarare una classe Active Record estendendo \n yii \\ db \\ ActiveRecord \n.\n\n\nImpostare il nome della tabella\n\n\nPer impostazione predefinita ogni classe Active Record \u00e8 associata alla sua tabella di database. Il metodo \ntableName()\n restituisce il nome della tabella convertendo il nome della classe tramite \nyii \\ helpers \\ Inflector :: camel2id()\n. \u00c8 possibile sovrascrivere questo metodo se la tabella non viene denominata dopo questa convenzione.\n\n\nPu\u00f2 essere applicato anche un valore predefinito \ntablePrefix\n. Ad esempio se tablePrefix \u00e8 \ntbl_\n, \nCustomer\n diventa \ntbl_customer\n e \nOrderItem\n diventa \ntbl_order_item\n.\n\n\nSe il nome di una tabella \u00e8 dato come \n{{%TableName}}\n, allora il carattere percentuale \n%\n verr\u00e0 sostituito con il prefisso della tabella. Ad esempio, \n{{%post}}\n diventa \n{{tbl_post}}\n. Le parentesi attorno al nome della tabella vengono utilizzate per la citazione in una query SQL.\n\n\nNell'esempio seguente, dichiariamo una classe Active Record chiamata \nCustomer\n per la tabella \ncustomer\n del database.\n\n\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass Customer extends ActiveRecord{\n\n    const STATUS_INACTIVE = 0;\n    const STATUS_ACTIVE = 1;\n\n    /**\n     * @return string the name of the table associated with this ActiveRecord class.\n    */\n    public static function tableName(){\n\n        return '{{customer}}';\n    }\n}\n\n\n\nGli Active Record sono chiamati come \"modelli\"\n\n\nLe istanze di Active Record sono considerate come modelli. Per questo motivo, di solito mettiamo le classi di Active Record sotto il namespace \napp\\models\n (o altri namespace per mantenere le classi del modello).\n\n\nPoich\u00e9 \nyii \\ db \\ ActiveRecord\n si estende da \nyii \\ base \\ Model\n, eredita tutte le funzionalit\u00e0 del modello, come attributi, regole di convalida, serializzazione dei dati, ecc. \n\n\nConnessione al database\n\n\nPer impostazione predefinita, Active Record utilizza il componente db dell'applicazione come connessione DB per accedere e manipolare i dati del database. Come spiegato in Database Access Objects, puoi configurare il componente db nella configurazione dell'applicazione come mostrato di seguito,\n\n\nreturn [\n    'components' =\n [\n        'db' =\n [\n            'class' =\n 'yii\\db\\Connection',\n            'dsn' =\n 'mysql:host=localhost;dbname=testdb',\n            'username' =\n 'demo',\n            'password' =\n 'demo',\n        ],\n    ],\n];\n\n\n\nSe si desidera utilizzare una connessione al database diversa dal dbcomponente, \u00e8 necessario eseguire l'override del metodo \ngetDb()\n:\n\n\nclass Customer extends ActiveRecord{\n\n    // ...\n\n    public static function getDb(){\n\n        // use the \"db2\" application component\n        return \\Yii::$app-\ndb2;  \n    }   \n}\n\n\n\nDati nelle query\n\n\nDopo aver dichiarato una classe Active Record, \u00e8 possibile utilizzarla per eseguire query sui dati dalla tabella di database corrispondente. Il processo solitamente richiede i seguenti tre passaggi:\n\n\n\n\nCreare un nuovo oggetto query chiamando il metodo \nyii \\ db \\ ActiveRecord :: find()\n;\n\n\nCostruire l'oggetto query chiamando i metodi di costruzione delle query;\n\n\nChiama un metodo di query per recuperare i dati in termini di istanze di record attivo.\n\n\n\n\nCome puoi vedere, questo \u00e8 molto simile alla procedura con il generatore di query. L'unica differenza \u00e8 che anzich\u00e9 utilizzare l'operatore \nnew\n per creare un oggetto query, si chiama \nyii \\ db \\ ActiveRecord :: find()\n per restituire un nuovo oggetto query che \u00e8 di classe \nyii \\ db \\ ActiveQuery\n.\n\n\nDi seguito sono riportati alcuni esempi che mostrano come utilizzare la Query attiva per interrogare i dati:\n\n\n// return a single customer whose ID is 123\n// SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::find()\n    -\nwhere(['id' =\n 123])\n    -\none();\n\n// return all active customers and order them by their IDs\n// SELECT * FROM `customer` WHERE `status` = 1 ORDER BY `id`\n$customers = Customer::find()\n    -\nwhere(['status' =\n Customer::STATUS_ACTIVE])\n    -\norderBy('id')\n    -\nall();\n\n// return the number of active customers\n// SELECT COUNT(*) FROM `customer` WHERE `status` = 1\n$count = Customer::find()\n    -\nwhere(['status' =\n Customer::STATUS_ACTIVE])\n    -\ncount();\n\n// return all customers in an array indexed by customer IDs\n// SELECT * FROM `customer`\n$customers = Customer::find()\n    -\nindexBy('id')\n    -\nall();\n\n\n\nIn quanto spiegato sopra, \n$customer\n \u00e8 un oggetto della class \nCustomer\n mentre \n$customers\n \u00e8 una matrice degli oggetti  \nCustomer\n. Sono tutti popolati con i dati recuperati dalla tabella \ncustomer\n.\n\n\n\n\nInfo\n\n\nPoich\u00e9 \nyii \\ db \\ ActiveQuery\n si estende da \nyii \\ db \\ Query\n, \u00e8 possibile utilizzare tutti i metodi di creazione di query e i metodi di query come descritto nella sezione Query Builder.\n\n\n\n\nPoich\u00e9 \u00e8 un'attivit\u00e0 comune per eseguire una query in base ai valori delle chiavi primarie o a un insieme di valori di colonna, Yii fornisce due metodi di scelta rapida per questo scopo:\n\n\n\n\nyii \\ db \\ ActiveRecord :: findOne()\n: restituisce una singola istanza del record attivo popolata con la prima riga del risultato della query.\n\n\nyii \\ db \\ ActiveRecord :: findAll()\n: restituisce una matrice di istanze di record attivo popolate con tutti i risultati della query.\n\n\n\n\nEntrambi i metodi possono assumere uno dei seguenti formati di parametro:\n\n\n\n\nun valore scalare: il valore viene considerato come il valore della chiave primaria desiderato da cercare. Yii determiner\u00e0 automaticamente quale colonna \u00e8 la colonna della chiave primaria leggendo le informazioni sullo schema del database.\n\n\nuna matrice di valori scalari: la matrice viene considerata come i valori della chiave primaria desiderati da cercare.\n\n\nun array associativo: le chiavi sono nomi di colonne e i valori sono i corrispondenti valori di colonna desiderati da cercare. Si prega di fare riferimento al formato hash per maggiori dettagli.\n\n\n\n\nIl codice seguente mostra come utilizzare questi metodi:\n\n\n// returns a single customer whose ID is 123\n// SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::findOne(123);\n\n// returns customers whose ID is 100, 101, 123 or 124\n// SELECT * FROM `customer` WHERE `id` IN (100, 101, 123, 124)\n$customers = Customer::findAll([100, 101, 123, 124]);\n\n// returns an active customer whose ID is 123\n// SELECT * FROM `customer` WHERE `id` = 123 AND `status` = 1\n$customer = Customer::findOne([\n    'id' =\n 123,\n    'status' =\n Customer::STATUS_ACTIVE,\n]);\n\n// returns all inactive customers\n// SELECT * FROM `customer` WHERE `status` = 0\n$customers = Customer::findAll([\n    'status' =\n Customer::STATUS_INACTIVE,\n]);\n\n\n\n\n\nNota\n\n\nN\u00e9 \nyii \\ db \\ ActiveRecord :: findOne()\n n\u00e9 \nyii \\ db \\ ActiveQuery :: one()\n verranno aggiunti \nLIMIT 1\n all'istruzione SQL generata. Se la tua query potrebbe restituire molte righe di dati, dovresti chiamare il metodo \nlimit(1)\n per migliorare le prestazioni, ad es \nCustomer::find()-\nlimit(1)-\none()\n.\n\n\n\n\nOltre a utilizzare metodi di creazione di query, \u00e8 anche possibile scrivere SQL raw per eseguire query sui dati e popolare i risultati in oggetti Active Record. \u00c8 possibile farlo chiamando il metodo \nyii \\ db \\ ActiveRecord :: findBySql()\n:\n\n\n// returns all inactive customers\n$sql = 'SELECT * FROM customer WHERE status=:status';\n$customers = Customer::findBySql($sql, [':status' =\n Customer::STATUS_INACTIVE])-\nall();\n\n\n\nSi consiglia di non chiamare metodi di creazione di query aggiuntivi dopo aver chiamato \nfindBySql()\n poich\u00e9 verranno ignorati.\n\n\nAccesso ai dati\n\n\nCome indicato sopra, i dati richiamati dal database vengono popolati in istanze di Active Record e ogni riga del risultato della query corrisponde a una singola istanza dell'Active Record. \u00c8 possibile accedere ai valori della colonna accedendo agli attributi delle sue istanze, ad esempio,\n\n\n// \"id\" and \"email\" are the names of columns in the \"customer\" table\n$customer = Customer::findOne(123);\n$id = $customer-\nid;\n$email = $customer-\nemail;\n\n\n\n\n\nNota\n\n\nGli attributi dell'Active Record vengono denominati in base alla distinzione tra maiuscole e minuscole della tabella associata. Yii definisce automaticamente un attributo in Active Record per ogni colonna della tabella associata. NON si deve ridichiarare nessuno degli attributi.\n\n\n\n\nPoich\u00e9 gli attributi di Active Record prendono il nome da colonne di tabelle, \u00e8 possibile che si stia scrivendo codice PHP simile a \n$customer-\nfirst_name\n, che utilizza caratteri di sottolineatura per separare le parole nei nomi di attributi se le colonne della tabella vengono denominate in questo modo. Se sei preoccupato della coerenza dello stile del codice, dovresti rinominare le colonne della tabella di conseguenza (per usare \ncamelCase\n, ad esempio).\n\n\nTrasformazione dei dati\n\n\nAccade spesso che i dati inseriti e / o visualizzati siano in un formato diverso da quello utilizzato per la memorizzazione dei dati in un database. Ad esempio, nel database si memorizzano i compleanni dei clienti come timestamp UNIX (che per\u00f2 non \u00e8 un buon design), mentre nella maggior parte dei casi si desidera manipolare i compleanni come stringhe nel formato di 'YYYY/MM/DD'. Per raggiungere questo obiettivo, \u00e8 possibile definire i metodi di trasformazione dei dati nella Customer classe Active Record come segue:\n\n\nclass Customer extends ActiveRecord{\n\n    // ...\n\n    public function getBirthdayText(){\n\n        return date('Y/m/d', $this-\nbirthday);\n    }\n\n    public function setBirthdayText($value){\n\n        $this-\nbirthday = strtotime($value);\n    }\n}\n\n\n\nOra nel tuo codice PHP, invece di accedere a \n$customer-\nbirthday\n, accederai a \n$customer-\nbirthdayText\n, il che ti consentir\u00e0 di inserire e visualizzare i compleanni dei clienti nel formato di 'YYYY/MM/DD'.\n\n\n\n\nTip\n\n\nL'esempio sopra mostra un modo generico di trasformare i dati in diversi formati. Se stai lavorando con i valori di date, puoi utilizzare \nDateValidator\n e \nDatePicker\n, che sono pi\u00f9 facili da usare e pi\u00f9 potenti.\n\n\n\n\nRecupero dei dati nelle matrici\n\n\nMentre il recupero dei dati in termini di oggetti Active Record \u00e8 comodo e flessibile, non \u00e8 sempre consigliabile quando si deve riportare una grande quantit\u00e0 di dati a causa del grande ingombro di memoria. In questo caso, puoi recuperare i dati utilizzando matrici PHP chiamando il metodo \nasArray()\n prima di eseguire un metodo di query:\n\n\n// return all customers\n// each customer is returned as an associative array\n$customers = Customer::find()\n    -\nasArray()\n    -\nall();\n\n\n\n\n\nNota\n\n\nMentre questo metodo consente di risparmiare memoria e migliorare le prestazioni, \u00e8 pi\u00f9 vicino al livello di astrazione DB inferiore, e si perderanno la maggior parte delle funzionalit\u00e0 di Active Record. Una distinzione molto importante si trova nel tipo di dati dei valori delle colonne. Quando restituisci i dati nelle istanze di Active Record, i valori delle colonne verranno automaticamente tipizzati in base ai tipi di colonna effettivi; d'altra parte quando si restituiscono i dati nelle matrici, i valori delle colonne saranno stringhe (poich\u00e9 sono il risultato di PDO senza elaborazione), indipendentemente dai loro effettivi tipi di colonna.\n\n\n\n\nRecupero dei dati in lotti\n\n\nIn Query Builder, abbiamo spiegato che \u00e8 possibile utilizzare la query batch per ridurre al minimo l'utilizzo della memoria quando si esegue una query su una grande quantit\u00e0 di dati dal database. Puoi usare la stessa tecnica in Active Record. Per esempio,\n\n\n// fetch 10 customers at a time\nforeach (Customer::find()-\nbatch(10) as $customers) {\n    // $customers is an array of 10 or fewer Customer objects\n}\n\n// fetch 10 customers at a time and iterate them one by one\nforeach (Customer::find()-\neach(10) as $customer) {\n    // $customer is a Customer object\n}\n\n// batch query with eager loading\nforeach (Customer::find()-\nwith('orders')-\neach() as $customer) {\n    // $customer is a Customer object with the 'orders' relation populated\n}\n\n\n\nSalvataggio dei dati\n\n\nUsando Active Record, puoi facilmente salvare i dati nel database seguendo i seguenti passi:\n\n\n\n\nPreparare un'istanza dell'Active Record\n\n\nAssegnare nuovi valori agli attributi dell'Active Record\n\n\nChiamare \nyii \\ db \\ ActiveRecord :: save()\n per salvare i dati nel database.\n\n\n\n\nPer esempio,\n\n\n// insert a new row of data\n$customer = new Customer();\n$customer-\nname = 'James';\n$customer-\nemail = 'james@example.com';\n$customer-\nsave();\n\n// update an existing row of data\n$customer = Customer::findOne(123);\n$customer-\nemail = 'james@newexample.com';\n$customer-\nsave();\n\n\n\nIl metodo \nsave()\n pu\u00f2 inserire o aggiornare una riga di dati, a seconda dello stato dell'istanza dell'Active Record. Se l'istanza \u00e8 stata appena creata dall'operatore \nnew\n, la chiamata a \nsave()\n causer\u00e0 l'inserimento di una nuova riga; Se l'istanza \u00e8 il risultato di un metodo di query, la chiamata a \nsave()\n aggiorner\u00e0 la riga associata all'istanza.\n\n\n\u00c8 possibile differenziare i due stati di un'istanza di Active Record controllando il valore della propriet\u00e0 \nyii \\ db \\ ActiveRecord :: isNewRecord\n. Questa propriet\u00e0 viene anche utilizzata internamente da \nsave()\n come segue:\n\n\npublic function save($runValidation = true, $attributeNames = null){\n\n    if ($this-\ngetIsNewRecord()) {\n        return $this-\ninsert($runValidation, $attributeNames);\n    } else {\n        return $this-\nupdate($runValidation, $attributeNames) !== false;\n    }\n}\n\n\n\n\n\nTip\n\n\nPuoi chiamare i metodi \ninsert()\n o \nupdate()\n direttamente per inserire o aggiornare una riga.\n\n\n\n\nConvalida dei dati\n\n\nPoich\u00e9 \nyii \\ db \\ ActiveRecord\n si estende da \nyii \\ base \\ Model\n, condivide la stessa funzione di convalida dei dati . \u00c8 possibile dichiarare regole di convalida sovrascrivendo il metodo \nrules()\n ed eseguire la convalida dei dati chiamando il metodo \nvalidate()\n.\n\n\nQuando chiami \nsave()\n, per impostazione predefinita chiamer\u00e0 automaticamente \nvalidate()\n. Solo quando passa la convalida, in realt\u00e0 salver\u00e0 i dati; altrimenti verr\u00e0 semplicemente restituito falsee sar\u00e0 possibile controllare la propriet\u00e0 \nyii \\ db \\ ActiveRecord :: errors\n per recuperare i messaggi di errore di convalida.\n\n\n\n\nTip\n\n\nSe si \u00e8 certi che i dati non necessitano di convalida (ad esempio, i dati provengono da fonti attendibili), \u00e8 possibile chiamare \nsave\n (false) per saltare la convalida.\n\n\n\n\nAssegnazione massiccia\n\n\nCome i modelli normali , anche le istanze di Active Record godono della massiccia funzione di assegnazione. Utilizzando questa funzione, \u00e8 possibile assegnare valori a pi\u00f9 attributi di un'istanza di Active Record in una singola istruzione PHP, come mostrato di seguito. Ricorda che solo gli attributi sicuri possono essere assegnati in modo massiccio, per\u00f2.\n\n\n$values = [\n    'name' =\n 'James',\n    'email' =\n 'james@example.com',\n];\n\n$customer = new Customer();\n\n$customer-\nattributes = $values;\n$customer-\nsave();\n\n\n\nAggiornamento dei contatori\n\n\n\u00c8 un'attivit\u00e0 comune incrementare o decrementare una colonna in una tabella di database. Chiamiamo queste colonne \"counter columns\". \u00c8 possibile utilizzare \nupdateCounters()\n per aggiornare una o pi\u00f9 colonne contatore. Per esempio,\n\n\n$post = Post::findOne(100);\n\n// UPDATE `post` SET `view_count` = `view_count` + 1 WHERE `id` = 100\n$post-\nupdateCounters(['view_count' =\n 1]);\n\n\n\n\n\nNota\n\n\nSe si utilizza \nyii \\ db \\ ActiveRecord :: save()\n per aggiornare una colonna contatore, si potrebbe finire con un risultato inaccurato, poich\u00e9 \u00e8 probabile che lo stesso contatore venga salvato da pi\u00f9 richieste che leggono e scrivono lo stesso valore contatore.\n\n\n\n\nAttributi dirty (sporchi)\n\n\nQuando si chiama il metodo \nsave()\n per salvare un'istanza dell'Active Record, vengono salvati solo gli attributi dirty. Un attributo \u00e8 considerato sporco se il suo valore \u00e8 stato modificato poich\u00e9 \u00e8 stato caricato dal DB o salvato in DB pi\u00f9 recentemente. Si noti che la convalida dei dati verr\u00e0 eseguita indipendentemente dal fatto che l'istanza dell'Active Record abbia o meno attributi sporchi.\n\n\nL'Active Record mantiene automaticamente l'elenco degli attributi dirty. Lo fa mantenendo una versione precedente dei valori degli attributi e confrontandoli con l'ultima. \u00c8 possibile chiamare \nyii \\ db \\ ActiveRecord :: getDirtyAttributes()\n per ottenere gli attributi attualmente sporchi. Puoi anche chiamare \nyii \\ db \\ ActiveRecord :: markAttributeDirty()\n per contrassegnare esplicitamente un attributo come dirty.\n\n\nSe sei interessato ai valori degli attributi prima della loro modifica pi\u00f9 recente, puoi chiamare i metodi \ngetOldAttributes()\n o \ngetOldAttribute()\n.\n\n\n\n\nNota\n\n\nIl confronto tra vecchi e nuovi valori verr\u00e0 eseguito utilizzando l'operatore \n===\n in modo che un valore venga considerato sporco anche se ha lo stesso valore ma un tipo diverso. Questo \u00e8 spesso il caso in cui il modello riceve input da moduli HTML in cui ogni valore \u00e8 rappresentato come una stringa. Per assicurare che il tipo corretto per esempio valori interi si pu\u00f2 applicare un filtro di convalida : \n['attributeName', 'filter', 'filter' =\n 'intval']\n. Funziona con tutte le funzioni di typecasting di PHP come \nintval()\n , \nfloatval()\n , \nboolval\n , ecc ...\n\n\n\n\nValori predefiniti di un attributo\n\n\nAlcune delle colonne della tabella possono avere valori predefiniti definiti nel database. A volte, \u00e8 possibile pre-compilare il modulo Web per un'istanza dell'Active Record con questi valori predefiniti. Per evitare di scrivere nuovamente gli stessi valori predefiniti, \u00e8 possibile chiamare \nloadDefaultValues \u200b()\n per popolare i valori predefiniti definiti dal DB negli attributi del record attivo corrispondente:\n\n\n$customer = new Customer();\n$customer-\nloadDefaultValues();\n// $customer-\nxyz will be assigned the default value declared when defining the \"xyz\" column\n\n\n\nAttributi Typecasting\n\n\nCompilando i risultati della query \nyii \\ db \\ ActiveRecord\n, viene eseguito un typecast automatico per i suoi valori di attributo, utilizzando le informazioni dallo schema della tabella del database. Ci\u00f2 consente ai dati recuperati dalla colonna della tabella dichiarata come numero intero di essere popolati nell'istanza dell'ActiveRecord con un valore PHP intero, booleano con booleano e cos\u00ec via. Tuttavia, il meccanismo di typecasting ha diverse limitazioni:\n\n\n\n\nI valori float non vengono convertiti e verranno rappresentati come stringhe, altrimenti potrebbero perdere precisione.\n\n\nLa conversione dei valori interi dipende dalla capacit\u00e0 intera del sistema operativo che si utilizza. In particolare: i valori della colonna dichiarata come \"intero senza segno\" o \"intero grande\" saranno convertiti in intero PHP solo con il sistema operativo a 64 bit, mentre su quelli a 32 bit saranno rappresentati come stringhe.\n\n\n\n\nSi noti che l'attributo \ntypecast\n viene eseguito solo durante il popolamento dell'istanza ActiveRecord dal risultato della query. Non esiste conversione automatica per i valori caricati dalla richiesta HTTP o impostati direttamente tramite l'accesso alla propriet\u00e0. Lo schema della tabella verr\u00e0 utilizzato anche durante la preparazione delle istruzioni SQL per il salvataggio dei dati di ActiveRecord, garantendo che i valori siano associati alla query con il tipo corretto. Tuttavia, i valori degli attributi dell'istanza di ActiveRecord non verranno convertiti durante il processo di salvataggio.\n\n\n\n\nTip\n\n\nE' possibile utilizzare \nyii \\ behaviors \\ AttributeTypecastBehavior\n per facilitare i valori degli attributi typecasting sulla convalida o il salvataggio di ActiveRecord.\n\n\n\n\nAggiornamento di pi\u00f9 righe\n\n\nI metodi descritti sopra funzionano tutti su singole istanze di Active Record, causando l'inserimento o l'aggiornamento di singole righe di tabella. Per aggiornare pi\u00f9 righe contemporaneamente, \u00e8 necessario chiamare il metodo \nupdateAll()\n , invece, che \u00e8 un metodo statico.\n\n\n// UPDATE `customer` SET `status` = 1 WHERE `email` LIKE `%@example.com%`\nCustomer::updateAll(['status' =\n Customer::STATUS_ACTIVE], ['like', 'email', '@example.com']);\n\n\n\nAllo stesso modo, puoi chiamare il metodo \nupdateAllCounters()\n per aggiornare le colonne contatore di pi\u00f9 righe contemporaneamente.\n\n\n// UPDATE `customer` SET `age` = `age` + 1\nCustomer::updateAllCounters(['age' =\n 1]);\n\n\n\nEliminazione dei dati\n\n\nPer eliminare una singola riga di dati, dobbiamo recuperare prima l'istanza dell'Active Record corrispondente a quella riga e quindi chiamare il metodo \nyii \\ db \\ ActiveRecord :: delete()\n.\n\n\n$customer = Customer::findOne(123);\n$customer-\ndelete();\n\n\n\n\u00c8 possibile chiamare \nyii \\ db \\ ActiveRecord :: deleteAll()\n per eliminare pi\u00f9 o tutte le righe di dati. Per esempio,\n\n\nCustomer::deleteAll(['status' =\n Customer::STATUS_INACTIVE]);\n\n\n\n\n\nWarning\n\n\nFai molta attenzione quando chiami \ndeleteAll()\n perch\u00e9 potrebbe cancellare completamente tutti i dati dalla tua tabella se commetti un errore nel specificare la condizione.\n\n\n\n\nCicli di vita dell'Active Record\n\n\n\u00c8 importante comprendere i cicli di vita dell'Active Record quando viene utilizzato per scopi diversi. Durante ciascun ciclo di vita, verr\u00e0 invocata una determinata sequenza di metodi e sar\u00e0 possibile ignorare questi metodi per ottenere la possibilit\u00e0 di personalizzare il ciclo di vita. Puoi anche rispondere a determinati eventi dell'Active Record attivati \u200b\u200bdurante un ciclo di vita per iniettare il tuo codice personalizzato. Questi eventi sono particolarmente utili quando si sviluppano comportamenti Active Record che devono personalizzare i cicli di vita di un determinato Active Record.\n\n\nDi seguito, riassumeremo i vari cicli di vita dell'Active Record e i metodi / eventi coinvolti nei cicli di vita.  \n\n\nNuovo ciclo di vita\n\n\nQuando si crea una nuova istanza Active Record tramite l'operatore \nnew\n, si verificher\u00e0 il seguente ciclo di vita:\n\n\n\n\nIstanziare il costruttre della classe.\n\n\ninit()\n: il metodo deve attivave un evento \nEVENT_INIT\n.\n\n\n\n\nInterrogare il ciclo di vita sui dati richiesti\n\n\nQuando si interrogano i dati tramite uno dei metodi di query , ciascun Active Record popolato di recente, subir\u00e0 il seguente ciclo di vita:\n\n\n\n\nIstanziare il costruttre della classe.\n\n\ninit()\n: il metodo deve attivare un evento \nEVENT_INIT\n.\n\n\nafterFind()\n: il metodo deve attivare un evento \nEVENT_AFTER_FIND\n.\n\n\n\n\nSalvataggio del ciclo di vita sui dati richiesti\n\n\nQuando si chiama il metodo \nsave()\n per inserire o aggiornare un'istanza di Active Record, si verificher\u00e0 il seguente ciclo di vita:\n\n\n\n\nSi verifica l'evento \nEVENT_BEFORE_VALIDATE\n. Se il metodo restituisce \nfalse\n o \nYii \\ base \\ ModelEvent :: $ isValid\n \u00e8 \nfalse\n, il resto dei passaggi verr\u00e0 ignorato.\n\n\nEsegue la convalida dei dati. Se la convalida dei dati fallisce, i passaggi successivi al passaggio 3 verranno saltati.\n\n\nSi verifica l'evento \nEVENT_AFTER_VALIDATE\n.\n\n\nSi verifica l'evento \nEVENT_BEFORE_INSERT\n o \nEVENT_BEFORE_UPDATE\n. Se il metodo restituisce \nfalse\n o \nYii \\ base \\ ModelEvent :: $ isValid\n \u00e8 \nfalse\n, il resto dei passaggi verr\u00e0 ignorato.\n\n\nEsegue l'inserimento o l'aggiornamento dei dati effettivi.\n\n\nSi verifica l'evento \nEVENT_AFTER_INSERT\n o \nEVENT_AFTER_UPDATE\n.\n\n\n\n\nEliminazione del ciclo di vita sui dati richiesti\n\n\nQuando si chiama il metodo \ndelete()\n per eliminare un'istanza di Active Record, si verificher\u00e0 il seguente ciclo di vita:\n\n\n\n\nSi verifica l'evento \nEVENT_BEFORE_DELETE\n. Se il metodo restituisce \nfalse\n o \nYii \\ base \\ ModelEvent :: $ isValid\n \u00e8 \nfalse\n, il resto dei passaggi verr\u00e0 ignorato.\n\n\nEsegue la cancellazione effettiva dei dati.\n\n\nSi verifica l'evento \nEVENT_AFTER_DELETE\n.\n\n\n\n\n\n\nWarning\n\n\nLa chiamata a uno dei seguenti metodi NON avvier\u00e0 nessuno dei suddetti cicli di vita perch\u00e9 funzionano direttamente sul database e non su base record:\n\n\n- ***Yii \\ db \\ ActiveRecord :: updateAll()***\n- ***Yii \\ db \\ ActiveRecord :: CancTutti()***\n- ***Yii \\ db \\ ActiveRecord :: updateCounters()***\n- ***Yii \\ db \\ ActiveRecord :: updateAllCounters()***\n\n\n\n\n\nRefresh del ciclo di vita sui dati richiesti\n\n\nQuando si chiama il metodo \nrefresh()\n per aggiornare un'istanza dell'Active Record, l' evento \nEVENT_AFTER_REFRESH\n viene attivato se l'aggiornamento ha esito positivo e il metodo restituisce \ntrue\n.\n\n\nLavorare con le transazioni\n\n\nEsistono due modi per utilizzare le transazioni mentre si lavora con l'Active Record.\n\n\nIl primo modo \u00e8 di includere esplicitamente le chiamate al metodo Active Record in un blocco transazionale, come mostrato di seguito,\n\n\n$customer = Customer::findOne(123);\n\nCustomer::getDb()-\ntransaction(function($db) use ($customer) {\n    $customer-\nid = 200;\n    $customer-\nsave();\n    // ...other DB operations...\n});\n\n// or alternatively\n\n$transaction = Customer::getDb()-\nbeginTransaction();\ntry {\n    $customer-\nid = 200;\n    $customer-\nsave();\n    // ...other DB operations...\n    $transaction-\ncommit();\n} catch(\\Exception $e) {\n    $transaction-\nrollBack();\n    throw $e;\n} catch(\\Throwable $e) {\n    $transaction-\nrollBack();\n    throw $e;\n}\n\n\n\n\n\nWarning\n\n\nNel codice precedente abbiamo due blocchi di try - catch per la compatibilit\u00e0 con PHP 5.x e PHP 7.x. \n\\Exception\n implementa l'interfaccia  \n\\Throwable\n da PHP 7.0, quindi puoi saltare la parte \n\\Exceptions\n e la tua app utilizza solo PHP 7.0 e versioni successive.\n\n\n\n\nIl secondo modo \u00e8 elencare le operazioni DB che richiedono il supporto transazionale nel metodo \nyii \\ db \\ ActiveRecord :: transactions()\n. Per esempio,\n\n\nclass Customer extends ActiveRecord{\n\n    public function transactions(){\n\n        return [\n            'admin' =\n self::OP_INSERT,\n            'api' =\n self::OP_INSERT | self::OP_UPDATE | self::OP_DELETE,\n            // the above is equivalent to the following:\n            // 'api' =\n self::OP_ALL,\n        ];\n    }\n}\n\n\n\nIl metodo \nyii \\ db \\ ActiveRecord :: transactions()\n dovrebbe restituire un array le cui chiavi sono nomi di scenario e i valori sono le operazioni corrispondenti che devono essere racchiuse tra le transazioni. \u00c8 necessario utilizzare le seguenti costanti per fare riferimento a diverse operazioni DB:\n\n\n\n\nOP_INSERT\n: operazione di inserimento eseguita dal metodo \ninsert()\n;\n\n\nOP_UPDATE\n: operazione di aggiornamento eseguita dal metodo \nupdate()\n;\n\n\nOP_DELETE\n: operazione di cancellazione eseguita dal metodo \ndelete()\n.\n\n\n\n\nGli operatori \n|\n vengono usati per concatenare le costanti sopra indicate e anche per indicare pi\u00f9 operazioni. \u00c8 inoltre possibile utilizzare la costante di scelta rapida \nOP_ALL\n per fare riferimento a tutte e tre le operazioni precedenti.\n\n\nLe transazioni create utilizzando questo metodo verranno avviate prima di chiamare \nbeforeSave()\n e verranno eseguite dopo l'esecuzione di \nafterSave()\n.\n\n\nOptimistic Locks\n\n\nIl blocco ottimistico ( o optimistic locks ) \u00e8 un modo per prevenire i conflitti che possono verificarsi quando una singola riga di dati viene aggiornata da pi\u00f9 utenti. Ad esempio, sia l'utente A che l'utente B stanno modificando lo stesso articolo wiki allo stesso tempo. Dopo che l'utente A ha salvato le sue modifiche, l'utente B fa clic sul pulsante \"Salva\" nel tentativo di salvare anche le sue modifiche. Poich\u00e9 l'utente B stava effettivamente lavorando su una versione obsoleta dell'articolo, sarebbe auspicabile avere un modo per impedirgli di salvare l'articolo e mostrargli un messaggio di suggerimento.\n\n\nL'optimistic locks risolve il problema precedente utilizzando una colonna per registrare il numero di versione di ogni riga. Quando una riga viene salvata con un numero di versione obsoleto, verr\u00e0 generata un'eccezione \nyii \\ db \\ StaleObjectException\n, che impedisce il salvataggio della riga. L'optimistic locks \u00e8 supportato solo quando si aggiorna o si elimina una riga di dati esistente utilizzando \nyii \\ db \\ ActiveRecord :: update()\n o \nyii \\ db \\ ActiveRecord :: delete()\n.\n\n\nPer utilizzarel'optimistic locks dobbiamo:\n\n\n\n\nCreare una colonna nella tabella DB associata alla classe dell'Active Record, per memorizzare il numero di versione di ogni riga. La colonna dovrebbe essere di tipo \"big integer\" (in MySQL sarebbe \nBIGINT DEFAULT 0\n).\n\n\nSostituire il metodo \nyii \\ db \\ ActiveRecord :: optimisticLock()\n per restituire il nome di questa colonna.\n\n\nNel modulo Web che accetta gli input dell'utente, aggiungere un campo nascosto per memorizzare il numero di versione corrente della riga in aggiornamento. Assicurati che l'attributo della versione contenga regole di convalida dell'input e convalidi correttamente.\n\n\nNell'azione del controller che aggiorna la riga utilizzando l'Active Record, prova a rilevare l' eccezione \nyii \\ db \\ StaleObjectException\n. Implementare la logica aziendale necessaria (ad esempio unire le modifiche, richiamando i dati staled) per risolvere il conflitto.\n\n\n\n\nAd esempio, supponi che la colonna della versione sia nominata come \nversion\n. \u00c8 possibile implementare il blocco ottimistico con il codice come il seguente.\n\n\n// ------ view code -------\n\nuse yii\\helpers\\Html;\n\n// ...other input fields\necho Html::activeHiddenInput($model, 'version');\n\n\n// ------ controller code -------\n\nuse yii\\db\\StaleObjectException;\n\npublic function actionUpdate($id){\n\n    $model = $this-\nfindModel($id);\n\n    try {\n        if ($model-\nload(Yii::$app-\nrequest-\npost()) \n $model-\nsave()) {\n            return $this-\nredirect(['view', 'id' =\n $model-\nid]);\n        } else {\n            return $this-\nrender('update', [\n                'model' =\n $model,\n            ]);\n        }\n    } catch (StaleObjectException $e) {\n        // logic to resolve the conflict\n    }\n}\n\n\n\nLavorare con i dati relazionali\n\n\nOltre a lavorare con le singole tabelle del database, l'Active Record \u00e8 anche in grado di riunire i dati correlati, rendendoli facilmente accessibili attraverso i dati primari. Ad esempio, i dati del cliente sono correlati ai dati dell'ordine poich\u00e9 un cliente potrebbe aver effettuato uno o pi\u00f9 ordini. Con un'adeguata dichiarazione di questa relazione, sarete in grado di accedere alle informazioni sull'ordine di un cliente utilizzando l'espressione \n$customer-\norders\n che restituisce le informazioni sull'ordine del cliente in termini di una serie di instanze \nOrder\n dell'Active Record.\n\n\nDichiarare le relazioni\n\n\nPer lavorare con i dati relazionali utilizzando l'Active Record, \u00e8 necessario innanzitutto dichiarare le relazioni nelle classi dell'Active Record. Il compito \u00e8 semplice come dichiarare un metodo di relazione per ogni relazione interessata, come il seguente,\n\n\nclass Customer extends ActiveRecord{\n\n    // ...\n\n    public function getOrders(){\n\n        return $this-\nhasMany(Order::className(), ['customer_id' =\n 'id']);\n    }\n}\n\nclass Order extends ActiveRecord{\n\n    // ...\n\n    public function getCustomer(){\n\n        return $this-\nhasOne(Customer::className(), ['id' =\n 'customer_id']);\n    }\n}\n\n\n\nNel codice precedente, abbiamo dichiarato una relazione \norders\n per la classe \nCustomer\n e una relazione \ncustomer\n per la classe \nOrder\n.\n\n\nOgni metodo di relazione deve essere nominato come \ngetXyz\n. Chiamiamo \nxyz\n(la prima lettera \u00e8 in minuscolo) il nome della relazione. Nota che i nomi delle relazioni sono case sensitive .\n\n\nDurante la dichiarazione di una relazione, \u00e8 necessario specificare le seguenti informazioni:\n\n\n\n\nla molteplicit\u00e0 della relazione: specificata chiamando i metodi \nhasMany()\n o \nhasOne()\n. Nell'esempio sopra puoi leggere facilmente nelle dichiarazioni di relazione che un cliente ha molti ordini mentre un ordine ha un solo cliente.\n\n\nil nome della classe Active Record correlata: specificato come primo parametro su \nhasMany()\n o \nhasOne()\n. Si consiglia di chiamare \nXyz::className()\n per ottenere la stringa del nome della classe in modo da poter ricevere il supporto per il completamento automatico IDE e il rilevamento degli errori in fase di compilazione.\n\n\nil collegamento tra i due tipi di dati: specifica le colonne attraverso le quali i due tipi di dati sono correlati. I valori dell'array sono le colonne dei dati primari (rappresentati dalla classe Active Record che stai dichiarando nelle relazioni), mentre le chiavi dell'array sono le colonne dei dati correlati.\n\n\n\n\nUna regola facile da ricordare \u00e8, come vedi nell'esempio sopra, che scrivi la colonna che appartiene al relativo Active Record direttamente accanto ad essa. Vedi l\u00ec che \ncustomer_id\n \u00e8 una propriet\u00e0 di \nOrder\n ed \nid\n \u00e8 una propriet\u00e0 di \nCustomer\n.\n\n\nAccesso ai dati relazionali\n\n\nDopo aver dichiarato le relazioni, puoi accedere ai dati relazionali attraverso i loro nomi. Questo \u00e8 come accedere a una propriet\u00e0 dell'oggetto definita dal metodo di una relazione. Per questo motivo, lo chiamiamo \"propriet\u00e0 relazionale\". Per esempio,\n\n\n// SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::findOne(123);\n\n// SELECT * FROM `order` WHERE `customer_id` = 123\n// $orders is an array of Order objects\n$orders = $customer-\norders;\n\n\n\n\n\nInfo\n\n\nQuando dichiari una relazione denominata \nxyz\n tramite un metodo getter \ngetXyz()\n, sarai in grado di accedere \nxyz\n come una propriet\u00e0 dell'oggetto . Si noti che il nome \u00e8 case sensitive.\n\n\n\n\nSe una relazione \u00e8 dichiarata con \nhasMany()\n, l'accesso a questa propriet\u00e0 di relazione restituir\u00e0 una matrice delle istanze relative all'Active Record;se una relazione viene dichiarata con il metodo \nhasOne()\n, l'accesso alla propriet\u00e0 della relazione restituir\u00e0 l'istanza relativa all'Active Record o  valore \nnull\n se non viene trovato alcun dato correlato.\n\n\nQuando si accede a una propriet\u00e0 di relazione per la prima volta, verr\u00e0 eseguita un'istruzione SQL, come mostrato nell'esempio precedente. Se si accede nuovamente alla stessa propriet\u00e0, il risultato precedente verr\u00e0 restituito senza rieseguire l'istruzione SQL. Per forzare la ri-esecuzione dell'istruzione SQL, \u00e8 necessario eliminare la propriet\u00e0: \nunset($customer-\norders)\n.\n\n\n\n\nNota\n\n\nSebbene questo concetto sia simile alla funzione della propriet\u00e0 dell'oggetto, esiste una differenza importante. Per le normali propriet\u00e0 il valore della propriet\u00e0 \u00e8 dello stesso tipo del metodo getter definitivo. Un metodo di relazione tuttavia restituisce un'istanza \nyii \\ db \\ ActiveQuer\n, mentre l'accesso a una propriet\u00e0 di relazione restituir\u00e0 un'istanza \nyii \\ db \\ ActiveRecord\n o una matrice di questi.\n\n\n$customer-\norders; // is an array of \nOrder\n objects\n$customer-\ngetOrders(); // returns an ActiveQuery instance\n\n\n\n\nQuesto \u00e8 utile per creare query personalizzate, come descritto nella prossima sezione.\n\n\nQuery con relazioni dinamiche\n\n\nPoich\u00e9 un metodo di relazione restituisce un'istanza di \nyii \\ db \\ ActiveQuery\n, \u00e8 possibile creare ulteriormente questa query utilizzando i metodi di creazione di query prima di eseguire la query DB. Per esempio,\n\n\n$customer = Customer::findOne(123);\n\n// SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal` \n 200 ORDER BY `id`\n$orders = $customer-\ngetOrders()\n    -\nwhere(['\n', 'subtotal', 200])\n    -\norderBy('id')\n    -\nall();\n\n\n\nOgni volta che si esegue una query relazionale dinamica tramite un metodo di relazione, verr\u00e0 eseguita un'istruzione SQL, anche se prima veniva eseguita la stessa query relazionale dinamica.\n\n\nA volte potresti persino voler parametrizzare una dichiarazione di relazione in modo da poter eseguire pi\u00f9 facilmente query relazionali dinamiche. Ad esempio, puoi dichiarare una relazione \nbigOrders\n come segue,\n\n\nclass Customer extends ActiveRecord{\n\n    public function getBigOrders($threshold = 100){\n\n        return $this-\nhasMany(Order::className(), ['customer_id' =\n 'id'])\n            -\nwhere('subtotal \n :threshold', [':threshold' =\n $threshold])\n            -\norderBy('id');\n    }\n}\n\n\n\nQuindi sarai in grado di eseguire le seguenti query relazionali:\n\n\n// SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal` \n 200 ORDER BY `id`\n$orders = $customer-\ngetBigOrders(200)-\nall();\n\n// SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal` \n 100 ORDER BY `id`\n$orders = $customer-\nbigOrders;\n\n\n\nRelazioni tramite una Junction Table\n\n\nNella modellazione di database, quando la molteplicit\u00e0 tra due tabelle correlate \u00e8 molti-a-molti, viene generalmente introdotta una tabella di giunzione . Ad esempio, la order tabel e la item tabel possono essere correlate tramite una tabella di giunzione denominata \norder_item\n. Un ordine corrisponder\u00e0 quindi a pi\u00f9 articoli dell'ordine, mentre un articolo prodotto corrisponder\u00e0 anche a pi\u00f9 articoli dell'ordine.\n\n\nQuando si dichiarano tali relazioni, si pu\u00f2 chiamare \nvia()\n o \nviaTabella()\n per specificare la tabella di giunzione. La differenza tra \nvia()\n e \nviaTable()\n \u00e8 che il primo specifica la tabella di congiunzione in termini di un nome di relazione esistente, mentre il secondo utilizza direttamente la tabella di giunzione. Per esempio,\n\n\nclass Order extends ActiveRecord{\n\npublic function getItems(){\n\n        return $this-\nhasMany(Item::className(), ['id' =\n 'item_id'])\n            -\nviaTable('order_item', ['order_id' =\n 'id']);\n    }\n}\n\n\n\no in alternativa,\n\n\nclass Order extends ActiveRecord{\n\n    public function getOrderItems(){\n\n        return $this-\nhasMany(OrderItem::className(), ['order_id' =\n 'id']);\n    }\n\n    public function getItems(){\n\n        return $this-\nhasMany(Item::className(), ['id' =\n 'item_id'])\n            -\nvia('orderItems');\n    }\n}\n\n\n\nL'uso delle relazioni dichiarate con una tabella di giunzione \u00e8 uguale a quello delle relazioni normali. Per esempio,\n\n\n// SELECT * FROM `order` WHERE `id` = 100\n$order = Order::findOne(100);\n\n// SELECT * FROM `order_item` WHERE `order_id` = 100\n// SELECT * FROM `item` WHERE `item_id` IN (...)\n// returns an array of Item objects\n$items = $order-\nitems;\n\n\n\nConcatenare le definizioni delle relazioni tramite pi\u00f9 tabelle\n\n\n\u00c8 inoltre possibile definire le relazioni tramite pi\u00f9 tabelle concatenando le definizioni di relazione usando il metodo \nvia()\n. Considerando gli esempi precedenti, abbiamo classi \nCustomer\n, \nOrder\n e \nItem\n. Possiamo aggiungere una relazione alla classe \nCustomer\n che elenca tutti gli articoli da tutti gli ordini che hanno inserito e nominarla \ngetPurchasedItems()\n, il concatenamento delle relazioni \u00e8 mostrato nel seguente esempio di codice:\n\n\nclass Customer extends ActiveRecord{\n\n    // ...\n\n    public function getPurchasedItems(){\n\n        // customer's items, matching 'id' column of `Item` to 'item_id' in OrderItem\n        return $this-\nhasMany(Item::className(), ['id' =\n 'item_id'])\n                    -\nvia('orderItems');\n    }\n\n    public function getOrderItems(){\n\n        // customer's order items, matching 'id' column of `Order` to 'order_id' in OrderItem\n        return $this-\nhasMany(OrderItem::className(), ['order_id' =\n 'id'])\n                    -\nvia('orders');\n    }\n\n    public function getOrders(){\n\n        // same as above\n        return $this-\nhasMany(Order::className(), ['customer_id' =\n 'id']);\n    }\n}\n\n\n\nLazy Loading e Eager Loading\n\n\nIN precedenza, quando abbiamo parlato all'accesso ai dati relazionali, abbiamo spiegato che \u00e8 possibile accedere a una propriet\u00e0 di relazione di un'istanza dell'Active Record come l'accesso a una normale propriet\u00e0 dell'oggetto. Un'istruzione SQL verr\u00e0 eseguita solo quando si accede alla propriet\u00e0 della relazione la prima volta. Chiamiamo questo tipo di dati relazionali che accedono al metodo di \"caricamento lazy\". Per esempio,\n\n\n// SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::findOne(123);\n\n// SELECT * FROM `order` WHERE `customer_id` = 123\n$orders = $customer-\norders;\n\n// no SQL executed\n$orders2 = $customer-\norders;\n\n\n\nIl caricamento lento \u00e8 molto comodo da usare. Tuttavia, potrebbe verificarsi un problema di prestazioni quando \u00e8 necessario accedere alla stessa propriet\u00e0 di relazione in pi\u00f9 istanze dell'Active Record. Considera il seguente esempio di codice. Quante istruzioni SQL saranno eseguite?\n\n\n// SELECT * FROM `customer` LIMIT 100\n$customers = Customer::find()-\nlimit(100)-\nall();\n\nforeach ($customers as $customer) {\n    // SELECT * FROM `order` WHERE `customer_id` = ...\n    $orders = $customer-\norders;\n}\n\n\n\nCome puoi vedere dal commento del codice sopra, ci sono 101 istruzioni SQL in esecuzione! Questo perch\u00e9 ogni volta che si accede alla propriet\u00e0 di relazione \norders\n di un oggetto \nCustomer\n diverso nel ciclo for, verr\u00e0 eseguita un'istruzione SQL.\n\n\nPer risolvere questo problema di prestazioni, \u00e8 possibile utilizzare il cosiddetto \"Eager Loading\" come mostrato di seguito,\n\n\n// SELECT * FROM `customer` LIMIT 100;\n// SELECT * FROM `orders` WHERE `customer_id` IN (...)\n$customers = Customer::find()\n    -\nwith('orders')\n    -\nlimit(100)\n    -\nall();\n\nforeach ($customers as $customer) {\n    // no SQL executed\n    $orders = $customer-\norders;\n}\n\n\n\nChiamando \nyii \\ db \\ ActiveQuery :: with()\n, si istruisce l'Active Record per riportare gli ordini per i primi 100 clienti in una singola istruzione SQL. Di conseguenza, riduci il numero delle istruzioni SQL eseguite da 101 a 2!\n\n\nPuoi caricare avidamente una o pi\u00f9 relazioni. Puoi anche caricare avidamente relazioni nidificate. Una relazione nidificata \u00e8 una relazione dichiarata all'interno di una classe Active Record correlata. Ad esempio, \nCustomer\n \u00e8 correlato con \nOrder\n attraverso la relazione \norders\n ed \nOrder\n \u00e8 correlato con \nItem\n attraverso la relazione \nitems\n. Quando si esegue una query per \nCustomer\n, \u00e8 possibile caricare \nitems\n con impazienza utilizzando la notazione della relazione nidificata \norders.items\n.\n\n\nIl seguente codice mostra l'uso differente di \nwith()\n. Assumiamo che la classe \nCustomer\n abbia due relazioni \norders\n e \ncountry\n, mentre la classe \nOrder\n ha una relazione \nitems\n.\n\n\n// eager loading both \"orders\" and \"country\"\n$customers = Customer::find()-\nwith('orders', 'country')-\nall();\n// equivalent to the array syntax below\n$customers = Customer::find()-\nwith(['orders', 'country'])-\nall();\n// no SQL executed \n$orders= $customers[0]-\norders;\n// no SQL executed \n$country = $customers[0]-\ncountry;\n\n// eager loading \"orders\" and the nested relation \"orders.items\"\n$customers = Customer::find()-\nwith('orders.items')-\nall();\n// access the items of the first order of the first customer\n// no SQL executed\n$items = $customers[0]-\norders[0]-\nitems;\n\n\n\nPuoi caricare le relazioni in modo eagerly in modo annidato, come ad esempio \na.b.c.d\n. Cio\u00e8, quando si chiama \nwith()\n utilizzando \na.b.c.d\n, avrai un caricamento lento come segue: \na\n, \na.b\n, \na.b.c\n e \na.b.c.d\n.\n\n\n\n\nInfo\n\n\nIn generale, quando si caricano in modo \"eagerly (aviademnte) le \nN\n relazioni tra le quali le \nM\n relazioni vengono definite con una tabella di giunzione, \nN+M+1\n verr\u00e0 eseguito un numero totale di istruzioni SQL. Si noti che una relazione nidificata \na.b.c.d\n conta come 4 relazioni.\n\n\n\n\nQuando si carica in modo eagerly una relazione, \u00e8 possibile personalizzare la query relazionale corrispondente utilizzando una funzione anonima. Per esempio,\n\n\n// find customers and bring back together their country and active orders\n// SELECT * FROM `customer`\n// SELECT * FROM `country` WHERE `id` IN (...)\n// SELECT * FROM `order` WHERE `customer_id` IN (...) AND `status` = 1\n$customers = Customer::find()-\nwith([\n    'country',\n    'orders' =\n function ($query) {\n        $query-\nandWhere(['status' =\n Order::STATUS_ACTIVE]);\n    },\n])-\nall();\n\n\n\nQuando si personalizza la query relazionale per una relazione, \u00e8 necessario specificare il nome della relazione come chiave di array e utilizzare una funzione anonima come valore dell'array corrispondente. La funzione anonima ricever\u00e0 un parametro \n$query\n che rappresenta l'oggetto \nyii \\ db \\ ActiveQuery\n utilizzato per eseguire la query relazionale per la relazione. Nell'esempio di codice sopra, stiamo modificando la query relazionale aggiungendo una condizione aggiuntiva sullo stato dell'ordine.\n\n\n\n\nNota\n\n\nSe viene chiamato il metodo \nselect()\n, dovete assicurarvi che le colonne referenziate nelle dichiarazioni di relazione siano selezionate. In caso contrario, i relativi modelli potrebbero non essere caricati correttamente. Per esempio,\n\n\n$orders = Order::find()-\nselect(['id', 'amount'])-\nwith('customer')-\nall();\n// $orders[0]-\ncustomer is always `null`. To fix the problem, you should do the following:\n$orders = Order::find()-\nselect(['id', 'amount', 'customer_id'])-\nwith('customer')-\nall();\n\n\n\n\n\nJoining with relations\n\n\n\n\nNota\n\n\nIl contenuto descritto in questa sottosezione \u00e8 applicabile solo ai database relazionali, come MySQL, PostgreSQL, ecc.\n\n\n\n\nLe query relazionalali che abbiamo descritto finora fanno riferimento solo alle colonne della tabella principale quando si esegue una query per i dati primari. In realt\u00e0 spesso \u00e8 necessario fare riferimento alle colonne nelle tabelle correlate. Ad esempio, potremmo voler riportare i clienti che hanno almeno un ordine attivo. Per risolvere questo problema, possiamo creare una query di join come la seguente:\n\n\n// SELECT `customer`.* FROM `customer`\n// LEFT JOIN `order` ON `order`.`customer_id` = `customer`.`id`\n// WHERE `order`.`status` = 1\n// \n// SELECT * FROM `order` WHERE `customer_id` IN (...)\n$customers = Customer::find()\n    -\nselect('customer.*')\n    -\nleftJoin('order', '`order`.`customer_id` = `customer`.`id`')\n    -\nwhere(['order.status' =\n Order::STATUS_ACTIVE])\n    -\nwith('orders')\n    -\nall();\n\n\n\n\n\nNota\n\n\nE' importante togliere l'ambiguit\u00e0 ai nomi delle colonne quando si creano query relazionali che coinvolgono istruzioni SQL \nJOIN\n. Una pratica comune \u00e8 di anteporre i nomi delle colonne ai loro nomi di tabelle corrispondenti.\n\n\n\n\nTuttavia, un approccio migliore \u00e8 quello di sfruttare le dichiarazioni di relazione esistenti chiamando \nyii \\ db \\ ActiveQuery :: joinWith()\n:\n\n\n$customers = Customer::find()\n    -\njoinWith('orders')\n    -\nwhere(['order.status' =\n Order::STATUS_ACTIVE])\n    -\nall();\n\n\n\nEntrambi gli approcci eseguono lo stesso insieme di istruzioni SQL. Quest'ultimo approccio \u00e8 molto pi\u00f9 pulito e asciutto, per\u00f2.\n\n\nPer impostazione predefinita, nel metodo \njoinWith()\n verr\u00e0 utilizzato il comando \nLEFT JOIN\n per unirsi alla tabella primaria con la tabella correlata. \u00c8 possibile specificare un tipo di join diverso (ad esempio \nRIGHT JOIN\n) tramite il terzo parametro \n$joinType\n. Se il tipo di join desiderato \u00e8 \nINNER JOIN\n, puoi semplicemente chiamare il metodo \ninnerJoinWith()\n.\n\n\nChiamare \njoinWith()\n caricher\u00e0 avidamente i dati relativi per impostazione predefinita. Se non vuoi inserire i dati relativi, puoi specificare il suo secondo parametro \n$eagerLoading\n a \nfalse\n.\n\n\n\n\nNota\n\n\nAnche quando si utilizza \njoinWith()\n o \ninnerJoinWith()\n con l'eager loading attivato, i dati correlati non verranno popolati dal risultato della query \nJOIN\n. Quindi c'\u00e8 ancora una query aggiuntiva per ogni relazione unita.\n\n\n\n\nCome con il metodo \nwith()\n, puoi unirti a una o pi\u00f9 relazioni; puoi personalizzare le query di relazione al volo; puoi unirti a relazioni nidificate; e puoi mescolare l'uso di \nwith()\n e \njoinWith()\n. Per esempio,\n\n\n$customers = Customer::find()-\njoinWith([\n    'orders' =\n function ($query) {\n        $query-\nandWhere(['\n', 'subtotal', 100]);\n    },\n])-\nwith('country')\n    -\nall();\n\n\n\nA volte quando si uniscono due tabelle, potrebbe essere necessario specificare alcune condizioni aggiuntive nella parte \nON\n della query \nJOIN\n. Questo pu\u00f2 essere fatto chiamando il metodo \nyii \\ db \\ ActiveQuery :: onCondition()\n come il seguente:\n\n\n// SELECT `customer`.* FROM `customer`\n// LEFT JOIN `order` ON `order`.`customer_id` = `customer`.`id` AND `order`.`status` = 1 \n// \n// SELECT * FROM `order` WHERE `customer_id` IN (...)\n$customers = Customer::find()-\njoinWith([\n    'orders' =\n function ($query) {\n        $query-\nonCondition(['order.status' =\n Order::STATUS_ACTIVE]);\n    },\n])-\nall();\n\n\n\nQuesta query sopra riportata riporta tutti i clienti e per ogni cliente riporta tutti gli ordini attivi. Si noti che questo differisce dal nostro esempio precedente che riporta solo i clienti che hanno almeno un ordine attivo.\n\n\n\n\nInfo\n\n\nQuando \nyii \\ db \\ ActiveQuery\n viene specificato con una condizione tramite il metodo \nonCondition()\n, la condizione verr\u00e0 inserita nella parte \nON\n se la query implica una query \nJOIN\n. Se la query non coinvolge un \nJOIN\n, la condizione \non\n verr\u00e0 automaticamente aggiunta alla parte \nWHERE\n della query. Pertanto pu\u00f2 contenere solo condizioni comprese tra le colonne della tabella correlata.\n\n\n\n\nAlias della tabella nelle relazioni\n\n\nCome notato in precedenza, quando si utilizza \nJOIN\n in una query, \u00e8 necessario distinguere i nomi delle colonne. Per questo un alias \u00e8 definito per una tabella. Impostare un alias per la query relazionale sarebbe possibile personalizzando la query di relazione nel seguente modo:\n\n\n$query-\njoinWith([\n    'orders' =\n function ($q) {\n        $q-\nfrom(['o' =\n Order::tableName()]);\n    },\n])\n\n\n\nCi\u00f2 sembra molto complicato e comporta l'hardcoding del nome della tabella degli oggetti correlati o delle chiamate \nOrder::tableName()\n. Dalla versione 2.0.7, Yii fornisce una scorciatoia per questo. Ora puoi definire e utilizzare l'alias per la tabella delle relazioni come segue:\n\n\n// join the orders relation and sort the result by orders.id\n$query-\njoinWith(['orders o'])-\norderBy('o.id');\n\n\n\nLa sintassi precedente funziona per relazioni semplici. Se hai bisogno di un alias per una tabella intermedia quando ti unisci alle relazioni annidate [\n$query-\njoinWith(['orders.product'])\n], per esempio, puoi nidificare le chiamate \njoinWith\n come nell'esempio seguente:\n\n\n$query-\njoinWith(['orders o' =\n function($q) {\n        $q-\njoinWith('product p');\n    }])\n    -\nwhere('o.amount \n 100');\n\n\n\nRelazioni inverse\n\n\nLe dichiarazioni di relazione sono spesso reciproche tra due classi Active Record. Ad esempio, \nCustomer\n \u00e8 correlato a \nOrder\n tramite la relazione \norders\n ed \nOrder\n \u00e8 correlato a \nCustomer\n tramite la relazione \ncustomer\n.\n\n\nclass Customer extends ActiveRecord{\n    public function getOrders(){\n\n        return $this-\nhasMany(Order::className(), ['customer_id' =\n 'id']);\n    }\n}\n\nclass Order extends ActiveRecord{\n\n    public function getCustomer(){\n\n        return $this-\nhasOne(Customer::className(), ['id' =\n 'customer_id']);\n    }\n}\n\n\n\nOra considera il seguente pezzo di codice:\n\n\n// SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::findOne(123);\n\n// SELECT * FROM `order` WHERE `customer_id` = 123\n$order = $customer-\norders[0];\n\n// SELECT * FROM `customer` WHERE `id` = 123\n$customer2 = $order-\ncustomer;\n\n// displays \"not the same\"\necho $customer2 === $customer ? 'same' : 'not the same';\n\n\n\nA questo punto, penseremmo che \n$customer\n e \n$customer2\n siano uguali, ma non lo sono! In realt\u00e0 contengono gli stessi dati dei clienti, ma sono oggetti diversi. Durante l'accesso \n$order-\ncustomer\n, viene eseguita un'istruzione SQL aggiuntiva per popolare un nuovo oggetto \n$customer2\n.\n\n\nPer evitare l'esecuzione ridondante dell'ultima istruzione SQL nell'esempio precedente, dovremmo dire a Yii che \ncustomer\n \u00e8 una relazione inversa di \norders\n chiamando il metodo \ninverseOf()\n come mostrato di seguito:\n\n\nclass Customer extends ActiveRecord{\n\n    public function getOrders(){\n\n        return $this-\nhasMany(Order::className(), ['customer_id' =\n 'id'])-\ninverseOf('customer');\n    }\n}\n\n\n\nCon questa dichiarazione di relazione modificata, avremo:\n\n\n// SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::findOne(123);\n\n// SELECT * FROM `order` WHERE `customer_id` = 123\n$order = $customer-\norders[0];\n\n// No SQL will be executed\n$customer2 = $order-\ncustomer;\n\n// displays \"same\"\necho $customer2 === $customer ? 'same' : 'not the same';\n\n\n\n\n\nNota\n\n\nLe relazioni inverse non possono essere definite relazioni che coinvolgono una junction table. Cio\u00e8, se una relazione \u00e8 definita con il metodo \nvia()\n o \nviaTable()\n, non c'\u00e8 bisogno di chiamare il metodo \ninverseOf()\n.\n\n\n\n\nSalvataggio delle relazioni\n\n\nQuando si lavora con dati relazionali, \u00e8 spesso necessario stabilire relazioni tra dati diversi o distruggere relazioni esistenti. Ci\u00f2 richiede l'impostazione di valori appropriati per le colonne che definiscono le relazioni. Usando Active Record, potresti finire per scrivere il codice come segue:\n\n\n$customer = Customer::findOne(123);\n$order = new Order();\n$order-\nsubtotal = 100;\n// ...\n\n// setting the attribute that defines the \"customer\" relation in Order\n$order-\ncustomer_id = $customer-\nid;\n$order-\nsave();\n\n\n\nActive Record fornisce il metodo \nlink()\n che consente di svolgere questo compito in modo pi\u00f9 efficace:\n\n\n$customer = Customer::findOne(123);\n$order = new Order();\n$order-\nsubtotal = 100;\n// ...\n\n$order-\nlink('customer', $customer);\n\n\n\nIl metodo \nlink()\n richiede di specificare il nome della relazione e l'istanza dell'Active Record di destinazione con cui deve essere stabilita la relazione. Il metodo modificher\u00e0 i valori degli attributi che collegano due istanze Active Record e li salvano nel database. Nell'esempio sopra, imposter\u00e0 l'attributo \ncustomer_id\n dell'istanza \nOrder\n come valore dell'attributio \nid\n dell'istanza \nCustomer\n e quindi lo salver\u00e0 nel database.\n\n\n\n\nNota\n\n\nNon \u00e8 possibile collegare due istanze Active Record appena create.\n\n\n\n\nIl vantaggio dell'uso del metodo \nlink()\n \u00e8 ancora pi\u00f9 evidente quando una relazione viene definita tramite una tabella di giunzione. Ad esempio, \u00e8 possibile utilizzare il codice seguente per collegare un'istanza \nOrder\n con un'istanza \nItem\n:\n\n\n$order-\nlink('items', $item);\n\n\n\nIl codice scritto sopra inserir\u00e0 automaticamente una riga nella tabella di giunzione \norder_item\n per mettere in relazione l'ordine con l'articolo.\n\n\n\n\nInfo\n\n\nIl metodo \nlink()\n NON esegue alcuna convalida dei dati durante il salvataggio dell'istanza Active Record interessata. \u00c8 tua responsabilit\u00e0 convalidare qualsiasi dato di input prima di chiamare questo metodo.\n\n\n\n\nL'operazione opposta a \nlink()\n \u00e8 \nunlink()\n che interrompe una relazione esistente tra due istanze Active Record. Per esempio,\n\n\n$customer = Customer::find()-\nwith('orders')-\nwhere(['id' =\n 123])-\none();\n$customer-\nunlink('orders', $customer-\norders[0]);\n\n\n\nPer impostazione predefinita, il metodo \nunlink()\n imposter\u00e0 i valori della chiave esterna che specificano la relazione esistente a \nnull\n. Tuttavia, \u00e8 possibile scegliere di eliminare la riga della tabella che contiene il valore della chiave esterna passando il parametro \n$delete\n con valore \ntrue\n al metodo.\n\n\nQuando una tabella di giunzione \u00e8 coinvolta in una relazione, la chiamata di \nunlink()\n provoca la cancellazione delle chiavi esterne nella tabella di giunzione o la cancellazione della riga corrispondente nella tabella di giuntura, se il valore di \n$delete\n \u00e8 \ntrue\n.\n\n\nRelazioni tra database\n\n\nActive Record consente di dichiarare le relazioni tra classi Active Record alimentate da diversi database. I database possono essere di tipi diversi (ad esempio MySQL e PostgreSQL, o MS SQL e MongoDB) e possono essere eseguiti su server diversi. \u00c8 possibile utilizzare la stessa sintassi per eseguire query relazionali. Per esempio,\n\n\n// Customer is associated with the \"customer\" table in a relational database (e.g. MySQL)\nclass Customer extends \\yii\\db\\ActiveRecord{\n\n    public static function tableName(){\n\n        return 'customer';\n    }\n\n    public function getComments(){\n\n        // a customer has many comments\n        return $this-\nhasMany(Comment::className(), ['customer_id' =\n 'id']);\n    }\n}\n\n// Comment is associated with the \"comment\" collection in a MongoDB database\nclass Comment extends \\yii\\mongodb\\ActiveRecord{\n\n    public static function collectionName(){\n\n        return 'comment';\n    }\n\n    public function getCustomer(){\n\n        // a comment has one customer\n        return $this-\nhasOne(Customer::className(), ['id' =\n 'customer_id']);\n    }\n}\n\n$customers = Customer::find()-\nwith('comments')-\nall();\n\n\n\n\u00c8 possibile utilizzare la maggior parte delle funzioni di query relazionali descritte in questa sezione.\n\n\n\n\nNota\n\n\nL'utilizzo del metodo \njoinWith()\n \u00e8 limitato ai database che consentono query \nJOIN\n tra database. Per questo motivo, non \u00e8 possibile utilizzare questo metodo nell'esempio precedente poich\u00e9 MongoDB non supporta la \nJOIN\n.\n\n\n\n\nPersonalizzazione delle classi di query\n\n\nPer impostazione predefinita, tutte le query degli Active Record sono supportate da \nyii \\ db \\ ActiveQuery\n. Per utilizzare una classe di query personalizzata in una classe Active Record, \u00e8 necessario eseguire l'override del metodo \nyii \\ db \\ ActiveRecord :: find()\n e restituire un'istanza della classe di query personalizzata. Per esempio,\n\n\n// file Comment.php\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass Comment extends ActiveRecord{\n\n    public static function find(){\n\n        return new CommentQuery(get_called_class());\n    }\n}\n\n\n\nOra, quando si esegue una query (ad esempio \nfind()\n, \nfindOne()\n) o si definisce una relazione (ad esempio \nhasOne()\n) la classe \nComment\n, si chiamer\u00e0 un'istanza \nCommentQuery\n anzich\u00e9 \nActiveQuery\n.\n\n\nOra devi definire la classe \nCommentQuery\n, che pu\u00f2 essere personalizzata in molti modi creativi per migliorare la tua esperienza nella creazione di query. Per esempio,\n\n\n// file CommentQuery.php\nnamespace app\\models;\n\nuse yii\\db\\ActiveQuery;\n\nclass CommentQuery extends ActiveQuery{\n\n    // conditions appended by default (can be skipped)\n    public function init(){\n\n        $this-\nandOnCondition(['deleted' =\n false]);\n        parent::init();\n    }\n\n    // ... add customized query methods here ...\n\n    public function active($state = true){\n\n        return $this-\nandOnCondition(['active' =\n $state]);\n    }\n}\n\n\n\n\n\nNota\n\n\nInvece di chiamare \nonCondition()\n, di solito si dovrebbe chiamare il metodo \nandOnCondition()\n o \norOnCondition()\n per aggiungere ulteriori condizioni al momento di definire nuovi metodi di costruzione di query in modo che le eventuali condizioni esistenti non vengono sovrascritti.\n\n\n\n\nQuesto ti permette di scrivere il codice di costruzione della query come il seguente:\n\n\n$comments = Comment::find()-\nactive()-\nall();\n$inactiveComments = Comment::find()-\nactive(false)-\nall();\n\n\n\n\n\nTip\n\n\nNei progetti di grandi dimensioni, si consiglia di utilizzare classi di query personalizzate per conservare la maggior parte del codice relativo alle query in modo che le classi Active Record possano essere mantenute pulite.\n\n\n\n\n\u00c8 inoltre possibile utilizzare i nuovi metodi di creazione di query quando si definiscono relazioni \nComment\n e si esegue una query relazionale:\n\n\nclass Customer extends \\yii\\db\\ActiveRecord{\n\n    public function getActiveComments(){\n\n        return $this-\nhasMany(Comment::className(), ['customer_id' =\n 'id'])-\nactive();\n    }\n}\n\n$customers = Customer::find()-\njoinWith('activeComments')-\nall();\n\n// or alternatively\nclass Customer extends \\yii\\db\\ActiveRecord{\n\n    public function getComments(){\n\n        return $this-\nhasMany(Comment::className(), ['customer_id' =\n 'id']);\n    }\n}\n\n$customers = Customer::find()-\njoinWith([\n    'comments' =\n function($q) {\n        $q-\nactive();\n    }\n])-\nall();\n\n\n\n\n\nInfo\n\n\nIn Yii 1.1, c'\u00e8 un concetto chiamato \nscope\n . L'ambito non \u00e8 pi\u00f9 supportato direttamente in Yii 2.0 e per raggiungere lo stesso obiettivo \u00e8 necessario utilizzare classi di query e metodi di query personalizzati.\n\n\n\n\nSelezione di campi aggiuntivi\n\n\nQuando l'istanza Active Record viene popolata dai risultati della query, i relativi attributi vengono riempiti dai corrispondenti valori di colonna dal set di dati ricevuti.\n\n\n\u00c8 possibile recuperare ulteriori colonne o valori dalla query e memorizzarli all'interno dell'Active Record. Ad esempio, supponiamo di avere una tabella di nome \nroom\n, che contiene informazioni sulle camere disponibili nell'hotel. Ogni camera memorizza le informazioni sulle sue dimensioni geometriche utilizzando i campi \nlength\n, \nwidth\n, \nheight\n. Immagina di dover recuperare l'elenco di tutte le stanze disponibili con il loro volume in ordine discendente. Quindi non puoi calcolare il volume usando PHP, perch\u00e9 abbiamo bisogno di ordinare i record in base al suo valore, ma tu vuoi anche che il volume possa essere visualizzato nella lista. Per raggiungere l'obiettivo, \u00e8 necessario dichiarare un campo aggiuntivo nella classe \nRoom\n Active Record,che memorizzer\u00e0 il valore \nvolume\n:\n\n\nclass Room extends \\yii\\db\\ActiveRecord\n{\n    public $volume;\n\n    // ...\n}\n\n\n\nQuindi \u00e8 necessario comporre una query, che calcola il volume della stanza ed esegue l'ordinamento:\n\n\n$rooms = Room::find()\n    -\nselect([\n        '{{room}}.*', // select all columns\n        '([[length]] * [[width]] * [[height]]) AS volume', // calculate a volume\n    ])\n    -\norderBy('volume DESC') // apply sort\n    -\nall();\n\nforeach ($rooms as $room) {\n    echo $room-\nvolume; // contains value calculated by SQL\n}\n\n\n\nLa possibilit\u00e0 di selezionare campi aggiuntivi pu\u00f2 essere eccezionalmente utile per le query di aggregazione. Supponiamo di dover visualizzare un elenco di clienti con il conteggio degli ordini effettuati. Prima di tutto, \u00e8 necessario dichiarare una classe \nCustomer\n con una relazione \norders\n e campo aggiuntivo per la memorizzazione dei conteggi:\n\n\nclass Customer extends \\yii\\db\\ ActiveRecord{\n\n    public $ordersCount;\n\n    // ...\n\n    public function getOrders(){\n\n        return $this-\nhasMany(Order::className(), ['customer_id' =\n 'id']);\n    }\n}\n\n\n\nQuindi puoi comporre una query, che unisce gli ordini e calcola il loro conteggio:\n\n\n$customers = Customer::find()\n    -\nselect([\n        '{{customer}}.*', // select all customer fields\n        'COUNT({{order}}.id) AS ordersCount' // calculate orders count\n    ])\n    -\njoinWith('orders') // ensure table junction\n    -\ngroupBy('{{customer}}.id') // group the result to ensure aggregation function works\n    -\nall();\n\n\n\nUno svantaggio dell'utilizzo di questo metodo sarebbe che, se l'informazione non \u00e8 caricata nella query SQL, deve essere calcolata separatamente. Pertanto, se hai trovato record particolari tramite query regolari senza istruzioni select extra, non sar\u00e0 in grado di restituire il valore effettivo per il campo extra. Lo stesso accadr\u00e0 per il record appena salvato.\n\n\n$room = new Room();\n$room-\nlength = 100;\n$room-\nwidth = 50;\n$room-\nheight = 2;\n\n\n\n$   room-\nvolume; // this value will be \nnull\n, since it was not declared yet\n\n\nUsando i metodi magici \n__get()\n e \n__set()\n possiamo emulare il comportamento di una propriet\u00e0:\n\n\nclass Room extends \\yii\\db\\ActiveRecord{\n\n    private $_volume;\n\n    public function setVolume($volume){\n\n        $this-\n_volume = (float) $volume;\n    }\n\n    public function getVolume(){\n\n        if (empty($this-\nlength) || empty($this-\nwidth) || empty($this-\nheight)) {\n            return null;\n        }\n\n        if ($this-\n_volume === null) {\n            $this-\nsetVolume(\n                $this-\nlength * $this-\nwidth * $this-\nheight\n            );\n        }\n\n        return $this-\n_volume;\n    }\n\n    // ...\n}\n\n\n\nQuando la query di selezione non fornisce il volume, il modello sar\u00e0 in grado di calcolarlo automaticamente utilizzando gli attributi del modello.\n\n\nPuoi anche calcolare i campi di aggregazione usando le relazioni definite:\n\n\nclass Customer extends \\yii\\db\\ActiveRecord{\n\n    private $_ordersCount;\n\n    public function setOrdersCount($count){\n\n        $this-\n_ordersCount = (int) $count;\n    }\n\n    public function getOrdersCount(){\n\n        if ($this-\nisNewRecord) {\n            return null; // this avoid calling a query searching for null primary keys\n        }\n\n        if ($this-\n_ordersCount === null) {\n            $this-\nsetOrdersCount($this-\ngetOrders()-\ncount()); // calculate aggregation on demand from relation\n        }\n\n        return $this-\n_ordersCount;\n    }\n\n    // ...\n\n    public function getOrders(){\n\n        return $this-\nhasMany(Order::className(), ['customer_id' =\n 'id']);\n    }\n}\n\n\n\nCon questo codice, nel caso in cui \n'ordersCount'\n sia presente nell'istruzione \n'select' - Customer::ordersCount\n, verr\u00e0 popolato dai risultati dell'interrogazione, altrimenti verr\u00e0 calcolato su richiesta utilizzando la relazione \nCustomer::orders\n.\n\n\nQuesto approccio pu\u00f2 essere utilizzato anche per la creazione delle scorciatoie per alcuni dati relazionali, in particolare per l'aggregazione. Per esempio:\n\n\nclass Customer extends \\yii\\db\\ActiveRecord{\n\n    /**\n    * Defines read-only virtual property for aggregation data.\n    */\n    public function getOrdersCount(){\n\n        if ($this-\nisNewRecord) {\n            return null; // this avoid calling a query searching for null primary keys\n        }\n\n        return empty($this-\nordersAggregation) ? 0 : $this-\nordersAggregation[0]['counted'];\n    }\n\n    /**\n    * Declares normal 'orders' relation.\n    */\n    public function getOrders(){\n\n        return $this-\nhasMany(Order::className(), ['customer_id' =\n 'id']);\n    }\n\n    /**\n    * Declares new relation based on 'orders', which provides aggregation.\n    */\n    public function getOrdersAggregation(){\n\n        return $this-\ngetOrders()\n            -\nselect(['customer_id', 'counted' =\n 'count(*)'])\n            -\ngroupBy('customer_id')\n            -\nasArray(true);\n    }\n\n    // ...\n}\n\nforeach (Customer::find()-\nwith('ordersAggregation')-\nall() as $customer) {\n    echo $customer-\nordersCount; // outputs aggregation data from relation without extra query due to eager loading\n}\n\n$customer = Customer::findOne($pk);\n$customer-\nordersCount; // output aggregation data from lazy loaded relation",
            "title": "Active Record"
        },
        {
            "location": "/working-with-databases/sub-active-record/#active-record",
            "text": "Active Record fornisce un'interfaccia orientata agli oggetti per l'accesso e la manipolazione dei dati memorizzati nei database. Una classe di Active Record \u00e8 associata a una tabella di database, un'istanza di Active Record corrisponde a una riga di tale tabella e un attributo di un'istanza di Active Record, rappresenta il valore di una determinata colonna in tale riga. Invece di scrivere istruzioni SQL non elaborate, \u00e8 necessario accedere agli attributi di Active Record e chiamare i metodi per accedere e manipolare i dati memorizzati nelle tabelle del database.  Ad esempio, supponiamo che  Customer  sia una classe Active Record associata alla tabella  customer  e  name  sia una colonna della tabelle  customer . Puoi scrivere il seguente codice per inserire una nuova riga nella tabelle  customer :  $customer = new Customer();\n$customer- name = 'Qiang';\n$customer- save();  Il codice precedente equivale a utilizzare la seguente istruzione SQL raw per MySQL, che \u00e8 meno intuitiva, pi\u00f9 incline agli errori e potrebbe persino presentare problemi di compatibilit\u00e0 se si utilizza un tipo diverso di database:  $db- createCommand('INSERT INTO `customer` (`name`) VALUES (:name)', [\n    ':name' =  'Qiang',\n])- execute();  Yii fornisce il supporto Active Record per i seguenti database relazionali:   MySQL 4.1 o versioni successive: tramite  yii \\ db \\ ActiveRecord  PostgreSQL 7.3 o successivo: tramite  yii \\ db \\ ActiveRecord  SQLite 2 e 3: tramite  yii \\ db \\ ActiveRecord  Microsoft SQL Server 2008 o versioni successive: tramite  yii \\ db \\ ActiveRecord  Oracle: tramite  yii \\ db \\ ActiveRecord  CUBRID 9.3 o successivo: tramite  yii \\ db \\ ActiveRecord  (si noti che a causa di un bug nell'estensione PDO cubrid, la citazione dei valori non funzioner\u00e0, quindi \u00e8 necessario CUBRID 9.3 come client e server)  Sfinge: tramite  yii \\ sphinx \\ ActiveRecord  , richiede l'estensione  yii2-sphinx  ElasticSearch: tramite  yii \\ elasticsearch \\ ActiveRecord , richiede l'estensione  yii2-elasticsearch   Inoltre, Yii supporta anche l'uso di Active Record con i seguenti database NoSQL:   Redis 2.6.12 o successivo: tramite  yii \\ redis \\ ActiveRecord , richiede l'estensione  yii2-redis  MongoDB 1.3.0 o versioni successive: tramite  yii \\ mongodb \\ ActiveRecord , richiede l'estensione  yii2-mongodb   In questo tutorial, descriveremo principalmente l'utilizzo di Active Record per i database relazionali. Tuttavia, la maggior parte dei contenuti descritti qui sono applicabili anche a Active Record per database NoSQL.  Dichiarazione di classi di Active Record  Per iniziare, dobbiamo dichiarare una classe Active Record estendendo   yii \\ db \\ ActiveRecord  .",
            "title": "Active Record"
        },
        {
            "location": "/working-with-databases/sub-active-record/#impostare-il-nome-della-tabella",
            "text": "Per impostazione predefinita ogni classe Active Record \u00e8 associata alla sua tabella di database. Il metodo  tableName()  restituisce il nome della tabella convertendo il nome della classe tramite  yii \\ helpers \\ Inflector :: camel2id() . \u00c8 possibile sovrascrivere questo metodo se la tabella non viene denominata dopo questa convenzione.  Pu\u00f2 essere applicato anche un valore predefinito  tablePrefix . Ad esempio se tablePrefix \u00e8  tbl_ ,  Customer  diventa  tbl_customer  e  OrderItem  diventa  tbl_order_item .  Se il nome di una tabella \u00e8 dato come  {{%TableName}} , allora il carattere percentuale  %  verr\u00e0 sostituito con il prefisso della tabella. Ad esempio,  {{%post}}  diventa  {{tbl_post}} . Le parentesi attorno al nome della tabella vengono utilizzate per la citazione in una query SQL.  Nell'esempio seguente, dichiariamo una classe Active Record chiamata  Customer  per la tabella  customer  del database.  namespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass Customer extends ActiveRecord{\n\n    const STATUS_INACTIVE = 0;\n    const STATUS_ACTIVE = 1;\n\n    /**\n     * @return string the name of the table associated with this ActiveRecord class.\n    */\n    public static function tableName(){\n\n        return '{{customer}}';\n    }\n}  Gli Active Record sono chiamati come \"modelli\"  Le istanze di Active Record sono considerate come modelli. Per questo motivo, di solito mettiamo le classi di Active Record sotto il namespace  app\\models  (o altri namespace per mantenere le classi del modello).  Poich\u00e9  yii \\ db \\ ActiveRecord  si estende da  yii \\ base \\ Model , eredita tutte le funzionalit\u00e0 del modello, come attributi, regole di convalida, serializzazione dei dati, ecc.",
            "title": "Impostare il nome della tabella"
        },
        {
            "location": "/working-with-databases/sub-active-record/#connessione-al-database",
            "text": "Per impostazione predefinita, Active Record utilizza il componente db dell'applicazione come connessione DB per accedere e manipolare i dati del database. Come spiegato in Database Access Objects, puoi configurare il componente db nella configurazione dell'applicazione come mostrato di seguito,  return [\n    'components' =  [\n        'db' =  [\n            'class' =  'yii\\db\\Connection',\n            'dsn' =  'mysql:host=localhost;dbname=testdb',\n            'username' =  'demo',\n            'password' =  'demo',\n        ],\n    ],\n];  Se si desidera utilizzare una connessione al database diversa dal dbcomponente, \u00e8 necessario eseguire l'override del metodo  getDb() :  class Customer extends ActiveRecord{\n\n    // ...\n\n    public static function getDb(){\n\n        // use the \"db2\" application component\n        return \\Yii::$app- db2;  \n    }   \n}",
            "title": "Connessione al database"
        },
        {
            "location": "/working-with-databases/sub-active-record/#dati-nelle-query",
            "text": "Dopo aver dichiarato una classe Active Record, \u00e8 possibile utilizzarla per eseguire query sui dati dalla tabella di database corrispondente. Il processo solitamente richiede i seguenti tre passaggi:   Creare un nuovo oggetto query chiamando il metodo  yii \\ db \\ ActiveRecord :: find() ;  Costruire l'oggetto query chiamando i metodi di costruzione delle query;  Chiama un metodo di query per recuperare i dati in termini di istanze di record attivo.   Come puoi vedere, questo \u00e8 molto simile alla procedura con il generatore di query. L'unica differenza \u00e8 che anzich\u00e9 utilizzare l'operatore  new  per creare un oggetto query, si chiama  yii \\ db \\ ActiveRecord :: find()  per restituire un nuovo oggetto query che \u00e8 di classe  yii \\ db \\ ActiveQuery .  Di seguito sono riportati alcuni esempi che mostrano come utilizzare la Query attiva per interrogare i dati:  // return a single customer whose ID is 123\n// SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::find()\n    - where(['id' =  123])\n    - one();\n\n// return all active customers and order them by their IDs\n// SELECT * FROM `customer` WHERE `status` = 1 ORDER BY `id`\n$customers = Customer::find()\n    - where(['status' =  Customer::STATUS_ACTIVE])\n    - orderBy('id')\n    - all();\n\n// return the number of active customers\n// SELECT COUNT(*) FROM `customer` WHERE `status` = 1\n$count = Customer::find()\n    - where(['status' =  Customer::STATUS_ACTIVE])\n    - count();\n\n// return all customers in an array indexed by customer IDs\n// SELECT * FROM `customer`\n$customers = Customer::find()\n    - indexBy('id')\n    - all();  In quanto spiegato sopra,  $customer  \u00e8 un oggetto della class  Customer  mentre  $customers  \u00e8 una matrice degli oggetti   Customer . Sono tutti popolati con i dati recuperati dalla tabella  customer .   Info  Poich\u00e9  yii \\ db \\ ActiveQuery  si estende da  yii \\ db \\ Query , \u00e8 possibile utilizzare tutti i metodi di creazione di query e i metodi di query come descritto nella sezione Query Builder.   Poich\u00e9 \u00e8 un'attivit\u00e0 comune per eseguire una query in base ai valori delle chiavi primarie o a un insieme di valori di colonna, Yii fornisce due metodi di scelta rapida per questo scopo:   yii \\ db \\ ActiveRecord :: findOne() : restituisce una singola istanza del record attivo popolata con la prima riga del risultato della query.  yii \\ db \\ ActiveRecord :: findAll() : restituisce una matrice di istanze di record attivo popolate con tutti i risultati della query.   Entrambi i metodi possono assumere uno dei seguenti formati di parametro:   un valore scalare: il valore viene considerato come il valore della chiave primaria desiderato da cercare. Yii determiner\u00e0 automaticamente quale colonna \u00e8 la colonna della chiave primaria leggendo le informazioni sullo schema del database.  una matrice di valori scalari: la matrice viene considerata come i valori della chiave primaria desiderati da cercare.  un array associativo: le chiavi sono nomi di colonne e i valori sono i corrispondenti valori di colonna desiderati da cercare. Si prega di fare riferimento al formato hash per maggiori dettagli.   Il codice seguente mostra come utilizzare questi metodi:  // returns a single customer whose ID is 123\n// SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::findOne(123);\n\n// returns customers whose ID is 100, 101, 123 or 124\n// SELECT * FROM `customer` WHERE `id` IN (100, 101, 123, 124)\n$customers = Customer::findAll([100, 101, 123, 124]);\n\n// returns an active customer whose ID is 123\n// SELECT * FROM `customer` WHERE `id` = 123 AND `status` = 1\n$customer = Customer::findOne([\n    'id' =  123,\n    'status' =  Customer::STATUS_ACTIVE,\n]);\n\n// returns all inactive customers\n// SELECT * FROM `customer` WHERE `status` = 0\n$customers = Customer::findAll([\n    'status' =  Customer::STATUS_INACTIVE,\n]);   Nota  N\u00e9  yii \\ db \\ ActiveRecord :: findOne()  n\u00e9  yii \\ db \\ ActiveQuery :: one()  verranno aggiunti  LIMIT 1  all'istruzione SQL generata. Se la tua query potrebbe restituire molte righe di dati, dovresti chiamare il metodo  limit(1)  per migliorare le prestazioni, ad es  Customer::find()- limit(1)- one() .   Oltre a utilizzare metodi di creazione di query, \u00e8 anche possibile scrivere SQL raw per eseguire query sui dati e popolare i risultati in oggetti Active Record. \u00c8 possibile farlo chiamando il metodo  yii \\ db \\ ActiveRecord :: findBySql() :  // returns all inactive customers\n$sql = 'SELECT * FROM customer WHERE status=:status';\n$customers = Customer::findBySql($sql, [':status' =  Customer::STATUS_INACTIVE])- all();  Si consiglia di non chiamare metodi di creazione di query aggiuntivi dopo aver chiamato  findBySql()  poich\u00e9 verranno ignorati.",
            "title": "Dati nelle query"
        },
        {
            "location": "/working-with-databases/sub-active-record/#accesso-ai-dati",
            "text": "Come indicato sopra, i dati richiamati dal database vengono popolati in istanze di Active Record e ogni riga del risultato della query corrisponde a una singola istanza dell'Active Record. \u00c8 possibile accedere ai valori della colonna accedendo agli attributi delle sue istanze, ad esempio,  // \"id\" and \"email\" are the names of columns in the \"customer\" table\n$customer = Customer::findOne(123);\n$id = $customer- id;\n$email = $customer- email;   Nota  Gli attributi dell'Active Record vengono denominati in base alla distinzione tra maiuscole e minuscole della tabella associata. Yii definisce automaticamente un attributo in Active Record per ogni colonna della tabella associata. NON si deve ridichiarare nessuno degli attributi.   Poich\u00e9 gli attributi di Active Record prendono il nome da colonne di tabelle, \u00e8 possibile che si stia scrivendo codice PHP simile a  $customer- first_name , che utilizza caratteri di sottolineatura per separare le parole nei nomi di attributi se le colonne della tabella vengono denominate in questo modo. Se sei preoccupato della coerenza dello stile del codice, dovresti rinominare le colonne della tabella di conseguenza (per usare  camelCase , ad esempio).",
            "title": "Accesso ai dati"
        },
        {
            "location": "/working-with-databases/sub-active-record/#trasformazione-dei-dati",
            "text": "Accade spesso che i dati inseriti e / o visualizzati siano in un formato diverso da quello utilizzato per la memorizzazione dei dati in un database. Ad esempio, nel database si memorizzano i compleanni dei clienti come timestamp UNIX (che per\u00f2 non \u00e8 un buon design), mentre nella maggior parte dei casi si desidera manipolare i compleanni come stringhe nel formato di 'YYYY/MM/DD'. Per raggiungere questo obiettivo, \u00e8 possibile definire i metodi di trasformazione dei dati nella Customer classe Active Record come segue:  class Customer extends ActiveRecord{\n\n    // ...\n\n    public function getBirthdayText(){\n\n        return date('Y/m/d', $this- birthday);\n    }\n\n    public function setBirthdayText($value){\n\n        $this- birthday = strtotime($value);\n    }\n}  Ora nel tuo codice PHP, invece di accedere a  $customer- birthday , accederai a  $customer- birthdayText , il che ti consentir\u00e0 di inserire e visualizzare i compleanni dei clienti nel formato di 'YYYY/MM/DD'.   Tip  L'esempio sopra mostra un modo generico di trasformare i dati in diversi formati. Se stai lavorando con i valori di date, puoi utilizzare  DateValidator  e  DatePicker , che sono pi\u00f9 facili da usare e pi\u00f9 potenti.",
            "title": "Trasformazione dei dati"
        },
        {
            "location": "/working-with-databases/sub-active-record/#recupero-dei-dati-nelle-matrici",
            "text": "Mentre il recupero dei dati in termini di oggetti Active Record \u00e8 comodo e flessibile, non \u00e8 sempre consigliabile quando si deve riportare una grande quantit\u00e0 di dati a causa del grande ingombro di memoria. In questo caso, puoi recuperare i dati utilizzando matrici PHP chiamando il metodo  asArray()  prima di eseguire un metodo di query:  // return all customers\n// each customer is returned as an associative array\n$customers = Customer::find()\n    - asArray()\n    - all();   Nota  Mentre questo metodo consente di risparmiare memoria e migliorare le prestazioni, \u00e8 pi\u00f9 vicino al livello di astrazione DB inferiore, e si perderanno la maggior parte delle funzionalit\u00e0 di Active Record. Una distinzione molto importante si trova nel tipo di dati dei valori delle colonne. Quando restituisci i dati nelle istanze di Active Record, i valori delle colonne verranno automaticamente tipizzati in base ai tipi di colonna effettivi; d'altra parte quando si restituiscono i dati nelle matrici, i valori delle colonne saranno stringhe (poich\u00e9 sono il risultato di PDO senza elaborazione), indipendentemente dai loro effettivi tipi di colonna.",
            "title": "Recupero dei dati nelle matrici"
        },
        {
            "location": "/working-with-databases/sub-active-record/#recupero-dei-dati-in-lotti",
            "text": "In Query Builder, abbiamo spiegato che \u00e8 possibile utilizzare la query batch per ridurre al minimo l'utilizzo della memoria quando si esegue una query su una grande quantit\u00e0 di dati dal database. Puoi usare la stessa tecnica in Active Record. Per esempio,  // fetch 10 customers at a time\nforeach (Customer::find()- batch(10) as $customers) {\n    // $customers is an array of 10 or fewer Customer objects\n}\n\n// fetch 10 customers at a time and iterate them one by one\nforeach (Customer::find()- each(10) as $customer) {\n    // $customer is a Customer object\n}\n\n// batch query with eager loading\nforeach (Customer::find()- with('orders')- each() as $customer) {\n    // $customer is a Customer object with the 'orders' relation populated\n}",
            "title": "Recupero dei dati in lotti"
        },
        {
            "location": "/working-with-databases/sub-active-record/#salvataggio-dei-dati",
            "text": "Usando Active Record, puoi facilmente salvare i dati nel database seguendo i seguenti passi:   Preparare un'istanza dell'Active Record  Assegnare nuovi valori agli attributi dell'Active Record  Chiamare  yii \\ db \\ ActiveRecord :: save()  per salvare i dati nel database.   Per esempio,  // insert a new row of data\n$customer = new Customer();\n$customer- name = 'James';\n$customer- email = 'james@example.com';\n$customer- save();\n\n// update an existing row of data\n$customer = Customer::findOne(123);\n$customer- email = 'james@newexample.com';\n$customer- save();  Il metodo  save()  pu\u00f2 inserire o aggiornare una riga di dati, a seconda dello stato dell'istanza dell'Active Record. Se l'istanza \u00e8 stata appena creata dall'operatore  new , la chiamata a  save()  causer\u00e0 l'inserimento di una nuova riga; Se l'istanza \u00e8 il risultato di un metodo di query, la chiamata a  save()  aggiorner\u00e0 la riga associata all'istanza.  \u00c8 possibile differenziare i due stati di un'istanza di Active Record controllando il valore della propriet\u00e0  yii \\ db \\ ActiveRecord :: isNewRecord . Questa propriet\u00e0 viene anche utilizzata internamente da  save()  come segue:  public function save($runValidation = true, $attributeNames = null){\n\n    if ($this- getIsNewRecord()) {\n        return $this- insert($runValidation, $attributeNames);\n    } else {\n        return $this- update($runValidation, $attributeNames) !== false;\n    }\n}   Tip  Puoi chiamare i metodi  insert()  o  update()  direttamente per inserire o aggiornare una riga.",
            "title": "Salvataggio dei dati"
        },
        {
            "location": "/working-with-databases/sub-active-record/#convalida-dei-dati",
            "text": "Poich\u00e9  yii \\ db \\ ActiveRecord  si estende da  yii \\ base \\ Model , condivide la stessa funzione di convalida dei dati . \u00c8 possibile dichiarare regole di convalida sovrascrivendo il metodo  rules()  ed eseguire la convalida dei dati chiamando il metodo  validate() .  Quando chiami  save() , per impostazione predefinita chiamer\u00e0 automaticamente  validate() . Solo quando passa la convalida, in realt\u00e0 salver\u00e0 i dati; altrimenti verr\u00e0 semplicemente restituito falsee sar\u00e0 possibile controllare la propriet\u00e0  yii \\ db \\ ActiveRecord :: errors  per recuperare i messaggi di errore di convalida.   Tip  Se si \u00e8 certi che i dati non necessitano di convalida (ad esempio, i dati provengono da fonti attendibili), \u00e8 possibile chiamare  save  (false) per saltare la convalida.",
            "title": "Convalida dei dati"
        },
        {
            "location": "/working-with-databases/sub-active-record/#assegnazione-massiccia",
            "text": "Come i modelli normali , anche le istanze di Active Record godono della massiccia funzione di assegnazione. Utilizzando questa funzione, \u00e8 possibile assegnare valori a pi\u00f9 attributi di un'istanza di Active Record in una singola istruzione PHP, come mostrato di seguito. Ricorda che solo gli attributi sicuri possono essere assegnati in modo massiccio, per\u00f2.  $values = [\n    'name' =  'James',\n    'email' =  'james@example.com',\n];\n\n$customer = new Customer();\n\n$customer- attributes = $values;\n$customer- save();",
            "title": "Assegnazione massiccia"
        },
        {
            "location": "/working-with-databases/sub-active-record/#aggiornamento-dei-contatori",
            "text": "\u00c8 un'attivit\u00e0 comune incrementare o decrementare una colonna in una tabella di database. Chiamiamo queste colonne \"counter columns\". \u00c8 possibile utilizzare  updateCounters()  per aggiornare una o pi\u00f9 colonne contatore. Per esempio,  $post = Post::findOne(100);\n\n// UPDATE `post` SET `view_count` = `view_count` + 1 WHERE `id` = 100\n$post- updateCounters(['view_count' =  1]);   Nota  Se si utilizza  yii \\ db \\ ActiveRecord :: save()  per aggiornare una colonna contatore, si potrebbe finire con un risultato inaccurato, poich\u00e9 \u00e8 probabile che lo stesso contatore venga salvato da pi\u00f9 richieste che leggono e scrivono lo stesso valore contatore.",
            "title": "Aggiornamento dei contatori"
        },
        {
            "location": "/working-with-databases/sub-active-record/#attributi-dirty-sporchi",
            "text": "Quando si chiama il metodo  save()  per salvare un'istanza dell'Active Record, vengono salvati solo gli attributi dirty. Un attributo \u00e8 considerato sporco se il suo valore \u00e8 stato modificato poich\u00e9 \u00e8 stato caricato dal DB o salvato in DB pi\u00f9 recentemente. Si noti che la convalida dei dati verr\u00e0 eseguita indipendentemente dal fatto che l'istanza dell'Active Record abbia o meno attributi sporchi.  L'Active Record mantiene automaticamente l'elenco degli attributi dirty. Lo fa mantenendo una versione precedente dei valori degli attributi e confrontandoli con l'ultima. \u00c8 possibile chiamare  yii \\ db \\ ActiveRecord :: getDirtyAttributes()  per ottenere gli attributi attualmente sporchi. Puoi anche chiamare  yii \\ db \\ ActiveRecord :: markAttributeDirty()  per contrassegnare esplicitamente un attributo come dirty.  Se sei interessato ai valori degli attributi prima della loro modifica pi\u00f9 recente, puoi chiamare i metodi  getOldAttributes()  o  getOldAttribute() .   Nota  Il confronto tra vecchi e nuovi valori verr\u00e0 eseguito utilizzando l'operatore  ===  in modo che un valore venga considerato sporco anche se ha lo stesso valore ma un tipo diverso. Questo \u00e8 spesso il caso in cui il modello riceve input da moduli HTML in cui ogni valore \u00e8 rappresentato come una stringa. Per assicurare che il tipo corretto per esempio valori interi si pu\u00f2 applicare un filtro di convalida :  ['attributeName', 'filter', 'filter' =  'intval'] . Funziona con tutte le funzioni di typecasting di PHP come  intval()  ,  floatval()  ,  boolval  , ecc ...",
            "title": "Attributi dirty (sporchi)"
        },
        {
            "location": "/working-with-databases/sub-active-record/#valori-predefiniti-di-un-attributo",
            "text": "Alcune delle colonne della tabella possono avere valori predefiniti definiti nel database. A volte, \u00e8 possibile pre-compilare il modulo Web per un'istanza dell'Active Record con questi valori predefiniti. Per evitare di scrivere nuovamente gli stessi valori predefiniti, \u00e8 possibile chiamare  loadDefaultValues \u200b()  per popolare i valori predefiniti definiti dal DB negli attributi del record attivo corrispondente:  $customer = new Customer();\n$customer- loadDefaultValues();\n// $customer- xyz will be assigned the default value declared when defining the \"xyz\" column",
            "title": "Valori predefiniti di un attributo"
        },
        {
            "location": "/working-with-databases/sub-active-record/#attributi-typecasting",
            "text": "Compilando i risultati della query  yii \\ db \\ ActiveRecord , viene eseguito un typecast automatico per i suoi valori di attributo, utilizzando le informazioni dallo schema della tabella del database. Ci\u00f2 consente ai dati recuperati dalla colonna della tabella dichiarata come numero intero di essere popolati nell'istanza dell'ActiveRecord con un valore PHP intero, booleano con booleano e cos\u00ec via. Tuttavia, il meccanismo di typecasting ha diverse limitazioni:   I valori float non vengono convertiti e verranno rappresentati come stringhe, altrimenti potrebbero perdere precisione.  La conversione dei valori interi dipende dalla capacit\u00e0 intera del sistema operativo che si utilizza. In particolare: i valori della colonna dichiarata come \"intero senza segno\" o \"intero grande\" saranno convertiti in intero PHP solo con il sistema operativo a 64 bit, mentre su quelli a 32 bit saranno rappresentati come stringhe.   Si noti che l'attributo  typecast  viene eseguito solo durante il popolamento dell'istanza ActiveRecord dal risultato della query. Non esiste conversione automatica per i valori caricati dalla richiesta HTTP o impostati direttamente tramite l'accesso alla propriet\u00e0. Lo schema della tabella verr\u00e0 utilizzato anche durante la preparazione delle istruzioni SQL per il salvataggio dei dati di ActiveRecord, garantendo che i valori siano associati alla query con il tipo corretto. Tuttavia, i valori degli attributi dell'istanza di ActiveRecord non verranno convertiti durante il processo di salvataggio.   Tip  E' possibile utilizzare  yii \\ behaviors \\ AttributeTypecastBehavior  per facilitare i valori degli attributi typecasting sulla convalida o il salvataggio di ActiveRecord.",
            "title": "Attributi Typecasting"
        },
        {
            "location": "/working-with-databases/sub-active-record/#aggiornamento-di-piu-righe",
            "text": "I metodi descritti sopra funzionano tutti su singole istanze di Active Record, causando l'inserimento o l'aggiornamento di singole righe di tabella. Per aggiornare pi\u00f9 righe contemporaneamente, \u00e8 necessario chiamare il metodo  updateAll()  , invece, che \u00e8 un metodo statico.  // UPDATE `customer` SET `status` = 1 WHERE `email` LIKE `%@example.com%`\nCustomer::updateAll(['status' =  Customer::STATUS_ACTIVE], ['like', 'email', '@example.com']);  Allo stesso modo, puoi chiamare il metodo  updateAllCounters()  per aggiornare le colonne contatore di pi\u00f9 righe contemporaneamente.  // UPDATE `customer` SET `age` = `age` + 1\nCustomer::updateAllCounters(['age' =  1]);",
            "title": "Aggiornamento di pi\u00f9 righe"
        },
        {
            "location": "/working-with-databases/sub-active-record/#eliminazione-dei-dati",
            "text": "Per eliminare una singola riga di dati, dobbiamo recuperare prima l'istanza dell'Active Record corrispondente a quella riga e quindi chiamare il metodo  yii \\ db \\ ActiveRecord :: delete() .  $customer = Customer::findOne(123);\n$customer- delete();  \u00c8 possibile chiamare  yii \\ db \\ ActiveRecord :: deleteAll()  per eliminare pi\u00f9 o tutte le righe di dati. Per esempio,  Customer::deleteAll(['status' =  Customer::STATUS_INACTIVE]);   Warning  Fai molta attenzione quando chiami  deleteAll()  perch\u00e9 potrebbe cancellare completamente tutti i dati dalla tua tabella se commetti un errore nel specificare la condizione.",
            "title": "Eliminazione dei dati"
        },
        {
            "location": "/working-with-databases/sub-active-record/#cicli-di-vita-dellactive-record",
            "text": "\u00c8 importante comprendere i cicli di vita dell'Active Record quando viene utilizzato per scopi diversi. Durante ciascun ciclo di vita, verr\u00e0 invocata una determinata sequenza di metodi e sar\u00e0 possibile ignorare questi metodi per ottenere la possibilit\u00e0 di personalizzare il ciclo di vita. Puoi anche rispondere a determinati eventi dell'Active Record attivati \u200b\u200bdurante un ciclo di vita per iniettare il tuo codice personalizzato. Questi eventi sono particolarmente utili quando si sviluppano comportamenti Active Record che devono personalizzare i cicli di vita di un determinato Active Record.  Di seguito, riassumeremo i vari cicli di vita dell'Active Record e i metodi / eventi coinvolti nei cicli di vita.    Nuovo ciclo di vita  Quando si crea una nuova istanza Active Record tramite l'operatore  new , si verificher\u00e0 il seguente ciclo di vita:   Istanziare il costruttre della classe.  init() : il metodo deve attivave un evento  EVENT_INIT .   Interrogare il ciclo di vita sui dati richiesti  Quando si interrogano i dati tramite uno dei metodi di query , ciascun Active Record popolato di recente, subir\u00e0 il seguente ciclo di vita:   Istanziare il costruttre della classe.  init() : il metodo deve attivare un evento  EVENT_INIT .  afterFind() : il metodo deve attivare un evento  EVENT_AFTER_FIND .   Salvataggio del ciclo di vita sui dati richiesti  Quando si chiama il metodo  save()  per inserire o aggiornare un'istanza di Active Record, si verificher\u00e0 il seguente ciclo di vita:   Si verifica l'evento  EVENT_BEFORE_VALIDATE . Se il metodo restituisce  false  o  Yii \\ base \\ ModelEvent :: $ isValid  \u00e8  false , il resto dei passaggi verr\u00e0 ignorato.  Esegue la convalida dei dati. Se la convalida dei dati fallisce, i passaggi successivi al passaggio 3 verranno saltati.  Si verifica l'evento  EVENT_AFTER_VALIDATE .  Si verifica l'evento  EVENT_BEFORE_INSERT  o  EVENT_BEFORE_UPDATE . Se il metodo restituisce  false  o  Yii \\ base \\ ModelEvent :: $ isValid  \u00e8  false , il resto dei passaggi verr\u00e0 ignorato.  Esegue l'inserimento o l'aggiornamento dei dati effettivi.  Si verifica l'evento  EVENT_AFTER_INSERT  o  EVENT_AFTER_UPDATE .   Eliminazione del ciclo di vita sui dati richiesti  Quando si chiama il metodo  delete()  per eliminare un'istanza di Active Record, si verificher\u00e0 il seguente ciclo di vita:   Si verifica l'evento  EVENT_BEFORE_DELETE . Se il metodo restituisce  false  o  Yii \\ base \\ ModelEvent :: $ isValid  \u00e8  false , il resto dei passaggi verr\u00e0 ignorato.  Esegue la cancellazione effettiva dei dati.  Si verifica l'evento  EVENT_AFTER_DELETE .    Warning  La chiamata a uno dei seguenti metodi NON avvier\u00e0 nessuno dei suddetti cicli di vita perch\u00e9 funzionano direttamente sul database e non su base record:  - ***Yii \\ db \\ ActiveRecord :: updateAll()***\n- ***Yii \\ db \\ ActiveRecord :: CancTutti()***\n- ***Yii \\ db \\ ActiveRecord :: updateCounters()***\n- ***Yii \\ db \\ ActiveRecord :: updateAllCounters()***   Refresh del ciclo di vita sui dati richiesti  Quando si chiama il metodo  refresh()  per aggiornare un'istanza dell'Active Record, l' evento  EVENT_AFTER_REFRESH  viene attivato se l'aggiornamento ha esito positivo e il metodo restituisce  true .",
            "title": "Cicli di vita dell'Active Record"
        },
        {
            "location": "/working-with-databases/sub-active-record/#lavorare-con-le-transazioni",
            "text": "Esistono due modi per utilizzare le transazioni mentre si lavora con l'Active Record.  Il primo modo \u00e8 di includere esplicitamente le chiamate al metodo Active Record in un blocco transazionale, come mostrato di seguito,  $customer = Customer::findOne(123);\n\nCustomer::getDb()- transaction(function($db) use ($customer) {\n    $customer- id = 200;\n    $customer- save();\n    // ...other DB operations...\n});\n\n// or alternatively\n\n$transaction = Customer::getDb()- beginTransaction();\ntry {\n    $customer- id = 200;\n    $customer- save();\n    // ...other DB operations...\n    $transaction- commit();\n} catch(\\Exception $e) {\n    $transaction- rollBack();\n    throw $e;\n} catch(\\Throwable $e) {\n    $transaction- rollBack();\n    throw $e;\n}   Warning  Nel codice precedente abbiamo due blocchi di try - catch per la compatibilit\u00e0 con PHP 5.x e PHP 7.x.  \\Exception  implementa l'interfaccia   \\Throwable  da PHP 7.0, quindi puoi saltare la parte  \\Exceptions  e la tua app utilizza solo PHP 7.0 e versioni successive.   Il secondo modo \u00e8 elencare le operazioni DB che richiedono il supporto transazionale nel metodo  yii \\ db \\ ActiveRecord :: transactions() . Per esempio,  class Customer extends ActiveRecord{\n\n    public function transactions(){\n\n        return [\n            'admin' =  self::OP_INSERT,\n            'api' =  self::OP_INSERT | self::OP_UPDATE | self::OP_DELETE,\n            // the above is equivalent to the following:\n            // 'api' =  self::OP_ALL,\n        ];\n    }\n}  Il metodo  yii \\ db \\ ActiveRecord :: transactions()  dovrebbe restituire un array le cui chiavi sono nomi di scenario e i valori sono le operazioni corrispondenti che devono essere racchiuse tra le transazioni. \u00c8 necessario utilizzare le seguenti costanti per fare riferimento a diverse operazioni DB:   OP_INSERT : operazione di inserimento eseguita dal metodo  insert() ;  OP_UPDATE : operazione di aggiornamento eseguita dal metodo  update() ;  OP_DELETE : operazione di cancellazione eseguita dal metodo  delete() .   Gli operatori  |  vengono usati per concatenare le costanti sopra indicate e anche per indicare pi\u00f9 operazioni. \u00c8 inoltre possibile utilizzare la costante di scelta rapida  OP_ALL  per fare riferimento a tutte e tre le operazioni precedenti.  Le transazioni create utilizzando questo metodo verranno avviate prima di chiamare  beforeSave()  e verranno eseguite dopo l'esecuzione di  afterSave() .",
            "title": "Lavorare con le transazioni"
        },
        {
            "location": "/working-with-databases/sub-active-record/#optimistic-locks",
            "text": "Il blocco ottimistico ( o optimistic locks ) \u00e8 un modo per prevenire i conflitti che possono verificarsi quando una singola riga di dati viene aggiornata da pi\u00f9 utenti. Ad esempio, sia l'utente A che l'utente B stanno modificando lo stesso articolo wiki allo stesso tempo. Dopo che l'utente A ha salvato le sue modifiche, l'utente B fa clic sul pulsante \"Salva\" nel tentativo di salvare anche le sue modifiche. Poich\u00e9 l'utente B stava effettivamente lavorando su una versione obsoleta dell'articolo, sarebbe auspicabile avere un modo per impedirgli di salvare l'articolo e mostrargli un messaggio di suggerimento.  L'optimistic locks risolve il problema precedente utilizzando una colonna per registrare il numero di versione di ogni riga. Quando una riga viene salvata con un numero di versione obsoleto, verr\u00e0 generata un'eccezione  yii \\ db \\ StaleObjectException , che impedisce il salvataggio della riga. L'optimistic locks \u00e8 supportato solo quando si aggiorna o si elimina una riga di dati esistente utilizzando  yii \\ db \\ ActiveRecord :: update()  o  yii \\ db \\ ActiveRecord :: delete() .  Per utilizzarel'optimistic locks dobbiamo:   Creare una colonna nella tabella DB associata alla classe dell'Active Record, per memorizzare il numero di versione di ogni riga. La colonna dovrebbe essere di tipo \"big integer\" (in MySQL sarebbe  BIGINT DEFAULT 0 ).  Sostituire il metodo  yii \\ db \\ ActiveRecord :: optimisticLock()  per restituire il nome di questa colonna.  Nel modulo Web che accetta gli input dell'utente, aggiungere un campo nascosto per memorizzare il numero di versione corrente della riga in aggiornamento. Assicurati che l'attributo della versione contenga regole di convalida dell'input e convalidi correttamente.  Nell'azione del controller che aggiorna la riga utilizzando l'Active Record, prova a rilevare l' eccezione  yii \\ db \\ StaleObjectException . Implementare la logica aziendale necessaria (ad esempio unire le modifiche, richiamando i dati staled) per risolvere il conflitto.   Ad esempio, supponi che la colonna della versione sia nominata come  version . \u00c8 possibile implementare il blocco ottimistico con il codice come il seguente.  // ------ view code -------\n\nuse yii\\helpers\\Html;\n\n// ...other input fields\necho Html::activeHiddenInput($model, 'version');\n\n\n// ------ controller code -------\n\nuse yii\\db\\StaleObjectException;\n\npublic function actionUpdate($id){\n\n    $model = $this- findModel($id);\n\n    try {\n        if ($model- load(Yii::$app- request- post())   $model- save()) {\n            return $this- redirect(['view', 'id' =  $model- id]);\n        } else {\n            return $this- render('update', [\n                'model' =  $model,\n            ]);\n        }\n    } catch (StaleObjectException $e) {\n        // logic to resolve the conflict\n    }\n}",
            "title": "Optimistic Locks"
        },
        {
            "location": "/working-with-databases/sub-active-record/#lavorare-con-i-dati-relazionali",
            "text": "Oltre a lavorare con le singole tabelle del database, l'Active Record \u00e8 anche in grado di riunire i dati correlati, rendendoli facilmente accessibili attraverso i dati primari. Ad esempio, i dati del cliente sono correlati ai dati dell'ordine poich\u00e9 un cliente potrebbe aver effettuato uno o pi\u00f9 ordini. Con un'adeguata dichiarazione di questa relazione, sarete in grado di accedere alle informazioni sull'ordine di un cliente utilizzando l'espressione  $customer- orders  che restituisce le informazioni sull'ordine del cliente in termini di una serie di instanze  Order  dell'Active Record.",
            "title": "Lavorare con i dati relazionali"
        },
        {
            "location": "/working-with-databases/sub-active-record/#dichiarare-le-relazioni",
            "text": "Per lavorare con i dati relazionali utilizzando l'Active Record, \u00e8 necessario innanzitutto dichiarare le relazioni nelle classi dell'Active Record. Il compito \u00e8 semplice come dichiarare un metodo di relazione per ogni relazione interessata, come il seguente,  class Customer extends ActiveRecord{\n\n    // ...\n\n    public function getOrders(){\n\n        return $this- hasMany(Order::className(), ['customer_id' =  'id']);\n    }\n}\n\nclass Order extends ActiveRecord{\n\n    // ...\n\n    public function getCustomer(){\n\n        return $this- hasOne(Customer::className(), ['id' =  'customer_id']);\n    }\n}  Nel codice precedente, abbiamo dichiarato una relazione  orders  per la classe  Customer  e una relazione  customer  per la classe  Order .  Ogni metodo di relazione deve essere nominato come  getXyz . Chiamiamo  xyz (la prima lettera \u00e8 in minuscolo) il nome della relazione. Nota che i nomi delle relazioni sono case sensitive .  Durante la dichiarazione di una relazione, \u00e8 necessario specificare le seguenti informazioni:   la molteplicit\u00e0 della relazione: specificata chiamando i metodi  hasMany()  o  hasOne() . Nell'esempio sopra puoi leggere facilmente nelle dichiarazioni di relazione che un cliente ha molti ordini mentre un ordine ha un solo cliente.  il nome della classe Active Record correlata: specificato come primo parametro su  hasMany()  o  hasOne() . Si consiglia di chiamare  Xyz::className()  per ottenere la stringa del nome della classe in modo da poter ricevere il supporto per il completamento automatico IDE e il rilevamento degli errori in fase di compilazione.  il collegamento tra i due tipi di dati: specifica le colonne attraverso le quali i due tipi di dati sono correlati. I valori dell'array sono le colonne dei dati primari (rappresentati dalla classe Active Record che stai dichiarando nelle relazioni), mentre le chiavi dell'array sono le colonne dei dati correlati.   Una regola facile da ricordare \u00e8, come vedi nell'esempio sopra, che scrivi la colonna che appartiene al relativo Active Record direttamente accanto ad essa. Vedi l\u00ec che  customer_id  \u00e8 una propriet\u00e0 di  Order  ed  id  \u00e8 una propriet\u00e0 di  Customer .",
            "title": "Dichiarare le relazioni"
        },
        {
            "location": "/working-with-databases/sub-active-record/#accesso-ai-dati-relazionali",
            "text": "Dopo aver dichiarato le relazioni, puoi accedere ai dati relazionali attraverso i loro nomi. Questo \u00e8 come accedere a una propriet\u00e0 dell'oggetto definita dal metodo di una relazione. Per questo motivo, lo chiamiamo \"propriet\u00e0 relazionale\". Per esempio,  // SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::findOne(123);\n\n// SELECT * FROM `order` WHERE `customer_id` = 123\n// $orders is an array of Order objects\n$orders = $customer- orders;   Info  Quando dichiari una relazione denominata  xyz  tramite un metodo getter  getXyz() , sarai in grado di accedere  xyz  come una propriet\u00e0 dell'oggetto . Si noti che il nome \u00e8 case sensitive.   Se una relazione \u00e8 dichiarata con  hasMany() , l'accesso a questa propriet\u00e0 di relazione restituir\u00e0 una matrice delle istanze relative all'Active Record;se una relazione viene dichiarata con il metodo  hasOne() , l'accesso alla propriet\u00e0 della relazione restituir\u00e0 l'istanza relativa all'Active Record o  valore  null  se non viene trovato alcun dato correlato.  Quando si accede a una propriet\u00e0 di relazione per la prima volta, verr\u00e0 eseguita un'istruzione SQL, come mostrato nell'esempio precedente. Se si accede nuovamente alla stessa propriet\u00e0, il risultato precedente verr\u00e0 restituito senza rieseguire l'istruzione SQL. Per forzare la ri-esecuzione dell'istruzione SQL, \u00e8 necessario eliminare la propriet\u00e0:  unset($customer- orders) .   Nota  Sebbene questo concetto sia simile alla funzione della propriet\u00e0 dell'oggetto, esiste una differenza importante. Per le normali propriet\u00e0 il valore della propriet\u00e0 \u00e8 dello stesso tipo del metodo getter definitivo. Un metodo di relazione tuttavia restituisce un'istanza  yii \\ db \\ ActiveQuer , mentre l'accesso a una propriet\u00e0 di relazione restituir\u00e0 un'istanza  yii \\ db \\ ActiveRecord  o una matrice di questi.  $customer- orders; // is an array of  Order  objects\n$customer- getOrders(); // returns an ActiveQuery instance   Questo \u00e8 utile per creare query personalizzate, come descritto nella prossima sezione.",
            "title": "Accesso ai dati relazionali"
        },
        {
            "location": "/working-with-databases/sub-active-record/#query-con-relazioni-dinamiche",
            "text": "Poich\u00e9 un metodo di relazione restituisce un'istanza di  yii \\ db \\ ActiveQuery , \u00e8 possibile creare ulteriormente questa query utilizzando i metodi di creazione di query prima di eseguire la query DB. Per esempio,  $customer = Customer::findOne(123);\n\n// SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal`   200 ORDER BY `id`\n$orders = $customer- getOrders()\n    - where([' ', 'subtotal', 200])\n    - orderBy('id')\n    - all();  Ogni volta che si esegue una query relazionale dinamica tramite un metodo di relazione, verr\u00e0 eseguita un'istruzione SQL, anche se prima veniva eseguita la stessa query relazionale dinamica.  A volte potresti persino voler parametrizzare una dichiarazione di relazione in modo da poter eseguire pi\u00f9 facilmente query relazionali dinamiche. Ad esempio, puoi dichiarare una relazione  bigOrders  come segue,  class Customer extends ActiveRecord{\n\n    public function getBigOrders($threshold = 100){\n\n        return $this- hasMany(Order::className(), ['customer_id' =  'id'])\n            - where('subtotal   :threshold', [':threshold' =  $threshold])\n            - orderBy('id');\n    }\n}  Quindi sarai in grado di eseguire le seguenti query relazionali:  // SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal`   200 ORDER BY `id`\n$orders = $customer- getBigOrders(200)- all();\n\n// SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal`   100 ORDER BY `id`\n$orders = $customer- bigOrders;",
            "title": "Query con relazioni dinamiche"
        },
        {
            "location": "/working-with-databases/sub-active-record/#relazioni-tramite-una-junction-table",
            "text": "Nella modellazione di database, quando la molteplicit\u00e0 tra due tabelle correlate \u00e8 molti-a-molti, viene generalmente introdotta una tabella di giunzione . Ad esempio, la order tabel e la item tabel possono essere correlate tramite una tabella di giunzione denominata  order_item . Un ordine corrisponder\u00e0 quindi a pi\u00f9 articoli dell'ordine, mentre un articolo prodotto corrisponder\u00e0 anche a pi\u00f9 articoli dell'ordine.  Quando si dichiarano tali relazioni, si pu\u00f2 chiamare  via()  o  viaTabella()  per specificare la tabella di giunzione. La differenza tra  via()  e  viaTable()  \u00e8 che il primo specifica la tabella di congiunzione in termini di un nome di relazione esistente, mentre il secondo utilizza direttamente la tabella di giunzione. Per esempio,  class Order extends ActiveRecord{\n\npublic function getItems(){\n\n        return $this- hasMany(Item::className(), ['id' =  'item_id'])\n            - viaTable('order_item', ['order_id' =  'id']);\n    }\n}  o in alternativa,  class Order extends ActiveRecord{\n\n    public function getOrderItems(){\n\n        return $this- hasMany(OrderItem::className(), ['order_id' =  'id']);\n    }\n\n    public function getItems(){\n\n        return $this- hasMany(Item::className(), ['id' =  'item_id'])\n            - via('orderItems');\n    }\n}  L'uso delle relazioni dichiarate con una tabella di giunzione \u00e8 uguale a quello delle relazioni normali. Per esempio,  // SELECT * FROM `order` WHERE `id` = 100\n$order = Order::findOne(100);\n\n// SELECT * FROM `order_item` WHERE `order_id` = 100\n// SELECT * FROM `item` WHERE `item_id` IN (...)\n// returns an array of Item objects\n$items = $order- items;",
            "title": "Relazioni tramite una Junction Table"
        },
        {
            "location": "/working-with-databases/sub-active-record/#concatenare-le-definizioni-delle-relazioni-tramite-piu-tabelle",
            "text": "\u00c8 inoltre possibile definire le relazioni tramite pi\u00f9 tabelle concatenando le definizioni di relazione usando il metodo  via() . Considerando gli esempi precedenti, abbiamo classi  Customer ,  Order  e  Item . Possiamo aggiungere una relazione alla classe  Customer  che elenca tutti gli articoli da tutti gli ordini che hanno inserito e nominarla  getPurchasedItems() , il concatenamento delle relazioni \u00e8 mostrato nel seguente esempio di codice:  class Customer extends ActiveRecord{\n\n    // ...\n\n    public function getPurchasedItems(){\n\n        // customer's items, matching 'id' column of `Item` to 'item_id' in OrderItem\n        return $this- hasMany(Item::className(), ['id' =  'item_id'])\n                    - via('orderItems');\n    }\n\n    public function getOrderItems(){\n\n        // customer's order items, matching 'id' column of `Order` to 'order_id' in OrderItem\n        return $this- hasMany(OrderItem::className(), ['order_id' =  'id'])\n                    - via('orders');\n    }\n\n    public function getOrders(){\n\n        // same as above\n        return $this- hasMany(Order::className(), ['customer_id' =  'id']);\n    }\n}",
            "title": "Concatenare le definizioni delle relazioni tramite pi\u00f9 tabelle"
        },
        {
            "location": "/working-with-databases/sub-active-record/#lazy-loading-e-eager-loading",
            "text": "IN precedenza, quando abbiamo parlato all'accesso ai dati relazionali, abbiamo spiegato che \u00e8 possibile accedere a una propriet\u00e0 di relazione di un'istanza dell'Active Record come l'accesso a una normale propriet\u00e0 dell'oggetto. Un'istruzione SQL verr\u00e0 eseguita solo quando si accede alla propriet\u00e0 della relazione la prima volta. Chiamiamo questo tipo di dati relazionali che accedono al metodo di \"caricamento lazy\". Per esempio,  // SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::findOne(123);\n\n// SELECT * FROM `order` WHERE `customer_id` = 123\n$orders = $customer- orders;\n\n// no SQL executed\n$orders2 = $customer- orders;  Il caricamento lento \u00e8 molto comodo da usare. Tuttavia, potrebbe verificarsi un problema di prestazioni quando \u00e8 necessario accedere alla stessa propriet\u00e0 di relazione in pi\u00f9 istanze dell'Active Record. Considera il seguente esempio di codice. Quante istruzioni SQL saranno eseguite?  // SELECT * FROM `customer` LIMIT 100\n$customers = Customer::find()- limit(100)- all();\n\nforeach ($customers as $customer) {\n    // SELECT * FROM `order` WHERE `customer_id` = ...\n    $orders = $customer- orders;\n}  Come puoi vedere dal commento del codice sopra, ci sono 101 istruzioni SQL in esecuzione! Questo perch\u00e9 ogni volta che si accede alla propriet\u00e0 di relazione  orders  di un oggetto  Customer  diverso nel ciclo for, verr\u00e0 eseguita un'istruzione SQL.  Per risolvere questo problema di prestazioni, \u00e8 possibile utilizzare il cosiddetto \"Eager Loading\" come mostrato di seguito,  // SELECT * FROM `customer` LIMIT 100;\n// SELECT * FROM `orders` WHERE `customer_id` IN (...)\n$customers = Customer::find()\n    - with('orders')\n    - limit(100)\n    - all();\n\nforeach ($customers as $customer) {\n    // no SQL executed\n    $orders = $customer- orders;\n}  Chiamando  yii \\ db \\ ActiveQuery :: with() , si istruisce l'Active Record per riportare gli ordini per i primi 100 clienti in una singola istruzione SQL. Di conseguenza, riduci il numero delle istruzioni SQL eseguite da 101 a 2!  Puoi caricare avidamente una o pi\u00f9 relazioni. Puoi anche caricare avidamente relazioni nidificate. Una relazione nidificata \u00e8 una relazione dichiarata all'interno di una classe Active Record correlata. Ad esempio,  Customer  \u00e8 correlato con  Order  attraverso la relazione  orders  ed  Order  \u00e8 correlato con  Item  attraverso la relazione  items . Quando si esegue una query per  Customer , \u00e8 possibile caricare  items  con impazienza utilizzando la notazione della relazione nidificata  orders.items .  Il seguente codice mostra l'uso differente di  with() . Assumiamo che la classe  Customer  abbia due relazioni  orders  e  country , mentre la classe  Order  ha una relazione  items .  // eager loading both \"orders\" and \"country\"\n$customers = Customer::find()- with('orders', 'country')- all();\n// equivalent to the array syntax below\n$customers = Customer::find()- with(['orders', 'country'])- all();\n// no SQL executed \n$orders= $customers[0]- orders;\n// no SQL executed \n$country = $customers[0]- country;\n\n// eager loading \"orders\" and the nested relation \"orders.items\"\n$customers = Customer::find()- with('orders.items')- all();\n// access the items of the first order of the first customer\n// no SQL executed\n$items = $customers[0]- orders[0]- items;  Puoi caricare le relazioni in modo eagerly in modo annidato, come ad esempio  a.b.c.d . Cio\u00e8, quando si chiama  with()  utilizzando  a.b.c.d , avrai un caricamento lento come segue:  a ,  a.b ,  a.b.c  e  a.b.c.d .   Info  In generale, quando si caricano in modo \"eagerly (aviademnte) le  N  relazioni tra le quali le  M  relazioni vengono definite con una tabella di giunzione,  N+M+1  verr\u00e0 eseguito un numero totale di istruzioni SQL. Si noti che una relazione nidificata  a.b.c.d  conta come 4 relazioni.   Quando si carica in modo eagerly una relazione, \u00e8 possibile personalizzare la query relazionale corrispondente utilizzando una funzione anonima. Per esempio,  // find customers and bring back together their country and active orders\n// SELECT * FROM `customer`\n// SELECT * FROM `country` WHERE `id` IN (...)\n// SELECT * FROM `order` WHERE `customer_id` IN (...) AND `status` = 1\n$customers = Customer::find()- with([\n    'country',\n    'orders' =  function ($query) {\n        $query- andWhere(['status' =  Order::STATUS_ACTIVE]);\n    },\n])- all();  Quando si personalizza la query relazionale per una relazione, \u00e8 necessario specificare il nome della relazione come chiave di array e utilizzare una funzione anonima come valore dell'array corrispondente. La funzione anonima ricever\u00e0 un parametro  $query  che rappresenta l'oggetto  yii \\ db \\ ActiveQuery  utilizzato per eseguire la query relazionale per la relazione. Nell'esempio di codice sopra, stiamo modificando la query relazionale aggiungendo una condizione aggiuntiva sullo stato dell'ordine.   Nota  Se viene chiamato il metodo  select() , dovete assicurarvi che le colonne referenziate nelle dichiarazioni di relazione siano selezionate. In caso contrario, i relativi modelli potrebbero non essere caricati correttamente. Per esempio,  $orders = Order::find()- select(['id', 'amount'])- with('customer')- all();\n// $orders[0]- customer is always `null`. To fix the problem, you should do the following:\n$orders = Order::find()- select(['id', 'amount', 'customer_id'])- with('customer')- all();",
            "title": "Lazy Loading e Eager Loading"
        },
        {
            "location": "/working-with-databases/sub-active-record/#joining-with-relations",
            "text": "Nota  Il contenuto descritto in questa sottosezione \u00e8 applicabile solo ai database relazionali, come MySQL, PostgreSQL, ecc.   Le query relazionalali che abbiamo descritto finora fanno riferimento solo alle colonne della tabella principale quando si esegue una query per i dati primari. In realt\u00e0 spesso \u00e8 necessario fare riferimento alle colonne nelle tabelle correlate. Ad esempio, potremmo voler riportare i clienti che hanno almeno un ordine attivo. Per risolvere questo problema, possiamo creare una query di join come la seguente:  // SELECT `customer`.* FROM `customer`\n// LEFT JOIN `order` ON `order`.`customer_id` = `customer`.`id`\n// WHERE `order`.`status` = 1\n// \n// SELECT * FROM `order` WHERE `customer_id` IN (...)\n$customers = Customer::find()\n    - select('customer.*')\n    - leftJoin('order', '`order`.`customer_id` = `customer`.`id`')\n    - where(['order.status' =  Order::STATUS_ACTIVE])\n    - with('orders')\n    - all();   Nota  E' importante togliere l'ambiguit\u00e0 ai nomi delle colonne quando si creano query relazionali che coinvolgono istruzioni SQL  JOIN . Una pratica comune \u00e8 di anteporre i nomi delle colonne ai loro nomi di tabelle corrispondenti.   Tuttavia, un approccio migliore \u00e8 quello di sfruttare le dichiarazioni di relazione esistenti chiamando  yii \\ db \\ ActiveQuery :: joinWith() :  $customers = Customer::find()\n    - joinWith('orders')\n    - where(['order.status' =  Order::STATUS_ACTIVE])\n    - all();  Entrambi gli approcci eseguono lo stesso insieme di istruzioni SQL. Quest'ultimo approccio \u00e8 molto pi\u00f9 pulito e asciutto, per\u00f2.  Per impostazione predefinita, nel metodo  joinWith()  verr\u00e0 utilizzato il comando  LEFT JOIN  per unirsi alla tabella primaria con la tabella correlata. \u00c8 possibile specificare un tipo di join diverso (ad esempio  RIGHT JOIN ) tramite il terzo parametro  $joinType . Se il tipo di join desiderato \u00e8  INNER JOIN , puoi semplicemente chiamare il metodo  innerJoinWith() .  Chiamare  joinWith()  caricher\u00e0 avidamente i dati relativi per impostazione predefinita. Se non vuoi inserire i dati relativi, puoi specificare il suo secondo parametro  $eagerLoading  a  false .   Nota  Anche quando si utilizza  joinWith()  o  innerJoinWith()  con l'eager loading attivato, i dati correlati non verranno popolati dal risultato della query  JOIN . Quindi c'\u00e8 ancora una query aggiuntiva per ogni relazione unita.   Come con il metodo  with() , puoi unirti a una o pi\u00f9 relazioni; puoi personalizzare le query di relazione al volo; puoi unirti a relazioni nidificate; e puoi mescolare l'uso di  with()  e  joinWith() . Per esempio,  $customers = Customer::find()- joinWith([\n    'orders' =  function ($query) {\n        $query- andWhere([' ', 'subtotal', 100]);\n    },\n])- with('country')\n    - all();  A volte quando si uniscono due tabelle, potrebbe essere necessario specificare alcune condizioni aggiuntive nella parte  ON  della query  JOIN . Questo pu\u00f2 essere fatto chiamando il metodo  yii \\ db \\ ActiveQuery :: onCondition()  come il seguente:  // SELECT `customer`.* FROM `customer`\n// LEFT JOIN `order` ON `order`.`customer_id` = `customer`.`id` AND `order`.`status` = 1 \n// \n// SELECT * FROM `order` WHERE `customer_id` IN (...)\n$customers = Customer::find()- joinWith([\n    'orders' =  function ($query) {\n        $query- onCondition(['order.status' =  Order::STATUS_ACTIVE]);\n    },\n])- all();  Questa query sopra riportata riporta tutti i clienti e per ogni cliente riporta tutti gli ordini attivi. Si noti che questo differisce dal nostro esempio precedente che riporta solo i clienti che hanno almeno un ordine attivo.   Info  Quando  yii \\ db \\ ActiveQuery  viene specificato con una condizione tramite il metodo  onCondition() , la condizione verr\u00e0 inserita nella parte  ON  se la query implica una query  JOIN . Se la query non coinvolge un  JOIN , la condizione  on  verr\u00e0 automaticamente aggiunta alla parte  WHERE  della query. Pertanto pu\u00f2 contenere solo condizioni comprese tra le colonne della tabella correlata.",
            "title": "Joining with relations"
        },
        {
            "location": "/working-with-databases/sub-active-record/#alias-della-tabella-nelle-relazioni",
            "text": "Come notato in precedenza, quando si utilizza  JOIN  in una query, \u00e8 necessario distinguere i nomi delle colonne. Per questo un alias \u00e8 definito per una tabella. Impostare un alias per la query relazionale sarebbe possibile personalizzando la query di relazione nel seguente modo:  $query- joinWith([\n    'orders' =  function ($q) {\n        $q- from(['o' =  Order::tableName()]);\n    },\n])  Ci\u00f2 sembra molto complicato e comporta l'hardcoding del nome della tabella degli oggetti correlati o delle chiamate  Order::tableName() . Dalla versione 2.0.7, Yii fornisce una scorciatoia per questo. Ora puoi definire e utilizzare l'alias per la tabella delle relazioni come segue:  // join the orders relation and sort the result by orders.id\n$query- joinWith(['orders o'])- orderBy('o.id');  La sintassi precedente funziona per relazioni semplici. Se hai bisogno di un alias per una tabella intermedia quando ti unisci alle relazioni annidate [ $query- joinWith(['orders.product']) ], per esempio, puoi nidificare le chiamate  joinWith  come nell'esempio seguente:  $query- joinWith(['orders o' =  function($q) {\n        $q- joinWith('product p');\n    }])\n    - where('o.amount   100');",
            "title": "Alias della tabella nelle relazioni"
        },
        {
            "location": "/working-with-databases/sub-active-record/#relazioni-inverse",
            "text": "Le dichiarazioni di relazione sono spesso reciproche tra due classi Active Record. Ad esempio,  Customer  \u00e8 correlato a  Order  tramite la relazione  orders  ed  Order  \u00e8 correlato a  Customer  tramite la relazione  customer .  class Customer extends ActiveRecord{\n    public function getOrders(){\n\n        return $this- hasMany(Order::className(), ['customer_id' =  'id']);\n    }\n}\n\nclass Order extends ActiveRecord{\n\n    public function getCustomer(){\n\n        return $this- hasOne(Customer::className(), ['id' =  'customer_id']);\n    }\n}  Ora considera il seguente pezzo di codice:  // SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::findOne(123);\n\n// SELECT * FROM `order` WHERE `customer_id` = 123\n$order = $customer- orders[0];\n\n// SELECT * FROM `customer` WHERE `id` = 123\n$customer2 = $order- customer;\n\n// displays \"not the same\"\necho $customer2 === $customer ? 'same' : 'not the same';  A questo punto, penseremmo che  $customer  e  $customer2  siano uguali, ma non lo sono! In realt\u00e0 contengono gli stessi dati dei clienti, ma sono oggetti diversi. Durante l'accesso  $order- customer , viene eseguita un'istruzione SQL aggiuntiva per popolare un nuovo oggetto  $customer2 .  Per evitare l'esecuzione ridondante dell'ultima istruzione SQL nell'esempio precedente, dovremmo dire a Yii che  customer  \u00e8 una relazione inversa di  orders  chiamando il metodo  inverseOf()  come mostrato di seguito:  class Customer extends ActiveRecord{\n\n    public function getOrders(){\n\n        return $this- hasMany(Order::className(), ['customer_id' =  'id'])- inverseOf('customer');\n    }\n}  Con questa dichiarazione di relazione modificata, avremo:  // SELECT * FROM `customer` WHERE `id` = 123\n$customer = Customer::findOne(123);\n\n// SELECT * FROM `order` WHERE `customer_id` = 123\n$order = $customer- orders[0];\n\n// No SQL will be executed\n$customer2 = $order- customer;\n\n// displays \"same\"\necho $customer2 === $customer ? 'same' : 'not the same';   Nota  Le relazioni inverse non possono essere definite relazioni che coinvolgono una junction table. Cio\u00e8, se una relazione \u00e8 definita con il metodo  via()  o  viaTable() , non c'\u00e8 bisogno di chiamare il metodo  inverseOf() .",
            "title": "Relazioni inverse"
        },
        {
            "location": "/working-with-databases/sub-active-record/#salvataggio-delle-relazioni",
            "text": "Quando si lavora con dati relazionali, \u00e8 spesso necessario stabilire relazioni tra dati diversi o distruggere relazioni esistenti. Ci\u00f2 richiede l'impostazione di valori appropriati per le colonne che definiscono le relazioni. Usando Active Record, potresti finire per scrivere il codice come segue:  $customer = Customer::findOne(123);\n$order = new Order();\n$order- subtotal = 100;\n// ...\n\n// setting the attribute that defines the \"customer\" relation in Order\n$order- customer_id = $customer- id;\n$order- save();  Active Record fornisce il metodo  link()  che consente di svolgere questo compito in modo pi\u00f9 efficace:  $customer = Customer::findOne(123);\n$order = new Order();\n$order- subtotal = 100;\n// ...\n\n$order- link('customer', $customer);  Il metodo  link()  richiede di specificare il nome della relazione e l'istanza dell'Active Record di destinazione con cui deve essere stabilita la relazione. Il metodo modificher\u00e0 i valori degli attributi che collegano due istanze Active Record e li salvano nel database. Nell'esempio sopra, imposter\u00e0 l'attributo  customer_id  dell'istanza  Order  come valore dell'attributio  id  dell'istanza  Customer  e quindi lo salver\u00e0 nel database.   Nota  Non \u00e8 possibile collegare due istanze Active Record appena create.   Il vantaggio dell'uso del metodo  link()  \u00e8 ancora pi\u00f9 evidente quando una relazione viene definita tramite una tabella di giunzione. Ad esempio, \u00e8 possibile utilizzare il codice seguente per collegare un'istanza  Order  con un'istanza  Item :  $order- link('items', $item);  Il codice scritto sopra inserir\u00e0 automaticamente una riga nella tabella di giunzione  order_item  per mettere in relazione l'ordine con l'articolo.   Info  Il metodo  link()  NON esegue alcuna convalida dei dati durante il salvataggio dell'istanza Active Record interessata. \u00c8 tua responsabilit\u00e0 convalidare qualsiasi dato di input prima di chiamare questo metodo.   L'operazione opposta a  link()  \u00e8  unlink()  che interrompe una relazione esistente tra due istanze Active Record. Per esempio,  $customer = Customer::find()- with('orders')- where(['id' =  123])- one();\n$customer- unlink('orders', $customer- orders[0]);  Per impostazione predefinita, il metodo  unlink()  imposter\u00e0 i valori della chiave esterna che specificano la relazione esistente a  null . Tuttavia, \u00e8 possibile scegliere di eliminare la riga della tabella che contiene il valore della chiave esterna passando il parametro  $delete  con valore  true  al metodo.  Quando una tabella di giunzione \u00e8 coinvolta in una relazione, la chiamata di  unlink()  provoca la cancellazione delle chiavi esterne nella tabella di giunzione o la cancellazione della riga corrispondente nella tabella di giuntura, se il valore di  $delete  \u00e8  true .",
            "title": "Salvataggio delle relazioni"
        },
        {
            "location": "/working-with-databases/sub-active-record/#relazioni-tra-database",
            "text": "Active Record consente di dichiarare le relazioni tra classi Active Record alimentate da diversi database. I database possono essere di tipi diversi (ad esempio MySQL e PostgreSQL, o MS SQL e MongoDB) e possono essere eseguiti su server diversi. \u00c8 possibile utilizzare la stessa sintassi per eseguire query relazionali. Per esempio,  // Customer is associated with the \"customer\" table in a relational database (e.g. MySQL)\nclass Customer extends \\yii\\db\\ActiveRecord{\n\n    public static function tableName(){\n\n        return 'customer';\n    }\n\n    public function getComments(){\n\n        // a customer has many comments\n        return $this- hasMany(Comment::className(), ['customer_id' =  'id']);\n    }\n}\n\n// Comment is associated with the \"comment\" collection in a MongoDB database\nclass Comment extends \\yii\\mongodb\\ActiveRecord{\n\n    public static function collectionName(){\n\n        return 'comment';\n    }\n\n    public function getCustomer(){\n\n        // a comment has one customer\n        return $this- hasOne(Customer::className(), ['id' =  'customer_id']);\n    }\n}\n\n$customers = Customer::find()- with('comments')- all();  \u00c8 possibile utilizzare la maggior parte delle funzioni di query relazionali descritte in questa sezione.   Nota  L'utilizzo del metodo  joinWith()  \u00e8 limitato ai database che consentono query  JOIN  tra database. Per questo motivo, non \u00e8 possibile utilizzare questo metodo nell'esempio precedente poich\u00e9 MongoDB non supporta la  JOIN .",
            "title": "Relazioni tra database"
        },
        {
            "location": "/working-with-databases/sub-active-record/#personalizzazione-delle-classi-di-query",
            "text": "Per impostazione predefinita, tutte le query degli Active Record sono supportate da  yii \\ db \\ ActiveQuery . Per utilizzare una classe di query personalizzata in una classe Active Record, \u00e8 necessario eseguire l'override del metodo  yii \\ db \\ ActiveRecord :: find()  e restituire un'istanza della classe di query personalizzata. Per esempio,  // file Comment.php\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass Comment extends ActiveRecord{\n\n    public static function find(){\n\n        return new CommentQuery(get_called_class());\n    }\n}  Ora, quando si esegue una query (ad esempio  find() ,  findOne() ) o si definisce una relazione (ad esempio  hasOne() ) la classe  Comment , si chiamer\u00e0 un'istanza  CommentQuery  anzich\u00e9  ActiveQuery .  Ora devi definire la classe  CommentQuery , che pu\u00f2 essere personalizzata in molti modi creativi per migliorare la tua esperienza nella creazione di query. Per esempio,  // file CommentQuery.php\nnamespace app\\models;\n\nuse yii\\db\\ActiveQuery;\n\nclass CommentQuery extends ActiveQuery{\n\n    // conditions appended by default (can be skipped)\n    public function init(){\n\n        $this- andOnCondition(['deleted' =  false]);\n        parent::init();\n    }\n\n    // ... add customized query methods here ...\n\n    public function active($state = true){\n\n        return $this- andOnCondition(['active' =  $state]);\n    }\n}   Nota  Invece di chiamare  onCondition() , di solito si dovrebbe chiamare il metodo  andOnCondition()  o  orOnCondition()  per aggiungere ulteriori condizioni al momento di definire nuovi metodi di costruzione di query in modo che le eventuali condizioni esistenti non vengono sovrascritti.   Questo ti permette di scrivere il codice di costruzione della query come il seguente:  $comments = Comment::find()- active()- all();\n$inactiveComments = Comment::find()- active(false)- all();   Tip  Nei progetti di grandi dimensioni, si consiglia di utilizzare classi di query personalizzate per conservare la maggior parte del codice relativo alle query in modo che le classi Active Record possano essere mantenute pulite.   \u00c8 inoltre possibile utilizzare i nuovi metodi di creazione di query quando si definiscono relazioni  Comment  e si esegue una query relazionale:  class Customer extends \\yii\\db\\ActiveRecord{\n\n    public function getActiveComments(){\n\n        return $this- hasMany(Comment::className(), ['customer_id' =  'id'])- active();\n    }\n}\n\n$customers = Customer::find()- joinWith('activeComments')- all();\n\n// or alternatively\nclass Customer extends \\yii\\db\\ActiveRecord{\n\n    public function getComments(){\n\n        return $this- hasMany(Comment::className(), ['customer_id' =  'id']);\n    }\n}\n\n$customers = Customer::find()- joinWith([\n    'comments' =  function($q) {\n        $q- active();\n    }\n])- all();   Info  In Yii 1.1, c'\u00e8 un concetto chiamato  scope  . L'ambito non \u00e8 pi\u00f9 supportato direttamente in Yii 2.0 e per raggiungere lo stesso obiettivo \u00e8 necessario utilizzare classi di query e metodi di query personalizzati.",
            "title": "Personalizzazione delle classi di query"
        },
        {
            "location": "/working-with-databases/sub-active-record/#selezione-di-campi-aggiuntivi",
            "text": "Quando l'istanza Active Record viene popolata dai risultati della query, i relativi attributi vengono riempiti dai corrispondenti valori di colonna dal set di dati ricevuti.  \u00c8 possibile recuperare ulteriori colonne o valori dalla query e memorizzarli all'interno dell'Active Record. Ad esempio, supponiamo di avere una tabella di nome  room , che contiene informazioni sulle camere disponibili nell'hotel. Ogni camera memorizza le informazioni sulle sue dimensioni geometriche utilizzando i campi  length ,  width ,  height . Immagina di dover recuperare l'elenco di tutte le stanze disponibili con il loro volume in ordine discendente. Quindi non puoi calcolare il volume usando PHP, perch\u00e9 abbiamo bisogno di ordinare i record in base al suo valore, ma tu vuoi anche che il volume possa essere visualizzato nella lista. Per raggiungere l'obiettivo, \u00e8 necessario dichiarare un campo aggiuntivo nella classe  Room  Active Record,che memorizzer\u00e0 il valore  volume :  class Room extends \\yii\\db\\ActiveRecord\n{\n    public $volume;\n\n    // ...\n}  Quindi \u00e8 necessario comporre una query, che calcola il volume della stanza ed esegue l'ordinamento:  $rooms = Room::find()\n    - select([\n        '{{room}}.*', // select all columns\n        '([[length]] * [[width]] * [[height]]) AS volume', // calculate a volume\n    ])\n    - orderBy('volume DESC') // apply sort\n    - all();\n\nforeach ($rooms as $room) {\n    echo $room- volume; // contains value calculated by SQL\n}  La possibilit\u00e0 di selezionare campi aggiuntivi pu\u00f2 essere eccezionalmente utile per le query di aggregazione. Supponiamo di dover visualizzare un elenco di clienti con il conteggio degli ordini effettuati. Prima di tutto, \u00e8 necessario dichiarare una classe  Customer  con una relazione  orders  e campo aggiuntivo per la memorizzazione dei conteggi:  class Customer extends \\yii\\db\\ ActiveRecord{\n\n    public $ordersCount;\n\n    // ...\n\n    public function getOrders(){\n\n        return $this- hasMany(Order::className(), ['customer_id' =  'id']);\n    }\n}  Quindi puoi comporre una query, che unisce gli ordini e calcola il loro conteggio:  $customers = Customer::find()\n    - select([\n        '{{customer}}.*', // select all customer fields\n        'COUNT({{order}}.id) AS ordersCount' // calculate orders count\n    ])\n    - joinWith('orders') // ensure table junction\n    - groupBy('{{customer}}.id') // group the result to ensure aggregation function works\n    - all();  Uno svantaggio dell'utilizzo di questo metodo sarebbe che, se l'informazione non \u00e8 caricata nella query SQL, deve essere calcolata separatamente. Pertanto, se hai trovato record particolari tramite query regolari senza istruzioni select extra, non sar\u00e0 in grado di restituire il valore effettivo per il campo extra. Lo stesso accadr\u00e0 per il record appena salvato.  $room = new Room();\n$room- length = 100;\n$room- width = 50;\n$room- height = 2;  $   room- volume; // this value will be  null , since it was not declared yet  Usando i metodi magici  __get()  e  __set()  possiamo emulare il comportamento di una propriet\u00e0:  class Room extends \\yii\\db\\ActiveRecord{\n\n    private $_volume;\n\n    public function setVolume($volume){\n\n        $this- _volume = (float) $volume;\n    }\n\n    public function getVolume(){\n\n        if (empty($this- length) || empty($this- width) || empty($this- height)) {\n            return null;\n        }\n\n        if ($this- _volume === null) {\n            $this- setVolume(\n                $this- length * $this- width * $this- height\n            );\n        }\n\n        return $this- _volume;\n    }\n\n    // ...\n}  Quando la query di selezione non fornisce il volume, il modello sar\u00e0 in grado di calcolarlo automaticamente utilizzando gli attributi del modello.  Puoi anche calcolare i campi di aggregazione usando le relazioni definite:  class Customer extends \\yii\\db\\ActiveRecord{\n\n    private $_ordersCount;\n\n    public function setOrdersCount($count){\n\n        $this- _ordersCount = (int) $count;\n    }\n\n    public function getOrdersCount(){\n\n        if ($this- isNewRecord) {\n            return null; // this avoid calling a query searching for null primary keys\n        }\n\n        if ($this- _ordersCount === null) {\n            $this- setOrdersCount($this- getOrders()- count()); // calculate aggregation on demand from relation\n        }\n\n        return $this- _ordersCount;\n    }\n\n    // ...\n\n    public function getOrders(){\n\n        return $this- hasMany(Order::className(), ['customer_id' =  'id']);\n    }\n}  Con questo codice, nel caso in cui  'ordersCount'  sia presente nell'istruzione  'select' - Customer::ordersCount , verr\u00e0 popolato dai risultati dell'interrogazione, altrimenti verr\u00e0 calcolato su richiesta utilizzando la relazione  Customer::orders .  Questo approccio pu\u00f2 essere utilizzato anche per la creazione delle scorciatoie per alcuni dati relazionali, in particolare per l'aggregazione. Per esempio:  class Customer extends \\yii\\db\\ActiveRecord{\n\n    /**\n    * Defines read-only virtual property for aggregation data.\n    */\n    public function getOrdersCount(){\n\n        if ($this- isNewRecord) {\n            return null; // this avoid calling a query searching for null primary keys\n        }\n\n        return empty($this- ordersAggregation) ? 0 : $this- ordersAggregation[0]['counted'];\n    }\n\n    /**\n    * Declares normal 'orders' relation.\n    */\n    public function getOrders(){\n\n        return $this- hasMany(Order::className(), ['customer_id' =  'id']);\n    }\n\n    /**\n    * Declares new relation based on 'orders', which provides aggregation.\n    */\n    public function getOrdersAggregation(){\n\n        return $this- getOrders()\n            - select(['customer_id', 'counted' =  'count(*)'])\n            - groupBy('customer_id')\n            - asArray(true);\n    }\n\n    // ...\n}\n\nforeach (Customer::find()- with('ordersAggregation')- all() as $customer) {\n    echo $customer- ordersCount; // outputs aggregation data from relation without extra query due to eager loading\n}\n\n$customer = Customer::findOne($pk);\n$customer- ordersCount; // output aggregation data from lazy loaded relation",
            "title": "Selezione di campi aggiuntivi"
        },
        {
            "location": "/working-with-databases/sub-migrations/",
            "text": "Migrazione del Database\n\n\nDurante lo sviluppo e il mantenimento di un'applicazione basata su database, la struttura del database in uso si evolve proprio come fa il codice sorgente. Ad esempio, durante lo sviluppo di un'applicazione, possiamo aver bisogno di una nuova tabella; dopo che l'applicazione \u00e8 stata distribuita in produzione, \u00e8 possibile che venga creato un indice per migliorare le prestazioni della query; e cos\u00ec via. Poich\u00e9 una modifica della struttura del database richiede spesso alcune modifiche al codice sorgente, Yii supporta la cosiddetta funzione di migrazione del database che consente di tenere traccia delle modifiche del database in termini di migrazioni del database controllate dalla versione insieme al codice sorgente.\n\n\nLe seguenti fasi mostrano come la migrazione del database pu\u00f2 essere utilizzata da un team durante lo sviluppo:\n\n\n\n\nLuca crea una nuova migrazione (ad esempio crea una nuova tabella, cambia una definizione di colonna, ecc.).\n\n\nLuca usa la nuova migrazione nel sistema di controllo del codice sorgente (es. Git, Mercurial).\n\n\nAndrea aggiorna il suo repository dal sistema di controllo del codice sorgente e riceve la nuova migrazione.\n\n\nAndrea applica la migrazione al suo database di sviluppo locale, sincronizzando cos\u00ec il suo database per riflettere le modifiche apportate da Tim.\n\n\n\n\nE i seguenti passaggi mostrano come distribuire una nuova versione con le migrazioni del database alla produzione:\n\n\n\n\nScott crea un tag di rilascio per il repository del progetto che contiene alcune nuove migrazioni del database.\n\n\nScott aggiorna il codice sorgente sul server di produzione sul tag di rilascio.\n\n\nScott applica eventuali migrazioni di database accumulate al database di produzione.\n\n\n\n\nYii fornisce una serie di strumenti per la riga di comando di migrazione che consentono di:\n\n\n\n\ncreare nuove migrazioni;\n\n\napplicare le migrazioni;\n\n\nripristinare le migrazioni;\n\n\nriapplicare le migrazioni;\n\n\nmostra la cronologia e lo stato della migrazione.\n\n\n\n\nTutti questi strumenti sono accessibili tramite il comando \nyii migrate\n. In questa sezione descriveremo in dettaglio come eseguire varie attivit\u00e0 utilizzando questi strumenti. \u00c8 inoltre possibile ottenere l'utilizzo di ogni strumento tramite il comando di aiuto \nyii help migrate\n.\n\n\n\n\nTip\n\n\nLe migrazioni potrebbero influire non solo sullo schema del database, ma anche sui dati esistenti per adattarsi al nuovo schema, creare la gerarchia RBAC o pulire la cache.\n\n\n\n\nCreazione di una migrazione\n\n\nPer creare una nuova migrazione, eseguire il seguente comando:\n\n\nyii migrate/create \nname\n\n\n\n\nL'argomento \nname\n richiesto fornisce una breve descrizione della nuova migrazione. Ad esempio, se la migrazione riguarda la creazione di una nuova tabella denominata \nnotizie\n, \u00e8 possibile utilizzare il nome \ncreate_news_table\n ed eseguire il seguente comando:\n\n\nyii migrate/create create_news_table\n\n\n\n\n\nNota\n\n\nPoich\u00e9 l'argomento \nname\n verr\u00e0 utilizzato come parte del nome della classe di migrazione generato, dovrebbe contenere solo lettere, cifre e / o caratteri di sottolineatura.\n\n\n\n\nIl comando precedente creer\u00e0 un nuovo file di classe PHP chiamato \nm150101_185401_create_news_table.php\n nella \n@app/migrationsdirectory\n. Il file contiene il seguente codice che dichiara principalmente una classe di migrazione \nm150101_185401_create_news_table\n con il codice scheletro:\n\n\n?php\n\nuse yii\\db\\Migration;\n\nclass m150101_185401_create_news_table extends Migration{\n\n    public function up(){\n\n    }\n\n    public function down(){\n\n        echo \"m101129_185401_create_news_table cannot be reverted.\\n\";\n\n        return false;\n    }\n\n    /*\n    // Use safeUp/safeDown to run migration code within a transaction\n    public function safeUp(){\n\n    }\n\n    public function safeDown(){\n\n    }\n    */\n}\n\n\n\nOgni migrazione del database \u00e8 definita come una classe PHP che si estende da \nyii \\ db \\ Migration\n. Il nome della classe di migrazione viene generato automaticamente nel formato di \nm\nYYMMDD_HHMMSS\n_\nName\n, dove\n\n\n\n\nYYMMDD_HHMMSS\n fa riferimento al datetime UTC in cui viene eseguito il comando di creazione della migrazione.\n\n\nName\n \u00e8 uguale al valore dell'argomento \nname\n che fornisci al comando.\n\n\n\n\nNella classe di migrazione, \u00e8 previsto che si scriva codice nel metodo \nup()\n che apporta modifiche alla struttura del database. Si consiglia inoltre di scrivere il codice nel metodo \ndown()\n per annullare le modifiche apportate da \nup()\n. Il metodo \nup()\n viene richiamato quando si aggiorna il database con questa migrazione, mentre il metodo \ndown()\n viene richiamato quando si esegue il downgrade del database. Il codice seguente mostra come \u00e8 possibile implementare la classe di migrazione per creare una tabella \nnews\n:\n\n\n?php\n\nuse yii\\db\\Schema;\nuse yii\\db\\Migration;\n\nclass m150101_185401_create_news_table extends Migration{\n\n    public function up(){\n\n            $this-\ncreateTable('news', [\n            'id' =\n Schema::TYPE_PK,\n            'title' =\n Schema::TYPE_STRING . ' NOT NULL',\n            'content' =\n Schema::TYPE_TEXT,\n        ]);\n    }\n\n    public function down(){\n\n        $this-\ndropTable('news');\n    }\n}\n\n\n\n\n\nInfo\n\n\nNon tutte le migrazioni sono reversibili. Ad esempio, se il metodo \nup()\n elimina una riga di una tabella, potresti non essere in grado di recuperare questa riga nel metodo \ndown()\n. A volte, potresti essere troppo pigro per implementare il metodo \ndown()\n, perch\u00e9 non \u00e8 molto comune ripristinare le migrazioni del database. In questo caso, \u00e8 necessario tornare un valore \nfalse\n nel metodo \ndown()\n per indicare che la migrazione non \u00e8 reversibile.\n\n\n\n\nLa classe di migrazione di base \nyii \\ db \\ Migration\n espone una connessione al database tramite la propriet\u00e0 \ndb\n. \u00c8 possibile utilizzarlo per manipolare lo schema del database utilizzando i metodi descritti in \"Operazioni con lo schema del database\".\n\n\nAnzich\u00e9 utilizzare tipi fisici, durante la creazione di una tabella o colonna \u00e8 necessario utilizzare i tipi astratti in modo che le migrazioni siano indipendenti da DBMS specifici. La classe \nyii \\ db \\ Schema\n definisce un insieme di costanti per rappresentare i tipi astratti supportati. Queste costanti sono denominate nel formato di \nTYPE_\nName\n. Ad esempio, \nTYPE_PK\n si riferisce al tipo di chiave primaria auto-incrementale; \nTYPE_STRING\n si riferisce a un tipo di stringa. Quando una migrazione viene applicata a un determinato database, i tipi astratti verranno tradotti nei corrispondenti tipi fisici. Nel caso di MySQL, \nTYPE_PK\n verr\u00e0 trasformato in \nint(11) NOT NULL AUTO_INCREMENT PRIMARY KEY\n, mentre \nTYPE_STRING\ndiventa \nvarchar(255)\n.\n\n\n\u00c8 possibile aggiungere ulteriori vincoli quando si utilizzano i tipi astratti. Nell'esempio sopra, \nNOT NULL\n viene aggiunto a \nSchema::TYPE_STRING\n per specificare che la colonna non pu\u00f2 essere \nnull\n.\n\n\n\n\nInfo\n\n\nLa mappatura tra tipi astratti e tipi fisici \u00e8 specificata dalla propriet\u00e0 \n$typeMap\n in ogni clsse \nQueryBuilder\n.\n\n\n\n\nDalla versione 2.0.6, \u00e8 possibile utilizzare il generatore di schemi appena introdotto che fornisce un modo pi\u00f9 conveniente di definire lo schema di colonna. Quindi la migrazione sopra potrebbe essere scritta come la seguente:\n\n\n?php\n\nuse yii\\db\\Migration;\n\nclass m150101_185401_create_news_table extends Migration{\n\n    public function up(){\n\n        $this-\ncreateTable('news', [\n            'id' =\n $this-\nprimaryKey(),\n            'title' =\n $this-\nstring()-\nnotNull(),\n            'content' =\n $this-\ntext(),\n        ]);\n    }\n\n    public function down(){\n\n        $this-\ndropTable('news');\n    }\n}\n\n\n\nUn elenco di tutti i metodi disponibili per la definizione dei tipi di colonna \u00e8 disponibile nella documentazione API di \nyii \\ db \\ SchemaBuilderTrait\n.\n\n\nGenerare una migrazioni\n\n\nLa console di migrazione della versione 2.0.7 offre un modo conveniente per creare migrazioni.\n\n\nSe il nome della migrazione \u00e8 di un modulo speciale, ad esempio \ncreate_xxx_table\n o \ndrop_xxx_table\n il file di migrazione generato conterr\u00e0 codice aggiuntivo, in questo caso la creazione / eliminazione di tabelle. Di seguito sono descritte tutte le varianti di questa funzione.\n\n\nCreazione di una tabella\n\n\nyii migrate/create create_post_table\n\n\n\ngenera\n\n\n/**\n* Handles the creation for table `post`.\n*/\n\nclass m150811_220037_create_post_table extends Migration{\n\n    /**\n    * @inheritdoc\n    */\n    public function up(){\n\n        $this-\ncreateTable('post', [\n            'id' =\n $this-\nprimaryKey()\n        ]);\n    }\n\n    /**\n    * @inheritdoc\n    */\n    public function down(){\n\n        $this-\ndropTable('post');\n    }\n}\n\n\n\nPer creare subito i campi tabella, dobbiamo specificarli tramite l'opzione \n--fields\n.\n\n\nyii migrate/create create_post_table --fields=\"title:string,body:text\"\n\n\n\ngenera\n\n\n/**\n* Handles the creation for table `post`.\n*/\nclass m150811_220037_create_post_table extends Migration{\n\n    /**\n    * @inheritdoc\n    */\n    public function up(){\n\n        $this-\ncreateTable('post', [\n            'id' =\n $this-\nprimaryKey(),\n            'title' =\n $this-\nstring(),\n            'body' =\n $this-\ntext(),\n        ]);\n    }\n\n    /**\n    * @inheritdoc\n    */\n    public function down(){\n\n        $this-\ndropTable('post');\n    }\n}\n\n\n\n\u00c8 possibile specificare pi\u00f9 parametri di campo.\n\n\nyii migrate/create create_post_table --fields=\"title:string(12):notNull:unique,body:text\"\n\n\n\ngenera\n\n\n/**\n * Handles the creation for table `post`.\n*/\nclass m150811_220037_create_post_table extends Migration{\n\n    /**\n    * @inheritdoc\n    */\n    public function up(){\n\n        $this-\ncreateTable('post', [\n            'id' =\n $this-\nprimaryKey(),\n            'title' =\n $this-\nstring(12)-\nnotNull()-\nunique(),\n            'body' =\n $this-\ntext()\n        ]);\n    }\n\n    /**\n    * @inheritdoc\n    */\n    public function down(){\n\n        $this-\ndropTable('post');\n    }\n}\n\n\n\n\n\nNota\n\n\nLa chiave primaria viene aggiunta automaticamente e viene denominata \nid\n per impostazione predefinita. Se vuoi usare un altro nome, puoi specificarlo esplicitamente \n--fields=\"name:primaryKey\"\n.\n\n\n\n\nChiavi esterne (foreign key)\n\n\nDal momento che 2.0.8 il generatore supporta chiavi esterne utilizzando la la chiave \nforeignKey\n.\n\n\nyii migrate/create create_post_table --fields=\"author_id:integer:notNull:foreignKey(user),category_id:integer:defaultValue(1):foreignKey,title:string,body:text\"\n\n\n\ngenera\n\n\n/**\n* Handles the creation for table `post`.\n* Has foreign keys to the tables:\n*\n* - `user`\n* - `category`\n*/\nclass m160328_040430_create_post_table extends Migration{\n\n    /**\n    * @inheritdoc\n    */\n    public function up(){\n\n        $this-\ncreateTable('post', [\n            'id' =\n $this-\nprimaryKey(),\n            'author_id' =\n $this-\ninteger()-\nnotNull(),\n            'category_id' =\n $this-\ninteger()-\ndefaultValue(1),\n            'title' =\n $this-\nstring(),\n            'body' =\n $this-\ntext(),\n        ]);\n\n        // creates index for column `author_id`\n        $this-\ncreateIndex(\n            'idx-post-author_id',\n            'post',\n            'author_id'\n        );\n\n        // add foreign key for table `user`\n        $this-\naddForeignKey(\n            'fk-post-author_id',\n            'post',\n            'author_id',\n            'user',\n            'id',\n            'CASCADE'\n        );\n\n        // creates index for column `category_id`\n        $this-\ncreateIndex(\n            'idx-post-category_id',\n            'post',\n            'category_id'\n        );\n\n        // add foreign key for table `category`\n        $this-\naddForeignKey(\n            'fk-post-category_id',\n            'post',\n            'category_id',\n            'category',\n            'id',\n            'CASCADE'\n        );\n    }\n\n    /**\n    * @inheritdoc\n    */\n    public function down(){\n\n        // drops foreign key for table `user`\n        $this-\ndropForeignKey(\n            'fk-post-author_id',\n            'post'\n        );\n\n        // drops index for column `author_id`\n        $this-\ndropIndex(\n            'idx-post-author_id',\n            'post'\n        );\n\n        // drops foreign key for table `category`\n        $this-\ndropForeignKey(\n            'fk-post-category_id',\n            'post'\n        );\n\n        // drops index for column `category_id`\n        $this-\ndropIndex(\n            'idx-post-category_id',\n            'post'\n        );\n\n        $this-\ndropTable('post');\n    }\n}\n\n\n\nLa posizione della parola chiave \nforeignKey\n nella descrizione della colonna non modifica il codice generato. Questo significa:\n\n\n\n\nauthor_id:integer:notNull:foreignKey(user)\n\n\nauthor_id:integer:foreignKey(user):notNull\n\n\nauthor_id:foreignKey(user):integer:notNull\n\n\n\n\nTutti generano lo stesso codice.\n\n\nLa parola chiave \nforeignKey\n pu\u00f2 prendere un parametro tra parentesi che sar\u00e0 il nome della tabella correlata per la chiave esterna generata. Se non viene passato alcun parametro, il nome della tabella sar\u00e0 dedotto dal nome della colonna.\n\n\nNell'esempio sopra \nauthor_id:integer:notNull:foreignKey(user)\n generer\u00e0 una colonna denominata \nauthor_id\n con una chiave esterna per la tabella \nuser\n mentre \ncategory_id:integer:defaultValue(1):foreignKey\n generer\u00e0 una colonna \ncategory_id\n con una chiave esterna per la tabella \ncategory\n.\n\n\nDalla 2.0.11, la parola chiave \nforeignKey\n accetta un secondo parametro, separato da uno spazio bianco. Accetta il nome della colonna correlata per la chiave esterna generata. Se non viene passato nessun secondo parametro, il nome della colonna verr\u00e0 recuperato dallo schema della tabella. Se non esiste uno schema, la chiave primaria non \u00e8 impostata o \u00e8 composta, e verr\u00e0 utilizzato il nome predefinito \nid\n.\n\n\nDrop Table\n\n\nyii migrate/create drop_post_table --fields=\"title:string(12):notNull:unique,body:text\"\n\n\n\ngenera\n\n\nclass m150811_220037_drop_post_table extends Migration{\n\n    public function up(){\n\n        $this-\ndropTable('post');\n    }\n\n    public function down(){\n\n        $this-\ncreateTable('post', [\n            'id' =\n $this-\nprimaryKey(),\n            'title' =\n $this-\nstring(12)-\nnotNull()-\nunique(),\n            'body' =\n $this-\ntext()\n        ]);\n    }\n}\n\n\n\nAggiungere una colonna\n\n\nSe il nome della migrazione \u00e8 del modulo, il contenuto del file \nadd_xxx_column_to_yyy_table\n conterr\u00e0 \naddColumn\n e le istruzioni necessarie \ndropColumn\n.\n\n\nPer aggiungere una colonna:\n\n\nyii migrate/create add_position_column_to_post_table --fields=\"position:integer\"\n\n\n\ngenera\n\n\nclass m150811_220037_add_position_column_to_post_table extends Migration{\n\n    public function up(){\n\n        $this-\naddColumn('post', 'position', $this-\ninteger());\n    }\n\n    public function down(){\n\n        $this-\ndropColumn('post', 'position');\n    }\n}\n\n\n\n\u00c8 possibile specificare pi\u00f9 colonne come segue:\n\n\nyii migrate/create add_xxx_column_yyy_column_to_zzz_table --fields=\"xxx:integer,yyy:text\"\n\n\n\nDrop Column\n\n\nSe il nome della migrazione \u00e8 del modulo, il contenuto del file \ndrop_xxx_column_from_yyy_table\n conterr\u00e0 \naddColumn\n e le istruzioni necessarie \ndropColumn\n.\n\n\nyii migrate/create drop_position_column_from_post_table --fields=\"position:integer\"\n\n\n\ngenera\n\n\nclass m150811_220037_drop_position_column_from_post_table extends Migration{\n\n    public function up(){\n\n        $this-\ndropColumn('post', 'position');\n    }\n\n    public function down(){\n\n        $this-\naddColumn('post', 'position', $this-\ninteger());\n    }\n}\n\n\n\nAggiungi tuan \"Junction Table\"\n\n\nSe il nome della migrazione \u00e8 nella forma \ncreate_junction_table_for_xxx_and_yyy_tables\n o \ncreate_junction_xxx_and_yyy_tables\n, significa che \u00e8 necessario creare una tabella di collegamento.\n\n\nyii migrate/create create_junction_table_for_post_and_tag_tables --fields=\"created_at:dateTime\"\n\n\n\ngenera\n\n\n/**\n* Handles the creation for table `post_tag`.\n* Has foreign keys to the tables:\n*\n* - `post`\n* - `tag`\n*/\nclass m160328_041642_create_junction_table_for_post_and_tag_tables extends Migration{\n\n    /**\n    * @inheritdoc\n    */\n    public function up(){\n\n        $this-\ncreateTable('post_tag', [\n            'post_id' =\n $this-\ninteger(),\n            'tag_id' =\n $this-\ninteger(),\n            'created_at' =\n $this-\ndateTime(),\n        'PRIMARY KEY(post_id, tag_id)',\n        ]);\n\n        // creates index for column `post_id`\n        $this-\ncreateIndex(\n            'idx-post_tag-post_id',\n            'post_tag',\n            'post_id'\n        );\n\n        // add foreign key for table `post`\n        $this-\naddForeignKey(\n            'fk-post_tag-post_id',\n            'post_tag',\n            'post_id',\n            'post',\n            'id',\n            'CASCADE'\n        );\n\n        // creates index for column `tag_id`\n        $this-\ncreateIndex(\n            'idx-post_tag-tag_id',\n            'post_tag',\n            'tag_id'\n        );\n\n        // add foreign key for table `tag`\n        $this-\naddForeignKey(\n            'fk-post_tag-tag_id',\n            'post_tag',\n            'tag_id',\n            'tag',\n            'id',\n            'CASCADE'\n        );\n    }\n\n    /**\n    * @inheritdoc\n    */\n    public function down(){\n\n        // drops foreign key for table `post`\n        $this-\ndropForeignKey(\n            'fk-post_tag-post_id',\n            'post_tag'\n        );\n\n        // drops index for column `post_id`\n        $this-\ndropIndex(\n            'idx-post_tag-post_id',\n            'post_tag'\n        );\n\n        // drops foreign key for table `tag`\n        $this-\ndropForeignKey(\n            'fk-post_tag-tag_id',\n        'post_tag'\n        );\n\n        // drops index for column `tag_id`\n        $this-\ndropIndex(\n            'idx-post_tag-tag_id',\n            'post_tag'\n        );\n\n        $this-\ndropTable('post_tag');\n    }\n}\n\n\n\nNel caso in cui la tabella non sia definita nello schema o la chiave primaria non sia impostata o sia composta, viene utilizzato il nome predefinito \nid\n.\n\n\nMigrazioni transazionali\n\n\nDurante l'esecuzione di migrazioni di DB complesse, \u00e8 importante garantire che ogni migrazione abbia esito positivo o negativo nel suo insieme, in modo che il database possa mantenere integrit\u00e0 e coerenza. Per raggiungere questo obiettivo,si consiglia di includere le operazioni DB di ogni migrazione in una transazione .\n\n\nUn modo ancora pi\u00f9 semplice di implementare le migrazioni transazionali \u00e8 inserire il codice di migrazione nei metodi \nsafeUp()\n e \nsafeDown()\n. Questi due metodi differiscono da \nup()\n e \ndown()\n in quanto sono inclusi implicitamente in una transazione. Di conseguenza, se qualsiasi operazione in questi metodi fallisce, tutte le operazioni precedenti verranno automaticamente ripristinate.\n\n\nNell'esempio seguente, oltre a creare la tabella \nnews\n, inseriamo anche una riga iniziale in questa tabella.\n\n\n?php\n\nuse yii\\db\\Migration;\n\nclass m150101_185401_create_news_table extends Migration{\n\n    public function safeUp(){\n\n        $this-\ncreateTable('news', [\n            'id' =\n $this-\nprimaryKey(),\n            'title' =\n $this-\nstring()-\nnotNull(),\n            'content' =\n $this-\ntext(),\n        ]);\n\n        $this-\ninsert('news', [\n            'title' =\n 'test 1',\n            'content' =\n 'content 1',\n        ]);\n    }\n\n    public function safeDown(){\n\n        $this-\ndelete('news', ['id' =\n 1]);\n        $this-\ndropTable('news');\n    }\n}\n\n\n\nSi noti che di solito quando si eseguono pi\u00f9 operazioni DB in \nsafeUp()\n, \u00e8 necessario invertire il loro ordine di esecuzione \nsafeDown()\n. Nell'esempio sopra, prima creiamo la tabella e poi inseriamo una riga in \nsafeUp()\n; mentre in \nsafeDown()\n prima eliminiamo la riga e poi rilasciamo la tabella.\n\n\n\n\nWarning\n\n\nNon tutti i DBMS supportano le transazioni. E alcune query DB non possono essere inserite in una transazione. Per alcuni esempi, fai riferimento a commit impliciti. Se questo \u00e8 il caso, dovresti comunque implementare \nup()\n e \ndown()\n, invece.\n\n\n\n\nMetodi di accesso al database\n\n\nLa classe di migrazione di base \nyii \\ db \\ Migration\n fornisce un insieme di metodi per consentire l'accesso e la manipolazione dei database. \u00c8 possibile che questi metodi vengano denominati in modo simile ai metodi DAO forniti dalla classe \nyii \\ db \\ Command\n. Ad esempio, il metodo \nyii \\ db \\ Migration :: createTable()\n consente di creare una nuova tabella, proprio come fa \nyii \\ db \\ Command :: createTable()\n.\n\n\nIl vantaggio dell'utilizzo dei metodi forniti da \nyii \\ db \\ Migration\n \u00e8 che non \u00e8 necessario creare esplicitamente istanze \nyii \\ db \\ Command\n e l'esecuzione di ogni metodo mostrer\u00e0 automaticamente messaggi utili che indicano quali operazioni di database sono eseguite e quanto tempo prendere.\n\n\nDi seguito \u00e8 riportato l'elenco di tutti questi metodi di accesso al database:\n\n\n\n\nexecute()\n: esecuzione di un'istruzione SQL\n\n\ninsert()\n: inserimento di una singola riga\n\n\nbatchInsert()\n: inserimento di pi\u00f9 righe\n\n\nupdate()\n: aggiornamento delle righe\n\n\ndelete()\n: eliminazione di righe\n\n\ncreateTable()\n: creazione di una tabella\n\n\nrenameTable()\n: rinomina una tabella\n\n\ndropTable()\n: rimozione di una tabella\n\n\ntruncateTable()\n: rimuove tutte le righe in una tabella\n\n\naddColumn()\n: aggiunta di una colonna\n\n\nrenameColumn()\n: rinomina una colonna\n\n\ndropColumn()\n: rimuovendo una colonna\n\n\nalterColumn()\n: modifica di una colonna\n\n\naddPrimaryKey()\n: aggiunta di una chiave primaria\n\n\ndropPrimaryKey()\n: rimozione di una chiave primaria\n\n\naddForeignKey()\n: aggiunta di una chiave esterna\n\n\ndropForeignKey()\n: rimozione di una chiave esterna\n\n\ncreateIndex()\n: creazione di un indice\n\n\ndropIndex()\n: rimozione di un indice\n\n\naddCommentOnColumn()\n: aggiunta di commenti alla colonna\n\n\ndropCommentFromColumn()\n: eliminazione del commento dalla colonna\n\n\naddCommentOnTable()\n: aggiunta di commenti alla tabella\n\n\ndropCommentFromTable()\n: eliminazione del commento dalla tabella\n\n\n\n\n\n\nInfo\n\n\nyii \\ db \\ Migration\n non fornisce un metodo di query del database. Questo perch\u00e9 normalmente non \u00e8 necessario visualizzare un messaggio aggiuntivo sul recupero dei dati da un database. \u00c8 anche possibile utilizzare il potente generatore di query per creare ed eseguire query complesse. L'utilizzo di Query Builder in una migrazione potrebbe essere simile a questo:\n\n\n// update status field for all users\nforeach((new Query)-\nfrom('users')-\neach() as $user) {\n    $this-\nupdate('users', ['status' =\n 1], ['id' =\n $user['id']]);\n}\n\n\n\n\n\n\n\nNota\n\n\nQuando si manipolano i dati utilizzando una migrazione, \u00e8 possibile che l'utilizzo delle classi Active Record, possa essere utile poich\u00e9 parte della logica \u00e8 gi\u00e0 implementata l\u00ec. Tuttavia, tenere presente che, contrariamente al codice scritto nelle migrazioni, la cui natura \u00e8 di rimanere costante per sempre, la logica dell'applicazione \u00e8 soggetta a modifiche. Pertanto, quando si utilizza l'Active Record nel codice di migrazione, le modifiche apportate alla logica nel livello Active Record possono interrompere accidentalmente le migrazioni esistenti. Per questo motivo il codice di migrazione dovrebbe essere tenuto indipendente da altre logiche applicative come le classi di record attivi.\n\n\n\n\nApplicazione delle migrazioni\n\n\nPer aggiornare un database alla sua ultima struttura, \u00e8 necessario applicare tutte le nuove migrazioni disponibili utilizzando il seguente comando:\n\n\nyii migrate\n\n\n\nQuesto comando elencher\u00e0 tutte le migrazioni che non sono state applicate finora. Se confermi di voler applicare queste migrazioni, eseguir\u00e0 il metodo \nup()\n o \nsafeUp()\n in ogni nuova classe di migrazione, una dopo l'altra, nell'ordine dei loro valori di timestamp. Se una qualsiasi delle migrazioni fallisce, il comando si chiude senza applicare il resto delle migrazioni.\n\n\n\n\nTip\n\n\nNel caso in cui tu non abbia una linea di comando sul tuo server puoi provare l' estensione della \nweb shell\n.\n\n\n\n\nPer ogni migrazione che \u00e8 stata applicata correttamente, il comando inserir\u00e0 una riga in una tabella di database chiamata \nmigration\n per registrare l'applicazione corretta della migrazione. Ci\u00f2 consentir\u00e0 allo strumento di migrazione di identificare quali migrazioni sono state applicate e quali no.\n\n\n\n\nInfo\n\n\nLo strumento di migrazione crea automaticamente la tabella \nmigration\n nel database specificato dall'opzione \ndb\n del comando. Per impostazione predefinita, il database \u00e8 specificato dal componente dell'applicazione \ndb\n.\n\n\n\n\nA volte, puoi solo applicare una o alcune nuove migrazioni, invece di tutte le migrazioni disponibili. \u00c8 possibile farlo specificando il numero di migrazioni che si desidera applicare durante l'esecuzione del comando. Ad esempio, il seguente comando prover\u00e0 ad applicare le successive tre migrazioni disponibili:\n\n\nyii migrate 3\n\n\n\n\u00c8 inoltre possibile specificare in modo esplicito una migrazione particolare a cui il database deve essere migrato utilizzando il migrate/tocomando in uno dei seguenti formati:\n\n\nyii migrate/to 150101_185401                      # using timestamp to specify the migration\nyii migrate/to \"2015-01-01 18:54:01\"              # using a string that can be parsed by strtotime()\nyii migrate/to m150101_185401_create_news_table   # using full name\nyii migrate/to 1392853618                         # using UNIX timestamp\n\n\n\nSe sono presenti migrazioni non applicate precedenti a quella specificata, verranno tutte applicate prima che venga applicata la migrazione specificata.\n\n\nSe la migrazione specificata \u00e8 gi\u00e0 stata applicata in precedenza, tutte le successive migrazioni applicate verranno ripristinate.\n\n\nRipristino delle migrazioni\n\n\nPer annullare una o pi\u00f9 migrazioni precedentemente applicate, \u00e8 possibile eseguire il seguente comando:\n\n\nyii migrate/down     # revert the most recently applied migration\nyii migrate/down 3   # revert the most 3 recently applied migrations\n\n\n\n\n\nWarning\n\n\nNon tutte le migrazioni sono reversibili. Il tentativo di annullare tali migrazioni causer\u00e0 un errore e interromper\u00e0 l'intero processo di ripristino.\n\n\n\n\nRipristino delle migrazioni\n\n\nRipristinare le migrazioni significa innanzitutto ripristinare le migrazioni specificate e quindi applicare nuovamente. Questo pu\u00f2 essere fatto come segue:\n\n\nyii migrate/redo        # redo the last applied migration\nyii migrate/redo 3      # redo the last 3 applied migrations\n\n\n\n\n\nWarning\n\n\nSe una migrazione non \u00e8 reversibile, non sar\u00e0 possibile ripristinarla.\n\n\n\n\nRefreshing delle migrazioni\n\n\nDal momento che Yii 2.0.13 \u00e8 possibile eliminare tutte le tabelle e le chiavi esterne dal database e applicare tutte le migrazioni dall'inizio.\n\n\nyii migrate/fresh       # Truncate the database and\n\n\n\nElenco delle migrazioni\n\n\nPer elencare quali migrazioni sono state applicate e quali no, puoi utilizzare i seguenti comandi:\n\n\nyii migrate/history     # showing the last 10 applied migrations\nyii migrate/history 5   # showing the last 5 applied migrations\nyii migrate/history all # showing all applied migrations\n\nyii migrate/new         # showing the first 10 new migrations\nyii migrate/new 5       # showing the first 5 new migrations\nyii migrate/new all     # showing all new migrations\n\n\n\nModifica della cronologia delle migrazioni\n\n\nInvece di applicare o ripristinare le migrazioni, a volte potresti semplicemente voler segnalare che il tuo database \u00e8 stato aggiornato a una particolare migrazione. Ci\u00f2 accade spesso quando si modifica manualmente il database in uno stato particolare e non si desidera che le migrazioni per tale modifica vengano applicate nuovamente in un secondo momento. \u00c8 possibile raggiungere questo obiettivo con il seguente comando:\n\n\nyii migrate/mark 150101_185401                      # using timestamp to specify the migration\nyii migrate/mark \"2015-01-01 18:54:01\"              # using a string that can be parsed by strtotime()\nyii migrate/mark m150101_185401_create_news_table   # using full name\nyii migrate/mark 1392853618                         # using UNIX timestamp\n\n\n\nIl comando modificher\u00e0 la tabella \nmigration\n aggiungendo o eliminando determinate righe per indicare che il database ha applicato le migrazioni a quella specificata. Nessuna migrazione verr\u00e0 applicata o ripristinata da questo comando.\n\n\nPersonalizzazione delle migrazioni\n\n\nEsistono diversi modi per personalizzare il comando di migrazione.\n\n\nUtilizzo delle opzioni della riga di comando\n\n\nIl comando di migrazione viene fornito con alcune opzioni della riga di comando che possono essere utilizzate per personalizzare i suoi comportamenti:\n\n\n\n\n\n\ninteractive\n: booleano (predefinito su \ntrue\n), specifica se eseguire le migrazioni in modalit\u00e0 interattiva. Quando questo \u00e8 \ntrue\n, l'utente verr\u00e0 richiesto prima che il comando esegua determinate azioni. Si consiglia di impostarlo su \nfalse\n se il comando viene utilizzato in un processo in background.\n\n\n\n\n\n\nmigrationPath\n: string | array (predefinito su \n@app/migrations\n), specifica la directory che memorizza tutti i file classe di migrazione. Questo pu\u00f2 essere specificato come un percorso di directory o un alias di percorso. Si noti che la directory deve esistere o che il comando potrebbe generare un errore. Dalla versione 2.0.12 \u00e8 possibile specificare un array per il caricamento delle migrazioni da pi\u00f9 origini.\n\n\n\n\n\n\nmigrationTable\n: string (predefinito su \nmigration\n), specifica il nome della tabella del database per la memorizzazione delle informazioni sulla cronologia della migrazione. La tabella verr\u00e0 automaticamente creata dal comando se non esiste. Puoi anche crearlo manualmente usando la struttura \nversion varchar(255) primary key, apply_time integer\n.\n\n\n\n\n\n\ndb\n: string (predefinito su \ndb\n), specifica l'ID del componente dell'applicazione di database. Rappresenta il database che verr\u00e0 migrato utilizzando questo comando.\n\n\n\n\n\n\ntemplateFile\n: string (predefinito su \n@yii/views/migration.php\n), specifica il percorso del file modello utilizzato per generare file di classe di migrazione scheletro. Questo pu\u00f2 essere specificato come percorso del file o alias del percorso. Il file modello \u00e8 uno script PHP in cui \u00e8 possibile utilizzare una variabile predefinita denominata $classNameper ottenere il nome della classe di migrazione.\n\n\n\n\n\n\ngeneratorTemplateFiles\n: array (predefinito su `[\n\n\n'create_table' =\n '@yii/views/createTableMigration.php',\n'drop_table' =\n '@yii/views/dropTableMigration.php',\n'add_column' =\n '@yii/views/addColumnMigration.php',\n'drop_column' =\n '@yii/views/dropColumnMigration.php',\n'create_junction' =\n '@yii/views/createTableMigration.php'\n\n\n\n\n\n\n] `), specifica i file modello per generare il codice di migrazione.\n\n\n\n\nfields\n: array di stringhe di definizione della colonna utilizzate per la creazione del codice di migrazione. Predefinito a \n[]\n. Il formato di ciascuna definizione \u00e8 \nCOLUMN_NAME:COLUMN_TYPE:COLUMN_DECORATOR\n. Ad esempio, \n--fields=name:string(12):notNull\n produce una colonna di stringa di dimensioni 12 che non lo \u00e8 \nnull\n.\n\n\n\n\nL'esempio seguente mostra come \u00e8 possibile utilizzare queste opzioni.\n\n\nAd esempio, se vogliamo migrare un modulo \nforum\n i cui file di migrazione si trovano all'interno della directory \nmigrations\n del modulo , quindi possiamo usare il seguente comando:\n\n\n# migrate the migrations in a forum module non-interactively\nyii migrate --migrationPath=@app/modules/forum/migrations --interactive=0\n\n\n\nConfigurazione del comando a livello globale\n\n\nInvece di immettere gli stessi valori di opzione ogni volta che si esegue il comando di migrazione, \u00e8 possibile configurarlo una volta per tutte nella configurazione dell'applicazione come mostrato di seguito:\n\n\nreturn [\n    'controllerMap' =\n [\n        'migrate' =\n [\n            'class' =\n 'yii\\console\\controllers\\MigrateController',\n            'migrationTable' =\n 'backend_migration',\n        ],\n    ],\n];\n\n\n\nCon la configurazione precedente, ogni volta che si esegue il comando di migrazione, la tabella \nbackend_migration\n verr\u00e0 utilizzata per registrare la cronologia di migrazione. Non \u00e8 pi\u00f9 necessario specificarlo tramite l'opzione \nmigrationTable\n della riga di comando.\n\n\nMigrazioni con i namespace\n\n\nDalla versione 2.0.10 \u00e8 possibile utilizzare i namespace per le classi di migrazione. \u00c8 possibile specificare l'elenco dei namespace di migrazione tramite \nmigrationNamespaces\n. L'utilizzo dei namespace per le classi di migrazione consente l'utilizzo delle diverse posizioni di origine per le migrazioni. Per esempio:\n\n\nreturn [\n    'controllerMap' =\n [\n        'migrate' =\n [\n            'class' =\n 'yii\\console\\controllers\\MigrateController',\n            'migrationPath' =\n null, // disable non-namespaced migrations if app\\migrations is listed below\n            'migrationNamespaces' =\n [\n                'app\\migrations', // Common migrations for the whole application\n                'module\\migrations', // Migrations for the specific project's module\n                'some\\extension\\migrations', // Migrations for the specific extension\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nNota\n\n\nLe migrazioni applicate da diversi namespace creeranno un'unica cronologia di migrazione, ad esempio potresti non essere in grado di applicare o ripristinare le migrazioni da un determinato namespace.\n\n\n\n\nDurante l'esecuzione delle migrazioni con namespace: possiamo crearne uno nuovo, ripristinarne uno,  e cos\u00ec via. E' necessario specificare il namespace completo prima del nome della migrazione. Si noti che il simbolo \n\\\n \u00e8 solitamente considerato un carattere speciale nella shell, quindi \u00e8 necessario eseguirlo correttamente per evitare errori di shell o comportamenti scorretti. Per esempio:\n\n\nyii migrate/create 'app\\\\migrations\\\\createUserTable'\n\n\n\n\n\nNota\n\n\nLe migrazioni specificate tramite \nmigrationPath\n non possono contenere un namespace, quindi la migrazione dei namespace pu\u00f2 essere applicata solo tramite la propriet\u00e0 \nyii \\ console \\ controllers \\ MigrateController :: $ migrationNamespaces\n.\n\n\n\n\nDalla versione 2.0.12 la propriet\u00e0 \nmigrationPath\n accetta anche una matrice per specificare pi\u00f9 directory che contengono migrazioni senza un namespace. Questo \u00e8 principalmente aggiunto per essere utilizzato in progetti esistenti che utilizzano migrazioni da luoghi diversi. Queste migrazioni provengono principalmente da fonti esterne, come le estensioni Yii sviluppate da altri sviluppatori, che non possono essere modificate per utilizzare facilmente spazi dei nomi quando si inizia a utilizzare il nuovo approccio.\n\n\nMigrazioni separate\n\n\nA volte l'utilizzo di un'unica cronologia di migrazione per tutte le migrazioni di progetto non \u00e8 auspicabile. Ad esempio: \u00e8 possibile installare alcune estensioni \"blog\", che contengono funzionalit\u00e0 completamente separate e contengono le proprie migrazioni, che non dovrebbero influire su quelle dedicate alle funzionalit\u00e0 del progetto principale.\n\n\nSe si desidera che diverse migrazioni vengano applicate e tracciate completamente separate l'una dall'altra, \u00e8 possibile configurare pi\u00f9 comandi di migrazione che utilizzeranno diversi spazi dei nomi e tabelle della cronologia delle migrazioni:\n\n\nreturn [\n    'controllerMap' =\n [\n        // Common migrations for the whole application\n        'migrate-app' =\n [\n            'class' =\n 'yii\\console\\controllers\\MigrateController',\n            'migrationNamespaces' =\n ['app\\migrations'],\n            'migrationTable' =\n 'migration_app',\n            'migrationPath' =\n null,\n        ],\n        // Migrations for the specific project's module\n        'migrate-module' =\n [\n            'class' =\n 'yii\\console\\controllers\\MigrateController',\n            'migrationNamespaces' =\n ['module\\migrations'],\n            'migrationTable' =\n 'migration_module',\n            'migrationPath' =\n null,\n        ],\n        // Migrations for the specific extension\n        'migrate-rbac' =\n [\n            'class' =\n 'yii\\console\\controllers\\MigrateController',\n            'migrationPath' =\n '@yii/rbac/migrations',\n            'migrationTable' =\n 'migration_rbac',\n        ],\n    ],\n];\n\n\n\nNota che per sincronizzare il database ora devi eseguire pi\u00f9 comandi invece di uno:\n\n\nyii migrate-app\nyii migrate-module\nyii migrate-rbac\n\n\n\nMigrazione di pi\u00f9 database\n\n\nPer impostazione predefinita, le migrazioni vengono applicate allo stesso database specificato dal componente \ndb\n dell'applicazione. Se vuoi che vengano applicati a un altro database, puoi specificare l'opzione \ndb\n della riga di comando come mostrato di seguito,\n\n\nyii migrate --db=db2\n\n\n\nIl comando precedente applicher\u00e0 le migrazioni al database \ndb2\n. \n\n\nA volte pu\u00f2 succedere che si voglia applicare alcune delle migrazioni a un database, mentre altre ad un altro database. Per raggiungere questo obiettivo, quando si implementa una classe di migrazione, \u00e8 necessario specificare esplicitamente l'ID del componente DB utilizzato dalla migrazione, come nel seguente esempio:\n\n\n?php\n\nuse yii\\db\\Migration;\n\nclass m150101_185401_create_news_table extends Migration{\n\n    public function init(){\n\n        $this-\ndb = 'db2';\n        parent::init();\n    }\n}\n\n\n\nLa suddetta migrazione verr\u00e0 applicata a \ndb2\n anche se si specifica un altro database tramite l'opzione \ndb\n della riga di comando. Si noti che la cronologia delle migrazioni verr\u00e0 comunque registrata nel database specificato dall'opzione \ndb\n della riga di comando.\n\n\nSe si dispone di pi\u00f9 migrazioni che utilizzano lo stesso database, si consiglia di creare una classe di migrazione di base con il codice precedente \ninit()\n. Quindi ogni classe di migrazione pu\u00f2 estendersi da questa classe base.\n\n\n\n\nTip\n\n\nOltre a impostare la propriet\u00e0 db, puoi anche operare su diversi database creando nuove connessioni database nelle classi di migrazione. Quindi si utilizzano i metodi DAO con queste connessioni per manipolare diversi database.\n\n\n\n\nUn'altra strategia che \u00e8 possibile eseguire per migrare pi\u00f9 database consiste nel mantenere le migrazioni per diversi database in diversi percorsi di migrazione. Quindi \u00e8 possibile migrare questi database in comandi separati come il seguente:\n\n\nyii migrate --migrationPath=@app/migrations/db1 --db=db1\nyii migrate --migrationPath=@app/migrations/db2 --db=db2\n...\n\n\n\nIl primo comando si applicher\u00e0 migrazioni in \n@app/migrations/db1\n al database \ndb1\n, il secondo comando si applicher\u00e0 migrazioni in \n@app/migrations/db2\n a \ndb2\n, e cos\u00ec via.",
            "title": "Migrazoni"
        },
        {
            "location": "/working-with-databases/sub-migrations/#migrazione-del-database",
            "text": "Durante lo sviluppo e il mantenimento di un'applicazione basata su database, la struttura del database in uso si evolve proprio come fa il codice sorgente. Ad esempio, durante lo sviluppo di un'applicazione, possiamo aver bisogno di una nuova tabella; dopo che l'applicazione \u00e8 stata distribuita in produzione, \u00e8 possibile che venga creato un indice per migliorare le prestazioni della query; e cos\u00ec via. Poich\u00e9 una modifica della struttura del database richiede spesso alcune modifiche al codice sorgente, Yii supporta la cosiddetta funzione di migrazione del database che consente di tenere traccia delle modifiche del database in termini di migrazioni del database controllate dalla versione insieme al codice sorgente.  Le seguenti fasi mostrano come la migrazione del database pu\u00f2 essere utilizzata da un team durante lo sviluppo:   Luca crea una nuova migrazione (ad esempio crea una nuova tabella, cambia una definizione di colonna, ecc.).  Luca usa la nuova migrazione nel sistema di controllo del codice sorgente (es. Git, Mercurial).  Andrea aggiorna il suo repository dal sistema di controllo del codice sorgente e riceve la nuova migrazione.  Andrea applica la migrazione al suo database di sviluppo locale, sincronizzando cos\u00ec il suo database per riflettere le modifiche apportate da Tim.   E i seguenti passaggi mostrano come distribuire una nuova versione con le migrazioni del database alla produzione:   Scott crea un tag di rilascio per il repository del progetto che contiene alcune nuove migrazioni del database.  Scott aggiorna il codice sorgente sul server di produzione sul tag di rilascio.  Scott applica eventuali migrazioni di database accumulate al database di produzione.   Yii fornisce una serie di strumenti per la riga di comando di migrazione che consentono di:   creare nuove migrazioni;  applicare le migrazioni;  ripristinare le migrazioni;  riapplicare le migrazioni;  mostra la cronologia e lo stato della migrazione.   Tutti questi strumenti sono accessibili tramite il comando  yii migrate . In questa sezione descriveremo in dettaglio come eseguire varie attivit\u00e0 utilizzando questi strumenti. \u00c8 inoltre possibile ottenere l'utilizzo di ogni strumento tramite il comando di aiuto  yii help migrate .   Tip  Le migrazioni potrebbero influire non solo sullo schema del database, ma anche sui dati esistenti per adattarsi al nuovo schema, creare la gerarchia RBAC o pulire la cache.",
            "title": "Migrazione del Database"
        },
        {
            "location": "/working-with-databases/sub-migrations/#creazione-di-una-migrazione",
            "text": "Per creare una nuova migrazione, eseguire il seguente comando:  yii migrate/create  name   L'argomento  name  richiesto fornisce una breve descrizione della nuova migrazione. Ad esempio, se la migrazione riguarda la creazione di una nuova tabella denominata  notizie , \u00e8 possibile utilizzare il nome  create_news_table  ed eseguire il seguente comando:  yii migrate/create create_news_table   Nota  Poich\u00e9 l'argomento  name  verr\u00e0 utilizzato come parte del nome della classe di migrazione generato, dovrebbe contenere solo lettere, cifre e / o caratteri di sottolineatura.   Il comando precedente creer\u00e0 un nuovo file di classe PHP chiamato  m150101_185401_create_news_table.php  nella  @app/migrationsdirectory . Il file contiene il seguente codice che dichiara principalmente una classe di migrazione  m150101_185401_create_news_table  con il codice scheletro:  ?php\n\nuse yii\\db\\Migration;\n\nclass m150101_185401_create_news_table extends Migration{\n\n    public function up(){\n\n    }\n\n    public function down(){\n\n        echo \"m101129_185401_create_news_table cannot be reverted.\\n\";\n\n        return false;\n    }\n\n    /*\n    // Use safeUp/safeDown to run migration code within a transaction\n    public function safeUp(){\n\n    }\n\n    public function safeDown(){\n\n    }\n    */\n}  Ogni migrazione del database \u00e8 definita come una classe PHP che si estende da  yii \\ db \\ Migration . Il nome della classe di migrazione viene generato automaticamente nel formato di  m YYMMDD_HHMMSS _ Name , dove   YYMMDD_HHMMSS  fa riferimento al datetime UTC in cui viene eseguito il comando di creazione della migrazione.  Name  \u00e8 uguale al valore dell'argomento  name  che fornisci al comando.   Nella classe di migrazione, \u00e8 previsto che si scriva codice nel metodo  up()  che apporta modifiche alla struttura del database. Si consiglia inoltre di scrivere il codice nel metodo  down()  per annullare le modifiche apportate da  up() . Il metodo  up()  viene richiamato quando si aggiorna il database con questa migrazione, mentre il metodo  down()  viene richiamato quando si esegue il downgrade del database. Il codice seguente mostra come \u00e8 possibile implementare la classe di migrazione per creare una tabella  news :  ?php\n\nuse yii\\db\\Schema;\nuse yii\\db\\Migration;\n\nclass m150101_185401_create_news_table extends Migration{\n\n    public function up(){\n\n            $this- createTable('news', [\n            'id' =  Schema::TYPE_PK,\n            'title' =  Schema::TYPE_STRING . ' NOT NULL',\n            'content' =  Schema::TYPE_TEXT,\n        ]);\n    }\n\n    public function down(){\n\n        $this- dropTable('news');\n    }\n}   Info  Non tutte le migrazioni sono reversibili. Ad esempio, se il metodo  up()  elimina una riga di una tabella, potresti non essere in grado di recuperare questa riga nel metodo  down() . A volte, potresti essere troppo pigro per implementare il metodo  down() , perch\u00e9 non \u00e8 molto comune ripristinare le migrazioni del database. In questo caso, \u00e8 necessario tornare un valore  false  nel metodo  down()  per indicare che la migrazione non \u00e8 reversibile.   La classe di migrazione di base  yii \\ db \\ Migration  espone una connessione al database tramite la propriet\u00e0  db . \u00c8 possibile utilizzarlo per manipolare lo schema del database utilizzando i metodi descritti in \"Operazioni con lo schema del database\".  Anzich\u00e9 utilizzare tipi fisici, durante la creazione di una tabella o colonna \u00e8 necessario utilizzare i tipi astratti in modo che le migrazioni siano indipendenti da DBMS specifici. La classe  yii \\ db \\ Schema  definisce un insieme di costanti per rappresentare i tipi astratti supportati. Queste costanti sono denominate nel formato di  TYPE_ Name . Ad esempio,  TYPE_PK  si riferisce al tipo di chiave primaria auto-incrementale;  TYPE_STRING  si riferisce a un tipo di stringa. Quando una migrazione viene applicata a un determinato database, i tipi astratti verranno tradotti nei corrispondenti tipi fisici. Nel caso di MySQL,  TYPE_PK  verr\u00e0 trasformato in  int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY , mentre  TYPE_STRING diventa  varchar(255) .  \u00c8 possibile aggiungere ulteriori vincoli quando si utilizzano i tipi astratti. Nell'esempio sopra,  NOT NULL  viene aggiunto a  Schema::TYPE_STRING  per specificare che la colonna non pu\u00f2 essere  null .   Info  La mappatura tra tipi astratti e tipi fisici \u00e8 specificata dalla propriet\u00e0  $typeMap  in ogni clsse  QueryBuilder .   Dalla versione 2.0.6, \u00e8 possibile utilizzare il generatore di schemi appena introdotto che fornisce un modo pi\u00f9 conveniente di definire lo schema di colonna. Quindi la migrazione sopra potrebbe essere scritta come la seguente:  ?php\n\nuse yii\\db\\Migration;\n\nclass m150101_185401_create_news_table extends Migration{\n\n    public function up(){\n\n        $this- createTable('news', [\n            'id' =  $this- primaryKey(),\n            'title' =  $this- string()- notNull(),\n            'content' =  $this- text(),\n        ]);\n    }\n\n    public function down(){\n\n        $this- dropTable('news');\n    }\n}  Un elenco di tutti i metodi disponibili per la definizione dei tipi di colonna \u00e8 disponibile nella documentazione API di  yii \\ db \\ SchemaBuilderTrait .",
            "title": "Creazione di una migrazione"
        },
        {
            "location": "/working-with-databases/sub-migrations/#generare-una-migrazioni",
            "text": "La console di migrazione della versione 2.0.7 offre un modo conveniente per creare migrazioni.  Se il nome della migrazione \u00e8 di un modulo speciale, ad esempio  create_xxx_table  o  drop_xxx_table  il file di migrazione generato conterr\u00e0 codice aggiuntivo, in questo caso la creazione / eliminazione di tabelle. Di seguito sono descritte tutte le varianti di questa funzione.",
            "title": "Generare una migrazioni"
        },
        {
            "location": "/working-with-databases/sub-migrations/#creazione-di-una-tabella",
            "text": "yii migrate/create create_post_table  genera  /**\n* Handles the creation for table `post`.\n*/\n\nclass m150811_220037_create_post_table extends Migration{\n\n    /**\n    * @inheritdoc\n    */\n    public function up(){\n\n        $this- createTable('post', [\n            'id' =  $this- primaryKey()\n        ]);\n    }\n\n    /**\n    * @inheritdoc\n    */\n    public function down(){\n\n        $this- dropTable('post');\n    }\n}  Per creare subito i campi tabella, dobbiamo specificarli tramite l'opzione  --fields .  yii migrate/create create_post_table --fields=\"title:string,body:text\"  genera  /**\n* Handles the creation for table `post`.\n*/\nclass m150811_220037_create_post_table extends Migration{\n\n    /**\n    * @inheritdoc\n    */\n    public function up(){\n\n        $this- createTable('post', [\n            'id' =  $this- primaryKey(),\n            'title' =  $this- string(),\n            'body' =  $this- text(),\n        ]);\n    }\n\n    /**\n    * @inheritdoc\n    */\n    public function down(){\n\n        $this- dropTable('post');\n    }\n}  \u00c8 possibile specificare pi\u00f9 parametri di campo.  yii migrate/create create_post_table --fields=\"title:string(12):notNull:unique,body:text\"  genera  /**\n * Handles the creation for table `post`.\n*/\nclass m150811_220037_create_post_table extends Migration{\n\n    /**\n    * @inheritdoc\n    */\n    public function up(){\n\n        $this- createTable('post', [\n            'id' =  $this- primaryKey(),\n            'title' =  $this- string(12)- notNull()- unique(),\n            'body' =  $this- text()\n        ]);\n    }\n\n    /**\n    * @inheritdoc\n    */\n    public function down(){\n\n        $this- dropTable('post');\n    }\n}   Nota  La chiave primaria viene aggiunta automaticamente e viene denominata  id  per impostazione predefinita. Se vuoi usare un altro nome, puoi specificarlo esplicitamente  --fields=\"name:primaryKey\" .",
            "title": "Creazione di una tabella"
        },
        {
            "location": "/working-with-databases/sub-migrations/#chiavi-esterne-foreign-key",
            "text": "Dal momento che 2.0.8 il generatore supporta chiavi esterne utilizzando la la chiave  foreignKey .  yii migrate/create create_post_table --fields=\"author_id:integer:notNull:foreignKey(user),category_id:integer:defaultValue(1):foreignKey,title:string,body:text\"  genera  /**\n* Handles the creation for table `post`.\n* Has foreign keys to the tables:\n*\n* - `user`\n* - `category`\n*/\nclass m160328_040430_create_post_table extends Migration{\n\n    /**\n    * @inheritdoc\n    */\n    public function up(){\n\n        $this- createTable('post', [\n            'id' =  $this- primaryKey(),\n            'author_id' =  $this- integer()- notNull(),\n            'category_id' =  $this- integer()- defaultValue(1),\n            'title' =  $this- string(),\n            'body' =  $this- text(),\n        ]);\n\n        // creates index for column `author_id`\n        $this- createIndex(\n            'idx-post-author_id',\n            'post',\n            'author_id'\n        );\n\n        // add foreign key for table `user`\n        $this- addForeignKey(\n            'fk-post-author_id',\n            'post',\n            'author_id',\n            'user',\n            'id',\n            'CASCADE'\n        );\n\n        // creates index for column `category_id`\n        $this- createIndex(\n            'idx-post-category_id',\n            'post',\n            'category_id'\n        );\n\n        // add foreign key for table `category`\n        $this- addForeignKey(\n            'fk-post-category_id',\n            'post',\n            'category_id',\n            'category',\n            'id',\n            'CASCADE'\n        );\n    }\n\n    /**\n    * @inheritdoc\n    */\n    public function down(){\n\n        // drops foreign key for table `user`\n        $this- dropForeignKey(\n            'fk-post-author_id',\n            'post'\n        );\n\n        // drops index for column `author_id`\n        $this- dropIndex(\n            'idx-post-author_id',\n            'post'\n        );\n\n        // drops foreign key for table `category`\n        $this- dropForeignKey(\n            'fk-post-category_id',\n            'post'\n        );\n\n        // drops index for column `category_id`\n        $this- dropIndex(\n            'idx-post-category_id',\n            'post'\n        );\n\n        $this- dropTable('post');\n    }\n}  La posizione della parola chiave  foreignKey  nella descrizione della colonna non modifica il codice generato. Questo significa:   author_id:integer:notNull:foreignKey(user)  author_id:integer:foreignKey(user):notNull  author_id:foreignKey(user):integer:notNull   Tutti generano lo stesso codice.  La parola chiave  foreignKey  pu\u00f2 prendere un parametro tra parentesi che sar\u00e0 il nome della tabella correlata per la chiave esterna generata. Se non viene passato alcun parametro, il nome della tabella sar\u00e0 dedotto dal nome della colonna.  Nell'esempio sopra  author_id:integer:notNull:foreignKey(user)  generer\u00e0 una colonna denominata  author_id  con una chiave esterna per la tabella  user  mentre  category_id:integer:defaultValue(1):foreignKey  generer\u00e0 una colonna  category_id  con una chiave esterna per la tabella  category .  Dalla 2.0.11, la parola chiave  foreignKey  accetta un secondo parametro, separato da uno spazio bianco. Accetta il nome della colonna correlata per la chiave esterna generata. Se non viene passato nessun secondo parametro, il nome della colonna verr\u00e0 recuperato dallo schema della tabella. Se non esiste uno schema, la chiave primaria non \u00e8 impostata o \u00e8 composta, e verr\u00e0 utilizzato il nome predefinito  id .",
            "title": "Chiavi esterne (foreign key)"
        },
        {
            "location": "/working-with-databases/sub-migrations/#drop-table",
            "text": "yii migrate/create drop_post_table --fields=\"title:string(12):notNull:unique,body:text\"  genera  class m150811_220037_drop_post_table extends Migration{\n\n    public function up(){\n\n        $this- dropTable('post');\n    }\n\n    public function down(){\n\n        $this- createTable('post', [\n            'id' =  $this- primaryKey(),\n            'title' =  $this- string(12)- notNull()- unique(),\n            'body' =  $this- text()\n        ]);\n    }\n}",
            "title": "Drop Table"
        },
        {
            "location": "/working-with-databases/sub-migrations/#aggiungere-una-colonna",
            "text": "Se il nome della migrazione \u00e8 del modulo, il contenuto del file  add_xxx_column_to_yyy_table  conterr\u00e0  addColumn  e le istruzioni necessarie  dropColumn .  Per aggiungere una colonna:  yii migrate/create add_position_column_to_post_table --fields=\"position:integer\"  genera  class m150811_220037_add_position_column_to_post_table extends Migration{\n\n    public function up(){\n\n        $this- addColumn('post', 'position', $this- integer());\n    }\n\n    public function down(){\n\n        $this- dropColumn('post', 'position');\n    }\n}  \u00c8 possibile specificare pi\u00f9 colonne come segue:  yii migrate/create add_xxx_column_yyy_column_to_zzz_table --fields=\"xxx:integer,yyy:text\"",
            "title": "Aggiungere una colonna"
        },
        {
            "location": "/working-with-databases/sub-migrations/#drop-column",
            "text": "Se il nome della migrazione \u00e8 del modulo, il contenuto del file  drop_xxx_column_from_yyy_table  conterr\u00e0  addColumn  e le istruzioni necessarie  dropColumn .  yii migrate/create drop_position_column_from_post_table --fields=\"position:integer\"  genera  class m150811_220037_drop_position_column_from_post_table extends Migration{\n\n    public function up(){\n\n        $this- dropColumn('post', 'position');\n    }\n\n    public function down(){\n\n        $this- addColumn('post', 'position', $this- integer());\n    }\n}",
            "title": "Drop Column"
        },
        {
            "location": "/working-with-databases/sub-migrations/#aggiungi-tuan-junction-table",
            "text": "Se il nome della migrazione \u00e8 nella forma  create_junction_table_for_xxx_and_yyy_tables  o  create_junction_xxx_and_yyy_tables , significa che \u00e8 necessario creare una tabella di collegamento.  yii migrate/create create_junction_table_for_post_and_tag_tables --fields=\"created_at:dateTime\"  genera  /**\n* Handles the creation for table `post_tag`.\n* Has foreign keys to the tables:\n*\n* - `post`\n* - `tag`\n*/\nclass m160328_041642_create_junction_table_for_post_and_tag_tables extends Migration{\n\n    /**\n    * @inheritdoc\n    */\n    public function up(){\n\n        $this- createTable('post_tag', [\n            'post_id' =  $this- integer(),\n            'tag_id' =  $this- integer(),\n            'created_at' =  $this- dateTime(),\n        'PRIMARY KEY(post_id, tag_id)',\n        ]);\n\n        // creates index for column `post_id`\n        $this- createIndex(\n            'idx-post_tag-post_id',\n            'post_tag',\n            'post_id'\n        );\n\n        // add foreign key for table `post`\n        $this- addForeignKey(\n            'fk-post_tag-post_id',\n            'post_tag',\n            'post_id',\n            'post',\n            'id',\n            'CASCADE'\n        );\n\n        // creates index for column `tag_id`\n        $this- createIndex(\n            'idx-post_tag-tag_id',\n            'post_tag',\n            'tag_id'\n        );\n\n        // add foreign key for table `tag`\n        $this- addForeignKey(\n            'fk-post_tag-tag_id',\n            'post_tag',\n            'tag_id',\n            'tag',\n            'id',\n            'CASCADE'\n        );\n    }\n\n    /**\n    * @inheritdoc\n    */\n    public function down(){\n\n        // drops foreign key for table `post`\n        $this- dropForeignKey(\n            'fk-post_tag-post_id',\n            'post_tag'\n        );\n\n        // drops index for column `post_id`\n        $this- dropIndex(\n            'idx-post_tag-post_id',\n            'post_tag'\n        );\n\n        // drops foreign key for table `tag`\n        $this- dropForeignKey(\n            'fk-post_tag-tag_id',\n        'post_tag'\n        );\n\n        // drops index for column `tag_id`\n        $this- dropIndex(\n            'idx-post_tag-tag_id',\n            'post_tag'\n        );\n\n        $this- dropTable('post_tag');\n    }\n}  Nel caso in cui la tabella non sia definita nello schema o la chiave primaria non sia impostata o sia composta, viene utilizzato il nome predefinito  id .",
            "title": "Aggiungi tuan \"Junction Table\""
        },
        {
            "location": "/working-with-databases/sub-migrations/#migrazioni-transazionali",
            "text": "Durante l'esecuzione di migrazioni di DB complesse, \u00e8 importante garantire che ogni migrazione abbia esito positivo o negativo nel suo insieme, in modo che il database possa mantenere integrit\u00e0 e coerenza. Per raggiungere questo obiettivo,si consiglia di includere le operazioni DB di ogni migrazione in una transazione .  Un modo ancora pi\u00f9 semplice di implementare le migrazioni transazionali \u00e8 inserire il codice di migrazione nei metodi  safeUp()  e  safeDown() . Questi due metodi differiscono da  up()  e  down()  in quanto sono inclusi implicitamente in una transazione. Di conseguenza, se qualsiasi operazione in questi metodi fallisce, tutte le operazioni precedenti verranno automaticamente ripristinate.  Nell'esempio seguente, oltre a creare la tabella  news , inseriamo anche una riga iniziale in questa tabella.  ?php\n\nuse yii\\db\\Migration;\n\nclass m150101_185401_create_news_table extends Migration{\n\n    public function safeUp(){\n\n        $this- createTable('news', [\n            'id' =  $this- primaryKey(),\n            'title' =  $this- string()- notNull(),\n            'content' =  $this- text(),\n        ]);\n\n        $this- insert('news', [\n            'title' =  'test 1',\n            'content' =  'content 1',\n        ]);\n    }\n\n    public function safeDown(){\n\n        $this- delete('news', ['id' =  1]);\n        $this- dropTable('news');\n    }\n}  Si noti che di solito quando si eseguono pi\u00f9 operazioni DB in  safeUp() , \u00e8 necessario invertire il loro ordine di esecuzione  safeDown() . Nell'esempio sopra, prima creiamo la tabella e poi inseriamo una riga in  safeUp() ; mentre in  safeDown()  prima eliminiamo la riga e poi rilasciamo la tabella.   Warning  Non tutti i DBMS supportano le transazioni. E alcune query DB non possono essere inserite in una transazione. Per alcuni esempi, fai riferimento a commit impliciti. Se questo \u00e8 il caso, dovresti comunque implementare  up()  e  down() , invece.",
            "title": "Migrazioni transazionali"
        },
        {
            "location": "/working-with-databases/sub-migrations/#metodi-di-accesso-al-database",
            "text": "La classe di migrazione di base  yii \\ db \\ Migration  fornisce un insieme di metodi per consentire l'accesso e la manipolazione dei database. \u00c8 possibile che questi metodi vengano denominati in modo simile ai metodi DAO forniti dalla classe  yii \\ db \\ Command . Ad esempio, il metodo  yii \\ db \\ Migration :: createTable()  consente di creare una nuova tabella, proprio come fa  yii \\ db \\ Command :: createTable() .  Il vantaggio dell'utilizzo dei metodi forniti da  yii \\ db \\ Migration  \u00e8 che non \u00e8 necessario creare esplicitamente istanze  yii \\ db \\ Command  e l'esecuzione di ogni metodo mostrer\u00e0 automaticamente messaggi utili che indicano quali operazioni di database sono eseguite e quanto tempo prendere.  Di seguito \u00e8 riportato l'elenco di tutti questi metodi di accesso al database:   execute() : esecuzione di un'istruzione SQL  insert() : inserimento di una singola riga  batchInsert() : inserimento di pi\u00f9 righe  update() : aggiornamento delle righe  delete() : eliminazione di righe  createTable() : creazione di una tabella  renameTable() : rinomina una tabella  dropTable() : rimozione di una tabella  truncateTable() : rimuove tutte le righe in una tabella  addColumn() : aggiunta di una colonna  renameColumn() : rinomina una colonna  dropColumn() : rimuovendo una colonna  alterColumn() : modifica di una colonna  addPrimaryKey() : aggiunta di una chiave primaria  dropPrimaryKey() : rimozione di una chiave primaria  addForeignKey() : aggiunta di una chiave esterna  dropForeignKey() : rimozione di una chiave esterna  createIndex() : creazione di un indice  dropIndex() : rimozione di un indice  addCommentOnColumn() : aggiunta di commenti alla colonna  dropCommentFromColumn() : eliminazione del commento dalla colonna  addCommentOnTable() : aggiunta di commenti alla tabella  dropCommentFromTable() : eliminazione del commento dalla tabella    Info  yii \\ db \\ Migration  non fornisce un metodo di query del database. Questo perch\u00e9 normalmente non \u00e8 necessario visualizzare un messaggio aggiuntivo sul recupero dei dati da un database. \u00c8 anche possibile utilizzare il potente generatore di query per creare ed eseguire query complesse. L'utilizzo di Query Builder in una migrazione potrebbe essere simile a questo:  // update status field for all users\nforeach((new Query)- from('users')- each() as $user) {\n    $this- update('users', ['status' =  1], ['id' =  $user['id']]);\n}    Nota  Quando si manipolano i dati utilizzando una migrazione, \u00e8 possibile che l'utilizzo delle classi Active Record, possa essere utile poich\u00e9 parte della logica \u00e8 gi\u00e0 implementata l\u00ec. Tuttavia, tenere presente che, contrariamente al codice scritto nelle migrazioni, la cui natura \u00e8 di rimanere costante per sempre, la logica dell'applicazione \u00e8 soggetta a modifiche. Pertanto, quando si utilizza l'Active Record nel codice di migrazione, le modifiche apportate alla logica nel livello Active Record possono interrompere accidentalmente le migrazioni esistenti. Per questo motivo il codice di migrazione dovrebbe essere tenuto indipendente da altre logiche applicative come le classi di record attivi.",
            "title": "Metodi di accesso al database"
        },
        {
            "location": "/working-with-databases/sub-migrations/#applicazione-delle-migrazioni",
            "text": "Per aggiornare un database alla sua ultima struttura, \u00e8 necessario applicare tutte le nuove migrazioni disponibili utilizzando il seguente comando:  yii migrate  Questo comando elencher\u00e0 tutte le migrazioni che non sono state applicate finora. Se confermi di voler applicare queste migrazioni, eseguir\u00e0 il metodo  up()  o  safeUp()  in ogni nuova classe di migrazione, una dopo l'altra, nell'ordine dei loro valori di timestamp. Se una qualsiasi delle migrazioni fallisce, il comando si chiude senza applicare il resto delle migrazioni.   Tip  Nel caso in cui tu non abbia una linea di comando sul tuo server puoi provare l' estensione della  web shell .   Per ogni migrazione che \u00e8 stata applicata correttamente, il comando inserir\u00e0 una riga in una tabella di database chiamata  migration  per registrare l'applicazione corretta della migrazione. Ci\u00f2 consentir\u00e0 allo strumento di migrazione di identificare quali migrazioni sono state applicate e quali no.   Info  Lo strumento di migrazione crea automaticamente la tabella  migration  nel database specificato dall'opzione  db  del comando. Per impostazione predefinita, il database \u00e8 specificato dal componente dell'applicazione  db .   A volte, puoi solo applicare una o alcune nuove migrazioni, invece di tutte le migrazioni disponibili. \u00c8 possibile farlo specificando il numero di migrazioni che si desidera applicare durante l'esecuzione del comando. Ad esempio, il seguente comando prover\u00e0 ad applicare le successive tre migrazioni disponibili:  yii migrate 3  \u00c8 inoltre possibile specificare in modo esplicito una migrazione particolare a cui il database deve essere migrato utilizzando il migrate/tocomando in uno dei seguenti formati:  yii migrate/to 150101_185401                      # using timestamp to specify the migration\nyii migrate/to \"2015-01-01 18:54:01\"              # using a string that can be parsed by strtotime()\nyii migrate/to m150101_185401_create_news_table   # using full name\nyii migrate/to 1392853618                         # using UNIX timestamp  Se sono presenti migrazioni non applicate precedenti a quella specificata, verranno tutte applicate prima che venga applicata la migrazione specificata.  Se la migrazione specificata \u00e8 gi\u00e0 stata applicata in precedenza, tutte le successive migrazioni applicate verranno ripristinate.",
            "title": "Applicazione delle migrazioni"
        },
        {
            "location": "/working-with-databases/sub-migrations/#ripristino-delle-migrazioni",
            "text": "Per annullare una o pi\u00f9 migrazioni precedentemente applicate, \u00e8 possibile eseguire il seguente comando:  yii migrate/down     # revert the most recently applied migration\nyii migrate/down 3   # revert the most 3 recently applied migrations   Warning  Non tutte le migrazioni sono reversibili. Il tentativo di annullare tali migrazioni causer\u00e0 un errore e interromper\u00e0 l'intero processo di ripristino.",
            "title": "Ripristino delle migrazioni"
        },
        {
            "location": "/working-with-databases/sub-migrations/#ripristino-delle-migrazioni_1",
            "text": "Ripristinare le migrazioni significa innanzitutto ripristinare le migrazioni specificate e quindi applicare nuovamente. Questo pu\u00f2 essere fatto come segue:  yii migrate/redo        # redo the last applied migration\nyii migrate/redo 3      # redo the last 3 applied migrations   Warning  Se una migrazione non \u00e8 reversibile, non sar\u00e0 possibile ripristinarla.",
            "title": "Ripristino delle migrazioni"
        },
        {
            "location": "/working-with-databases/sub-migrations/#refreshing-delle-migrazioni",
            "text": "Dal momento che Yii 2.0.13 \u00e8 possibile eliminare tutte le tabelle e le chiavi esterne dal database e applicare tutte le migrazioni dall'inizio.  yii migrate/fresh       # Truncate the database and",
            "title": "Refreshing delle migrazioni"
        },
        {
            "location": "/working-with-databases/sub-migrations/#elenco-delle-migrazioni",
            "text": "Per elencare quali migrazioni sono state applicate e quali no, puoi utilizzare i seguenti comandi:  yii migrate/history     # showing the last 10 applied migrations\nyii migrate/history 5   # showing the last 5 applied migrations\nyii migrate/history all # showing all applied migrations\n\nyii migrate/new         # showing the first 10 new migrations\nyii migrate/new 5       # showing the first 5 new migrations\nyii migrate/new all     # showing all new migrations",
            "title": "Elenco delle migrazioni"
        },
        {
            "location": "/working-with-databases/sub-migrations/#modifica-della-cronologia-delle-migrazioni",
            "text": "Invece di applicare o ripristinare le migrazioni, a volte potresti semplicemente voler segnalare che il tuo database \u00e8 stato aggiornato a una particolare migrazione. Ci\u00f2 accade spesso quando si modifica manualmente il database in uno stato particolare e non si desidera che le migrazioni per tale modifica vengano applicate nuovamente in un secondo momento. \u00c8 possibile raggiungere questo obiettivo con il seguente comando:  yii migrate/mark 150101_185401                      # using timestamp to specify the migration\nyii migrate/mark \"2015-01-01 18:54:01\"              # using a string that can be parsed by strtotime()\nyii migrate/mark m150101_185401_create_news_table   # using full name\nyii migrate/mark 1392853618                         # using UNIX timestamp  Il comando modificher\u00e0 la tabella  migration  aggiungendo o eliminando determinate righe per indicare che il database ha applicato le migrazioni a quella specificata. Nessuna migrazione verr\u00e0 applicata o ripristinata da questo comando.",
            "title": "Modifica della cronologia delle migrazioni"
        },
        {
            "location": "/working-with-databases/sub-migrations/#personalizzazione-delle-migrazioni",
            "text": "Esistono diversi modi per personalizzare il comando di migrazione.  Utilizzo delle opzioni della riga di comando  Il comando di migrazione viene fornito con alcune opzioni della riga di comando che possono essere utilizzate per personalizzare i suoi comportamenti:    interactive : booleano (predefinito su  true ), specifica se eseguire le migrazioni in modalit\u00e0 interattiva. Quando questo \u00e8  true , l'utente verr\u00e0 richiesto prima che il comando esegua determinate azioni. Si consiglia di impostarlo su  false  se il comando viene utilizzato in un processo in background.    migrationPath : string | array (predefinito su  @app/migrations ), specifica la directory che memorizza tutti i file classe di migrazione. Questo pu\u00f2 essere specificato come un percorso di directory o un alias di percorso. Si noti che la directory deve esistere o che il comando potrebbe generare un errore. Dalla versione 2.0.12 \u00e8 possibile specificare un array per il caricamento delle migrazioni da pi\u00f9 origini.    migrationTable : string (predefinito su  migration ), specifica il nome della tabella del database per la memorizzazione delle informazioni sulla cronologia della migrazione. La tabella verr\u00e0 automaticamente creata dal comando se non esiste. Puoi anche crearlo manualmente usando la struttura  version varchar(255) primary key, apply_time integer .    db : string (predefinito su  db ), specifica l'ID del componente dell'applicazione di database. Rappresenta il database che verr\u00e0 migrato utilizzando questo comando.    templateFile : string (predefinito su  @yii/views/migration.php ), specifica il percorso del file modello utilizzato per generare file di classe di migrazione scheletro. Questo pu\u00f2 essere specificato come percorso del file o alias del percorso. Il file modello \u00e8 uno script PHP in cui \u00e8 possibile utilizzare una variabile predefinita denominata $classNameper ottenere il nome della classe di migrazione.    generatorTemplateFiles : array (predefinito su `[  'create_table' =  '@yii/views/createTableMigration.php',\n'drop_table' =  '@yii/views/dropTableMigration.php',\n'add_column' =  '@yii/views/addColumnMigration.php',\n'drop_column' =  '@yii/views/dropColumnMigration.php',\n'create_junction' =  '@yii/views/createTableMigration.php'    ] `), specifica i file modello per generare il codice di migrazione.   fields : array di stringhe di definizione della colonna utilizzate per la creazione del codice di migrazione. Predefinito a  [] . Il formato di ciascuna definizione \u00e8  COLUMN_NAME:COLUMN_TYPE:COLUMN_DECORATOR . Ad esempio,  --fields=name:string(12):notNull  produce una colonna di stringa di dimensioni 12 che non lo \u00e8  null .   L'esempio seguente mostra come \u00e8 possibile utilizzare queste opzioni.  Ad esempio, se vogliamo migrare un modulo  forum  i cui file di migrazione si trovano all'interno della directory  migrations  del modulo , quindi possiamo usare il seguente comando:  # migrate the migrations in a forum module non-interactively\nyii migrate --migrationPath=@app/modules/forum/migrations --interactive=0",
            "title": "Personalizzazione delle migrazioni"
        },
        {
            "location": "/working-with-databases/sub-migrations/#configurazione-del-comando-a-livello-globale",
            "text": "Invece di immettere gli stessi valori di opzione ogni volta che si esegue il comando di migrazione, \u00e8 possibile configurarlo una volta per tutte nella configurazione dell'applicazione come mostrato di seguito:  return [\n    'controllerMap' =  [\n        'migrate' =  [\n            'class' =  'yii\\console\\controllers\\MigrateController',\n            'migrationTable' =  'backend_migration',\n        ],\n    ],\n];  Con la configurazione precedente, ogni volta che si esegue il comando di migrazione, la tabella  backend_migration  verr\u00e0 utilizzata per registrare la cronologia di migrazione. Non \u00e8 pi\u00f9 necessario specificarlo tramite l'opzione  migrationTable  della riga di comando.",
            "title": "Configurazione del comando a livello globale"
        },
        {
            "location": "/working-with-databases/sub-migrations/#migrazioni-con-i-namespace",
            "text": "Dalla versione 2.0.10 \u00e8 possibile utilizzare i namespace per le classi di migrazione. \u00c8 possibile specificare l'elenco dei namespace di migrazione tramite  migrationNamespaces . L'utilizzo dei namespace per le classi di migrazione consente l'utilizzo delle diverse posizioni di origine per le migrazioni. Per esempio:  return [\n    'controllerMap' =  [\n        'migrate' =  [\n            'class' =  'yii\\console\\controllers\\MigrateController',\n            'migrationPath' =  null, // disable non-namespaced migrations if app\\migrations is listed below\n            'migrationNamespaces' =  [\n                'app\\migrations', // Common migrations for the whole application\n                'module\\migrations', // Migrations for the specific project's module\n                'some\\extension\\migrations', // Migrations for the specific extension\n            ],\n        ],\n    ],\n];   Nota  Le migrazioni applicate da diversi namespace creeranno un'unica cronologia di migrazione, ad esempio potresti non essere in grado di applicare o ripristinare le migrazioni da un determinato namespace.   Durante l'esecuzione delle migrazioni con namespace: possiamo crearne uno nuovo, ripristinarne uno,  e cos\u00ec via. E' necessario specificare il namespace completo prima del nome della migrazione. Si noti che il simbolo  \\  \u00e8 solitamente considerato un carattere speciale nella shell, quindi \u00e8 necessario eseguirlo correttamente per evitare errori di shell o comportamenti scorretti. Per esempio:  yii migrate/create 'app\\\\migrations\\\\createUserTable'   Nota  Le migrazioni specificate tramite  migrationPath  non possono contenere un namespace, quindi la migrazione dei namespace pu\u00f2 essere applicata solo tramite la propriet\u00e0  yii \\ console \\ controllers \\ MigrateController :: $ migrationNamespaces .   Dalla versione 2.0.12 la propriet\u00e0  migrationPath  accetta anche una matrice per specificare pi\u00f9 directory che contengono migrazioni senza un namespace. Questo \u00e8 principalmente aggiunto per essere utilizzato in progetti esistenti che utilizzano migrazioni da luoghi diversi. Queste migrazioni provengono principalmente da fonti esterne, come le estensioni Yii sviluppate da altri sviluppatori, che non possono essere modificate per utilizzare facilmente spazi dei nomi quando si inizia a utilizzare il nuovo approccio.",
            "title": "Migrazioni con i namespace"
        },
        {
            "location": "/working-with-databases/sub-migrations/#migrazioni-separate",
            "text": "A volte l'utilizzo di un'unica cronologia di migrazione per tutte le migrazioni di progetto non \u00e8 auspicabile. Ad esempio: \u00e8 possibile installare alcune estensioni \"blog\", che contengono funzionalit\u00e0 completamente separate e contengono le proprie migrazioni, che non dovrebbero influire su quelle dedicate alle funzionalit\u00e0 del progetto principale.  Se si desidera che diverse migrazioni vengano applicate e tracciate completamente separate l'una dall'altra, \u00e8 possibile configurare pi\u00f9 comandi di migrazione che utilizzeranno diversi spazi dei nomi e tabelle della cronologia delle migrazioni:  return [\n    'controllerMap' =  [\n        // Common migrations for the whole application\n        'migrate-app' =  [\n            'class' =  'yii\\console\\controllers\\MigrateController',\n            'migrationNamespaces' =  ['app\\migrations'],\n            'migrationTable' =  'migration_app',\n            'migrationPath' =  null,\n        ],\n        // Migrations for the specific project's module\n        'migrate-module' =  [\n            'class' =  'yii\\console\\controllers\\MigrateController',\n            'migrationNamespaces' =  ['module\\migrations'],\n            'migrationTable' =  'migration_module',\n            'migrationPath' =  null,\n        ],\n        // Migrations for the specific extension\n        'migrate-rbac' =  [\n            'class' =  'yii\\console\\controllers\\MigrateController',\n            'migrationPath' =  '@yii/rbac/migrations',\n            'migrationTable' =  'migration_rbac',\n        ],\n    ],\n];  Nota che per sincronizzare il database ora devi eseguire pi\u00f9 comandi invece di uno:  yii migrate-app\nyii migrate-module\nyii migrate-rbac",
            "title": "Migrazioni separate"
        },
        {
            "location": "/working-with-databases/sub-migrations/#migrazione-di-piu-database",
            "text": "Per impostazione predefinita, le migrazioni vengono applicate allo stesso database specificato dal componente  db  dell'applicazione. Se vuoi che vengano applicati a un altro database, puoi specificare l'opzione  db  della riga di comando come mostrato di seguito,  yii migrate --db=db2  Il comando precedente applicher\u00e0 le migrazioni al database  db2 .   A volte pu\u00f2 succedere che si voglia applicare alcune delle migrazioni a un database, mentre altre ad un altro database. Per raggiungere questo obiettivo, quando si implementa una classe di migrazione, \u00e8 necessario specificare esplicitamente l'ID del componente DB utilizzato dalla migrazione, come nel seguente esempio:  ?php\n\nuse yii\\db\\Migration;\n\nclass m150101_185401_create_news_table extends Migration{\n\n    public function init(){\n\n        $this- db = 'db2';\n        parent::init();\n    }\n}  La suddetta migrazione verr\u00e0 applicata a  db2  anche se si specifica un altro database tramite l'opzione  db  della riga di comando. Si noti che la cronologia delle migrazioni verr\u00e0 comunque registrata nel database specificato dall'opzione  db  della riga di comando.  Se si dispone di pi\u00f9 migrazioni che utilizzano lo stesso database, si consiglia di creare una classe di migrazione di base con il codice precedente  init() . Quindi ogni classe di migrazione pu\u00f2 estendersi da questa classe base.   Tip  Oltre a impostare la propriet\u00e0 db, puoi anche operare su diversi database creando nuove connessioni database nelle classi di migrazione. Quindi si utilizzano i metodi DAO con queste connessioni per manipolare diversi database.   Un'altra strategia che \u00e8 possibile eseguire per migrare pi\u00f9 database consiste nel mantenere le migrazioni per diversi database in diversi percorsi di migrazione. Quindi \u00e8 possibile migrare questi database in comandi separati come il seguente:  yii migrate --migrationPath=@app/migrations/db1 --db=db1\nyii migrate --migrationPath=@app/migrations/db2 --db=db2\n...  Il primo comando si applicher\u00e0 migrazioni in  @app/migrations/db1  al database  db1 , il secondo comando si applicher\u00e0 migrazioni in  @app/migrations/db2  a  db2 , e cos\u00ec via.",
            "title": "Migrazione di pi\u00f9 database"
        }
    ]
}