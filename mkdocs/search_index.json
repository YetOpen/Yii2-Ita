{
    "docs": [
        {
            "location": "/",
            "text": "Che cos'\u00e8 Yii?\n\n\nYii \u00e8 un framework PHP basato su componenti per sviluppare rapidamente applicazioni web moderne. Il nome \"Yii\" significa \"semplice ed evolutivo\" in cinese. Pu\u00f2 essere considerato anche come acronimo di \"Yes It is!\"\n\n\nPerch\u00e8 confrontare Yii con gli altri Framework?\n\n\nSe hai gi\u00e0 familiarit\u00e0 con altri Framework, potresti apprezzare di sapere le caratteristiche di Yii:\n\n\n- Come la maggior parte dei framework PHP, Yii implementa il modello \n  architetturale MVC (model - view - controller) e promuove l'organizzazione \n  dei codici in base a quel modello.\n- Yii prende la filosofia che il codice deve essere scritto in modo semplice ma \n  elegante. Yii non cercher\u00e0 mai di sovrascrivere le cose, principalmente allo\n  scopo di seguire un modello di progettazione.\n- Yii \u00e8 un framework full-stack che fornisce molte funzionalit\u00e0 pronte \n  all'uso come i costruttori di query, l'Active Record per i database \n  relazionali e NoSQL; Massimo supporto per lo sviluppo di API, e molto \n  altro ancora.\n- Yii \u00e8 estremamente estensibile. E' possibile personalizzare o sostituire \n  quasi ogni pezzo di codice. E' inoltre possibile sfruttare l'architettura \n  solida di Yii per sviluppare estensioni ridistribuibili.\n- Obbiettivo primario di Yii \u00e8 quello di poter offrire alte prestazioni.\n\n\n\nVersioni di Yii\n\n\nAttualmente Yii dispone di due versioni principali: 1.1 e 2.0. La nuova versione 2.0 \u00e8 una riscrittura completa di Yii, adottando le pi\u00f9 recenti tecnologie e protocolli, tra cui Composer, PSR, namespaces e cos\u00ec via. Questa guida riguarder\u00e0 principalmente la versione 2.0.\n\n\nRequisiti e Prerequisiti\n\n\nYii 2.0 richiede PHP 5.4.0 o superiore e funziona meglio con l'ultima versione di PHP 7. E' possibile trovare requisiti pi\u00f9 dettagliati per le singole funzionalit\u00e0 eseguendo il checker di requisiti incluso in ogni versione di Yii.\n\n\nL'utilizzo di Yii richiede la conoscenza base della programmazione orientata agli oggetti (OOP), in quanto Yii \u00e8 un framework puro basato su OOP. Yii 2.0 utilizza anche funzionalit\u00e0 del PHP, come i namespaces e i traits.",
            "title": "Homepage"
        },
        {
            "location": "/#che-cose-yii",
            "text": "Yii \u00e8 un framework PHP basato su componenti per sviluppare rapidamente applicazioni web moderne. Il nome \"Yii\" significa \"semplice ed evolutivo\" in cinese. Pu\u00f2 essere considerato anche come acronimo di \"Yes It is!\"",
            "title": "Che cos'\u00e8 Yii?"
        },
        {
            "location": "/#perche-confrontare-yii-con-gli-altri-framework",
            "text": "Se hai gi\u00e0 familiarit\u00e0 con altri Framework, potresti apprezzare di sapere le caratteristiche di Yii:  - Come la maggior parte dei framework PHP, Yii implementa il modello \n  architetturale MVC (model - view - controller) e promuove l'organizzazione \n  dei codici in base a quel modello.\n- Yii prende la filosofia che il codice deve essere scritto in modo semplice ma \n  elegante. Yii non cercher\u00e0 mai di sovrascrivere le cose, principalmente allo\n  scopo di seguire un modello di progettazione.\n- Yii \u00e8 un framework full-stack che fornisce molte funzionalit\u00e0 pronte \n  all'uso come i costruttori di query, l'Active Record per i database \n  relazionali e NoSQL; Massimo supporto per lo sviluppo di API, e molto \n  altro ancora.\n- Yii \u00e8 estremamente estensibile. E' possibile personalizzare o sostituire \n  quasi ogni pezzo di codice. E' inoltre possibile sfruttare l'architettura \n  solida di Yii per sviluppare estensioni ridistribuibili.\n- Obbiettivo primario di Yii \u00e8 quello di poter offrire alte prestazioni.",
            "title": "Perch\u00e8 confrontare Yii con gli altri Framework?"
        },
        {
            "location": "/#versioni-di-yii",
            "text": "Attualmente Yii dispone di due versioni principali: 1.1 e 2.0. La nuova versione 2.0 \u00e8 una riscrittura completa di Yii, adottando le pi\u00f9 recenti tecnologie e protocolli, tra cui Composer, PSR, namespaces e cos\u00ec via. Questa guida riguarder\u00e0 principalmente la versione 2.0.",
            "title": "Versioni di Yii"
        },
        {
            "location": "/#requisiti-e-prerequisiti",
            "text": "Yii 2.0 richiede PHP 5.4.0 o superiore e funziona meglio con l'ultima versione di PHP 7. E' possibile trovare requisiti pi\u00f9 dettagliati per le singole funzionalit\u00e0 eseguendo il checker di requisiti incluso in ogni versione di Yii.  L'utilizzo di Yii richiede la conoscenza base della programmazione orientata agli oggetti (OOP), in quanto Yii \u00e8 un framework puro basato su OOP. Yii 2.0 utilizza anche funzionalit\u00e0 del PHP, come i namespaces e i traits.",
            "title": "Requisiti e Prerequisiti"
        },
        {
            "location": "/getting-started/sub-installing-Yii/",
            "text": "Installazione di Yii\n\n\nE\u2019 possibile installare Yii in due modi. Installarlo tramite Composer oppure installarlo da un file di archivio. Il primo \u00e8 il metodo migliore, in quanto consente di installare nuove estensioni oppure di aggiornare Yii in modo semplice.\nIn questa e nelle prossime sezioni descriveremo come installare Yii e di come implementare tutte le sue funzionalit\u00e0 e i suoi utilizzi. Esistono due versioni di Yii: la versione base (basic) e la versione avanzata(advanced). La basic \u00e8 diversa dall\u2019advanced principalmente per l\u2019organizzazione del codice. Nel primo avremo una struttura MVC, mentre nell\u2019advanced avremmo due strutture MVC separate. La parte \u201cbackend\u201d e la parte \u201cfrontend\u201d.\n\n\nInfo: Il modello della versione basic \u00e8 adatto allo sviluppo del 90% delle applicazioni Web. Se sei nuovo a Yii, ti consigliamo di attenersi al modello della versione basic per la sua semplicit\u00e0 e le sue funzionalit\u00e0.\n\n\nInstallazione tramite Composer\n\n\nSe \u00e8 la prima volta che installi il Composer, puoi seguire le istruzioni di \nhttps://getcomposer.org/download/\n . Su Linux e Max OS X, eseguire i seguenti comandi:\n\n\ncurl -sS https://getcomposer.org/installer | php \nmv composer.phar /usr/local/bin/composer\n\n\n\nIn questa guida tutti i comandi del compositore presuppongono di aver installato il compositore a livello globale in modo che sia disponibile come comando\ncomposer\n. \n\n\nSe hai gi\u00e0 installato Composer, assicuratevi di utilizzare una versione aggiornata. E' possibile aggiornare il proprio Composer con il comando \ncomposer self-update\n.\n\n\nInstallazione di Yii\n\n\nCon Composer installato, \u00e8 possibile installare Yii eseguendo i seguenti comandi in una cartella accessibile a Web.\n\n\ncomposer global require \"fxp/composer-asset-plugin:^1.3.1\"\ncomposer create-project --prefer-dist yiisoft/yii2-app-basic basic\n\n\n\nIl primo comando installa il plugin asset del Composer che consente di gestire le dipendenze del pacchetto. Basta eseguirlo solo una volta. Il secondo comando installa l'ultima versione stabile di Yii in una directory denominata \nbasic\n. Se si desidera \u00e8 possibile scegliere un nome diverso per la directory di destinazione.\n\n\n\n\nNote\n\n\nSe si desidera installare l'ultima versione di sviluppo di Yii, \u00e8 possibile utilizzare il seguente comando che permette di aggiungere un'opzione di stabilit\u00e0\n\n\ncomposer create-project --prefer-dist --stability=dev yiisoft/yii2-app-basic basic\n\n\n\n\n\nInstallazione da un file di archivio\n\n\nL'installazione di Yii da un file di archivio prevede 3 passaggi:\n1. Scaricare il file dall'archivio di http://www.yiiframework.com/download/.\n2. Scompattare il file scaricato in una cartella accessibile a web.\n3. Modificare il file \nconfig/web.php\n immettendo una chiave segreta per la \ncookieValidationKey\n (voce di configurazione). Questo avviene automaticamente se si installa Yii con Composer).\n\n\n// !!! insert a secret key in the following (if it is empty) - this is required \n       by cookie validation\n\n'cookieValidationKey' =\n 'enter your secret key here',\n\n\n\nVerifica dell'installazione\n\n\nUna volta completata l'installazione, configurare il server Web (vedere le sezione successiva)  oppure utilizzare il server Web incorporato PHP eseguendo il seguente comando della console nella \nweb\n directory del progetto\n\n\nphp yii serve\n\n\n\n\n\n\n\nNota: per impostazione predefinita, il server HTTP ascolter\u00e0 la porta 8080. Tuttavia, se la porta \u00e8 gi\u00e0 in uso o si desidera utilizzare pi\u00f9 applicazioni in questo modo, \u00e8 possibile specificare quale porta deve essere utilizzata. Basta aggiungere l'argomento -port\n\n\nphp yii serve --port=8888\n\n\n\n\n\n\nE' possibile usare il browser per accedere all'applicazione Yii installata con il seguente URL:\n\n\nhttp://localhost:8080/\n\n\n\n     \n\n\nDovresti avere una schermata uguale a quella sopra. Se ci\u00f2 non si vede, controlla se l'installazione PHP soddisfa i requisiti di Yii. E' possibile verificare se i requisiti minimi sono soddisfatti utilizzando uno dei sequenti approcci:\n- Copia \n\\requirements.php\n di \n/web/requirements.php\n e quindi utilizzare un browser per accedervi attraverso il seguene link \nhttp://localhost/requirements.php\n\n- Eseguire i seguenti comandi\n    cd basic\n    php requirements.php\n\n\nE' necessario configurare l'installazione PHP in modo da soddisfare i requisiti minimi di Yii.\n\n\nConfigurazione del server Web\n\n\n\n\nNote\n\n\nE' possibile saltare questa sezione per ora se si sta seguendo la guida di Yii senza alcuna intenzione di distribuirla a un server di produzione.\n\n\n\n\nSu un server di produzione, \u00e8 possibile configurare il server Web in modo che l'applicazione sia accessibile tramite l'URL \nhttp://www.example.com/index.php\n anzich\u00e8 \nhttp://www.example.com/basic/web/index.php\n. Tale configurazione richiede di indicare la radice del documento del server Web nella cartella\nbasic/web\n.\nSi potrebbe anche desiderare di nascondere nell'URL \nindex.php\n.",
            "title": "Installazione di Yii"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#installazione-di-yii",
            "text": "E\u2019 possibile installare Yii in due modi. Installarlo tramite Composer oppure installarlo da un file di archivio. Il primo \u00e8 il metodo migliore, in quanto consente di installare nuove estensioni oppure di aggiornare Yii in modo semplice.\nIn questa e nelle prossime sezioni descriveremo come installare Yii e di come implementare tutte le sue funzionalit\u00e0 e i suoi utilizzi. Esistono due versioni di Yii: la versione base (basic) e la versione avanzata(advanced). La basic \u00e8 diversa dall\u2019advanced principalmente per l\u2019organizzazione del codice. Nel primo avremo una struttura MVC, mentre nell\u2019advanced avremmo due strutture MVC separate. La parte \u201cbackend\u201d e la parte \u201cfrontend\u201d.  Info: Il modello della versione basic \u00e8 adatto allo sviluppo del 90% delle applicazioni Web. Se sei nuovo a Yii, ti consigliamo di attenersi al modello della versione basic per la sua semplicit\u00e0 e le sue funzionalit\u00e0.",
            "title": "Installazione di Yii"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#installazione-tramite-composer",
            "text": "Se \u00e8 la prima volta che installi il Composer, puoi seguire le istruzioni di  https://getcomposer.org/download/  . Su Linux e Max OS X, eseguire i seguenti comandi:  curl -sS https://getcomposer.org/installer | php \nmv composer.phar /usr/local/bin/composer  In questa guida tutti i comandi del compositore presuppongono di aver installato il compositore a livello globale in modo che sia disponibile come comando composer .   Se hai gi\u00e0 installato Composer, assicuratevi di utilizzare una versione aggiornata. E' possibile aggiornare il proprio Composer con il comando  composer self-update .",
            "title": "Installazione tramite Composer"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#installazione-di-yii_1",
            "text": "Con Composer installato, \u00e8 possibile installare Yii eseguendo i seguenti comandi in una cartella accessibile a Web.  composer global require \"fxp/composer-asset-plugin:^1.3.1\"\ncomposer create-project --prefer-dist yiisoft/yii2-app-basic basic  Il primo comando installa il plugin asset del Composer che consente di gestire le dipendenze del pacchetto. Basta eseguirlo solo una volta. Il secondo comando installa l'ultima versione stabile di Yii in una directory denominata  basic . Se si desidera \u00e8 possibile scegliere un nome diverso per la directory di destinazione.   Note  Se si desidera installare l'ultima versione di sviluppo di Yii, \u00e8 possibile utilizzare il seguente comando che permette di aggiungere un'opzione di stabilit\u00e0  composer create-project --prefer-dist --stability=dev yiisoft/yii2-app-basic basic",
            "title": "Installazione di Yii"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#installazione-da-un-file-di-archivio",
            "text": "L'installazione di Yii da un file di archivio prevede 3 passaggi:\n1. Scaricare il file dall'archivio di http://www.yiiframework.com/download/.\n2. Scompattare il file scaricato in una cartella accessibile a web.\n3. Modificare il file  config/web.php  immettendo una chiave segreta per la  cookieValidationKey  (voce di configurazione). Questo avviene automaticamente se si installa Yii con Composer).  // !!! insert a secret key in the following (if it is empty) - this is required \n       by cookie validation\n\n'cookieValidationKey' =  'enter your secret key here',",
            "title": "Installazione da un file di archivio"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#verifica-dellinstallazione",
            "text": "Una volta completata l'installazione, configurare il server Web (vedere le sezione successiva)  oppure utilizzare il server Web incorporato PHP eseguendo il seguente comando della console nella  web  directory del progetto  php yii serve    Nota: per impostazione predefinita, il server HTTP ascolter\u00e0 la porta 8080. Tuttavia, se la porta \u00e8 gi\u00e0 in uso o si desidera utilizzare pi\u00f9 applicazioni in questo modo, \u00e8 possibile specificare quale porta deve essere utilizzata. Basta aggiungere l'argomento -port  php yii serve --port=8888    E' possibile usare il browser per accedere all'applicazione Yii installata con il seguente URL:  http://localhost:8080/         Dovresti avere una schermata uguale a quella sopra. Se ci\u00f2 non si vede, controlla se l'installazione PHP soddisfa i requisiti di Yii. E' possibile verificare se i requisiti minimi sono soddisfatti utilizzando uno dei sequenti approcci:\n- Copia  \\requirements.php  di  /web/requirements.php  e quindi utilizzare un browser per accedervi attraverso il seguene link  http://localhost/requirements.php \n- Eseguire i seguenti comandi\n    cd basic\n    php requirements.php  E' necessario configurare l'installazione PHP in modo da soddisfare i requisiti minimi di Yii.",
            "title": "Verifica dell'installazione"
        },
        {
            "location": "/getting-started/sub-installing-Yii/#configurazione-del-server-web",
            "text": "Note  E' possibile saltare questa sezione per ora se si sta seguendo la guida di Yii senza alcuna intenzione di distribuirla a un server di produzione.   Su un server di produzione, \u00e8 possibile configurare il server Web in modo che l'applicazione sia accessibile tramite l'URL  http://www.example.com/index.php  anzich\u00e8  http://www.example.com/basic/web/index.php . Tale configurazione richiede di indicare la radice del documento del server Web nella cartella basic/web .\nSi potrebbe anche desiderare di nascondere nell'URL  index.php .",
            "title": "Configurazione del server Web"
        },
        {
            "location": "/getting-started/sub-saying-hello/",
            "text": "Iniziamo con un \"Ciao\"\n\n\nQuesta sezione descrive come creare una nuova pagina \"Ciao\" nella nostra applicazione. Per effettuare ci\u00f2, dovremmo creare un'azione e una vista.\n- L'applicazione invier\u00e0 la richiesta di pagina all'azione\n- e l'azione render\u00e0 a sua volta la visualizzazione della pagina all'utente finale con su scritta la parola \"Ciao\".\n\n\nCreazione di un'azione\n\n\nPer l'attivit\u00e0 che dovr\u00e0 scrivere \"Ciao\", bisogna creare un'azione  \nsay\n che legge un messaggio (\nmessage\n) come parametro dalla richiesta e visuallizza quel messaggio all'utente. Se la richiesta non fornisce un messaggio come parametro, l'azione visualizzer\u00e0 come predefinito la parola \"Ciao\".\n\n\nLe azioni devono essere dichiarate nella cartella \"controllers\". Per semplicit\u00e0, puoi dichiarare l'azione \nsay\n nell'esistente \nSiteController\n. Questo controller \u00e8 definito nel file che si trova in \ncontrollers/SiteControlle.php\n. Ecco l'inizio della nostra azione:\n\n\n?php\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    // ...existing code...\n\n    public function actionSay($message = 'Hello'){\n\n        return $this-\nrender('say', ['message' =\n $message]);\n\n    }\n}\n\n\n\nNel codice precedente l'azione \nsay\n viene definita in un metodo chiamato \nactionSay\n nella classe \nSiteController\n. Yii utilizza il prefisso \naction\n per differenziare i metodi d'azione dai metodi non di azione in una classe di controller. Il nome dopo l'\naction\n mappa l'ID dell'azione da effettuare.\n\n\nQuando si tratta di denominare le azioni, \u00e8 necessario capire come Yii tratta gli ID relativi all'azione che richiamiamo. I nomi/numeri relativi all'azione sono sempre indicati in minuscolo. Se un ID di un'azione \u00e8 composto da pi\u00f9 parole, verranno concatenate con i trattini ( per esempio, \ncreate-comment\n). I nomi del metodo di un'azione vengono mappati rimuovendo i trattini dall'ID, capitalizzando la prima lettera di ogni parola con la parola \naction\n. Ade esempio, l'ID associato all'azione \ncreate-comment\n corrisponde al nome del metodo dell'azione, che sar\u00e0 \nactionCreateComment\n.\n\n\nCreazione di una vista\n\n\nLe viste(views) sono gli script che scrivi per generare una risposta ad una determinata azione e stampata a video. Per l'attivit\u00e0 \"Ciao\", verr\u00e0 creata una vista relativa al \nsay\n che avr\u00e0 il compito di stampare il valore contenuto in \n$message\n a video.\n\n\n?php\nuse yii\\helpers\\Html;\n?\n\n\n?= Html::encode($message) ?\n\n\n\n\nLa vista relativa al \nsay\n deve essere salvata nel file \nviews/site/say.php\n.  Quando il metodo render() [inizializzato nel controller] verr\u00e0 chiamato in un'azione, cercher\u00e0 un file PHP denominato come segue:\n\n\nviews/ControllerID/ViewsName.php\n\n\nSi noti che nel codice soprastante il parametro \n$message\n \u00e8 codificato in HTML prima di essere stampato. Ci\u00f2 \u00e8 necessario poich\u00e8 il parametro viene da un utente finale, rendendolo vulnerabile agli attacchi di \"scripting cross-site(XSS)\n\" incorporando codice JavaScript dannoso all'interno del nostro parametro.\n\n\nDopo aver creato l'azione e la vista, puoi accedere alla nuova pagina tramite il seguente URL:\n\n\nhttp://hostname/index.php?r=site%2Fsay\nmessage=Hello+World\n\n\n\n\n\nSe tutto \u00e8 andato bene, visualizzerete a video un messaggio con su scritto \"Ciao!\".  Questo perch\u00e8 \nmessage\n viene passato come parametro al metodo nel Controller \nactionSay()\n. Il layout della pagina  (intestazione e pi\u00e8 di pagina) resta il solito perch\u00e8 il metodo render() incorpora automaticamente il risultato della vista del \nsay\n in un layout di default, che si trova in \nviews/layouts/main.php\n.\n\n\nIl parametro \nr\n nell'URL indicata sopra richiede ulteriori spiegazioni. Si tratta del percordo di un ID univoco dell'applicazione che si riferisce ad un'azione. Il formato del percordo \u00e8 \nControllerID/ActionID\n. Quando l'azione riceve una richiesta, verifica questo parametro utlizzando la parte del \nControllerID\n per determinare quale classe del controller deve essere instanziata per gestire la richiesta. A questo punto, il controllore user\u00e0 la parte dell'\nActionID\n per determinare quale azione deve essere instanziata. Nel nostro esempio, il percordo \nsite/say\n verr\u00e0 controllato nel file \nSiteController\n usando l'ID dell'azione \nsay\n. Di conseguenza verr\u00e0 richiamato il metodo \nactionSay()\n.",
            "title": "Iniziamo con un \"Ciao\""
        },
        {
            "location": "/getting-started/sub-saying-hello/#iniziamo-con-un-ciao",
            "text": "Questa sezione descrive come creare una nuova pagina \"Ciao\" nella nostra applicazione. Per effettuare ci\u00f2, dovremmo creare un'azione e una vista.\n- L'applicazione invier\u00e0 la richiesta di pagina all'azione\n- e l'azione render\u00e0 a sua volta la visualizzazione della pagina all'utente finale con su scritta la parola \"Ciao\".",
            "title": "Iniziamo con un \"Ciao\""
        },
        {
            "location": "/getting-started/sub-saying-hello/#creazione-di-unazione",
            "text": "Per l'attivit\u00e0 che dovr\u00e0 scrivere \"Ciao\", bisogna creare un'azione   say  che legge un messaggio ( message ) come parametro dalla richiesta e visuallizza quel messaggio all'utente. Se la richiesta non fornisce un messaggio come parametro, l'azione visualizzer\u00e0 come predefinito la parola \"Ciao\".  Le azioni devono essere dichiarate nella cartella \"controllers\". Per semplicit\u00e0, puoi dichiarare l'azione  say  nell'esistente  SiteController . Questo controller \u00e8 definito nel file che si trova in  controllers/SiteControlle.php . Ecco l'inizio della nostra azione:  ?php\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    // ...existing code...\n\n    public function actionSay($message = 'Hello'){\n\n        return $this- render('say', ['message' =  $message]);\n\n    }\n}  Nel codice precedente l'azione  say  viene definita in un metodo chiamato  actionSay  nella classe  SiteController . Yii utilizza il prefisso  action  per differenziare i metodi d'azione dai metodi non di azione in una classe di controller. Il nome dopo l' action  mappa l'ID dell'azione da effettuare.  Quando si tratta di denominare le azioni, \u00e8 necessario capire come Yii tratta gli ID relativi all'azione che richiamiamo. I nomi/numeri relativi all'azione sono sempre indicati in minuscolo. Se un ID di un'azione \u00e8 composto da pi\u00f9 parole, verranno concatenate con i trattini ( per esempio,  create-comment ). I nomi del metodo di un'azione vengono mappati rimuovendo i trattini dall'ID, capitalizzando la prima lettera di ogni parola con la parola  action . Ade esempio, l'ID associato all'azione  create-comment  corrisponde al nome del metodo dell'azione, che sar\u00e0  actionCreateComment .",
            "title": "Creazione di un'azione"
        },
        {
            "location": "/getting-started/sub-saying-hello/#creazione-di-una-vista",
            "text": "Le viste(views) sono gli script che scrivi per generare una risposta ad una determinata azione e stampata a video. Per l'attivit\u00e0 \"Ciao\", verr\u00e0 creata una vista relativa al  say  che avr\u00e0 il compito di stampare il valore contenuto in  $message  a video.  ?php\nuse yii\\helpers\\Html;\n?  ?= Html::encode($message) ?   La vista relativa al  say  deve essere salvata nel file  views/site/say.php .  Quando il metodo render() [inizializzato nel controller] verr\u00e0 chiamato in un'azione, cercher\u00e0 un file PHP denominato come segue:  views/ControllerID/ViewsName.php  Si noti che nel codice soprastante il parametro  $message  \u00e8 codificato in HTML prima di essere stampato. Ci\u00f2 \u00e8 necessario poich\u00e8 il parametro viene da un utente finale, rendendolo vulnerabile agli attacchi di \"scripting cross-site(XSS)\n\" incorporando codice JavaScript dannoso all'interno del nostro parametro.  Dopo aver creato l'azione e la vista, puoi accedere alla nuova pagina tramite il seguente URL:  http://hostname/index.php?r=site%2Fsay message=Hello+World   Se tutto \u00e8 andato bene, visualizzerete a video un messaggio con su scritto \"Ciao!\".  Questo perch\u00e8  message  viene passato come parametro al metodo nel Controller  actionSay() . Il layout della pagina  (intestazione e pi\u00e8 di pagina) resta il solito perch\u00e8 il metodo render() incorpora automaticamente il risultato della vista del  say  in un layout di default, che si trova in  views/layouts/main.php .  Il parametro  r  nell'URL indicata sopra richiede ulteriori spiegazioni. Si tratta del percordo di un ID univoco dell'applicazione che si riferisce ad un'azione. Il formato del percordo \u00e8  ControllerID/ActionID . Quando l'azione riceve una richiesta, verifica questo parametro utlizzando la parte del  ControllerID  per determinare quale classe del controller deve essere instanziata per gestire la richiesta. A questo punto, il controllore user\u00e0 la parte dell' ActionID  per determinare quale azione deve essere instanziata. Nel nostro esempio, il percordo  site/say  verr\u00e0 controllato nel file  SiteController  usando l'ID dell'azione  say . Di conseguenza verr\u00e0 richiamato il metodo  actionSay() .",
            "title": "Creazione di una vista"
        },
        {
            "location": "/getting-started/sub-working-with-forms/",
            "text": "Lavorare con i moduli\n\n\nQuesta sezione descrive come creare una nuova pagina con un modulo per ottenere dati/informazioni dall'utente. La pagina visualizzer\u00e0 una maschera con due campi di immmissione. Un campo per il nome e l'altra per l'e-mail. Dopo aver ricevuto i due valori dall'utente, la pagina ristamper\u00e0 i valori inseriti per conferma.\n\n\nAttraverso questo tutorial imparerai come:\n- creare un modello per rappresentare i dati inseriti da un utente attraverso un modulo.\n- dichiarare regole per convalidare i dati inseriti.\n- costruire un modulo HTML in una views.\n\n\nCreazione di un modello\n\n\nI dati da richiedere all'utente finale verranno rappresentati da una classe \nEntryForm\n (come mostrata di seguito) e salvata nella seguente directory \nmodels/EntryForm.php\n.\n\n\nCodice EntryForm.php\n\n\n?php\n\nnamespace app\\models;\n\nuse Yii;\nuse yii\\base\\Model;\n\nclass EntryForm extends Model{\n\n    public $name;\n    public $email;\n\n    public function rules(){\n\n        return [\n            [['name', 'email'], 'required'],\n            ['email', 'email'],\n        ];\n    }\n}\n\n\n\nLa classe \nEntryForm\n contiene due valori pubblici: \nname\n e \nemail\n, utilizzati per memorizzare i dati immessi dall'utente. Inoltre contiene un metodo denominato \nrules()\n che restituisce un insieme di regole per la convalida dei dati. Le regole di convalida scritte in precedenza controllano:\n\n\n\n\nentrambe le variabili \nname\n e \nemail\n che non siano vuote e che siano stati inseriti dei valori;\n\n\nche il campo \nemail\n deve coincidere con un indirizzo e-mail valido.\n\n\n\n\nSe si dispone di un oggetto \nEntryForm\n popolato con i dati immessi dall'utente, \u00e8 possibile chiamare il metodo validate() per attivare la routine di convalida dei dati. Se avviene un errore di convalida dei dati, verr\u00e0 stabilito il valore \"true\" alla propriet\u00e0 hasErrors e possiamo anche conoscere quali errori di convalida si verificano.\n\n\n?php\n    $model = new EntryForm();\n    $model-\nname = 'Qiang';\n    $model-\nemail = 'bad';\n    if ($model-\nvalidate()) {\n        // Good!   \n    } else {\n        // Failure!\n        // Use $model-\ngetErrors()\n    }\n?\n\n\n\n\nCreazione di un'azione\n\n\nSuccessivamente \u00e8 necessario creare un'azione di inserimento \nentry\n all'interno del file controllore della nostra applicazione (\nSiteController\n).\n\n\n?php\n\nnamespace app\\controllers;\n\nuse Yii;\nuse yii\\web\\Controller;\nuse app\\models\\EntryForm;\n\nclass SiteController extends Controller{\n\n    // ...existing code...\n\n    public function actionEntry(){\n\n        $model = new EntryForm();\n\n        if ($model-\nload(Yii::$app-\nrequest-\npost()) \n $model-\nvalidate()) {\n            // valid data received in $model\n\n            // do something meaningful here about $model ...\n\n            return $this-\nrender('entry-confirm', ['model' =\n $model]);\n        } else {\n            // either the page is initially displayed or there is some validation error\n            return $this-\nrender('entry', ['model' =\n $model]);\n        }\n    }\n}\n\n\n\nPer prima cosa viene creato un oggetto di tipo \nEntryForm\n. A questo punto cercher\u00e0 di popolare il modello con i dati $_POST forniti da Yii. Se il modello \u00e8 stato popolato correttamente, l'azione richiamer\u00e0 il metodo validate() per assicurarsi che i valori immessi siano validi.\n\n\n\n\nNote\n\n\nL'espressione \nYii::$app\n rappresenta l'istanza di applicazione, che \u00e8 un singleton accessibile a livello globale. E' anche un servizio che fornisce componenti quali \nrequest , response , db\n, ecc per supportare una specifica funzionalit\u00e0. Nel codice precedente il componente \nrequest\n viene utilizzato per accedere ai dati in \n$_POST\n.\n\n\n\n\nSe tutto va bene, l'azione render\u00e0 una vista denominata \nentry-confirm\n per confermare la presentazione dei dati in modo corretto all'utente. Se non vengono inviati i dati in modo corretto oppure i dati contengono errori, avremmo la visualizzazione dell'\nentry\n, in cui verr\u00e0 mostrata la maschera HTML insieme a tutti i messaggi di errori ( o di convalida).\n\n\nCreazione di Viste\n\n\nInfine, dobbiamo creare due file view denominati \nentry-form\n e \nentry\n. All'interno del primo file avverr\u00e0 la visualizzazione del nome e dell'email inseriti dall'utente. Questi dati devono essere memorizzati nella seguente directory: \nviews/site/entry-confirm.php\n.\n\n\nENTRY-CONFIRM.php\n\n\n?php\nuse yii\\helpers\\Html;\n?\n\n\np\nYou have entered the following information:\n/p\n\n\n\nul\n\n    \nli\nlabel\nName\n/label\n: \n?= Html::encode($model-\nname) ?\n/li\n\n    \nli\nlabel\nEmail\n/label\n: \n?= Html::encode($model-\nemail) ?\n/li\n\n\n/ul\n\n\n\n\nMentre all'interno del file \nentry\n ci sar\u00e0 la visualizzazione del modulo in HTML dove l'utente dovr\u00e0 inserire i propri dati. Questo file deve essere memorizzato nella seguente directory: \nviews/site/entry.php\n.\n\n\nENTRY.php\n\n\n?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\ActiveForm;\n?\n\n\n?php $form = ActiveForm::begin(); ?\n\n\n    \n?= $form-\nfield($model, 'name') ?\n\n\n    \n?= $form-\nfield($model, 'email') ?\n\n\n    \ndiv class=\"form-group\"\n\n        \n?= Html::submitButton('Submit', ['class' =\n 'btn btn-primary']) ?\n\n    \n/div\n\n\n\n?php ActiveForm::end(); ?\n\n\n\n\nLa vista \nentry.php\n utilizza un potente widget denominato \"ActiveForm\" per creare il modulo HTML. I metodi \nbegin()\n e \nend()\n vengono usati per tag di apertura e chiusura. Tra le due chiamate , i campi di input vengono creati dal metodo \nfield()\n. Il primo campo \u00e8 relativo al nome, mentre il secondo \u00e8 relativo all'email. Dopo i campi di input, il metodo \"submitButton\" viene chiamato per generare il pulsante di invio.\n\n\nPer controllare se tutto funziona, bisogna inserire il seguente URL nel browser\n\n\nhttp://hostname/index.php?r=site%2Fentry\n\n\n\n\n\nDopo aver inserito un nome e una e-mail validi e facendo sul pulsante \"Submit\", verr\u00e0 visualizzata una pagina che visualizzer\u00e0 i dati appena immessi.",
            "title": "Lavoriamo con i moduli"
        },
        {
            "location": "/getting-started/sub-working-with-forms/#lavorare-con-i-moduli",
            "text": "Questa sezione descrive come creare una nuova pagina con un modulo per ottenere dati/informazioni dall'utente. La pagina visualizzer\u00e0 una maschera con due campi di immmissione. Un campo per il nome e l'altra per l'e-mail. Dopo aver ricevuto i due valori dall'utente, la pagina ristamper\u00e0 i valori inseriti per conferma.  Attraverso questo tutorial imparerai come:\n- creare un modello per rappresentare i dati inseriti da un utente attraverso un modulo.\n- dichiarare regole per convalidare i dati inseriti.\n- costruire un modulo HTML in una views.",
            "title": "Lavorare con i moduli"
        },
        {
            "location": "/getting-started/sub-working-with-forms/#creazione-di-un-modello",
            "text": "I dati da richiedere all'utente finale verranno rappresentati da una classe  EntryForm  (come mostrata di seguito) e salvata nella seguente directory  models/EntryForm.php .  Codice EntryForm.php  ?php\n\nnamespace app\\models;\n\nuse Yii;\nuse yii\\base\\Model;\n\nclass EntryForm extends Model{\n\n    public $name;\n    public $email;\n\n    public function rules(){\n\n        return [\n            [['name', 'email'], 'required'],\n            ['email', 'email'],\n        ];\n    }\n}  La classe  EntryForm  contiene due valori pubblici:  name  e  email , utilizzati per memorizzare i dati immessi dall'utente. Inoltre contiene un metodo denominato  rules()  che restituisce un insieme di regole per la convalida dei dati. Le regole di convalida scritte in precedenza controllano:   entrambe le variabili  name  e  email  che non siano vuote e che siano stati inseriti dei valori;  che il campo  email  deve coincidere con un indirizzo e-mail valido.   Se si dispone di un oggetto  EntryForm  popolato con i dati immessi dall'utente, \u00e8 possibile chiamare il metodo validate() per attivare la routine di convalida dei dati. Se avviene un errore di convalida dei dati, verr\u00e0 stabilito il valore \"true\" alla propriet\u00e0 hasErrors e possiamo anche conoscere quali errori di convalida si verificano.  ?php\n    $model = new EntryForm();\n    $model- name = 'Qiang';\n    $model- email = 'bad';\n    if ($model- validate()) {\n        // Good!   \n    } else {\n        // Failure!\n        // Use $model- getErrors()\n    }\n?",
            "title": "Creazione di un modello"
        },
        {
            "location": "/getting-started/sub-working-with-forms/#creazione-di-unazione",
            "text": "Successivamente \u00e8 necessario creare un'azione di inserimento  entry  all'interno del file controllore della nostra applicazione ( SiteController ).  ?php\n\nnamespace app\\controllers;\n\nuse Yii;\nuse yii\\web\\Controller;\nuse app\\models\\EntryForm;\n\nclass SiteController extends Controller{\n\n    // ...existing code...\n\n    public function actionEntry(){\n\n        $model = new EntryForm();\n\n        if ($model- load(Yii::$app- request- post())   $model- validate()) {\n            // valid data received in $model\n\n            // do something meaningful here about $model ...\n\n            return $this- render('entry-confirm', ['model' =  $model]);\n        } else {\n            // either the page is initially displayed or there is some validation error\n            return $this- render('entry', ['model' =  $model]);\n        }\n    }\n}  Per prima cosa viene creato un oggetto di tipo  EntryForm . A questo punto cercher\u00e0 di popolare il modello con i dati $_POST forniti da Yii. Se il modello \u00e8 stato popolato correttamente, l'azione richiamer\u00e0 il metodo validate() per assicurarsi che i valori immessi siano validi.   Note  L'espressione  Yii::$app  rappresenta l'istanza di applicazione, che \u00e8 un singleton accessibile a livello globale. E' anche un servizio che fornisce componenti quali  request , response , db , ecc per supportare una specifica funzionalit\u00e0. Nel codice precedente il componente  request  viene utilizzato per accedere ai dati in  $_POST .   Se tutto va bene, l'azione render\u00e0 una vista denominata  entry-confirm  per confermare la presentazione dei dati in modo corretto all'utente. Se non vengono inviati i dati in modo corretto oppure i dati contengono errori, avremmo la visualizzazione dell' entry , in cui verr\u00e0 mostrata la maschera HTML insieme a tutti i messaggi di errori ( o di convalida).",
            "title": "Creazione di un'azione"
        },
        {
            "location": "/getting-started/sub-working-with-forms/#creazione-di-viste",
            "text": "Infine, dobbiamo creare due file view denominati  entry-form  e  entry . All'interno del primo file avverr\u00e0 la visualizzazione del nome e dell'email inseriti dall'utente. Questi dati devono essere memorizzati nella seguente directory:  views/site/entry-confirm.php .  ENTRY-CONFIRM.php  ?php\nuse yii\\helpers\\Html;\n?  p You have entered the following information: /p  ul \n     li label Name /label :  ?= Html::encode($model- name) ? /li \n     li label Email /label :  ?= Html::encode($model- email) ? /li  /ul   Mentre all'interno del file  entry  ci sar\u00e0 la visualizzazione del modulo in HTML dove l'utente dovr\u00e0 inserire i propri dati. Questo file deve essere memorizzato nella seguente directory:  views/site/entry.php .  ENTRY.php  ?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\ActiveForm;\n?  ?php $form = ActiveForm::begin(); ? \n\n     ?= $form- field($model, 'name') ? \n\n     ?= $form- field($model, 'email') ? \n\n     div class=\"form-group\" \n         ?= Html::submitButton('Submit', ['class' =  'btn btn-primary']) ? \n     /div  ?php ActiveForm::end(); ?   La vista  entry.php  utilizza un potente widget denominato \"ActiveForm\" per creare il modulo HTML. I metodi  begin()  e  end()  vengono usati per tag di apertura e chiusura. Tra le due chiamate , i campi di input vengono creati dal metodo  field() . Il primo campo \u00e8 relativo al nome, mentre il secondo \u00e8 relativo all'email. Dopo i campi di input, il metodo \"submitButton\" viene chiamato per generare il pulsante di invio.  Per controllare se tutto funziona, bisogna inserire il seguente URL nel browser  http://hostname/index.php?r=site%2Fentry   Dopo aver inserito un nome e una e-mail validi e facendo sul pulsante \"Submit\", verr\u00e0 visualizzata una pagina che visualizzer\u00e0 i dati appena immessi.",
            "title": "Creazione di Viste"
        },
        {
            "location": "/getting-started/sub-working-with-database/",
            "text": "Lavorare con i database\n\n\nQuesta sezione descrive come creare una nuova pagina che visualizza i dati di una paese recuperati da una tabella di database denominata \ncountry\n. Per raggiungere questo obiettivo, sar\u00e0 possibile configurare una connessione di database,creare una classe \"Active Record\", definire un'azione e creare una vista.\nAttraverso questo tutorial, imparerai come:\n- configurare una connessione DB,\n- definire una classe Active Record,\n- scrivere una query utilizzando la classe Active Record,\n- visualizzare i dati in una vista in modo paginato.\n\n\nTieni presente che per terminare questa sezione, dovresti avere conoscenze e esperienze di base nell'utilizzo dei database. In particolare, si dovrebbe sapere come creare un database e come seguire le istruzioni SQL utilizzando uno strumento client del DB.\n\n\nPreparazione del Database\n\n\nPer iniziare, creare un database denominato \nyii2basic\n, da cui recupererai i dati nell'applicazione. E' possibile creare un database SQLite,MySQL, MSSQL, Oracle, in quanto Yii ha un supporto integrato per molte applicazioni di database. Nella seguente descrizione, per assumeremo la descrizione di un database MySQL.\n\n\nA questo punto, dobbiamo creare una tabella denominata \ncountry\n nel database e inserire alcuni dati di esempio. E' possibile eseguire le seguenti istruzioni SQL per effettuarlo:\n\n\nCREATE TABLE `country` (\n    `code` CHAR(2) NOT NULL PRIMARY KEY,\n    `name` CHAR(52) NOT NULL,\n    `population` INT(11) NOT NULL DEFAULT '0'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `country` VALUES ('AU','Australia',24016400);\nINSERT INTO `country` VALUES ('BR','Brazil',205722000);\nINSERT INTO `country` VALUES ('CA','Canada',35985751);\nINSERT INTO `country` VALUES ('CN','China',1375210000);\nINSERT INTO `country` VALUES ('DE','Germany',81459000);\nINSERT INTO `country` VALUES ('FR','France',64513242);\nINSERT INTO `country` VALUES ('GB','United Kingdom',65097000);\nINSERT INTO `country` VALUES ('IN','India',1285400000);\nINSERT INTO `country` VALUES ('RU','Russia',146519759);\nINSERT INTO `country` VALUES ('US','United States',322976000);\n\n\n\nA questo punto,hai un database denominato \nyii2basic\n e all'interno di essa una tabella denominata \ncountry\n con tre colonne contenenti dieci righe di dati.\n\n\nConfigurazione di una connessione DB\n\n\nPrima di procedere, assicurarsi di aver installato sia l'estensione  del PDO di PHP che il driver PDO per il database che si sta utilizzando.\nCon quelli installati, aprire il file \nconfig/db.php\n e cambiare i parametri per far si che la connessione con il DB avvenga con successo. Per impostazione predefinita, il file \u00e8 composto come segue:\n\n\n?php\n\nreturn [\n    'class' =\n 'yii\\db\\Connection',\n    'dsn' =\n 'mysql:host=localhost;dbname=yii2basic',\n    'username' =\n 'root',\n    'password' =\n '',\n    'charset' =\n 'utf8',\n];\n\n\n\nIl file \nconfig/db.php\n \u00e8 uno strumento di configurazione tipico basato su file. Questo particolare file di configurazione specifica i parametri necessari per creare e inizializzare un'istanza del \" yii \\ db \\ Connection \" in cui \u00e8 possibile eseguire query SQL nei confronti del database sottostante.\n\n\n\n\nNote\n\n\nIl file \nconfig.db\n verr\u00e0 incluso nella configurazione principale dell'applicazione \nconfig/web.php\n, che specifica come inizializzare l'istanza della stessa.\n\n\n\n\nCreazione di un record attivo\n\n\nPer rappresentare e recuperare dati nella tabella \ncountry\n, dobbiamo creare una classe \" Active Record \" generata all'interno di un altra classe chiamata \nCountry\n e salvarla all'interno della directory \nmodels/Country.php\n.\n\n\n?php\n\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass Country extends ActiveRecord\n{\n}\n\n\n\nLa classe \nCountry\n estende la classe \"Active Record\". Non c'\u00e8 bisogno di scrivere nessun codice all'interno di esso! Con il codice precedente, Yii indovina il nome della tabella associata al nome della classe.\n\n\n\n\nNote\n\n\nSe non \u00e8 possibile eseguire una corrispondenza diretta dal nome della classe al nome della tabella del DB,\u00e8 possibile utilizzare il metodo \"tableName()\" per specificare esplicitamente il nome della tabella associato.\n\n\n\n\nUtilizzando la classe \nCountry\n, \u00e8 possibile modificare facilmente i dati nella tabella \ncountry\n, come mostrato in questi frammenti:\n\n\nuse app\\models\\Country;\n\n// get all rows from the country table and order them by \"name\"\n$countries = Country::find()-\norderBy('name')-\nall();\n\n// get the row whose primary key is \"US\"\n$country = Country::findOne('US');\n\n// displays \"United States\"\necho $country-\nname;\n\n// modifies the country name to be \"U.S.A.\" and save it to database\n$country-\nname = 'U.S.A.';\n$country-\nsave();\n\n\n\n\n\nNote\n\n\nActive Record \u00e8 un metodo molto potente e utile per accedere e manipolare i dati del database in modo orientato agli oggetti. Potete trovare informazioni pi\u00f9 dettaglia nella sezione Active Record spiegata successivamente. In alternativa \u00e8 possibile interagire con un database utilizzando un metodo di accesso ai dati di livello inferiore denominato \"Data Accesso Objects\".\n\n\n\n\nCreazione di un'azione\n\n\nPer far si che i dati inseriti nel nostro database vengano visualizzati all'utente finale, \u00e8 necessario creare una nuova azione. Invece di inserire la nuova azione nel \nsite\n controller, come nelle sezioni precedenti, \u00e8 pi\u00f9 logico creare un nuovo controller specificamente per tutte le azioni relative ai dati del paese. Denominare questo nuovo controller \nCountryController\n e creare un'azione \nindex\n in esso, come mostrato in seguito.\n\n\n?php\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\nuse yii\\data\\Pagination;\nuse app\\models\\Country;\n\nclass CountryController extends Controller{\n\n    public function actionIndex(){\n\n        $query = Country::find();\n\n        $pagination = new Pagination([\n            'defaultPageSize' =\n 5,\n            'totalCount' =\n $query-\ncount(),\n        ]);\n\n        $countries = $query-\norderBy('name')\n            -\noffset($pagination-\noffset)\n            -\nlimit($pagination-\nlimit)\n            -\nall();\n\n        return $this-\nrender('index', [\n            'countries' =\n $countries,\n            'pagination' =\n $pagination,\n        ]);\n    }\n}\n\n\n\nSalvare il precedente codice nella seguente directory: \ncontroller/CountryController.php\n.\nL'azione \nindex\n chiama \nCountry::find()\n. Questo metodo Active Record crea una query DB e recupera tutti i dati dalla tabella \ncountry\n nel nostro DB.\nPer limitare il numero di paesi restituiti in ogni richiesta, la query viene  paginata con l'aiuto di un oggetto \" yii \\ data \\ Pagination \". L'oggetto \nPagination\n serve per due scopi:\n- Imposta le clausole di '\noffset\n e di \nlimit\n per l'istruzione SQL rappresentato nella query in modo che restituisce solo una singola pagina di dati alla volta (max 5 righe in una pagina),\n- viene utilizzato nella visualizzazione di un pager costituito da un elenco di pulsanti di pagina, come verr\u00e0 spiegato nella sottosezione successiva.\n\n\nAlla fine l'azione \nindex\n rende una vista denominata \nindex\n e passa i dati del paese cos\u00ec come le informazioni di paginazione.\n\n\nCreazione di una vista\n\n\nSotto la directory delle \nviews\n, create una sotto-directory denominata \ncountry\n. Questa cartella verr\u00e0 utilizzata per contenere tutte le viste rese dal controllore \ncountry\n. All'interno della directory \nviews/country\n, creare un file denominato \nindex.php\n contenente quanto segue:\n\n\n?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\LinkPager;\n?\n\n\nh1\nCountries\n/h1\n\n\nul\n\n\n?php foreach ($countries as $country): ?\n\n    \nli\n\n        \n?= Html::encode(\"{$country-\nname} ({$country-\ncode})\") ?\n:\n        \n?= $country-\npopulation ?\n\n    \n/li\n\n\n?php endforeach; ?\n\n\n/ul\n\n\n\n?= LinkPager::widget(['pagination' =\n $pagination]) ?\n\n\n\n\nLa vista presenta due sezioni relative alla visualizzazione dei dati del paese. Nella prima parte, i dati che ci vengono forniti riguardante i paesi vengono attraversati e resi come un elenco HTML non ordinato. Nella seconda parte viene utilizzato un widget \" yii \\ widgets \\ LinkPager \" utlizzando le informazioni di paginazione passate dall'azione. Il widget \nLinkPager\n visualizza un elenco di pulsanti per la pagina. Facendo clic su uno di essi verranno aggiornati i dati del paese nella pagina corrispondente.\nPer vedere se e come funziona il codice precedente, dobbiamo incollare il seguente URL nel nostro browser\n\n\nhttp://hostname/index.php?r=country%2Findex\n\n\n\n\n\nIn un primo momento, vedrai una pagina che mostra 5 paesi. Sotto i paesi, vedrete un pager con 4 pulsanti. Se fai clic sul pulsante \"2\", la pagina visualizzer\u00e0 altri cinque paesi che si troveranno nel nostro database. Con il seguente URL se lo copiate e lo incollate nel vostro browser, vedrete a video la seconda pagina dei paesi.\n\n\nhttp://hostname/index.php?r=country%2Findex\npage=2",
            "title": "Lavoriamo con i database"
        },
        {
            "location": "/getting-started/sub-working-with-database/#lavorare-con-i-database",
            "text": "Questa sezione descrive come creare una nuova pagina che visualizza i dati di una paese recuperati da una tabella di database denominata  country . Per raggiungere questo obiettivo, sar\u00e0 possibile configurare una connessione di database,creare una classe \"Active Record\", definire un'azione e creare una vista.\nAttraverso questo tutorial, imparerai come:\n- configurare una connessione DB,\n- definire una classe Active Record,\n- scrivere una query utilizzando la classe Active Record,\n- visualizzare i dati in una vista in modo paginato.  Tieni presente che per terminare questa sezione, dovresti avere conoscenze e esperienze di base nell'utilizzo dei database. In particolare, si dovrebbe sapere come creare un database e come seguire le istruzioni SQL utilizzando uno strumento client del DB.",
            "title": "Lavorare con i database"
        },
        {
            "location": "/getting-started/sub-working-with-database/#preparazione-del-database",
            "text": "Per iniziare, creare un database denominato  yii2basic , da cui recupererai i dati nell'applicazione. E' possibile creare un database SQLite,MySQL, MSSQL, Oracle, in quanto Yii ha un supporto integrato per molte applicazioni di database. Nella seguente descrizione, per assumeremo la descrizione di un database MySQL.  A questo punto, dobbiamo creare una tabella denominata  country  nel database e inserire alcuni dati di esempio. E' possibile eseguire le seguenti istruzioni SQL per effettuarlo:  CREATE TABLE `country` (\n    `code` CHAR(2) NOT NULL PRIMARY KEY,\n    `name` CHAR(52) NOT NULL,\n    `population` INT(11) NOT NULL DEFAULT '0'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `country` VALUES ('AU','Australia',24016400);\nINSERT INTO `country` VALUES ('BR','Brazil',205722000);\nINSERT INTO `country` VALUES ('CA','Canada',35985751);\nINSERT INTO `country` VALUES ('CN','China',1375210000);\nINSERT INTO `country` VALUES ('DE','Germany',81459000);\nINSERT INTO `country` VALUES ('FR','France',64513242);\nINSERT INTO `country` VALUES ('GB','United Kingdom',65097000);\nINSERT INTO `country` VALUES ('IN','India',1285400000);\nINSERT INTO `country` VALUES ('RU','Russia',146519759);\nINSERT INTO `country` VALUES ('US','United States',322976000);  A questo punto,hai un database denominato  yii2basic  e all'interno di essa una tabella denominata  country  con tre colonne contenenti dieci righe di dati.",
            "title": "Preparazione del Database"
        },
        {
            "location": "/getting-started/sub-working-with-database/#configurazione-di-una-connessione-db",
            "text": "Prima di procedere, assicurarsi di aver installato sia l'estensione  del PDO di PHP che il driver PDO per il database che si sta utilizzando.\nCon quelli installati, aprire il file  config/db.php  e cambiare i parametri per far si che la connessione con il DB avvenga con successo. Per impostazione predefinita, il file \u00e8 composto come segue:  ?php\n\nreturn [\n    'class' =  'yii\\db\\Connection',\n    'dsn' =  'mysql:host=localhost;dbname=yii2basic',\n    'username' =  'root',\n    'password' =  '',\n    'charset' =  'utf8',\n];  Il file  config/db.php  \u00e8 uno strumento di configurazione tipico basato su file. Questo particolare file di configurazione specifica i parametri necessari per creare e inizializzare un'istanza del \" yii \\ db \\ Connection \" in cui \u00e8 possibile eseguire query SQL nei confronti del database sottostante.   Note  Il file  config.db  verr\u00e0 incluso nella configurazione principale dell'applicazione  config/web.php , che specifica come inizializzare l'istanza della stessa.",
            "title": "Configurazione di una connessione DB"
        },
        {
            "location": "/getting-started/sub-working-with-database/#creazione-di-un-record-attivo",
            "text": "Per rappresentare e recuperare dati nella tabella  country , dobbiamo creare una classe \" Active Record \" generata all'interno di un altra classe chiamata  Country  e salvarla all'interno della directory  models/Country.php .  ?php\n\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass Country extends ActiveRecord\n{\n}  La classe  Country  estende la classe \"Active Record\". Non c'\u00e8 bisogno di scrivere nessun codice all'interno di esso! Con il codice precedente, Yii indovina il nome della tabella associata al nome della classe.   Note  Se non \u00e8 possibile eseguire una corrispondenza diretta dal nome della classe al nome della tabella del DB,\u00e8 possibile utilizzare il metodo \"tableName()\" per specificare esplicitamente il nome della tabella associato.   Utilizzando la classe  Country , \u00e8 possibile modificare facilmente i dati nella tabella  country , come mostrato in questi frammenti:  use app\\models\\Country;\n\n// get all rows from the country table and order them by \"name\"\n$countries = Country::find()- orderBy('name')- all();\n\n// get the row whose primary key is \"US\"\n$country = Country::findOne('US');\n\n// displays \"United States\"\necho $country- name;\n\n// modifies the country name to be \"U.S.A.\" and save it to database\n$country- name = 'U.S.A.';\n$country- save();   Note  Active Record \u00e8 un metodo molto potente e utile per accedere e manipolare i dati del database in modo orientato agli oggetti. Potete trovare informazioni pi\u00f9 dettaglia nella sezione Active Record spiegata successivamente. In alternativa \u00e8 possibile interagire con un database utilizzando un metodo di accesso ai dati di livello inferiore denominato \"Data Accesso Objects\".",
            "title": "Creazione di un record attivo"
        },
        {
            "location": "/getting-started/sub-working-with-database/#creazione-di-unazione",
            "text": "Per far si che i dati inseriti nel nostro database vengano visualizzati all'utente finale, \u00e8 necessario creare una nuova azione. Invece di inserire la nuova azione nel  site  controller, come nelle sezioni precedenti, \u00e8 pi\u00f9 logico creare un nuovo controller specificamente per tutte le azioni relative ai dati del paese. Denominare questo nuovo controller  CountryController  e creare un'azione  index  in esso, come mostrato in seguito.  ?php\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\nuse yii\\data\\Pagination;\nuse app\\models\\Country;\n\nclass CountryController extends Controller{\n\n    public function actionIndex(){\n\n        $query = Country::find();\n\n        $pagination = new Pagination([\n            'defaultPageSize' =  5,\n            'totalCount' =  $query- count(),\n        ]);\n\n        $countries = $query- orderBy('name')\n            - offset($pagination- offset)\n            - limit($pagination- limit)\n            - all();\n\n        return $this- render('index', [\n            'countries' =  $countries,\n            'pagination' =  $pagination,\n        ]);\n    }\n}  Salvare il precedente codice nella seguente directory:  controller/CountryController.php .\nL'azione  index  chiama  Country::find() . Questo metodo Active Record crea una query DB e recupera tutti i dati dalla tabella  country  nel nostro DB.\nPer limitare il numero di paesi restituiti in ogni richiesta, la query viene  paginata con l'aiuto di un oggetto \" yii \\ data \\ Pagination \". L'oggetto  Pagination  serve per due scopi:\n- Imposta le clausole di ' offset  e di  limit  per l'istruzione SQL rappresentato nella query in modo che restituisce solo una singola pagina di dati alla volta (max 5 righe in una pagina),\n- viene utilizzato nella visualizzazione di un pager costituito da un elenco di pulsanti di pagina, come verr\u00e0 spiegato nella sottosezione successiva.  Alla fine l'azione  index  rende una vista denominata  index  e passa i dati del paese cos\u00ec come le informazioni di paginazione.",
            "title": "Creazione di un'azione"
        },
        {
            "location": "/getting-started/sub-working-with-database/#creazione-di-una-vista",
            "text": "Sotto la directory delle  views , create una sotto-directory denominata  country . Questa cartella verr\u00e0 utilizzata per contenere tutte le viste rese dal controllore  country . All'interno della directory  views/country , creare un file denominato  index.php  contenente quanto segue:  ?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\LinkPager;\n?  h1 Countries /h1  ul  ?php foreach ($countries as $country): ? \n     li \n         ?= Html::encode(\"{$country- name} ({$country- code})\") ? :\n         ?= $country- population ? \n     /li  ?php endforeach; ?  /ul  ?= LinkPager::widget(['pagination' =  $pagination]) ?   La vista presenta due sezioni relative alla visualizzazione dei dati del paese. Nella prima parte, i dati che ci vengono forniti riguardante i paesi vengono attraversati e resi come un elenco HTML non ordinato. Nella seconda parte viene utilizzato un widget \" yii \\ widgets \\ LinkPager \" utlizzando le informazioni di paginazione passate dall'azione. Il widget  LinkPager  visualizza un elenco di pulsanti per la pagina. Facendo clic su uno di essi verranno aggiornati i dati del paese nella pagina corrispondente.\nPer vedere se e come funziona il codice precedente, dobbiamo incollare il seguente URL nel nostro browser  http://hostname/index.php?r=country%2Findex   In un primo momento, vedrai una pagina che mostra 5 paesi. Sotto i paesi, vedrete un pager con 4 pulsanti. Se fai clic sul pulsante \"2\", la pagina visualizzer\u00e0 altri cinque paesi che si troveranno nel nostro database. Con il seguente URL se lo copiate e lo incollate nel vostro browser, vedrete a video la seconda pagina dei paesi.  http://hostname/index.php?r=country%2Findex page=2",
            "title": "Creazione di una vista"
        },
        {
            "location": "/getting-started/sub-generate-code-gii/",
            "text": "Generare codice con Gii\n\n\nQuesta sezione descrive come utilizzare \" Gii \" per generare automaticamente il codice che implementa alcune funzioni comuni del sito Web. Utilizzare Gii per generare codice in automatico \u00e8 semplicemente una questione di immissione delle informazioni giuste per le istruzioni visualizzate nelle pagine Web Gii.\nAttraverso questo tutorial, imparerai come:\n- abilitare Gii nella tua applicazione,\n- utilizzare Gii per generare una classe Active Record,\n- utilizzare Gii per generare il codice che implementa le operazioni CRUD per una tabella DB,\n- personalizzare il codice generato da Gii.\n\n\nPartiamo da Gii\n\n\nGii viene fornito da Yii come modulo. E' possibile abilitare Gii configurandolo nella propriet\u00e0 dei moduli nell'applicazione. A seconda del modo in cui \u00e8 stata creata l'applicazione, \u00e8 possibile che il codice riportato di seguito sia gi\u00e0 fornito nel file di configurazione \nconfig/web.php\n.\n\n\n$config = [ ... ];\n\nif (YII_ENV_DEV) {\n    $config['bootstrap'][] = 'gii';\n    $config['modules']['gii'] = [\n        'class' =\n 'yii\\gii\\Module',\n    ];\n}\n\n\n\nLa configurazione soprastante indica che l'applicazione deve includere un modulo denominato \ngii\n, che fa parte della classe \" yii \\ gii \\ Module \".\nSe selezioniamo l'entry script della nostra applicazione ( \nweb/index.php\n), troverete la seguente riga, il che rende essenzialmente \nYII_ENV_DEV\n a \ntrue\n\n\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n\n\nGrazie a questa linea di codica, la nostra applicazione \u00e8 in modalit\u00e0 di sviluppo e sar\u00e0 gi\u00e0 abilitata a Gii per la configurazione precedentemente impostata da noi. Adesso \u00e8 possibile accedere a Gii attraverso il seguente URL\n\n\nhttp://hostname/index.php?r=gii\n\n\n\n\n\nWarning\n\n\nSe accediamo a Gii da una macchina diversa da localhsot, l'accesso verr\u00e0 negato come impostazione predefinita per scopi di protezione. E' possibile configurare Gii per aggiungere gli indirizzi IP consentiti, come segue:\n\n\n'gii' =\n [\n    'class' =\n 'yii\\gii\\Module',\n    'allowedIPs' =\n ['127.0.0.1', '::1', '192.168.0.*', '192.168.178.20'] // adjust this to your needs\n],\n\n\n\n\n\n\n\nGenerare una classe Active Record\n\n\nPer utilizzare Gii nella generazione di una classe Active Record, dovete selezionare \"Model Generator\" (facendo click sul pulsante \"Start\"). Quindi compilare il modulo come segue:\n\n\n\n\nNome della tabella: \ncountry\n\n\nClasse del modello: \nCountry\n\n\n\n\n\n\nPremendo il pulsante \"Preview\" vedrete il file \nmodels/Country.php\n che verr\u00e0 creato dall'Active Record. Puoi anche cliccare sul nome del file per visualizzare l'anteprima del suo contenuto.\nQuando si utilizza Gii, se si \u00e8 gi\u00e0 creato lo stesso file, lo sovrascriver\u00e0, premendo il pulsante \ndiff\n accanto al nome del file per vedere le differenze tra il codice che verr\u00e0 generato e la versione esistente.\n\n\n\n\nQuando sovrascriverete un file esistente, selezionate la casella accanto a \"overwrite\" e quindi fate clic sul pulsante \"Generate\". Se invece si crea un nuovo file, \u00e8 sufficiente fare clic sul pulsante \"Generate\".\nSuccessivamente, verr\u00e0 visualizzata una pagina di conferma, per essere sicuri che il codice sia stato generato in modo corretto o meno. Se si avesse un file esistente, verr\u00e0 visualizzato anche un messaggio dove verr\u00e0 indicato che \u00e8 stato sovrascritto il codice appena generato.\n\n\nGenerazione codice di un CRUD\n\n\nCRUD sta per \"Create - Read - Update - Delete\". Rappresentano le 4 attivit\u00e0 comuni che si effettuano sui dati nella maggior parte dei siti Web. Per creare funzionalit\u00e0 CRUD usando Gii, dobbiamo selezione l'opzione \"CRUD Generator\" (nella pagina indice di Gii). Continuando con l'esempio dei \"paesi\", compilare il modulo come segue:\n- Model Class: \napp\\models\\Country\n\n- Search Model Class: \napp\\models\\CountrySearch\n\n- Controller Class: \napp\\controllers\\CountryController\n\n\n\n\nPremendo il pulsante \"preview\", verr\u00e0 visualizzato un elenco di file da generare, come mostrato di seguito:\n\n\n\n\nSe in precedenza avete creato i file \ncontrollers/CountryController.php\n e \nviews/country/index.php\n nella sezione 'Lavorare con i database', controllare la casella \"overwrite\" per sostituirli.\n\n\nPer vedere se tutto quello che abbiamo fatto funziona, copiamo il seguente URL nel nostro browser\n\n\nhttp://hostname/index.php?r=country%2Findex\n\n\n\nA questo punto vedrai una griglia di dati che mostra i paesi inseriti in precedenza nel nostro database. Puoi ordinare la griglia, oppure filtrarla immettendo le condizioni di filtro nelle intestazioni di colonna.\nPer ogni paese visualizzato nella griglia, \u00e8 possibile scegliere di visualizzarli, modificarli o elimiarli. Puoi anche scegliere di aggiungere un nuovo paese sul pulsante \"Create Country\" nella parte superiore della griglia.\n\n\n\n\nSchermata relativa alla modifica di un paese:\n\n\n\n\nDi seguito \u00e8 riportato l'elenco dei file generati da Gii, nel caso in cui si desidera esaminare, implementare (o personalizzare) le funzionalit\u00e0:\n- Controller: \ncontrollers/CountryController.php\n\n- Models: \nmodels/Country.php\n e \nmodels/CountrySearch.php\n\n- Views: \nviews/country/*.php\n\n\n\n\nTip\n\n\nGii \u00e8 stato progettato per essere uno strumento di generazione di codici estremamente personalizzabile e estensibile. Se utilizziamo Gii accelleriamo notevolmente la velocit\u00e0 nello sviluppo delle applicazioni.",
            "title": "Generare codice con Gii"
        },
        {
            "location": "/getting-started/sub-generate-code-gii/#generare-codice-con-gii",
            "text": "Questa sezione descrive come utilizzare \" Gii \" per generare automaticamente il codice che implementa alcune funzioni comuni del sito Web. Utilizzare Gii per generare codice in automatico \u00e8 semplicemente una questione di immissione delle informazioni giuste per le istruzioni visualizzate nelle pagine Web Gii.\nAttraverso questo tutorial, imparerai come:\n- abilitare Gii nella tua applicazione,\n- utilizzare Gii per generare una classe Active Record,\n- utilizzare Gii per generare il codice che implementa le operazioni CRUD per una tabella DB,\n- personalizzare il codice generato da Gii.",
            "title": "Generare codice con Gii"
        },
        {
            "location": "/getting-started/sub-generate-code-gii/#partiamo-da-gii",
            "text": "Gii viene fornito da Yii come modulo. E' possibile abilitare Gii configurandolo nella propriet\u00e0 dei moduli nell'applicazione. A seconda del modo in cui \u00e8 stata creata l'applicazione, \u00e8 possibile che il codice riportato di seguito sia gi\u00e0 fornito nel file di configurazione  config/web.php .  $config = [ ... ];\n\nif (YII_ENV_DEV) {\n    $config['bootstrap'][] = 'gii';\n    $config['modules']['gii'] = [\n        'class' =  'yii\\gii\\Module',\n    ];\n}  La configurazione soprastante indica che l'applicazione deve includere un modulo denominato  gii , che fa parte della classe \" yii \\ gii \\ Module \".\nSe selezioniamo l'entry script della nostra applicazione (  web/index.php ), troverete la seguente riga, il che rende essenzialmente  YII_ENV_DEV  a  true  defined('YII_ENV') or define('YII_ENV', 'dev');  Grazie a questa linea di codica, la nostra applicazione \u00e8 in modalit\u00e0 di sviluppo e sar\u00e0 gi\u00e0 abilitata a Gii per la configurazione precedentemente impostata da noi. Adesso \u00e8 possibile accedere a Gii attraverso il seguente URL  http://hostname/index.php?r=gii   Warning  Se accediamo a Gii da una macchina diversa da localhsot, l'accesso verr\u00e0 negato come impostazione predefinita per scopi di protezione. E' possibile configurare Gii per aggiungere gli indirizzi IP consentiti, come segue:  'gii' =  [\n    'class' =  'yii\\gii\\Module',\n    'allowedIPs' =  ['127.0.0.1', '::1', '192.168.0.*', '192.168.178.20'] // adjust this to your needs\n],",
            "title": "Partiamo da Gii"
        },
        {
            "location": "/getting-started/sub-generate-code-gii/#generare-una-classe-active-record",
            "text": "Per utilizzare Gii nella generazione di una classe Active Record, dovete selezionare \"Model Generator\" (facendo click sul pulsante \"Start\"). Quindi compilare il modulo come segue:   Nome della tabella:  country  Classe del modello:  Country    Premendo il pulsante \"Preview\" vedrete il file  models/Country.php  che verr\u00e0 creato dall'Active Record. Puoi anche cliccare sul nome del file per visualizzare l'anteprima del suo contenuto.\nQuando si utilizza Gii, se si \u00e8 gi\u00e0 creato lo stesso file, lo sovrascriver\u00e0, premendo il pulsante  diff  accanto al nome del file per vedere le differenze tra il codice che verr\u00e0 generato e la versione esistente.   Quando sovrascriverete un file esistente, selezionate la casella accanto a \"overwrite\" e quindi fate clic sul pulsante \"Generate\". Se invece si crea un nuovo file, \u00e8 sufficiente fare clic sul pulsante \"Generate\".\nSuccessivamente, verr\u00e0 visualizzata una pagina di conferma, per essere sicuri che il codice sia stato generato in modo corretto o meno. Se si avesse un file esistente, verr\u00e0 visualizzato anche un messaggio dove verr\u00e0 indicato che \u00e8 stato sovrascritto il codice appena generato.",
            "title": "Generare una classe Active Record"
        },
        {
            "location": "/getting-started/sub-generate-code-gii/#generazione-codice-di-un-crud",
            "text": "CRUD sta per \"Create - Read - Update - Delete\". Rappresentano le 4 attivit\u00e0 comuni che si effettuano sui dati nella maggior parte dei siti Web. Per creare funzionalit\u00e0 CRUD usando Gii, dobbiamo selezione l'opzione \"CRUD Generator\" (nella pagina indice di Gii). Continuando con l'esempio dei \"paesi\", compilare il modulo come segue:\n- Model Class:  app\\models\\Country \n- Search Model Class:  app\\models\\CountrySearch \n- Controller Class:  app\\controllers\\CountryController   Premendo il pulsante \"preview\", verr\u00e0 visualizzato un elenco di file da generare, come mostrato di seguito:   Se in precedenza avete creato i file  controllers/CountryController.php  e  views/country/index.php  nella sezione 'Lavorare con i database', controllare la casella \"overwrite\" per sostituirli.  Per vedere se tutto quello che abbiamo fatto funziona, copiamo il seguente URL nel nostro browser  http://hostname/index.php?r=country%2Findex  A questo punto vedrai una griglia di dati che mostra i paesi inseriti in precedenza nel nostro database. Puoi ordinare la griglia, oppure filtrarla immettendo le condizioni di filtro nelle intestazioni di colonna.\nPer ogni paese visualizzato nella griglia, \u00e8 possibile scegliere di visualizzarli, modificarli o elimiarli. Puoi anche scegliere di aggiungere un nuovo paese sul pulsante \"Create Country\" nella parte superiore della griglia.   Schermata relativa alla modifica di un paese:   Di seguito \u00e8 riportato l'elenco dei file generati da Gii, nel caso in cui si desidera esaminare, implementare (o personalizzare) le funzionalit\u00e0:\n- Controller:  controllers/CountryController.php \n- Models:  models/Country.php  e  models/CountrySearch.php \n- Views:  views/country/*.php   Tip  Gii \u00e8 stato progettato per essere uno strumento di generazione di codici estremamente personalizzabile e estensibile. Se utilizziamo Gii accelleriamo notevolmente la velocit\u00e0 nello sviluppo delle applicazioni.",
            "title": "Generazione codice di un CRUD"
        },
        {
            "location": "/getting-started/sub-looking-ahead/",
            "text": "Guadiamo avanti\n\n\nSe hai letto tutto il capitolo \"Come iniziare\" hai creato un'applicazione Yii completa. Nel corso del capitolo, hai imparato come implementare alcune funzionalit\u00e0 comunemente necessarie, come ottenere dati dagli utenti tramite un modulo HTML, recuperare dati da un database e visualizzare i dati in modo paginato. Hai anche imparato a utilizzare Gii per generare automaticamente il codice. L'utilizzo di Gii per la generazione di codici trasforma la maggior parte del tuo processo di sviluppo Web in un compito semplice come quello di riempire alcuni form.\nAdesso continuiamo a scoprire in modo pi\u00f9 approfondito il framework Yii e quello che pu\u00f2 offrire.",
            "title": "Guardiamo avanti"
        },
        {
            "location": "/getting-started/sub-looking-ahead/#guadiamo-avanti",
            "text": "Se hai letto tutto il capitolo \"Come iniziare\" hai creato un'applicazione Yii completa. Nel corso del capitolo, hai imparato come implementare alcune funzionalit\u00e0 comunemente necessarie, come ottenere dati dagli utenti tramite un modulo HTML, recuperare dati da un database e visualizzare i dati in modo paginato. Hai anche imparato a utilizzare Gii per generare automaticamente il codice. L'utilizzo di Gii per la generazione di codici trasforma la maggior parte del tuo processo di sviluppo Web in un compito semplice come quello di riempire alcuni form.\nAdesso continuiamo a scoprire in modo pi\u00f9 approfondito il framework Yii e quello che pu\u00f2 offrire.",
            "title": "Guadiamo avanti"
        },
        {
            "location": "/application-structure/sub-overview/",
            "text": "Panoramica\n\n\nLe applicazioni Yii sono organizzate in base al modello MVC ( model - view - controller ). I model (modelli) rappresentano i dati, la logica aziendale e le regole; le view (viste) rappresentano la rappresentazione dei modelli; e i controller (controllori) prendono l'input e lo trasformano in comandi per i model e le view.\n\n\nOltre al MVC, le applicazioni Yii hanno anche le seguenti entit\u00e0:\n- Entry script: sono script PHP che sono direttamente accessibili dagli utenti finali. Sono responsabili dell'avvio di un ciclo che permette la gestione delle richieste da parte dell'utente.\n- Application: sono oggetti accessibili a livello globale che gestiscono i componenti dell'applicazione e le coordinano per soddisfare le richieste.\n- Application component: sono oggetti registrati con applicazioni e forniscono veri servizi per soddisfare le richieste.\n- Module: sono pacchetti autonomi che contengono pattern MVC completi da soli. Un'applicazione pu\u00f2 essere organizzata in termini di moduli multipli.\n- Filtri: rappresentano il codice che deve essere richiamato prima e dopo la gestione effettiva di ogni richiesta da parte dei controllori.\n- Widget: sono oggetti che possono essere incorporati nelle view(viste).Possono contenere la logica dei controller e possono essere anche riutilizzati in viste diverse.\n\n\nIl seguente schema mostra la struttura statica di un'applicazione:",
            "title": "Panoramica"
        },
        {
            "location": "/application-structure/sub-overview/#panoramica",
            "text": "Le applicazioni Yii sono organizzate in base al modello MVC ( model - view - controller ). I model (modelli) rappresentano i dati, la logica aziendale e le regole; le view (viste) rappresentano la rappresentazione dei modelli; e i controller (controllori) prendono l'input e lo trasformano in comandi per i model e le view.  Oltre al MVC, le applicazioni Yii hanno anche le seguenti entit\u00e0:\n- Entry script: sono script PHP che sono direttamente accessibili dagli utenti finali. Sono responsabili dell'avvio di un ciclo che permette la gestione delle richieste da parte dell'utente.\n- Application: sono oggetti accessibili a livello globale che gestiscono i componenti dell'applicazione e le coordinano per soddisfare le richieste.\n- Application component: sono oggetti registrati con applicazioni e forniscono veri servizi per soddisfare le richieste.\n- Module: sono pacchetti autonomi che contengono pattern MVC completi da soli. Un'applicazione pu\u00f2 essere organizzata in termini di moduli multipli.\n- Filtri: rappresentano il codice che deve essere richiamato prima e dopo la gestione effettiva di ogni richiesta da parte dei controllori.\n- Widget: sono oggetti che possono essere incorporati nelle view(viste).Possono contenere la logica dei controller e possono essere anche riutilizzati in viste diverse.  Il seguente schema mostra la struttura statica di un'applicazione:",
            "title": "Panoramica"
        },
        {
            "location": "/application-structure/sub-entry-script/",
            "text": "Entry Script\n\n\nGli \"Entry Scipt\" ( oppure \"script di accesso\") sono il primo passo nel processo di avvio dell'applicazione. Questi script devono essere memorizzati nelle directory accessibili al Web, in modo tale che possano essere accessibili dagli utenti finali. Sono spesso chiamati \nindex.php\n, ma possono anche utilizzare altri nomi,\n\n\nGli script di accesso effettuano principalmente i seguenti lavori:\n- Definire costanti globali;\n- Registra il \"Composer autoloader\";\n- Include il file della classe Yii;\n- Carica la configurazione dell'applicazione;\n- Crea e configura un'istanza dell'applicazione;\n- Chiama \nyii \\ base \\ Application ::run()\n per elaborare la richiesta di entrata.\n\n\nApplicazioni Web\n\n\nDi seguito \u00e8 riportato il codice dello script di accesso per il modello di progetto di un'applicazione Web:\n\n\n?php\n\ndefined('YII_DEBUG') or define('YII_DEBUG', true);\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n// register Composer autoloader\nrequire(__DIR__ . '/../vendor/autoload.php');\n\n// include Yii class file\nrequire(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/../config/web.php');\n\n// create, configure and run application\n(new yii\\web\\Application($config))-\nrun();\n\n\n\nApplicazioni tramite Console\n\n\nAnalogamente, il seguente codice \u00e8 lo script di accesso per il modello di progetto di un'applicazione console:\n\n\n#!/usr/bin/env php\n\n?php\n/**\n * Yii console bootstrap file.\n *\n * @link http://www.yiiframework.com/\n * @copyright Copyright (c) 2008 Yii Software LLC\n * @license http://www.yiiframework.com/license/\n */\n\ndefined('YII_DEBUG') or define('YII_DEBUG', true);\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n// register Composer autoloader\nrequire(__DIR__ . '/vendor/autoload.php');\n\n// include Yii class file\nrequire(__DIR__ . '/vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/config/console.php');\n\n$application = new yii\\console\\Application($config);\n$exitCode = $application-\nrun();\nexit($exitCode);\n\n\n\nDefinizione di costanti\n\n\nGli script di inserimento sono il luogo migliore per definire le costanti globali. Yii supporta le seguenti 3 costanti:\n\n\n\n\nYII_DEBUG\n: specifica se l'applicazione \u00e8 in esecuzione in modalit\u00e0 di debug. Quando la modalit\u00e0 debug sar\u00e0 attiva ( cio\u00e8 settata a \ntrue\n) manterr\u00f2 ulteriori informazioni sul registro e riveler\u00e0 gli stack di chiamata degli errori dettagliata se vengono prelevate eccezioni. Per questo questa modalit\u00e0 andrebbe sempre attivata durante lo sviluppo. Il valore predefinito \u00e8 \nfalse\n.\n\n\nYII_ENV\n: specifica l'ambiente in cui \u00e8 in esecuzione l'applicazione. Il valore predefinitodi \nYII_ENV\n \u00e8 \n'prod'\n, il che significa che l'applicazione \u00e8 in esecuzione in ambiente di produzione.\n\n\nYII_ENABLE_HERROR_HANDLER\n: specifica se abilitare il gestore di errori fornito da Yii. Il valore predefinito di questa costante \u00e8 \ntrue\n.\n\n\n\n\nQuando si definisce una costante, utilizziamo spesso il seguente codice:\n\n\ndefined('YII_DEBUG') or define('YII_DEBUG', true);\n\n\n\nLe definizioni di costanti dovrebbero essere eseguite nell'entry script in modo che possano avere effetto quando altri file PHP vengano inclusi.",
            "title": "Entry Script"
        },
        {
            "location": "/application-structure/sub-entry-script/#entry-script",
            "text": "Gli \"Entry Scipt\" ( oppure \"script di accesso\") sono il primo passo nel processo di avvio dell'applicazione. Questi script devono essere memorizzati nelle directory accessibili al Web, in modo tale che possano essere accessibili dagli utenti finali. Sono spesso chiamati  index.php , ma possono anche utilizzare altri nomi,  Gli script di accesso effettuano principalmente i seguenti lavori:\n- Definire costanti globali;\n- Registra il \"Composer autoloader\";\n- Include il file della classe Yii;\n- Carica la configurazione dell'applicazione;\n- Crea e configura un'istanza dell'applicazione;\n- Chiama  yii \\ base \\ Application ::run()  per elaborare la richiesta di entrata.",
            "title": "Entry Script"
        },
        {
            "location": "/application-structure/sub-entry-script/#applicazioni-web",
            "text": "Di seguito \u00e8 riportato il codice dello script di accesso per il modello di progetto di un'applicazione Web:  ?php\n\ndefined('YII_DEBUG') or define('YII_DEBUG', true);\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n// register Composer autoloader\nrequire(__DIR__ . '/../vendor/autoload.php');\n\n// include Yii class file\nrequire(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/../config/web.php');\n\n// create, configure and run application\n(new yii\\web\\Application($config))- run();",
            "title": "Applicazioni Web"
        },
        {
            "location": "/application-structure/sub-entry-script/#applicazioni-tramite-console",
            "text": "Analogamente, il seguente codice \u00e8 lo script di accesso per il modello di progetto di un'applicazione console:  #!/usr/bin/env php ?php\n/**\n * Yii console bootstrap file.\n *\n * @link http://www.yiiframework.com/\n * @copyright Copyright (c) 2008 Yii Software LLC\n * @license http://www.yiiframework.com/license/\n */\n\ndefined('YII_DEBUG') or define('YII_DEBUG', true);\ndefined('YII_ENV') or define('YII_ENV', 'dev');\n\n// register Composer autoloader\nrequire(__DIR__ . '/vendor/autoload.php');\n\n// include Yii class file\nrequire(__DIR__ . '/vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/config/console.php');\n\n$application = new yii\\console\\Application($config);\n$exitCode = $application- run();\nexit($exitCode);",
            "title": "Applicazioni tramite Console"
        },
        {
            "location": "/application-structure/sub-entry-script/#definizione-di-costanti",
            "text": "Gli script di inserimento sono il luogo migliore per definire le costanti globali. Yii supporta le seguenti 3 costanti:   YII_DEBUG : specifica se l'applicazione \u00e8 in esecuzione in modalit\u00e0 di debug. Quando la modalit\u00e0 debug sar\u00e0 attiva ( cio\u00e8 settata a  true ) manterr\u00f2 ulteriori informazioni sul registro e riveler\u00e0 gli stack di chiamata degli errori dettagliata se vengono prelevate eccezioni. Per questo questa modalit\u00e0 andrebbe sempre attivata durante lo sviluppo. Il valore predefinito \u00e8  false .  YII_ENV : specifica l'ambiente in cui \u00e8 in esecuzione l'applicazione. Il valore predefinitodi  YII_ENV  \u00e8  'prod' , il che significa che l'applicazione \u00e8 in esecuzione in ambiente di produzione.  YII_ENABLE_HERROR_HANDLER : specifica se abilitare il gestore di errori fornito da Yii. Il valore predefinito di questa costante \u00e8  true .   Quando si definisce una costante, utilizziamo spesso il seguente codice:  defined('YII_DEBUG') or define('YII_DEBUG', true);  Le definizioni di costanti dovrebbero essere eseguite nell'entry script in modo che possano avere effetto quando altri file PHP vengano inclusi.",
            "title": "Definizione di costanti"
        },
        {
            "location": "/application-structure/sub-applications/",
            "text": "Applicazioni\n\n\nLe applicazioni sono oggetti che regolano la struttura complessiva e il ciclo di vita dei sistemi applicativi di Yii. Ogni sistema applicativo Yii contiene un singolo oggetto di applicazione che viene creato nell'entry script ed \u00e8 globalmente accessibile tramite l'espressione \n\\Yii::$app\n.\n\n\n\n\nInfo\n\n\nA seconda del contesto, quando diciamo \"un'applicazione\", pu\u00f2 significare o un oggetto dell'applicazione o un sistema applicativo\n\n\n\n\nEsistono due tipo di applicazioni: applicazioni Web e applicazioni Console.  Come indicano i nomi, il primo gestisce principalmente le richieste Web, mentre quest'ultimo gestisce le richieste di comando della console.\n\n\nConfigurazione dell'applicazione\n\n\nQuando uno script di accesso crea un'applicazione, caricher\u00e0 una configurazione e la applica all'app, come segue:\n\n\nrequire(__DIR__ . '/../vendor/autoload.php');\nrequire(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/../config/web.php');\n\n// instantiate and configure the application\n(new yii\\web\\Application($config))-\nrun();\n\n\n\nLe configurazioni applicative specificano come inizializzare le propriet\u00e0 degli oggetti applicativi. Poich\u00e8 le configurazioni di applicazione sono complesse, vengono di solito conservate in file di configurazione come \nweb.php\n nell'esempio precedente.\n\n\nPropriet\u00e0 dell'applicazione\n\n\nCi sono molte propriet\u00e0 che pu\u00f2 avere un'applicazione e che dovremmo configurare ne file di configurazione. Queste propriet\u00e0 descrivono in genere l'ambiente in cui sono in esecuzione applicazioni. Ad esemppio, le applicazioni devono sapere come caricare i controller, dove memorizzare file temporanei, ect.. Adesso andremo ad elencare queste propriet\u00e0.\n\n\nPropriet\u00e0 richieste\n\n\nIn qualsiasi applicazione, \u00e8 necessario almeno configurare le seguenti due propriet\u00e0:\n\n\nID\n\n\nLa propriet\u00e0 ID specifica un id univoco che differenzia un'applicazione da un'altra. Sebbene non sia un requisito, per una migliore interoperabilit\u00e0 \u00e8 consigliabile utilizzare solo caratteri alfanumerici quando si specifica un ID dell'applicazione.\n\n\nbasePath\n\n\nLa propriet\u00e0 \"basePath\" specifica la directory principale di un'applicazione. E' la directory che contiene tutto il codice sorgente protetto di un sistema applicativo. In base a tale directory, normalmente ci saranno sotto-directory come \nmodels\n, \nviews\n e \ncontrollers\n che contengono il codice sorgente corrispondente al pattern MVC.\nE' possibile configurare la propriet\u00e0 \"basePath\" utilizzando un percorso di directory o un alias di percorso. In entrambe le forme, la directory corrispondente deve esistere oppure verr\u00e0 lanciata un'eccezione. Il percorso viene normalizzato chiamando la funzione \nrealpath()\n.\n\n\nPropriet\u00e0 importanti\n\n\nLe propriet\u00e0 descritte in questa sottosezione spesso devono essere configurare perch\u00e8 differiscono da diverse applicazioni.\n\n\nAlias\n\n\nQuesta propriet\u00e0 consente di definire un insieme di alias in termini di array. Le chiavi dell'array sono nomi di alias e i valori dell'array sono le corrispondenti definizioni del percorso. Per esempio:\n\n\n[\n    'aliases' =\n [\n        '@name1' =\n 'path/to/path1',\n        '@name2' =\n 'path/to/path2',\n    ],\n]\n\n\n\nQuesta propriet\u00e0 viene utilizzata per richiamare un'applicazione che potrebbe avere un nome differente a quello indicato nell'ID.\n\n\nBootstrap\n\n\nQuesta \u00e8 una propriet\u00e0 molto utile. Consente di specificare una serie di componenti che devono essere eseguiti durante il processo di avvio dell'applicazione. Ad esempio, se si desidera che un modulo personalizza le regole URL, \u00e8 possibile elencare l'ID come elemento di questa propriet\u00e0.\nOgni componente elencato in questa propriet\u00e0 pu\u00f2 essere specificato in uno dei seguenti formati:\n- un ID di un'applicazione specificato tramite componenti,\n- un modulo ID specificato tramite moduli,\n- un nome di una classe,\n- un array di configurazione,\n- una funzione anonima che crea e restituisce un determinato componente.\n\n\nEsempio:\n\n\n[\n    'bootstrap' =\n [\n        // an application component ID or module ID\n        'demo',\n\n        // a class name\n        'app\\components\\Profiler',\n\n        // a configuration array\n        [\n            'class' =\n 'app\\components\\Profiler',\n            'level' =\n 3,\n        ],\n\n        // an anonymous function\n        function () {\n            return new app\\components\\Profiler();\n        }\n    ],\n]\n\n\n\n\n\nInfo\n\n\nse un ID di un modulo \u00e8 lo stesso ID di un componente dell'applicazione, il componente verr\u00e0 utilizzato durante il processo di avvio. Se si desidera usare il modulo invece del componente, \u00e8 possibile specificarlo utilizzando una funzione anonima come segue:\n\n\n[\n    function () {\n        return Yii::$app-\ngetModule('user');\n    },\n]\n\n\n\n\n\nDurante il processo di avvio ogni componente viene instanziato. Se la classe dei componenti implementa \u201c yii /base / BootstrapInterface\", verr\u00e0 anche chiamato il metodo \"bootstrap()\". Questo metodo pu\u00f2 contenere ID di eventuali moduli che voglio caricare prima di alcuni ( per es. il modulo \u2018log\u2019 per tener traccia di eventuali errori nella fase di caricamento ).\n\n\nCatchAll\n\n\nQuesta propriet\u00e0 \u00e8 supportata solo dalle applicazioni Web. Specifica un'azione del controller che dovrebbe gestire tutte le richieste dell'utente. Questo viene utilizzato principalmente quando l'applicazione \u00e8 in modalit\u00e0 di manutenzione (debug) e deve gestire tutte le richieste in entrata tramite un'unica azione.\nLa configurazione \u00e8 una matrice il cui primo elemento specifica il percorso dell'azione. Il resto degli elementi della matrice specifica i parametri da associare all'azione. \n\n\nEsempio:\n\n\n[\n    'catchAll' =\n [\n        'offline/notice',\n        'param1' =\n 'value1',\n        'param2' =\n 'value2',\n    ],\n]\n\n\n\n\n\nInfo\n\n\nIl pannello di debug sull'ambiente di sviluppo non funziona quando questa propriet\u00e0 \u00e8 abilitata.\n\n\n\n\nComponenti - (components)\n\n\nQuesta \u00e8 la propriet\u00e0 pi\u00f9 importante. Consente di registrare un elenco di componenti denominati \"application component\" che \u00e8 possibile utilizzare in altri luoghi. \n\n\nEsempio:\n\n\n[\n    'components' =\n [\n        'cache' =\n [\n            'class' =\n 'yii\\caching\\FileCache',\n        ],\n        'user' =\n [\n            'identityClass' =\n 'app\\models\\User',\n            'enableAutoLogin' =\n true,\n        ],\n    ],  \n]\n\n\n\nOgni componente dell'applicazione viene specificata come array di chiave valore.\n\n\nEsempio 2:\n\n\n'components' =\n [\n        'user' =\n [\n            'identityClass' =\n 'common\\models\\User',\n            'enableAutoLogin' =\n true,\n        ],]\n\n\nNella parte di codice sopra, si vede la struttura chiave-valore applicata.\nLa prima chiave che troviamo \u00e8 \u201cUser\u201d cio\u00e8 l\u2019identificavo (ID) del modulo/componente, e il suo valore, \u00e8 composto a sua volta da un array chiave-valore, dove le chiavi questa volta sono identificativi o della classe principale del modulo (identityClass) o di una sua configurazione (enableAutoLogin).\n\n\nControllerMap\n\n\nQuesta propriet\u00e0 consente di mappare un controller ID in una classe arbitraria del controller. Per impostazione predefinitam Yii mapper\u00e0 gli ID alle classi di controller basate su una convenzione ( ad esempio l'ID \npost\n verr\u00e0 mappato \napp\\controller\\PostController\n). Configurando questa propriet\u00e0, \u00e8 possibile rompere la convenzione per specifici controller. Nell'esempio seguente, \naccount\n verr\u00e0 mappato \napp\\controllers\\UserController\n, mentre \narticle\n verr\u00e0 mappato su \napp\\controllers\\PostController\n.\n\n\n[\n    'controllerMap' =\n [\n        'account' =\n 'app\\controllers\\UserController',\n        'article' =\n [\n            'class' =\n 'app\\controllers\\PostController',\n            'enableCsrfValidation' =\n false,\n        ],\n    ],  \n]\n\n\n\nLe chiavi dell'array rappresentano gli ID del controller, mentre i valori dell'array rappresentano i nomi o le configurazioni dei nomi delle classi di controllo corrispondenti.\n\n\nControllerNamespace\n\n\nQuesta propriet\u00e0 specifica i namespace predefiniti in cui le classi controller devono essere posizionate. Come posizione di default li troveremo in \napp\\controllers\n. Se \u00e8 un ID del controller \npost\n, per convenzione corrisponderebbe il nome della classe di controllo \nPostController\n e il nome della classe completamente qualificato \napp\\controllers\\PostController\n.\nLe classi del controller possono anche essere posizionate sotto le sotto-directory della directory corrispondente a questi namespace. Ad esempio, dato un ID controller \nadmin/post\n, la corrispondente classe del controller completamente qualificata sarebbe \napp\\controllers\\admin\\PostController\n.\nE' importante che le classi di controllo pienamente qualificate debbano essere \"autoloadable\" e i namespace delle classi di controller corrispondino al valore di questa propriet\u00e0. Altrimenti riceverai un errore \"Pagina non trovata\" quando si accede alla nostra applicazione.\n\n\nLingua - (language)\n\n\nQuesta propriet\u00e0 specifica la lingua in cui l'applicazionedeve visualizzare il contenuto agli utenti finali. Il valore predefinito di questa propriet\u00e0 \u00e8 \nen\n ( inglese ). E' necessario configurare questa propriet\u00e0 se vogliamo che l'applicazione possa supportare pi\u00f9 lingue.\nIl valore di questa propriet\u00e0 determina diversi aspetti di internalizzazione, tra cui la traduzione dei messaggi, la formattazione della data, la formattazione del numero, ecc..\n\n\nModuli - (modules)\n\n\nQuesta propriet\u00e0 specifica i moduli che contiene l'applicazione. I moduli vengono visti come sotto-applicazioni della nostra applicazione padre.\n\n\nEsempio:\n\n\n[\n    'modules' =\n [\n        // a \"booking\" module specified with the module class\n        'booking' =\n 'app\\modules\\booking\\BookingModule',\n\n        // a \"comment\" module specified with a configuration array\n        'comment' =\n [\n            'class' =\n 'app\\modules\\comment\\CommentModule',\n            'db' =\n 'db',\n        ],\n    ],  \n]\n\n\n\nNome - (name)\n\n\nQuesta propriet\u00e0 specifica il nome dell'applicazione che pu\u00f2 essere visualizzato agli utenti finali. A differenza della propriet\u00e0 ID, che dovrebbe assumere un valore univoco, il valore di questa propriet\u00e0 \u00e8 usato principalmente per scopi di visualizzazione. Non deve essere univoco.\n\n\nParametri - (params)\n\n\nQuesta propriet\u00e0 specifica una serie di parametri applicativi accessibili a livello globale. Invece di utilizzare numerosi codici e stringhe dappertutto nel codice, \u00e8 una buona pratica definirli come parametri dell'app in un unico punto e utilizzare parametri in luoghi dove \u00e8 necessario. \n\n\nEsempio: possiamo utilizzare questa propriet\u00e0 per definire la dimensione dell'immagine in miniatura come parametro\n\n\n[\n    'params' =\n [\n        'thumbnail.size' =\n [128, 128],\n    ],\n]\n\n\n\nA questo punto nel codice in cui bisgona utilizzare il valore della dimensione, possiamo usare il seguente codice:\n\n\n$size = \\Yii::$app-\nparams['thumbnail.size'];\n$width = \\Yii::$app-\nparams['thumbnail.size'][0];\n\n\n\nIn seguito, se si decide di modificare le dimensioni delle miniature, \u00e8 necessario modificarlo solo nella configurazione dell'applicazione; non \u00e8 necessario toccare alcun codice dipendente.\n\n\nLinguaggio del codice - (sourceLanguage)\n\n\nQuesta propriet\u00e0 specifica la lingua in cui \u00e8 scritto il codice dell'applicazione. Il valore predefinito \u00e8 \nen-US\n, cio\u00e8 l'inglese (Stati Uniti). E' necessario configurare questo propriet\u00e0 se il contenuto del testo nel codice non \u00e8 in inglese.\n\n\nFuso orario - (timeZone)\n\n\nQuesta propriet\u00e0 viene fornita come modalit\u00e0 alternativa per impostare il fuso orario predefinito del runtime PHP. Configurando questa propriet\u00e0, si sta chiamando essenzialmente la funzione PHP \"date_default_timezone_set()\u201c.\n\n\nEsempio:\n\n\n[\n    'timeZone' =\n 'America/Los_Angeles',\n]\n\n\n\nVersioni - (version)\n\n\nQuesta propriet\u00e0 specifica la versione dell'applicazione. E' predefinito \n1.0\n.\n\n\nPropriet\u00e0 Utili\n\n\nLe propriet\u00e0 descritte in questa sottosezione non sono comunemente configurate perch\u00e8 i loro valori predefiniti derivano da convenzioni comuni. Tuttavia, \u00e8 possibile configurarli nel caso in cui si desidera rompere le convenzioni.\n\n\nCharset\n\n\nQuesta propriet\u00e0 specifica il carattere che l'applicazione utilizza. Il valore predefinito \u00e8 quello \nUTF-8\n che dovrebbe essere mantenuto come per la maggior parte delle applicazioni a meno che non si tratti di un sistema legacy che utilizza un sacco di dati non Unicode.\n\n\nDefaultRoute\n\n\nQuesta propriet\u00e0 specifica il percorso che un'applicazione deve utilizzare quando una richiesta non lo specifica. Ad esempio, \nhelp\n,\npost/create\n o \nadmin/post/create\n. Se non viene dato un ID dell'azione, questa propriet\u00e0 prende il valore predefinito specificato in \u201c yii \\base \\ Controller :: $defaultAction\".\n\n\nPer le applicazioni Web, il valore predefinito di questa propriet\u00e0 \u00e8 \nsite\n, il che significa che il \nSiteController\n e l'azione predefinita devono essere utilizzati. Di conseguenza se si accede all'applicazione senza specificare un percorso, verr\u00e0 visualizzato il risultato di \napp\\controllers\\SiteController::actionIndex()\n.\n\n\nPer le applicazioni tramite console, il valore predefinito \u00e8 \nhelp\n, il che significa che il comando principale \u201c yii \\ console \\ controllers \\ HelpController::actionIndex()\u201c deve essere utilizzato. Di conseguenza, se su esegue il comando \nyii\n senza fornire argomenti, visualizzer\u00e0 le informazioni di aiuto(help).\n\n\nEstensioni - (extensions)\n\n\nQuesta propriet\u00e0 specifica l'elenco delle estensioni installate e utilizzate dall'applicazione. Per impostazione predefinita, l'array verr\u00e0 restituito dal file \n@vendor/yiisoft/extensions.php\n. Il file \nextensions.php\n viene generato e mantenuto automaticamente quando si utilizza il Composer per installare le estensioni. Quindi, la maggior parte dei casi, non \u00e8 necessario configurare questa propriet\u00e0.\nNel caso particolare quando si desidera mantenere manualmente le estensioni, \u00e8 possibile configurare questa propriet\u00e0 come segue:\n\n\n[\n    'extensions' =\n [\n        [\n            'name' =\n 'extension name',\n            'version' =\n 'version number',\n            'bootstrap' =\n 'BootstrapClassName',  // optional, may also be a configuration array\n            'alias' =\n [  // optional\n                '@alias1' =\n 'to/path1',\n                '@alias2' =\n 'to/path2',\n            ],\n        ],\n\n        // ... more extensions like the above ...\n\n    ],\n]\n\n\n\nCome potete vedere, la propriet\u00e0 prende una serie di specifiche di estensione. Ogni estensione \u00e8 specificata con una matrice composta da elementi \nname\n e \nversion\n.\n\n\nDisposizione - (layout)\n\n\nQuesta propriet\u00e0 specifica il nome del layout predefinito che dovrebbe essere utilizzato quando si effettua una visualizzazione. Il valore di defult \u00e8 \nmain\n, significa che il file di layout \nmain.php\n sotto il percorso di layout dovrebbe essere usato. Se entrambi i percorsi di layout e il percorso di visualizzazione stanno prendendo i valori predefiniti, il file di layout predefinito pu\u00f2 essere rappresentato come alias di percorso \n@app/views/layouts/main.php\n.\nE' possibile configurare questa propriet\u00e0 \nfalse\n se si desidera disattivare l'impostazione predefinita di layout.\n\n\nlayoutPath\n\n\nQuesta propriet\u00e0 specifica il percorso in cui dovrebbero essere caricati i file di layout. Il valore predefinito \u00e8 la sotto-directory \nlayouts\n sotto il percorso di visualizzazione. Se il percorso di visualizzazione sta prendendo il suo valore predefinito, il percorso di layout pu\u00f2 essere rappresentato come alias di percorso: \n@app/views/layouts\n.\n\n\nruntimepath\n\n\nQuesta propriet\u00e0 specifica il percorso in cui possono essere generati file temporanei, ad esempio file di log, file di cache.Il valore predefinito \u00e8 la directory rappresentata dall'alias \n@app/runtime\n.\n\n\nviewPath\n\n\nQuesta propriet\u00e0 specifica la directory principale in cui si trovano i file di visualizzazione. Il valore predefinito della directory \u00e8 rappresentata dall'alias \n@app/views\n.\n\n\nvendorPath\n\n\nQuesta propriet\u00e0 specifica la directory del fornitore gestita dal Composer. Contriene tutte le livrerie di terze parti utilizzate dall'applicazione, incluso il framework Yii. Il valore predefinito \u00e8 la directory rappresentata dall'alias \n@aap/vendor\n.\n\n\nenableCoreCommands\n\n\nQuesta propriet\u00e0 \u00e8 supportata solo dalle applicazioni tramite console. Specifica se i comandi base inclusi nella versione di Yii dovrebbero essere abilitati. Il valore predefinito \u00e8 \ntrue\n.\n\n\nEventi dell'applicazione\n\n\nUn'applicazione attiva diversi eventi durante il ciclo di vita di una richiesta. E' possibile associare i gestori di eventi nelle configurazioni dell'applicazione come segue:\n\n\n[\n    'on beforeRequest' =\n function ($event) {\n        // ...\n    },\n]\n\n\n\nIn alternativa \u00e8 possibile associare i gestori di eventi durante il processo di avvio dopo che viene creata l'istanza dell'applicazione.\n\n\nEsempio:\n\n\n\\Yii::$app-\non(\\yii\\base\\Application::EVENT_BEFORE_REQUEST, function ($event) {\n    // ...\n});\n\n\n\nEVENT_BEFORE_REQUEST\n\n\nQuesto evento viene attivato \nprima\n che un'applicazione gestisca una richiesta. Il nome effettivo dell'evento \u00e8 \nbeforeRequest\n.\n\n\nEVENT_AFTER_REQUEST\n\n\nQuesto evento viene attivato \ndopo\n che un'applicazione gestisca una richiesta, ma \nprima\n di inviare la risposta. Il nome effettivo dell'evento \u00e8 \nafterRequest\n.\nQuando questo evento viene attivato, la gestione delle richieste \u00e8 completata e si pu\u00f2 prendere questa possibilit\u00e0 per eseguire una successiva elaborazione della richiesta o personalizzare la risposta.\n\n\nEVENT_BEFORE_ACTION\n\n\nQuesto evento viene attivato \nprima\n di eseguire tutte le azioni del controller. Il nome effettivo dell'evento \u00e8 \nbeforeAction\n.\nIl parametro dell'evento \u00e8 un'istanza di \nyii \\ base \\ ActioneEvent\n. Un gestore di evento pu\u00f2 impostare la propriet\u00e0 dell'actionEvent [isValid()] ad essere \nfalse\n e smettere di eseguire l'azione. \n\n\nEsempio:\n\n\n[\n    'on beforeAction' =\n function ($event) {\n        if (some condition) {\n            $event-\nisValid = false;\n        } else {\n        }\n    },\n]\n\n\n\nSi noti che lo stesso evento \nbeforeAction\n viene attivato anche dai moduli e dai controller. Gli oggetti applicativi sono i primi che innescano questo evento, seguito da moduli (se esistono) e infire da controllori. Se settiamo l'evento a \nfalse\n tramite il metodo [isValid()] tutti gli eventi successivi non vettanno attivati.\n\n\nEVENT_AFTER_ACTION\n\n\nQuesto evento viene attivato \ndopo\n l'esecuzione di ogni azione del controller. Il nome effettivo dell'evento \u00e8 \nafterAction\n.\nIl parametro che andremo a settare all'evento \u00e8 un'istanza di \nyii \\ base \\ ActionEvent\n. Attraverso la propriet\u00e0 Yii dell'evento, un gestore di eventi pu\u00f2 accedere o modificare il risultato dell'azione.\n\n\nEsempio:\n\n\n[\n    'on afterAction' =\n function ($event) {\n        if (some condition) {\n            // modify $event-\nresult\n        } else {\n        }\n    },\n]\n\n\n\nSi noti che lo stesso evento \nafterAction\n viene attivato anche dai moduli e dai controller. Questi oggetti innescano questo evento nell'ordine inverso come per quello del \nbeforeAction\n. Cio\u00e8, i controller sono i primi oggetti che innescano questo evento, seguito dai moduli ( ovviamente se esistono )e infine dalle applicazioni.\n\n\nCiclo di vita dell'applicazione\n\n\n\n\nQuando viene eseguito uno script di inserimento (entry script) per gestire una richiesta, un'applicazione sar\u00e0 sottoposta al seguente ciclo di vita:\n\n\n\n\nLo script di inserimento carica la configurazione dell'applicazione come un array.\n\n\nLo script di inserimento crea una nuova istanza dell'applicazione:\n\n\nviene chiamato \npreInit()\n, che configura alcune propriet\u00e0 dell'applicazione al alta priorit\u00e0 ( come per esempio il \nbasePath\n);\n\n\nregistrare eventuali errori nel \ngestore di errori\n;\n\n\nconfigurare le propriet\u00e0 dell'applicazione;\n\n\nviene chiamato \ninit()\n che chiama ulteriormente \nbootstrap()\n per eseguire questi ultimi componenti.\n\n\n\n\n\n\nL'entry script chiama \nyii \\ base Application :: run()\n per eseguire l'applicazione:\n\n\nviene attivato l'evento \nEVENT_BEFORE_REQUEST\n;\n\n\nviene controllata la richiesta. Viene convertita la richiesta in un percorso con i relativi parametri, viene creato un modulo, i controller e gli oggetti di azione come specificato nel percorso e infine viene eseguita l'azione;\n\n\nviene attivato l'evento \nEVENT_AFTER_REQUEST\n;\n\n\ninfine viene inviata una risposta all'utente finale.\n\n\n\n\n\n\nL'entry script riceve lo stato di uscita dall'applicazione e completa l'elaborazione delle richieste.",
            "title": "Applicazioni"
        },
        {
            "location": "/application-structure/sub-applications/#applicazioni",
            "text": "Le applicazioni sono oggetti che regolano la struttura complessiva e il ciclo di vita dei sistemi applicativi di Yii. Ogni sistema applicativo Yii contiene un singolo oggetto di applicazione che viene creato nell'entry script ed \u00e8 globalmente accessibile tramite l'espressione  \\Yii::$app .   Info  A seconda del contesto, quando diciamo \"un'applicazione\", pu\u00f2 significare o un oggetto dell'applicazione o un sistema applicativo   Esistono due tipo di applicazioni: applicazioni Web e applicazioni Console.  Come indicano i nomi, il primo gestisce principalmente le richieste Web, mentre quest'ultimo gestisce le richieste di comando della console.",
            "title": "Applicazioni"
        },
        {
            "location": "/application-structure/sub-applications/#configurazione-dellapplicazione",
            "text": "Quando uno script di accesso crea un'applicazione, caricher\u00e0 una configurazione e la applica all'app, come segue:  require(__DIR__ . '/../vendor/autoload.php');\nrequire(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');\n\n// load application configuration\n$config = require(__DIR__ . '/../config/web.php');\n\n// instantiate and configure the application\n(new yii\\web\\Application($config))- run();  Le configurazioni applicative specificano come inizializzare le propriet\u00e0 degli oggetti applicativi. Poich\u00e8 le configurazioni di applicazione sono complesse, vengono di solito conservate in file di configurazione come  web.php  nell'esempio precedente.",
            "title": "Configurazione dell'applicazione"
        },
        {
            "location": "/application-structure/sub-applications/#proprieta-dellapplicazione",
            "text": "Ci sono molte propriet\u00e0 che pu\u00f2 avere un'applicazione e che dovremmo configurare ne file di configurazione. Queste propriet\u00e0 descrivono in genere l'ambiente in cui sono in esecuzione applicazioni. Ad esemppio, le applicazioni devono sapere come caricare i controller, dove memorizzare file temporanei, ect.. Adesso andremo ad elencare queste propriet\u00e0.",
            "title": "Propriet\u00e0 dell'applicazione"
        },
        {
            "location": "/application-structure/sub-applications/#proprieta-richieste",
            "text": "In qualsiasi applicazione, \u00e8 necessario almeno configurare le seguenti due propriet\u00e0:  ID  La propriet\u00e0 ID specifica un id univoco che differenzia un'applicazione da un'altra. Sebbene non sia un requisito, per una migliore interoperabilit\u00e0 \u00e8 consigliabile utilizzare solo caratteri alfanumerici quando si specifica un ID dell'applicazione.  basePath  La propriet\u00e0 \"basePath\" specifica la directory principale di un'applicazione. E' la directory che contiene tutto il codice sorgente protetto di un sistema applicativo. In base a tale directory, normalmente ci saranno sotto-directory come  models ,  views  e  controllers  che contengono il codice sorgente corrispondente al pattern MVC.\nE' possibile configurare la propriet\u00e0 \"basePath\" utilizzando un percorso di directory o un alias di percorso. In entrambe le forme, la directory corrispondente deve esistere oppure verr\u00e0 lanciata un'eccezione. Il percorso viene normalizzato chiamando la funzione  realpath() .",
            "title": "Propriet\u00e0 richieste"
        },
        {
            "location": "/application-structure/sub-applications/#proprieta-importanti",
            "text": "Le propriet\u00e0 descritte in questa sottosezione spesso devono essere configurare perch\u00e8 differiscono da diverse applicazioni.  Alias  Questa propriet\u00e0 consente di definire un insieme di alias in termini di array. Le chiavi dell'array sono nomi di alias e i valori dell'array sono le corrispondenti definizioni del percorso. Per esempio:  [\n    'aliases' =  [\n        '@name1' =  'path/to/path1',\n        '@name2' =  'path/to/path2',\n    ],\n]  Questa propriet\u00e0 viene utilizzata per richiamare un'applicazione che potrebbe avere un nome differente a quello indicato nell'ID.  Bootstrap  Questa \u00e8 una propriet\u00e0 molto utile. Consente di specificare una serie di componenti che devono essere eseguiti durante il processo di avvio dell'applicazione. Ad esempio, se si desidera che un modulo personalizza le regole URL, \u00e8 possibile elencare l'ID come elemento di questa propriet\u00e0.\nOgni componente elencato in questa propriet\u00e0 pu\u00f2 essere specificato in uno dei seguenti formati:\n- un ID di un'applicazione specificato tramite componenti,\n- un modulo ID specificato tramite moduli,\n- un nome di una classe,\n- un array di configurazione,\n- una funzione anonima che crea e restituisce un determinato componente.  Esempio:  [\n    'bootstrap' =  [\n        // an application component ID or module ID\n        'demo',\n\n        // a class name\n        'app\\components\\Profiler',\n\n        // a configuration array\n        [\n            'class' =  'app\\components\\Profiler',\n            'level' =  3,\n        ],\n\n        // an anonymous function\n        function () {\n            return new app\\components\\Profiler();\n        }\n    ],\n]   Info  se un ID di un modulo \u00e8 lo stesso ID di un componente dell'applicazione, il componente verr\u00e0 utilizzato durante il processo di avvio. Se si desidera usare il modulo invece del componente, \u00e8 possibile specificarlo utilizzando una funzione anonima come segue:  [\n    function () {\n        return Yii::$app- getModule('user');\n    },\n]   Durante il processo di avvio ogni componente viene instanziato. Se la classe dei componenti implementa \u201c yii /base / BootstrapInterface\", verr\u00e0 anche chiamato il metodo \"bootstrap()\". Questo metodo pu\u00f2 contenere ID di eventuali moduli che voglio caricare prima di alcuni ( per es. il modulo \u2018log\u2019 per tener traccia di eventuali errori nella fase di caricamento ).  CatchAll  Questa propriet\u00e0 \u00e8 supportata solo dalle applicazioni Web. Specifica un'azione del controller che dovrebbe gestire tutte le richieste dell'utente. Questo viene utilizzato principalmente quando l'applicazione \u00e8 in modalit\u00e0 di manutenzione (debug) e deve gestire tutte le richieste in entrata tramite un'unica azione.\nLa configurazione \u00e8 una matrice il cui primo elemento specifica il percorso dell'azione. Il resto degli elementi della matrice specifica i parametri da associare all'azione.   Esempio:  [\n    'catchAll' =  [\n        'offline/notice',\n        'param1' =  'value1',\n        'param2' =  'value2',\n    ],\n]   Info  Il pannello di debug sull'ambiente di sviluppo non funziona quando questa propriet\u00e0 \u00e8 abilitata.   Componenti - (components)  Questa \u00e8 la propriet\u00e0 pi\u00f9 importante. Consente di registrare un elenco di componenti denominati \"application component\" che \u00e8 possibile utilizzare in altri luoghi.   Esempio:  [\n    'components' =  [\n        'cache' =  [\n            'class' =  'yii\\caching\\FileCache',\n        ],\n        'user' =  [\n            'identityClass' =  'app\\models\\User',\n            'enableAutoLogin' =  true,\n        ],\n    ],  \n]  Ogni componente dell'applicazione viene specificata come array di chiave valore.  Esempio 2:  'components' =  [\n        'user' =  [\n            'identityClass' =  'common\\models\\User',\n            'enableAutoLogin' =  true,\n        ],]  Nella parte di codice sopra, si vede la struttura chiave-valore applicata.\nLa prima chiave che troviamo \u00e8 \u201cUser\u201d cio\u00e8 l\u2019identificavo (ID) del modulo/componente, e il suo valore, \u00e8 composto a sua volta da un array chiave-valore, dove le chiavi questa volta sono identificativi o della classe principale del modulo (identityClass) o di una sua configurazione (enableAutoLogin).  ControllerMap  Questa propriet\u00e0 consente di mappare un controller ID in una classe arbitraria del controller. Per impostazione predefinitam Yii mapper\u00e0 gli ID alle classi di controller basate su una convenzione ( ad esempio l'ID  post  verr\u00e0 mappato  app\\controller\\PostController ). Configurando questa propriet\u00e0, \u00e8 possibile rompere la convenzione per specifici controller. Nell'esempio seguente,  account  verr\u00e0 mappato  app\\controllers\\UserController , mentre  article  verr\u00e0 mappato su  app\\controllers\\PostController .  [\n    'controllerMap' =  [\n        'account' =  'app\\controllers\\UserController',\n        'article' =  [\n            'class' =  'app\\controllers\\PostController',\n            'enableCsrfValidation' =  false,\n        ],\n    ],  \n]  Le chiavi dell'array rappresentano gli ID del controller, mentre i valori dell'array rappresentano i nomi o le configurazioni dei nomi delle classi di controllo corrispondenti.  ControllerNamespace  Questa propriet\u00e0 specifica i namespace predefiniti in cui le classi controller devono essere posizionate. Come posizione di default li troveremo in  app\\controllers . Se \u00e8 un ID del controller  post , per convenzione corrisponderebbe il nome della classe di controllo  PostController  e il nome della classe completamente qualificato  app\\controllers\\PostController .\nLe classi del controller possono anche essere posizionate sotto le sotto-directory della directory corrispondente a questi namespace. Ad esempio, dato un ID controller  admin/post , la corrispondente classe del controller completamente qualificata sarebbe  app\\controllers\\admin\\PostController .\nE' importante che le classi di controllo pienamente qualificate debbano essere \"autoloadable\" e i namespace delle classi di controller corrispondino al valore di questa propriet\u00e0. Altrimenti riceverai un errore \"Pagina non trovata\" quando si accede alla nostra applicazione.  Lingua - (language)  Questa propriet\u00e0 specifica la lingua in cui l'applicazionedeve visualizzare il contenuto agli utenti finali. Il valore predefinito di questa propriet\u00e0 \u00e8  en  ( inglese ). E' necessario configurare questa propriet\u00e0 se vogliamo che l'applicazione possa supportare pi\u00f9 lingue.\nIl valore di questa propriet\u00e0 determina diversi aspetti di internalizzazione, tra cui la traduzione dei messaggi, la formattazione della data, la formattazione del numero, ecc..  Moduli - (modules)  Questa propriet\u00e0 specifica i moduli che contiene l'applicazione. I moduli vengono visti come sotto-applicazioni della nostra applicazione padre.  Esempio:  [\n    'modules' =  [\n        // a \"booking\" module specified with the module class\n        'booking' =  'app\\modules\\booking\\BookingModule',\n\n        // a \"comment\" module specified with a configuration array\n        'comment' =  [\n            'class' =  'app\\modules\\comment\\CommentModule',\n            'db' =  'db',\n        ],\n    ],  \n]  Nome - (name)  Questa propriet\u00e0 specifica il nome dell'applicazione che pu\u00f2 essere visualizzato agli utenti finali. A differenza della propriet\u00e0 ID, che dovrebbe assumere un valore univoco, il valore di questa propriet\u00e0 \u00e8 usato principalmente per scopi di visualizzazione. Non deve essere univoco.  Parametri - (params)  Questa propriet\u00e0 specifica una serie di parametri applicativi accessibili a livello globale. Invece di utilizzare numerosi codici e stringhe dappertutto nel codice, \u00e8 una buona pratica definirli come parametri dell'app in un unico punto e utilizzare parametri in luoghi dove \u00e8 necessario.   Esempio: possiamo utilizzare questa propriet\u00e0 per definire la dimensione dell'immagine in miniatura come parametro  [\n    'params' =  [\n        'thumbnail.size' =  [128, 128],\n    ],\n]  A questo punto nel codice in cui bisgona utilizzare il valore della dimensione, possiamo usare il seguente codice:  $size = \\Yii::$app- params['thumbnail.size'];\n$width = \\Yii::$app- params['thumbnail.size'][0];  In seguito, se si decide di modificare le dimensioni delle miniature, \u00e8 necessario modificarlo solo nella configurazione dell'applicazione; non \u00e8 necessario toccare alcun codice dipendente.  Linguaggio del codice - (sourceLanguage)  Questa propriet\u00e0 specifica la lingua in cui \u00e8 scritto il codice dell'applicazione. Il valore predefinito \u00e8  en-US , cio\u00e8 l'inglese (Stati Uniti). E' necessario configurare questo propriet\u00e0 se il contenuto del testo nel codice non \u00e8 in inglese.  Fuso orario - (timeZone)  Questa propriet\u00e0 viene fornita come modalit\u00e0 alternativa per impostare il fuso orario predefinito del runtime PHP. Configurando questa propriet\u00e0, si sta chiamando essenzialmente la funzione PHP \"date_default_timezone_set()\u201c.  Esempio:  [\n    'timeZone' =  'America/Los_Angeles',\n]  Versioni - (version)  Questa propriet\u00e0 specifica la versione dell'applicazione. E' predefinito  1.0 .",
            "title": "Propriet\u00e0 importanti"
        },
        {
            "location": "/application-structure/sub-applications/#proprieta-utili",
            "text": "Le propriet\u00e0 descritte in questa sottosezione non sono comunemente configurate perch\u00e8 i loro valori predefiniti derivano da convenzioni comuni. Tuttavia, \u00e8 possibile configurarli nel caso in cui si desidera rompere le convenzioni.  Charset  Questa propriet\u00e0 specifica il carattere che l'applicazione utilizza. Il valore predefinito \u00e8 quello  UTF-8  che dovrebbe essere mantenuto come per la maggior parte delle applicazioni a meno che non si tratti di un sistema legacy che utilizza un sacco di dati non Unicode.  DefaultRoute  Questa propriet\u00e0 specifica il percorso che un'applicazione deve utilizzare quando una richiesta non lo specifica. Ad esempio,  help , post/create  o  admin/post/create . Se non viene dato un ID dell'azione, questa propriet\u00e0 prende il valore predefinito specificato in \u201c yii \\base \\ Controller :: $defaultAction\".  Per le applicazioni Web, il valore predefinito di questa propriet\u00e0 \u00e8  site , il che significa che il  SiteController  e l'azione predefinita devono essere utilizzati. Di conseguenza se si accede all'applicazione senza specificare un percorso, verr\u00e0 visualizzato il risultato di  app\\controllers\\SiteController::actionIndex() .  Per le applicazioni tramite console, il valore predefinito \u00e8  help , il che significa che il comando principale \u201c yii \\ console \\ controllers \\ HelpController::actionIndex()\u201c deve essere utilizzato. Di conseguenza, se su esegue il comando  yii  senza fornire argomenti, visualizzer\u00e0 le informazioni di aiuto(help).  Estensioni - (extensions)  Questa propriet\u00e0 specifica l'elenco delle estensioni installate e utilizzate dall'applicazione. Per impostazione predefinita, l'array verr\u00e0 restituito dal file  @vendor/yiisoft/extensions.php . Il file  extensions.php  viene generato e mantenuto automaticamente quando si utilizza il Composer per installare le estensioni. Quindi, la maggior parte dei casi, non \u00e8 necessario configurare questa propriet\u00e0.\nNel caso particolare quando si desidera mantenere manualmente le estensioni, \u00e8 possibile configurare questa propriet\u00e0 come segue:  [\n    'extensions' =  [\n        [\n            'name' =  'extension name',\n            'version' =  'version number',\n            'bootstrap' =  'BootstrapClassName',  // optional, may also be a configuration array\n            'alias' =  [  // optional\n                '@alias1' =  'to/path1',\n                '@alias2' =  'to/path2',\n            ],\n        ],\n\n        // ... more extensions like the above ...\n\n    ],\n]  Come potete vedere, la propriet\u00e0 prende una serie di specifiche di estensione. Ogni estensione \u00e8 specificata con una matrice composta da elementi  name  e  version .  Disposizione - (layout)  Questa propriet\u00e0 specifica il nome del layout predefinito che dovrebbe essere utilizzato quando si effettua una visualizzazione. Il valore di defult \u00e8  main , significa che il file di layout  main.php  sotto il percorso di layout dovrebbe essere usato. Se entrambi i percorsi di layout e il percorso di visualizzazione stanno prendendo i valori predefiniti, il file di layout predefinito pu\u00f2 essere rappresentato come alias di percorso  @app/views/layouts/main.php .\nE' possibile configurare questa propriet\u00e0  false  se si desidera disattivare l'impostazione predefinita di layout.  layoutPath  Questa propriet\u00e0 specifica il percorso in cui dovrebbero essere caricati i file di layout. Il valore predefinito \u00e8 la sotto-directory  layouts  sotto il percorso di visualizzazione. Se il percorso di visualizzazione sta prendendo il suo valore predefinito, il percorso di layout pu\u00f2 essere rappresentato come alias di percorso:  @app/views/layouts .  runtimepath  Questa propriet\u00e0 specifica il percorso in cui possono essere generati file temporanei, ad esempio file di log, file di cache.Il valore predefinito \u00e8 la directory rappresentata dall'alias  @app/runtime .  viewPath  Questa propriet\u00e0 specifica la directory principale in cui si trovano i file di visualizzazione. Il valore predefinito della directory \u00e8 rappresentata dall'alias  @app/views .  vendorPath  Questa propriet\u00e0 specifica la directory del fornitore gestita dal Composer. Contriene tutte le livrerie di terze parti utilizzate dall'applicazione, incluso il framework Yii. Il valore predefinito \u00e8 la directory rappresentata dall'alias  @aap/vendor .  enableCoreCommands  Questa propriet\u00e0 \u00e8 supportata solo dalle applicazioni tramite console. Specifica se i comandi base inclusi nella versione di Yii dovrebbero essere abilitati. Il valore predefinito \u00e8  true .",
            "title": "Propriet\u00e0 Utili"
        },
        {
            "location": "/application-structure/sub-applications/#eventi-dellapplicazione",
            "text": "Un'applicazione attiva diversi eventi durante il ciclo di vita di una richiesta. E' possibile associare i gestori di eventi nelle configurazioni dell'applicazione come segue:  [\n    'on beforeRequest' =  function ($event) {\n        // ...\n    },\n]  In alternativa \u00e8 possibile associare i gestori di eventi durante il processo di avvio dopo che viene creata l'istanza dell'applicazione.  Esempio:  \\Yii::$app- on(\\yii\\base\\Application::EVENT_BEFORE_REQUEST, function ($event) {\n    // ...\n});  EVENT_BEFORE_REQUEST  Questo evento viene attivato  prima  che un'applicazione gestisca una richiesta. Il nome effettivo dell'evento \u00e8  beforeRequest .  EVENT_AFTER_REQUEST  Questo evento viene attivato  dopo  che un'applicazione gestisca una richiesta, ma  prima  di inviare la risposta. Il nome effettivo dell'evento \u00e8  afterRequest .\nQuando questo evento viene attivato, la gestione delle richieste \u00e8 completata e si pu\u00f2 prendere questa possibilit\u00e0 per eseguire una successiva elaborazione della richiesta o personalizzare la risposta.  EVENT_BEFORE_ACTION  Questo evento viene attivato  prima  di eseguire tutte le azioni del controller. Il nome effettivo dell'evento \u00e8  beforeAction .\nIl parametro dell'evento \u00e8 un'istanza di  yii \\ base \\ ActioneEvent . Un gestore di evento pu\u00f2 impostare la propriet\u00e0 dell'actionEvent [isValid()] ad essere  false  e smettere di eseguire l'azione.   Esempio:  [\n    'on beforeAction' =  function ($event) {\n        if (some condition) {\n            $event- isValid = false;\n        } else {\n        }\n    },\n]  Si noti che lo stesso evento  beforeAction  viene attivato anche dai moduli e dai controller. Gli oggetti applicativi sono i primi che innescano questo evento, seguito da moduli (se esistono) e infire da controllori. Se settiamo l'evento a  false  tramite il metodo [isValid()] tutti gli eventi successivi non vettanno attivati.  EVENT_AFTER_ACTION  Questo evento viene attivato  dopo  l'esecuzione di ogni azione del controller. Il nome effettivo dell'evento \u00e8  afterAction .\nIl parametro che andremo a settare all'evento \u00e8 un'istanza di  yii \\ base \\ ActionEvent . Attraverso la propriet\u00e0 Yii dell'evento, un gestore di eventi pu\u00f2 accedere o modificare il risultato dell'azione.  Esempio:  [\n    'on afterAction' =  function ($event) {\n        if (some condition) {\n            // modify $event- result\n        } else {\n        }\n    },\n]  Si noti che lo stesso evento  afterAction  viene attivato anche dai moduli e dai controller. Questi oggetti innescano questo evento nell'ordine inverso come per quello del  beforeAction . Cio\u00e8, i controller sono i primi oggetti che innescano questo evento, seguito dai moduli ( ovviamente se esistono )e infine dalle applicazioni.",
            "title": "Eventi dell'applicazione"
        },
        {
            "location": "/application-structure/sub-applications/#ciclo-di-vita-dellapplicazione",
            "text": "Quando viene eseguito uno script di inserimento (entry script) per gestire una richiesta, un'applicazione sar\u00e0 sottoposta al seguente ciclo di vita:   Lo script di inserimento carica la configurazione dell'applicazione come un array.  Lo script di inserimento crea una nuova istanza dell'applicazione:  viene chiamato  preInit() , che configura alcune propriet\u00e0 dell'applicazione al alta priorit\u00e0 ( come per esempio il  basePath );  registrare eventuali errori nel  gestore di errori ;  configurare le propriet\u00e0 dell'applicazione;  viene chiamato  init()  che chiama ulteriormente  bootstrap()  per eseguire questi ultimi componenti.    L'entry script chiama  yii \\ base Application :: run()  per eseguire l'applicazione:  viene attivato l'evento  EVENT_BEFORE_REQUEST ;  viene controllata la richiesta. Viene convertita la richiesta in un percorso con i relativi parametri, viene creato un modulo, i controller e gli oggetti di azione come specificato nel percorso e infine viene eseguita l'azione;  viene attivato l'evento  EVENT_AFTER_REQUEST ;  infine viene inviata una risposta all'utente finale.    L'entry script riceve lo stato di uscita dall'applicazione e completa l'elaborazione delle richieste.",
            "title": "Ciclo di vita dell'applicazione"
        },
        {
            "location": "/application-structure/sub-application-components/",
            "text": "Componenti applicativi\n\n\nLe applicazioni sono localizzatori di servizi. Essi ospitano un insieme di componenti dell'applicazione che forniscono diversi servizi per le richieste di elaborazione. Ad esempio, il componente \nurlManager\n \u00e8 responsabile dell'instradamento delle richieste Web ai vai controller appropriati; il componente \ndb\n fornisce servizi correlati al DB, e cos\u00ec via.\nOgni componente di applicazione ha un ID che lo identifica in modo univoco tra gli altri componenti dell'applicazione. E' possibile accedere ad ogni componente applicativo tramite la seguente espressione:\n\n\n\\Yii::$app-\ncomponentID\n\n\n\nAd esempio, \u00e8 possibile utilizzare \n\\Yii::$app-\ndb\n per ottenere la connessione al DB e \n\\Yii::$app-\ncache\n per ottenere la cache primaria registrata con l'applicazione.\n\n\nUna componente di applicazione viene creata la prima volta che viene acceduto tramite l'espressione indicata in precedenza. Tutti gli altri accsessi restituiranno la stessa istanza di componente.\nI componenti dell'applicazione possono essere oggetti. E' possibile registrarli configurando la propriet\u00e0 \nyii \\ base \\ Application :: $\n nella parte in cui avviene la configurazione della nostra applicazione.\n\n\nEsempio:\n\n\n[\n    'components' =\n [\n        // register \"cache\" component using a class name\n        'cache' =\n 'yii\\caching\\ApcCache',\n\n        // register \"db\" component using a configuration array\n        'db' =\n [\n            'class' =\n 'yii\\db\\Connection',\n            'dsn' =\n 'mysql:host=localhost;dbname=demo',\n            'username' =\n 'root',\n            'password' =\n '',\n        ],\n\n        // register \"search\" component using an anonymous function\n        'search' =\n function () {\n            return new app\\components\\SolrService;\n        },\n    ],\n]\n\n\n\n\n\nInfo\n\n\nMentre \u00e8 possibile registrare quanti componenti voi vogliate, devi fare questo giudizio. I componenti dell'applicazione sono come variabili globali. L'utilizzo di troppi componenti dell'applicazione pu\u00f2 potenzialmente rendere il codice pi\u00f9 difficile da testare. In molti casi, \u00e8 possibile creare una componente locale e utilizzarlo quando necessario.\n\n\n\n\nComponenti di avvio\n\n\nCome accennato in precedenza, una componente dell'applicazione verr\u00e0 istanziata solo quando viene visualizzata la prima volta. Se non \u00e8 affatto accessibile durante una richiesta, non verr\u00e0 istanziata. A volte, per\u00f2 si pu\u00f2 desiderare di creare un'istanza di un componente applicativo per ogni richiesta, anche se non \u00e8 esplicitamente accessibile. A tal fine, \u00e8 possibile elencare l'ID nella propriet\u00e0 d'avvio dell'applicazione.\n\n\nAd esempio, la seguente configurazione dell'applicazione assicura che il componente di \nlog\n sia sempre caricato:\n\n\n[\n    'bootstrap' =\n [\n        'log',\n    ],\n    'components' =\n [\n        'log' =\n [\n            // configuration for \"log\" component\n        ],\n    ],\n]\n\n\n\nComponenti dell'applicazione di base\n\n\nYii definisce un insieme di componenti dell'applicazione \"principali\" con ID fisse e configurazioni predefinite. Ad esempio, la componente di \nrequest(richiesta)\n viene utilizzata per raccogliere informazioni su una richiesta di utente e risolverla in una \nroute(percorso)\n; il componente \ndb\n rappresenta una connessione di database tramite cui \u00e8 possibile eseguire query di database. Con l'aiuto di questi componenti principali, le applicazioni Yii sono in grado di gestire le richieste degli utenti.\nDi seguito viene riportato l'elenco dei componenti predefiniti dell'applicazione di base. Puoi configurarli e personalizzarli come fai con i componenti di applicazione normali. Quando si configura una componente dell'applicazione principale, se non si specifica la classe, verr\u00e0 utilizzato il valore predefinito.\n\n\n\n\nassetManager\n: gestisce i bundle di asset e asset per la pubblicazione di informazioni(publishing);\n\n\ndb\n: rappresenta una connessione di database tramite cui \u00e8 possibile eseguire query DB. Notare che quando si configura questo componente, \u00e8 necessario specificare la classe del componente e altre propriet\u00e0 richieste ( ad esempio ***yii \\ db \\ Connection :: $ dsn);\n\n\nyii \\ base \\ Application :: errorHandler\n: gestisce errori e eccezioni PHP;\n\n\nformatter\n: formatta i dati quando vengono visualizzati agli utenti finali. Ad esempio, una data pu\u00f2 essere formattata in formato long;\n\n\ni18n\n: supporta la traduzione e la formattazione dei messaggi;\n\n\nlog\n: gestisce gli obiettivi di log;\n\n\nmailer\n: supporta la composizione e l'invio di posta;\n\n\nyii \\ base \\ Application :: response\n: rappresenta la risposta inviata agli utenti finali;\n\n\nyii \\ base \\ Application :: request\n: rappresenta la richiesta ricevuta dagli utenti finali;\n\n\nsession(sessione)\n: rappresenta le informazioni sulla sessione. Questo componente \u00e8 disponibile solo nelle applicazioni Web;\n\n\nurlManager\n: supporta l'analisi e la creazione di URL;\n\n\nuser(utente)\n: rappresenta le informazioni di autenticazione utente. Questo componente \u00e8 disponibile solo nelle applicazioni Web;\n\n\nview(vista)\n: supporta la visualizzazione delle view.",
            "title": "Componenti applicativi"
        },
        {
            "location": "/application-structure/sub-application-components/#componenti-applicativi",
            "text": "Le applicazioni sono localizzatori di servizi. Essi ospitano un insieme di componenti dell'applicazione che forniscono diversi servizi per le richieste di elaborazione. Ad esempio, il componente  urlManager  \u00e8 responsabile dell'instradamento delle richieste Web ai vai controller appropriati; il componente  db  fornisce servizi correlati al DB, e cos\u00ec via.\nOgni componente di applicazione ha un ID che lo identifica in modo univoco tra gli altri componenti dell'applicazione. E' possibile accedere ad ogni componente applicativo tramite la seguente espressione:  \\Yii::$app- componentID  Ad esempio, \u00e8 possibile utilizzare  \\Yii::$app- db  per ottenere la connessione al DB e  \\Yii::$app- cache  per ottenere la cache primaria registrata con l'applicazione.  Una componente di applicazione viene creata la prima volta che viene acceduto tramite l'espressione indicata in precedenza. Tutti gli altri accsessi restituiranno la stessa istanza di componente.\nI componenti dell'applicazione possono essere oggetti. E' possibile registrarli configurando la propriet\u00e0  yii \\ base \\ Application :: $  nella parte in cui avviene la configurazione della nostra applicazione.  Esempio:  [\n    'components' =  [\n        // register \"cache\" component using a class name\n        'cache' =  'yii\\caching\\ApcCache',\n\n        // register \"db\" component using a configuration array\n        'db' =  [\n            'class' =  'yii\\db\\Connection',\n            'dsn' =  'mysql:host=localhost;dbname=demo',\n            'username' =  'root',\n            'password' =  '',\n        ],\n\n        // register \"search\" component using an anonymous function\n        'search' =  function () {\n            return new app\\components\\SolrService;\n        },\n    ],\n]   Info  Mentre \u00e8 possibile registrare quanti componenti voi vogliate, devi fare questo giudizio. I componenti dell'applicazione sono come variabili globali. L'utilizzo di troppi componenti dell'applicazione pu\u00f2 potenzialmente rendere il codice pi\u00f9 difficile da testare. In molti casi, \u00e8 possibile creare una componente locale e utilizzarlo quando necessario.",
            "title": "Componenti applicativi"
        },
        {
            "location": "/application-structure/sub-application-components/#componenti-di-avvio",
            "text": "Come accennato in precedenza, una componente dell'applicazione verr\u00e0 istanziata solo quando viene visualizzata la prima volta. Se non \u00e8 affatto accessibile durante una richiesta, non verr\u00e0 istanziata. A volte, per\u00f2 si pu\u00f2 desiderare di creare un'istanza di un componente applicativo per ogni richiesta, anche se non \u00e8 esplicitamente accessibile. A tal fine, \u00e8 possibile elencare l'ID nella propriet\u00e0 d'avvio dell'applicazione.  Ad esempio, la seguente configurazione dell'applicazione assicura che il componente di  log  sia sempre caricato:  [\n    'bootstrap' =  [\n        'log',\n    ],\n    'components' =  [\n        'log' =  [\n            // configuration for \"log\" component\n        ],\n    ],\n]",
            "title": "Componenti di avvio"
        },
        {
            "location": "/application-structure/sub-application-components/#componenti-dellapplicazione-di-base",
            "text": "Yii definisce un insieme di componenti dell'applicazione \"principali\" con ID fisse e configurazioni predefinite. Ad esempio, la componente di  request(richiesta)  viene utilizzata per raccogliere informazioni su una richiesta di utente e risolverla in una  route(percorso) ; il componente  db  rappresenta una connessione di database tramite cui \u00e8 possibile eseguire query di database. Con l'aiuto di questi componenti principali, le applicazioni Yii sono in grado di gestire le richieste degli utenti.\nDi seguito viene riportato l'elenco dei componenti predefiniti dell'applicazione di base. Puoi configurarli e personalizzarli come fai con i componenti di applicazione normali. Quando si configura una componente dell'applicazione principale, se non si specifica la classe, verr\u00e0 utilizzato il valore predefinito.   assetManager : gestisce i bundle di asset e asset per la pubblicazione di informazioni(publishing);  db : rappresenta una connessione di database tramite cui \u00e8 possibile eseguire query DB. Notare che quando si configura questo componente, \u00e8 necessario specificare la classe del componente e altre propriet\u00e0 richieste ( ad esempio ***yii \\ db \\ Connection :: $ dsn);  yii \\ base \\ Application :: errorHandler : gestisce errori e eccezioni PHP;  formatter : formatta i dati quando vengono visualizzati agli utenti finali. Ad esempio, una data pu\u00f2 essere formattata in formato long;  i18n : supporta la traduzione e la formattazione dei messaggi;  log : gestisce gli obiettivi di log;  mailer : supporta la composizione e l'invio di posta;  yii \\ base \\ Application :: response : rappresenta la risposta inviata agli utenti finali;  yii \\ base \\ Application :: request : rappresenta la richiesta ricevuta dagli utenti finali;  session(sessione) : rappresenta le informazioni sulla sessione. Questo componente \u00e8 disponibile solo nelle applicazioni Web;  urlManager : supporta l'analisi e la creazione di URL;  user(utente) : rappresenta le informazioni di autenticazione utente. Questo componente \u00e8 disponibile solo nelle applicazioni Web;  view(vista) : supporta la visualizzazione delle view.",
            "title": "Componenti dell'applicazione di base"
        },
        {
            "location": "/application-structure/sub-controllers/",
            "text": "Controllori  (Controllers)\n\n\nI controllori(controller) sono parte dell'architettura MVC. Sono oggetti di classi che si estendono da \nyii \\ base \\ Controller\n e sono responsabili delle richieste di elaborazione e della generazione di risposte. In particolare, dopo aver assunto il controllo delle applicazioni, i controller analizzeranno i dati ricevuti dalla richieste in entrata, li passano ai modelli, iniettano i risultati dei modelli nelle viste(view) e, infine, generano risposte in uscita.\n\n\nAzioni\n\n\nI controller sono composti da azioni che sono le unit\u00e0 pi\u00f9 semplici che gli utenti finali possono richiederne l'esecuzione. Un controller pu\u00f2 avere una o pi\u00f9 azioni.\nL'esempio seguente mostra un controller \npost\n con due azioni: azione di vista ( \nview\n) e azione di creazione ( \ncreate\n):\n\n\nnamespace app\\controllers;\n\nuse Yii;\nuse app\\models\\Post;\nuse yii\\web\\Controller;\nuse yii\\web\\NotFoundHttpException;\n\nclass PostController extends Controller{\n    public function actionView($id){\n        $model = Post::findOne($id);\n        if ($model === null) {\n            throw new NotFoundHttpException;\n        }\n\n        return $this-\nrender('view', [\n            'model' =\n $model,\n        ]);\n    }\n\n    public function actionCreate(){\n        $model = new Post;\n\n        if ($model-\nload(Yii::$app-\nrequest-\npost()) \n $model-\nsave()) {\n            return $this-\nredirect(['view', 'id' =\n $model-\nid]);\n        } else {\n            return $this-\nrender('create', [\n                'model' =\n $model,\n            ]);\n        }\n    }\n}\n\n\n\nNell'azione di vista( definita dal metodo \nactionView()\n),carica il modello secondo l'ID del modello richiesto. Se il modello viene caricato correttamente, lo visualizzer\u00e0 utilizzando un vista denominata \nview\n. Altrimenti verr\u00e0 lanciata un'eccezione.\n\n\nNell'azione di creazione( definita dal metodo \nactionCreate()\n), carica il modello secondo l'ID del modello richiesto. In primo luogo cerca di popolare una nuova istanza del modello utilizzando i dati di richiesta e salvarli all'interno del modello. Se entrambe le azioni avvengono con successo, reindirizzer\u00e0 il browser all'azione \nview\n con l'ID del modello appena creato. Altrimenti verr\u00e0 visualizzata la vista di creazione (\ncreate\n) attraverso la quale gli utenti possono fornire l'input necessario.\n\n\nItinerari\n\n\nGli utenti finali gestiscono le azioni attraverso i percorsi. Un percorso \u00e8 una stringa che consiste nelle seguenti parti:\n\n\n\n\nun modulo ID: questo esiste solo se il controller appartiene a un modulo non applicativo;\n\n\nun controller ID: una stringa che identifica in modo univoco il controller tra tutti i controller della stessa applicazione;\n\n\nun ID d'azione: una stringa che identifica in modo univoco l'azione tra tutte le azioni all'interno dello stesso controller.\n\n\n\n\nI percorsi hanno il seguente formato:\n\n\nControllerID/ActionID\n\n\n\noppure il seguente formato se il controller appartiene a un modulo:\n\n\nModuleID/ControllerID/ActionID\n\n\n\nQuindi, se un utente possa richiedere il seguente URL (http://hostname/index.php?r=site/index), verr\u00e0 eseguita l'azione di \nindex\n nel controller del \nsite\n.\n\n\nCreazione di un controller\n\n\nNelle applicazioni Web, i controller devono estendere \nyii \\ web \\ Controller\n. Analogamente nelle applicazioni console,i controller devono estendersi da \nyii \\ web \\ Controller\n. Il seguente codice definisce un controller \nsite\n.\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n}\n\n\n\nDi solito, un controllore \u00e8 progettato per gestire le richieste relative a un particolare tipo di risorsa. Per questo motivo, gli ID controller sono spesso nomi che si riferiscono ai tipi delle risorse che gestiscono. Ad esempio, \u00e8 possibile utilizzare \narticle\n come ID di un controller che gestisce i dati dell'articolo.\n\n\nPer impostazione predefinita, gli ID controller devono contenere solo questi caratteri: lettere minuscole, cifre, sottolineature, trattini e barre in avanti. Ad esempio, \narticle\n e \npost-comment\n sono entrambi ID controller validi, mentre \narticle?\n,\nPostComment\n,\nadmin\\post\n non lo sono.\n\n\nUn ID controller pu\u00f2 anche contenere un prefisso della sotto-directory. Ad esempio, \nadmin/article\n sta per un controller \narticle\n nella sotto-directory \nadmin\n sotto lo spazio dei nomi del controller. I caratteri validi per i prefissi della sotto-directory includono: lettere maiuscole o minuscole, cifre, sottolineature, trattini, ect.\n\n\nNome del codice dei controller\n\n\nI nomi delle classi di controller possono essere derivati da un ID controller secondo la seguente procedura:\n\n\n\n\nruotare la prima lettera in ogni parola separata da trattini in maiuscolo. Notare che se l'ID del controller contiene barre di scorrimento, questa regola si applica solo alla parte dopo l'ultima barra dell'ID;\n\n\nrimuovere i trattini e sostituire gli \"slash\" con i \"backslash\".\n\n\naggiungi il suffisso \nController\n.\n\n\nprendere il namespace del controller.\n\n\n\n\nDi seguito sono riportati alcuni esempi, supponendo che i namespace dei controller prendano il valore predefinito \napp\\controllers\n:\n\n\n\n\narticle\n diventa \napp\\controllers\\ArticleController\n;\n\n\npost-comment\n diventa \napp\\controllers\\PostCommentController\n;\n\n\nadmin/post-comment\n diventa \napp\\controllers\\admin\\PostCommentController\n;\n\n\nadminPanels/post-comment\n diventa \napp\\controllers\\adminPanels\\PostCommentController\n.\n\n\n\n\nLe classi del controllore devono essere \nautoloadable\n. Per questo motivo, negli esempi precedenti, la classe controller \narticle\n dovrebbe essere salvata dove lo pseudonimo \u00e8 \n@app/controllers/ArticleController.php\n; mentre il controller \nadmin/post-comment\n dovrebbero essere in \n@app/controllers/admin/PostCommentController.php\n.\n\n\n\n\nInfo\n\n\nL'ultimo esempio \nadmin/post-comment\n mostra come \u00e8 possibile inserire un controller sotto una sotto-directory del namespace del controller. Questo \u00e8 utile quando si desidera organizzare i controller in pi\u00f9 categorie e non si desidera utilizzare i moduli.\n\n\n\n\nMappa dei controller\n\n\nE' possibile configurare la mappa del controller per superare i vincoli degli ID del controller e dei nomi di classe descritti in precedenza. Ci\u00f2 \u00e8 principalmente utile quando si utilizzano controllori di terze parti e non si ha il controllo sui nomi delle classi.\nE' possibile configurare la mappa dei controller nella configurazione dell'applicazione.\n\n\nEsempio:\n\n\n[\n    'controllerMap' =\n [\n        // declares \"account\" controller using a class name\n        'account' =\n 'app\\controllers\\UserController',\n\n        // declares \"article\" controller using a configuration array\n        'article' =\n [\n            'class' =\n 'app\\controllers\\PostController',\n            'enableCsrfValidation' =\n false,\n        ],\n    ],\n]\n\n\n\nController di default\n\n\nOgni applicazione dispone di un controller predefinito specificato tramite la propriet\u00e0 \nyii \\ base \\ Application :: $ defaultRoute\n. Quando una richiesta non specifica un percorso, verr\u00e0 utilizzato il percorso specificato da questa propriet\u00e0. Per le applicazioni Web, il suo valore \u00e8 \nsite\n, mentre per le applicazioni tramite console \u00e8 \nhelp\n.\nE' possibile modificare il controller di default con la seguente configurazione dell'applicazione:\n\n\n[\n    'defaultRoute' =\n 'main',\n]\n\n\n\nCreazione delle azioni\n\n\nLa creazione delle azioni \u00e8 semplice, come definite i cosiddetti \"metodi di azione\" in una classe controller. Un metodo di azione \u00e8 un metodo \"pubblico\" il nome inizia con un \naction\n. Il valore restituito da un metodo di azione rappresenta i dati di risposta che dovranno essere inviati poi all'utente finale. Il seguente codice definisce due azioni: l'azione \nindex\n e l'azione \nhello-world\n:\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public function actionIndex(){\n\n        return $this-\nrender('index');\n\n    }\n    public function actionHelloWorld(){\n\n        return 'Hello World';\n\n    }\n}\n\n\n\nID dell'azione\n\n\nUn'azione \u00e8 spesso progettata per eseguire una particolare manipolazione di una risorsa. Per questo motivo, gli ID dell'azione sono solitamente verbi ( come per esempio \nview\n, \nupdate\n, ect..).\n\n\nPer impostazione predefinita, l'ID dell'azione deve contenere solo questi caratteri: lettere minuscole,cifre,sottolineature,e trattini. Ad esempio, \nview\n,\nupdate2\n, e \ncomment-post\n sono tutti ID di azioni valide, mentre \nview?\n e \nUpdate\n non lo sono.\n\n\nE' possibile creare azioni in due modi: azioni in linea e azioni autonome. Un'azione inline \u00e8 definita come un metodo della classe controller, mentre un'azione autonoma \u00e8 una classe che estende \n yii \\ base \\ Action \n o le sue classi figlio. Le azioni in linea sono pi\u00f9 veloci e semplici da creare e sono spesso preferite se non si intende riutilizzarle. Le azioni autonome invece sono principalmente create per essere utilizzate in diversi controller o essere ridistribuite come estensioni.\n\n\nAzioni in linea (inline)\n\n\nI nomi dei metodi di azione sono derivati dal proprio ID secondo la seguente procedura:\n1. Ruotare la prima lettera in ogni parola dell'ID dell'azione in caso di maiuscolo.\n2. Rimuovere i trattini.\n3. Usare il prefisso \naction\n.\n\n\nAd esempio \nindex\n diventa \nactonIndex\n e \nhello-world\n diventa \nactionHelloWorld\n.\n\n\n\n\nWarning\n\n\nI nomi dei metodi d'azione sono sensibili alla distinzione tra minuscole e maiuscole. Se si dispone di un metodo denominato \nActionIndex\n, non verr\u00e0 considerato come un metodo di azione e pertanto la richiesta per l'azione \nindex\n provocher\u00e0 un'eccezione. Si noti inoltre che i metodi d'azione devono essere pubblici. Un metodo provato o privato \nNON\n definisce un'azione in linea.\n\n\n\n\nAzioni autonome (standalone)\n\n\nPer utilizzare un'azione autonoma, devi dichiararla nella mappa d'azione prevenendo il metodo \n yii \\ base \\ Controller :: actions() \n nelle classi di controllo, come nel seguente esempio:\n\n\npublic function actions(){\n\n    return [\n        // declares \"error\" action using a class name\n        'error' =\n 'yii\\web\\ErrorAction',\n\n        // declares \"view\" action using a configuration array\n        'view' =\n [\n            'class' =\n 'yii\\web\\ViewAction',\n            'viewPrefix' =\n '',\n        ],\n    ];\n}\n\n\n\nCome si pu\u00f2 vedere, il metodo \nactions()\n dovrebbe restituire un array dove i valori sono l'ID delle azioni e il loro nome. A differenza delle azioni in linea, gli ID di azione per azioni autonome possono contenere caratteri arbitrari, a condizione che siano dichiarati nel metodo \nactions()\n.\n\n\nPer creare una classe di azioni autonome, \u00e8 necessario estendere \n yii \\ base \\ Action \n o una sua classe figlia, e implementare un metodo denominato \nrun()\n.\n\n\n?php\nnamespace app\\components;\n\nuse yii\\base\\Action;\n\nclass HelloWorldAction extends Action{\n\n    public function run(){\n\n        return \"Hello World\";\n    }\n}\n\n\n\nRisultati dell'azione\n\n\nIl valore restituito da un metodo di azione ( o del metodo \nrun()\n) \u00e8 molto significativo. Questo valore pu\u00f2 essere un oggetto di risposta che verr\u00e0 inviato all'utente finale come risposta.\n\n\n\n\nPer applicazioni Web, il valore di ritorno pu\u00f2 essere anche un dato arbitrario che verr\u00e0 assegnato ai dati di \n yii \\ web \\ Response :: $ \n e deve essere ulteriormente convertito in una stringa che rappresenta il corpo della risposta.\n\n\nPer le applicazioni tramite console, il valore di ritorno pu\u00f2 anche essere un intero che rappresenta lo stato di uscita dell'esecuzione del comando.\n\n\n\n\nNegli esempi mostrati sopra, i risultati dell'azione sono tutte stringhe che saranno trattate come il corpo di risposta da inviare all'utente finale.\nIl seguente esempio vi mostra come un'azione pu\u00f2 reindirizzare il browser a un nuovo URL restituendo un oggetto di risposta ( perch\u00e8 il metodo \nredirect()\n restituisce un oggetto in risposta).\n\n\npublic function actionForward(){\n\n    // redirect the user browser to http://example.com\n    return $this-\nredirect('http://example.com');\n}\n\n\n\nParametri dell'azione\n\n\nI metodi di azione delle azioni in linea, dei metodi \nrun()\n, e per le azioni autonome possono assumere parametri, chiamati \n parametri d'azione \n. I loro valori sono ottenuti dalle richieste che vengono effettuate. Per le applicazioni Web, viene richiamato il valore di ogni parametro d'azione\n$_GET\n pi\u00f9 il nome del parametro come chiave, mentre per le applicazioni tramite console, questi parametri corrispondono agli argomenti della riga di comando.\n\n\nNell'esempio seguente, l'azione \nview\n ( azione in linea ) ha dichiarato due parametri: \n$id\n e \n$version\n.\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    public function actionView($id, $version = null){\n\n        // ...\n    }\n}\n\n\n\nI parametri della nostra azione saranno popolati come segue per le possibili richieste che possiamo effettuare:\n- \nhttp://hostname/index.php?r=post/view\nid=123\n: il parametro \n$id\n verr\u00e0 compilato con il valore \n123\n, mentre \n$version\n \u00e8 ancora \nnull\n perch\u00e8 non esiste alcun parametro di query \nversion\n.\n- \nhttp://hostname/index.php?r=post/view\nid=123\nversion=2\n: I due parametri \n$id\n e \n$version\n sono riempiti con i valori di \n123\n e \n2\n.\n- \nhttp://hostname/index.php?r=post/view\n: viene generata un'eccezione perch\u00e8 il parametro \n$id\n richiesto non \u00e8 fornito nella richiesta.\n- \nhttp://hostname/index.php?r=post/view\nid[]=123\n: verr\u00e0 generata anche qu\u00ec un'eccezione perch\u00e8 il parametro \n$id\n riceve un valore di array inaspettato, come \n['123']\n.\n\n\nSe desideriamo che un parametro di azione possa accettare valori come matrice,array, e necessario distinguerlo come segue:\n\n\npublic function actionView(array $id, $version = null){\n\n    // ...\n}\n\n\n\nOra se la richiesta fosse \nhttp://hostname/index.php?r=post/view\nid[]=123\n, il parametro \n$id\n prender\u00e0 il valore di \n['123']\n. Se la richiesta fosse \nhttp://hostname/index.php?r=post/view\nid=123\n il parametro \n$id\n ricever\u00e0 ancora lo stesso valore dell'array perch\u00e8 il valore scalare \n'123'\n verr\u00e0 auomtaticamente trasformato in array.\nGli esempi precedenti mostrano principalmente come funzionano i parametri d'azione per le applicazioni Web.\n\n\nAzioni predefinite\n\n\nOgni controller ha un'azione predefinita specificata tramite la propriet\u00e0 \n yii \\ base \\ Controller :: $defaultAction \n. Quando un percorso contiene solo il controller ID, significa che viene richiesta l'azione predefinita del controller specificato.\nPer impostazione predefinita, questa azione \u00e8 impostata come \nindex\n. Se si desidera modificare il valore predefinito, vi baster\u00e0 sovrascrivere questa propriet\u00e0 nella classe controller, come segue nell'esempio:\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public $defaultAction = 'home';\n\n    public function actionHome(){\n\n        return $this-\nrender('home');\n    }\n}\n\n\n\nCiclo di vita del controllore\n\n\nQuando si elabora una richiesta, un'applicazione creer\u00e0 un controller di base al percorso richiesto. Il controllore sar\u00e0 sottoposto al seguente ciclo di vita per soddisfare la richiesta:\n\n\n\n\nIl metodo \n yii \\ base \\ Controller :: init() \n viene chiamato dopo che il controller viene creato e configurato.\n\n\nIl controller crea un oggetto di azione in base all'ID dell'azione richiesta:\n\n\nSe l'ID dell'azione non \u00e8 specificato, verr\u00e0 utilizzato l'ID dell'azione predefinita.\n\n\nSe l'ID dell'azione si trova nella mappa d'azione, verr\u00e0 creata un'azione autonoma.\n\n\nSe l'ID dell'azione \u00e8 il risultato corrispondente a un metodo d'azione, verr\u00e0 creata una nuova azione in linea;\n\n\nIn caso contrario verr\u00e0 generata un'eccezione.\n\n\n\n\n\n\nIl controllore chiama sequenzialmente il metodo \nbeforeAction()\n  dell'applicazione.\n\n\nSe una delle chiamate restituisce \nfalse\n, il resto dei metodi \nbeforeAction()\n non chiamati verranno ignorati e l'esecuzione dell'azione verr\u00e0 annullata.\n\n\nPer impostazione predefinita, ogni chiamata del metodo \nbeforeAction()\n innescher\u00e0 un evento \nbeforeAction\n a cui \u00e8 possibile associare un gestore.\n\n\n\n\n\n\nIl controllore esegue l'azione.\n\n\nI parametri dell'azione saranno analizzati e popolati dai dati di richiesta.\n\n\n\n\n\n\nIl controllore chiama sequenzialmente il metodo del controller \nafterAction()\n.\n\n\nPer impostazione predefinita, ogni chiamata del metodo \nafterAction()\n innescher\u00e0 un evento \nafterAction\n a cui \u00e8 possibile associare un gestore.\n\n\n\n\n\n\nL'applicazione prender\u00e0 il risultato dell'azione e lo assegner\u00e0 alla risposta.",
            "title": "Controllori"
        },
        {
            "location": "/application-structure/sub-controllers/#controllori-controllers",
            "text": "I controllori(controller) sono parte dell'architettura MVC. Sono oggetti di classi che si estendono da  yii \\ base \\ Controller  e sono responsabili delle richieste di elaborazione e della generazione di risposte. In particolare, dopo aver assunto il controllo delle applicazioni, i controller analizzeranno i dati ricevuti dalla richieste in entrata, li passano ai modelli, iniettano i risultati dei modelli nelle viste(view) e, infine, generano risposte in uscita.",
            "title": "Controllori  (Controllers)"
        },
        {
            "location": "/application-structure/sub-controllers/#azioni",
            "text": "I controller sono composti da azioni che sono le unit\u00e0 pi\u00f9 semplici che gli utenti finali possono richiederne l'esecuzione. Un controller pu\u00f2 avere una o pi\u00f9 azioni.\nL'esempio seguente mostra un controller  post  con due azioni: azione di vista (  view ) e azione di creazione (  create ):  namespace app\\controllers;\n\nuse Yii;\nuse app\\models\\Post;\nuse yii\\web\\Controller;\nuse yii\\web\\NotFoundHttpException;\n\nclass PostController extends Controller{\n    public function actionView($id){\n        $model = Post::findOne($id);\n        if ($model === null) {\n            throw new NotFoundHttpException;\n        }\n\n        return $this- render('view', [\n            'model' =  $model,\n        ]);\n    }\n\n    public function actionCreate(){\n        $model = new Post;\n\n        if ($model- load(Yii::$app- request- post())   $model- save()) {\n            return $this- redirect(['view', 'id' =  $model- id]);\n        } else {\n            return $this- render('create', [\n                'model' =  $model,\n            ]);\n        }\n    }\n}  Nell'azione di vista( definita dal metodo  actionView() ),carica il modello secondo l'ID del modello richiesto. Se il modello viene caricato correttamente, lo visualizzer\u00e0 utilizzando un vista denominata  view . Altrimenti verr\u00e0 lanciata un'eccezione.  Nell'azione di creazione( definita dal metodo  actionCreate() ), carica il modello secondo l'ID del modello richiesto. In primo luogo cerca di popolare una nuova istanza del modello utilizzando i dati di richiesta e salvarli all'interno del modello. Se entrambe le azioni avvengono con successo, reindirizzer\u00e0 il browser all'azione  view  con l'ID del modello appena creato. Altrimenti verr\u00e0 visualizzata la vista di creazione ( create ) attraverso la quale gli utenti possono fornire l'input necessario.",
            "title": "Azioni"
        },
        {
            "location": "/application-structure/sub-controllers/#itinerari",
            "text": "Gli utenti finali gestiscono le azioni attraverso i percorsi. Un percorso \u00e8 una stringa che consiste nelle seguenti parti:   un modulo ID: questo esiste solo se il controller appartiene a un modulo non applicativo;  un controller ID: una stringa che identifica in modo univoco il controller tra tutti i controller della stessa applicazione;  un ID d'azione: una stringa che identifica in modo univoco l'azione tra tutte le azioni all'interno dello stesso controller.   I percorsi hanno il seguente formato:  ControllerID/ActionID  oppure il seguente formato se il controller appartiene a un modulo:  ModuleID/ControllerID/ActionID  Quindi, se un utente possa richiedere il seguente URL (http://hostname/index.php?r=site/index), verr\u00e0 eseguita l'azione di  index  nel controller del  site .",
            "title": "Itinerari"
        },
        {
            "location": "/application-structure/sub-controllers/#creazione-di-un-controller",
            "text": "Nelle applicazioni Web, i controller devono estendere  yii \\ web \\ Controller . Analogamente nelle applicazioni console,i controller devono estendersi da  yii \\ web \\ Controller . Il seguente codice definisce un controller  site .  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n}  Di solito, un controllore \u00e8 progettato per gestire le richieste relative a un particolare tipo di risorsa. Per questo motivo, gli ID controller sono spesso nomi che si riferiscono ai tipi delle risorse che gestiscono. Ad esempio, \u00e8 possibile utilizzare  article  come ID di un controller che gestisce i dati dell'articolo.  Per impostazione predefinita, gli ID controller devono contenere solo questi caratteri: lettere minuscole, cifre, sottolineature, trattini e barre in avanti. Ad esempio,  article  e  post-comment  sono entrambi ID controller validi, mentre  article? , PostComment , admin\\post  non lo sono.  Un ID controller pu\u00f2 anche contenere un prefisso della sotto-directory. Ad esempio,  admin/article  sta per un controller  article  nella sotto-directory  admin  sotto lo spazio dei nomi del controller. I caratteri validi per i prefissi della sotto-directory includono: lettere maiuscole o minuscole, cifre, sottolineature, trattini, ect.",
            "title": "Creazione di un controller"
        },
        {
            "location": "/application-structure/sub-controllers/#nome-del-codice-dei-controller",
            "text": "I nomi delle classi di controller possono essere derivati da un ID controller secondo la seguente procedura:   ruotare la prima lettera in ogni parola separata da trattini in maiuscolo. Notare che se l'ID del controller contiene barre di scorrimento, questa regola si applica solo alla parte dopo l'ultima barra dell'ID;  rimuovere i trattini e sostituire gli \"slash\" con i \"backslash\".  aggiungi il suffisso  Controller .  prendere il namespace del controller.   Di seguito sono riportati alcuni esempi, supponendo che i namespace dei controller prendano il valore predefinito  app\\controllers :   article  diventa  app\\controllers\\ArticleController ;  post-comment  diventa  app\\controllers\\PostCommentController ;  admin/post-comment  diventa  app\\controllers\\admin\\PostCommentController ;  adminPanels/post-comment  diventa  app\\controllers\\adminPanels\\PostCommentController .   Le classi del controllore devono essere  autoloadable . Per questo motivo, negli esempi precedenti, la classe controller  article  dovrebbe essere salvata dove lo pseudonimo \u00e8  @app/controllers/ArticleController.php ; mentre il controller  admin/post-comment  dovrebbero essere in  @app/controllers/admin/PostCommentController.php .   Info  L'ultimo esempio  admin/post-comment  mostra come \u00e8 possibile inserire un controller sotto una sotto-directory del namespace del controller. Questo \u00e8 utile quando si desidera organizzare i controller in pi\u00f9 categorie e non si desidera utilizzare i moduli.",
            "title": "Nome del codice dei controller"
        },
        {
            "location": "/application-structure/sub-controllers/#mappa-dei-controller",
            "text": "E' possibile configurare la mappa del controller per superare i vincoli degli ID del controller e dei nomi di classe descritti in precedenza. Ci\u00f2 \u00e8 principalmente utile quando si utilizzano controllori di terze parti e non si ha il controllo sui nomi delle classi.\nE' possibile configurare la mappa dei controller nella configurazione dell'applicazione.  Esempio:  [\n    'controllerMap' =  [\n        // declares \"account\" controller using a class name\n        'account' =  'app\\controllers\\UserController',\n\n        // declares \"article\" controller using a configuration array\n        'article' =  [\n            'class' =  'app\\controllers\\PostController',\n            'enableCsrfValidation' =  false,\n        ],\n    ],\n]",
            "title": "Mappa dei controller"
        },
        {
            "location": "/application-structure/sub-controllers/#controller-di-default",
            "text": "Ogni applicazione dispone di un controller predefinito specificato tramite la propriet\u00e0  yii \\ base \\ Application :: $ defaultRoute . Quando una richiesta non specifica un percorso, verr\u00e0 utilizzato il percorso specificato da questa propriet\u00e0. Per le applicazioni Web, il suo valore \u00e8  site , mentre per le applicazioni tramite console \u00e8  help .\nE' possibile modificare il controller di default con la seguente configurazione dell'applicazione:  [\n    'defaultRoute' =  'main',\n]",
            "title": "Controller di default"
        },
        {
            "location": "/application-structure/sub-controllers/#creazione-delle-azioni",
            "text": "La creazione delle azioni \u00e8 semplice, come definite i cosiddetti \"metodi di azione\" in una classe controller. Un metodo di azione \u00e8 un metodo \"pubblico\" il nome inizia con un  action . Il valore restituito da un metodo di azione rappresenta i dati di risposta che dovranno essere inviati poi all'utente finale. Il seguente codice definisce due azioni: l'azione  index  e l'azione  hello-world :  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public function actionIndex(){\n\n        return $this- render('index');\n\n    }\n    public function actionHelloWorld(){\n\n        return 'Hello World';\n\n    }\n}",
            "title": "Creazione delle azioni"
        },
        {
            "location": "/application-structure/sub-controllers/#id-dellazione",
            "text": "Un'azione \u00e8 spesso progettata per eseguire una particolare manipolazione di una risorsa. Per questo motivo, gli ID dell'azione sono solitamente verbi ( come per esempio  view ,  update , ect..).  Per impostazione predefinita, l'ID dell'azione deve contenere solo questi caratteri: lettere minuscole,cifre,sottolineature,e trattini. Ad esempio,  view , update2 , e  comment-post  sono tutti ID di azioni valide, mentre  view?  e  Update  non lo sono.  E' possibile creare azioni in due modi: azioni in linea e azioni autonome. Un'azione inline \u00e8 definita come un metodo della classe controller, mentre un'azione autonoma \u00e8 una classe che estende   yii \\ base \\ Action   o le sue classi figlio. Le azioni in linea sono pi\u00f9 veloci e semplici da creare e sono spesso preferite se non si intende riutilizzarle. Le azioni autonome invece sono principalmente create per essere utilizzate in diversi controller o essere ridistribuite come estensioni.",
            "title": "ID dell'azione"
        },
        {
            "location": "/application-structure/sub-controllers/#azioni-in-linea-inline",
            "text": "I nomi dei metodi di azione sono derivati dal proprio ID secondo la seguente procedura:\n1. Ruotare la prima lettera in ogni parola dell'ID dell'azione in caso di maiuscolo.\n2. Rimuovere i trattini.\n3. Usare il prefisso  action .  Ad esempio  index  diventa  actonIndex  e  hello-world  diventa  actionHelloWorld .   Warning  I nomi dei metodi d'azione sono sensibili alla distinzione tra minuscole e maiuscole. Se si dispone di un metodo denominato  ActionIndex , non verr\u00e0 considerato come un metodo di azione e pertanto la richiesta per l'azione  index  provocher\u00e0 un'eccezione. Si noti inoltre che i metodi d'azione devono essere pubblici. Un metodo provato o privato  NON  definisce un'azione in linea.",
            "title": "Azioni in linea (inline)"
        },
        {
            "location": "/application-structure/sub-controllers/#azioni-autonome-standalone",
            "text": "Per utilizzare un'azione autonoma, devi dichiararla nella mappa d'azione prevenendo il metodo   yii \\ base \\ Controller :: actions()   nelle classi di controllo, come nel seguente esempio:  public function actions(){\n\n    return [\n        // declares \"error\" action using a class name\n        'error' =  'yii\\web\\ErrorAction',\n\n        // declares \"view\" action using a configuration array\n        'view' =  [\n            'class' =  'yii\\web\\ViewAction',\n            'viewPrefix' =  '',\n        ],\n    ];\n}  Come si pu\u00f2 vedere, il metodo  actions()  dovrebbe restituire un array dove i valori sono l'ID delle azioni e il loro nome. A differenza delle azioni in linea, gli ID di azione per azioni autonome possono contenere caratteri arbitrari, a condizione che siano dichiarati nel metodo  actions() .  Per creare una classe di azioni autonome, \u00e8 necessario estendere   yii \\ base \\ Action   o una sua classe figlia, e implementare un metodo denominato  run() .  ?php\nnamespace app\\components;\n\nuse yii\\base\\Action;\n\nclass HelloWorldAction extends Action{\n\n    public function run(){\n\n        return \"Hello World\";\n    }\n}",
            "title": "Azioni autonome (standalone)"
        },
        {
            "location": "/application-structure/sub-controllers/#risultati-dellazione",
            "text": "Il valore restituito da un metodo di azione ( o del metodo  run() ) \u00e8 molto significativo. Questo valore pu\u00f2 essere un oggetto di risposta che verr\u00e0 inviato all'utente finale come risposta.   Per applicazioni Web, il valore di ritorno pu\u00f2 essere anche un dato arbitrario che verr\u00e0 assegnato ai dati di   yii \\ web \\ Response :: $   e deve essere ulteriormente convertito in una stringa che rappresenta il corpo della risposta.  Per le applicazioni tramite console, il valore di ritorno pu\u00f2 anche essere un intero che rappresenta lo stato di uscita dell'esecuzione del comando.   Negli esempi mostrati sopra, i risultati dell'azione sono tutte stringhe che saranno trattate come il corpo di risposta da inviare all'utente finale.\nIl seguente esempio vi mostra come un'azione pu\u00f2 reindirizzare il browser a un nuovo URL restituendo un oggetto di risposta ( perch\u00e8 il metodo  redirect()  restituisce un oggetto in risposta).  public function actionForward(){\n\n    // redirect the user browser to http://example.com\n    return $this- redirect('http://example.com');\n}",
            "title": "Risultati dell'azione"
        },
        {
            "location": "/application-structure/sub-controllers/#parametri-dellazione",
            "text": "I metodi di azione delle azioni in linea, dei metodi  run() , e per le azioni autonome possono assumere parametri, chiamati   parametri d'azione  . I loro valori sono ottenuti dalle richieste che vengono effettuate. Per le applicazioni Web, viene richiamato il valore di ogni parametro d'azione $_GET  pi\u00f9 il nome del parametro come chiave, mentre per le applicazioni tramite console, questi parametri corrispondono agli argomenti della riga di comando.  Nell'esempio seguente, l'azione  view  ( azione in linea ) ha dichiarato due parametri:  $id  e  $version .  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    public function actionView($id, $version = null){\n\n        // ...\n    }\n}  I parametri della nostra azione saranno popolati come segue per le possibili richieste che possiamo effettuare:\n-  http://hostname/index.php?r=post/view id=123 : il parametro  $id  verr\u00e0 compilato con il valore  123 , mentre  $version  \u00e8 ancora  null  perch\u00e8 non esiste alcun parametro di query  version .\n-  http://hostname/index.php?r=post/view id=123 version=2 : I due parametri  $id  e  $version  sono riempiti con i valori di  123  e  2 .\n-  http://hostname/index.php?r=post/view : viene generata un'eccezione perch\u00e8 il parametro  $id  richiesto non \u00e8 fornito nella richiesta.\n-  http://hostname/index.php?r=post/view id[]=123 : verr\u00e0 generata anche qu\u00ec un'eccezione perch\u00e8 il parametro  $id  riceve un valore di array inaspettato, come  ['123'] .  Se desideriamo che un parametro di azione possa accettare valori come matrice,array, e necessario distinguerlo come segue:  public function actionView(array $id, $version = null){\n\n    // ...\n}  Ora se la richiesta fosse  http://hostname/index.php?r=post/view id[]=123 , il parametro  $id  prender\u00e0 il valore di  ['123'] . Se la richiesta fosse  http://hostname/index.php?r=post/view id=123  il parametro  $id  ricever\u00e0 ancora lo stesso valore dell'array perch\u00e8 il valore scalare  '123'  verr\u00e0 auomtaticamente trasformato in array.\nGli esempi precedenti mostrano principalmente come funzionano i parametri d'azione per le applicazioni Web.",
            "title": "Parametri dell'azione"
        },
        {
            "location": "/application-structure/sub-controllers/#azioni-predefinite",
            "text": "Ogni controller ha un'azione predefinita specificata tramite la propriet\u00e0   yii \\ base \\ Controller :: $defaultAction  . Quando un percorso contiene solo il controller ID, significa che viene richiesta l'azione predefinita del controller specificato.\nPer impostazione predefinita, questa azione \u00e8 impostata come  index . Se si desidera modificare il valore predefinito, vi baster\u00e0 sovrascrivere questa propriet\u00e0 nella classe controller, come segue nell'esempio:  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public $defaultAction = 'home';\n\n    public function actionHome(){\n\n        return $this- render('home');\n    }\n}",
            "title": "Azioni predefinite"
        },
        {
            "location": "/application-structure/sub-controllers/#ciclo-di-vita-del-controllore",
            "text": "Quando si elabora una richiesta, un'applicazione creer\u00e0 un controller di base al percorso richiesto. Il controllore sar\u00e0 sottoposto al seguente ciclo di vita per soddisfare la richiesta:   Il metodo   yii \\ base \\ Controller :: init()   viene chiamato dopo che il controller viene creato e configurato.  Il controller crea un oggetto di azione in base all'ID dell'azione richiesta:  Se l'ID dell'azione non \u00e8 specificato, verr\u00e0 utilizzato l'ID dell'azione predefinita.  Se l'ID dell'azione si trova nella mappa d'azione, verr\u00e0 creata un'azione autonoma.  Se l'ID dell'azione \u00e8 il risultato corrispondente a un metodo d'azione, verr\u00e0 creata una nuova azione in linea;  In caso contrario verr\u00e0 generata un'eccezione.    Il controllore chiama sequenzialmente il metodo  beforeAction()   dell'applicazione.  Se una delle chiamate restituisce  false , il resto dei metodi  beforeAction()  non chiamati verranno ignorati e l'esecuzione dell'azione verr\u00e0 annullata.  Per impostazione predefinita, ogni chiamata del metodo  beforeAction()  innescher\u00e0 un evento  beforeAction  a cui \u00e8 possibile associare un gestore.    Il controllore esegue l'azione.  I parametri dell'azione saranno analizzati e popolati dai dati di richiesta.    Il controllore chiama sequenzialmente il metodo del controller  afterAction() .  Per impostazione predefinita, ogni chiamata del metodo  afterAction()  innescher\u00e0 un evento  afterAction  a cui \u00e8 possibile associare un gestore.    L'applicazione prender\u00e0 il risultato dell'azione e lo assegner\u00e0 alla risposta.",
            "title": "Ciclo di vita del controllore"
        },
        {
            "location": "/application-structure/sub-models/",
            "text": "Modelli  (Models)\n\n\nI modelli sono parte dell'architettura MVC. Sono oggetti che rappresentano dati aziendali, regole e logica dell'applicazione. \n\n\nE' possibile creare classi model estendendo \n yii \\ base \\ Model \n o le sue classi figlio. Questa classe supporta molte funzioni utili:\n\n\n\n\nAttributi\n: rappresentano i dati aziendali ed \u00e8 possibile accedervi come propriet\u00e0 di oggetti normali;\n\n\nEtichette di attributi\n: permette di specificare le etichette di visualizzazione per gli attributi;\n\n\nAssegnazione massiva\n: supporta la popolazione di attributi multipli in un solo passsaggio;\n\n\nRegole di convalida\n: assicura che i dati di input vadano bene in base alle regole di convalida dichiarate;\n\n\nEsportazione dei dati\n: consente di esportare i dati del modello in termini di matrici con formati personalizzabili.\n\n\n\n\nLa classe \nModel\n \u00e8 anche la classe base per i modelli pi\u00f9 avanzati, ad esempio \n Active Record \n.\n\n\nAttributi\n\n\nOgni attributo \u00e8 come una propriet\u00e0 accessibile a livello pubblico di un modello. Il metodo \n yii \\ base \\ Model :: attributes() \n specifica quali attributi ha una classe modello.\n\n\nE' possibile accedere a un attributo come l'accesso a una propriet\u00e0 di oggetto normale: \n\n\nEsempio:\n\n\n$model = new \\app\\models\\ContactForm;\n\n// \"name\" is an attribute of ContactForm\n$model-\nname = 'example';\necho $model-\nname;\n\n\n\nE' inoltre possibile accedere agli attributi come l'accesso agli elementi dell'array, grazie al supporto per \n ArrayAccess \n e  Traversable ***.\n\n\n$model = new \\app\\models\\ContactForm;\n\n// accessing attributes like array elements\n$model['name'] = 'example';\necho $model['name'];\n\n// Model is traversable using foreach.\nforeach ($model as $name =\n $value) {\n    echo \"$name: $value\\n\";\n}\n\n\n\nDefinizione degli attributi\n\n\nPer impostazione predefinita, se la classe del modello si estende direttamente da \n yii \\ base \\ Model \n, tutte le sue variabili non statiche di membro pubblico sono attributi. Ad esempio, la classe del modello \nContactForm\n sotto ha quattro attributi: \nname\n, \nemail\n, \nsubject\n e \nbody\n. Il modello \nContactForm\n viene utilizzato per rappresentare i dati di input ricevuti da un modulo HTML.\n\n\nnamespace app\\models;\n\nuse yii\\base\\Model;\n\nclass ContactForm extends Model{\n\n    public $name;\n    public $email;\n    public $subject;\n    public $body;\n}\n\n\n\nEtichette di attributi\n\n\nQuando si visualizzano valori o otteniamo input per gli attributi, spesso \u00e8 necessario visualizzare alcune etichette associate agli attributi. Ad esempio, dato un attributo denominato, \nfirstName\n, e possibile visualizzare un'etichetta \nFirst Name\n che sia pi\u00f9 facile da usare quando viene visualizzata per mandare all'utente messaggi di errore oppure etichette di input.\n\n\nE' possibile ottenere l'etichetta di un attributo chiamando \n yii \\ base \\ Model :: getAttributeLabel() \n. Per esempio:\n\n\n$model = new \\app\\models\\ContactForm;\n\n// displays \"Name\"\necho $model-\ngetAttributeLabel('name');\n\n\n\nPer impostazione predefinita, le etichette degli attributi vengono generate automaticamente da nomi degli attributi. La generazione viene fatta con il metodo \n yii \\ base \\ Model :: generateAttributeLabel() \n. Alcuni esempi: \nusername\n diventa \nUsername\n, \nfirstName\n diventa \nFirst Name\n.\n\n\nSe non si desidare utilizzare etichette generate automaticamente, \u00e8 possibile ignorare \n yii \\ base \\ Model :: attributeLabels() \n per dichiarare esplicitamente le etichette degli attributi.\n\n\nEsempio:\n\n\nnamespace app\\models;\n\nuse yii\\base\\Model;\n\nclass ContactForm extends Model{\n\n    public $name;\n    public $email;\n    public $subject;\n    public $body;\n\n    public function attributeLabels(){\n\n        return [\n            'name' =\n 'Your name',\n            'email' =\n 'Your email address',\n            'subject' =\n 'Subject',\n            'body' =\n 'Content',\n        ];\n    }\n}\n\n\n\nPer le applicazioni che supportano pi\u00f9 lingue, \u00e8 possibile tradurre le etichette degli attributi. Questo pu\u00f2 essere fatto anche all'interno del metodo \nattributeLabels()\n, come nel seguente esempio:\n\n\npublic function attributeLabels(){\n\n    return [\n        'name' =\n \\Yii::t('app', 'Your name'),\n        'email' =\n \\Yii::t('app', 'Your email address'),\n        'subject' =\n \\Yii::t('app', 'Subject'),\n        'body' =\n \\Yii::t('app', 'Content'),\n    ];\n}\n\n\n\nE' possibile definire anche etichette degli attributi. Ad esempio, in base allo scenario in cui \u00e8 stato utilizzato il modello, \u00e8 possibile restituire diverse etichette per lo stesso attributo\n\n\n\n\nNote\n\n\nLe etichette degli attributi fanno parte delle stesse view(viste). Ma la dichiarazione di etichette nei modelli \u00e8 spesso molto conveniente ed \u00e8 molto comodo per avere un codice pi\u00f9 pulito e riutilizzabile.\n\n\n\n\nScenari\n\n\nUn modello pu\u00e0 essere utilizzato in diversi scenari. Ad esempio, un modello \nUser\n pu\u00f2 essere utilizzato per raccogliere gli ingressi di login utente, ma pu\u00f2 essere utilizzato anche per la registrazione di utenti. In diversi scenari, un modello pu\u00f2 utilizzare regole e logiche differenti. Ad esempio, l'attributo \nemail\n pu\u00f2 essere richiesto sia durante la registrazione degli utenti, ma non \u00e8 cos\u00ec durante la fase di login.\n\n\nUn modello utilizza la propriet\u00e0 \n scenario yii \\ base \\ Model :: \n per tenere traccia dello scenario in cui viene utilizzato. Per impostazione predefinita, un modello supporta solo un singolo scenario denominato \ndefault\n. Il seguente codice mostra due modi per impostare lo scenario di un modello:\n\n\n// scenario is set as a property\n$model = new User;\n$model-\nscenario = User::SCENARIO_LOGIN;\n\n// scenario is set through configuration\n$model = new User(['scenario' =\n User::SCENARIO_LOGIN]);\n\n\n\nPer impostazione predefinita, gli scenari supportati da un modello sono determinati dalle regole di convalida dichiarate nel modello. Tuttavia, \u00e8 possivile personalizzare questo comportamento prevenendo il meodo \n yii \\ base \\ Model :: scenari() \n, ad esempio:\n\n\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass User extends ActiveRecord{\n\n    const SCENARIO_LOGIN = 'login';\n    const SCENARIO_REGISTER = 'register';\n\n    public function scenarios(){\n\n        return [\n            self::SCENARIO_LOGIN =\n ['username', 'password'],\n            self::SCENARIO_REGISTER =\n ['username', 'email', 'password'],\n        ];\n    }\n}\n\n\n\nIl metodo \nscenarios()\n restituisce un array le cui chiavi sono i nomi di scenari e valori relativi agli attributi attivi. Un attributo attivo pu\u00f2 essere assegnato massicciamente e soggetto alla convalida. Nell'esempio precedente, gli attributi \nusername\n e \npassword\n sono attivi nello scenario \nlogin\n; mentre nello scenario \nregister\n, \nemail\n\u00e8 lo stesso attivo oltre a \nusername\n e \npassword\n.\n\n\nL'implementazione predefinita \nscenarios()\nrestituira tutti gli scenari trovati nel metodo di dichiarazione della regola valid \n yii \\ base \\ Model :: rules() \n. Quando si sceglie \nscenarios()\n, se si desidare introdurre nuovi scenari in aggiunta a quelli predefiniti, \u00e8 possibile scrivere un codice come segue:\n\n\nnamespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass User extends ActiveRecord{\n\n    const SCENARIO_LOGIN = 'login';\n    const SCENARIO_REGISTER = 'register';\n\n    public function scenarios(){\n\n        $scenarios = parent::scenarios();\n        $scenarios[self::SCENARIO_LOGIN] = ['username', 'password'];\n        $scenarios[self::SCENARIO_REGISTER] = ['username', 'email', 'password'];\n        return $scenarios;\n    }\n}\n\n\n\nRegole di convalida\n\n\nQuando i dati di un modello vengono ricevuti dagli utenti finali, deve essere convalidati per assicrarsi che soddisfino determinate regole ( chiamate \n regole di convalida \n). Ad esempio, dato un modello \nContactForm\n, \u00e8 possibile assicurarsi che tutti gli attributi non siano vuoti e che l'attributo \nemail\n contenga un indirizzo email valido. Se i valori di alcuni attributi non soddisfano le regole corrispondenti, \u00e8 necessario visualizzare i messaggi di errore appropriati per aiutare l'utente a correggere gli errori.\n\n\nPuoi chiamare il metodo \nyii \\ base \\ Model :: validate()\n per convalidare i dati ricevuti. Il metodo utilizzer\u00e0 le regole di convalida dichiarate all'interno del nostro modello. Se non viene trovato alcun errore, esso restituir\u00e0 \ntrue\n. In caso contrario, manterr\u00e0 gli errori nella propriet\u00e0 \n yii \\ base \\ Model :: errors \n e restituir\u00e0 \nfalse\n. Per esempio:\n\n\n$model = new \\app\\models\\ContactForm;\n\n// populate model attributes with user inputs\n$model-\nattributes = \\Yii::$app-\nrequest-\npost('ContactForm');\n\nif ($model-\nvalidate()) {\n    // all inputs are valid\n} else {\n    // validation failed: $errors is an array containing error messages\n    $errors = $model-\nerrors;\n}\n\n\n\nPer dichiarare regole di convalida associate a un modello, dovete aggiungere il metodo \n yii \\ base \\ Model :: rules() \n restituendo le regole che gli attributi del modello devono soddisfare. L'esempio seguente mostra le regole di convalida dichiarate per il modello \nContactForm\n:\n\n\npublic function rules(){\n\n    return [\n        // the name, email, subject and body attributes are required\n        [['name', 'email', 'subject', 'body'], 'required'],\n\n        // the email attribute should be a valid email address\n        ['email', 'email'],\n    ];\n}\n\n\n\nUna regola pu\u00f2 essere utilizzata per convalidare uno o pi\u00f9 attributi, e un attributo pu\u00f2 essere convalidato da una o pi\u00f9 regole.\nA volte, \u00e8 possibile che una regola venga applicata solo in alcuni scenari. A tal fine, \u00e8 possibile specificare la propriet\u00e0 \non\n ad una regola.\n\n\nEsempio:\n\n\npublic function rules(){\n\n    return [\n        // username, email and password are all required in \"register\" scenario\n        [['username', 'email', 'password'], 'required', 'on' =\n self::SCENARIO_REGISTER],\n\n        // username and password are required in \"login\" scenario\n        [['username', 'password'], 'required', 'on' =\n self::SCENARIO_LOGIN],\n    ];\n}\n\n\n\nSe non si specifica la propriet\u00e0 \non\n, questa regola verr\u00e0 applicata in tutti gli scenari. Una regola, viene definita \n attiva \n se pu\u00f2 essere applicata nello scenario del modello corrente.\n\n\nUn attributo verr\u00e0 convalidato se e solo se \u00e8 un attributo attivo dichiarato nel metodo \nscenarios()\n e associato a una o pi\u00f9 regole attive dichiarate nel metodo \nrules()\n.\n\n\nAssegnazione massiva\n\n\nL'assegnazione massiva \u00e8 un modo conveniente per popolare un modello con gli ingressi utente utilizzando una sola riga di codice. Consente di popolare gli attributi di un modello  assegnando i dati di input direttamente alla propriet\u00e0 del nostro modulo. Le seguenti due righe di codice sono equivalenti, entrambi associano i dati del modulo inviati dagli utenti finali agli attributi del modello \nContactForm\n. Chiaramente, il primo, \u00e8 pi\u00f9 pulito e meno erroneo del secondo:\n\n\n$model = new \\app\\models\\ContactForm;\n$model-\nattributes = \\Yii::$app-\nrequest-\npost('ContactForm');\n\n$model = new \\app\\models\\ContactForm;\n$data = \\Yii::$app-\nrequest-\npost('ContactForm', []);\n$model-\nname = isset($data['name']) ? $data['name'] : null;\n$model-\nemail = isset($data['email']) ? $data['email'] : null;\n$model-\nsubject = isset($data['subject']) ? $data['subject'] : null;\n$model-\nbody = isset($data['body']) ? $data['body'] : null;\n\n\n\nAttributi sicuri\n\n\nL'assegnazione massiva si applica solo ai cosiddetti  \n attributi sicuri \n che sono gli attributi elencati negli scenari del modello corrente. Ad esempio, se il modello \nUser\n ha la seguente dichiarazione di scenari, allora quando lo scenario corrente \u00e8 \nlogin\n, solo l'\nusername\n e \npassword\n pu\u00f2 essere assegnato massivamente. Qualsiasi altro attributo sar\u00e0 mantenuto intatto.\n\n\npublic function scenarios(){\n\n    return [\n        self::SCENARIO_LOGIN =\n ['username', 'password'],\n        self::SCENARIO_REGISTER =\n ['username', 'email', 'password'],\n    ];\n}\n\n\n\n\n\nNote\n\n\nIl motivo per cui l'assegnazione di massa si applica solo agli attributi sicuri, \u00e8 perch\u00e8 si desidera controllare quali attributi possono essere modificati dagli utenti finali. Ad esempio, se il modello \nUser\n dispone di un attributo \npermission\n che determina l'autorizzazione assegnata all'utente, si desidera modificare tale attributo dagli amministratori solo tramite un'interfaccia backend.\n\n\n\n\nPer rendere un attributo sicuro, viene fornito un alias chiamato \nsafe\n. E' un alias di validazione speciale in modo da poter dichiarare un attributo sicuro senza effettuare la convalida. Ad esempio, le seguenti regole dichiarano che sia \ntitle\n che \ndescription\n siano attributi sicuri.\n\n\npublic function rules(){\n\n    return [\n        [['title', 'description'], 'safe'],\n\n    ];\n}\n\n\n\nAttributi non sicuri\n\n\nCome detto in precedenza, il metodo \nscenarios()\n serve per due scopi: determinare quali attributi devono essere convalidati e determinare quali attributi sono sicuri. In alcuni casi rari, si potrebbe desiderare di convalidare un attributo, ma non si desidera contrassegnarlo. Puoi farlo configurando un punto esclamativo \n!\n al nome dell'attributo quando lo dichiari all'interno del metodo \nscenarios()\n, come l'esempio dell'attributo \nsecret\n nel seguente esempio:\n\n\npublic function scenarios(){\n\n    return [\n        self::SCENARIO_LOGIN =\n ['username', 'password', '!secret'],\n\n    ];\n}\n\n\n\nQuando il modello \u00e8 nello scenario \nlogin\n, tutti e tre gli attributi verranno convalidati. Tuttavia, solo gli attributi \nusername\n e \npassword\n possono essere assegnati in modo massivo. Per assegnare un valore di input all'attributo \nsecret\n, dobbiamo farlo in modo esplicito\n\n\n$model-\nsecret = $secret;\n\n\n\nLa stessa cosa pu\u00f2 essere fatta nel metodo \nrules()\n.\n\n\npublic function rules(){\n\n    return [\n        [['username', 'password', '!secret'], 'required', 'on' =\n 'login']\n    ];\n}\n\n\n\nIn questo caso gli attributi \nusername\n, \npassword\n e \nsecret\n sono necessari, ma \nsecret\n deve essere assegnato in modo esplicito.\n\n\nEsportazione dei dati\n\n\nI modelli spesso devono essere esportati in diversi formati. Ad esempio, \u00e8 possibile convertire una raccolta di modeli in formato JSON o Excel. Il processo di esportazione pu\u00f2 essere suddiviso in due fasi indipendenti:\n- i modelli vengono convertiti in array;\n- gli array vengono convertiti in formati di destinazione.\n\n\nPuoi concentrarti solo sul primo passo, perch\u00e8 il secondo pu\u00f2 essere raggiungo da formattatori di dati generici, come \n yii \\ web \\ JsonResponseFormatter \n.\n\n\nIl modo pi\u00f9 semplice per convertire un modello in un array \u00e8 quello di utilizzare la propriet\u00e0 \n yii \\ base \\ Model :: $attributes \n. Per esempio:\n\n\n$post = \\app\\models\\Post::findOne(100);\n$array = $post-\nattributes;\n\n\n\nPer impostazione predefinita, la propriet\u00e0 \nattributes\n restituir\u00e0 i valori di tutti gli attributi dichiarati in \n yii \\ base \\ Model :: () \n.\n\n\nUn modo pi\u00f9 flessibile e potente per convertire un modello in un array \u00e8 quello di utilizzare il metodo \nyii\\ base \\ Model :: to Array()\n. Il suo comportamento predefinito \u00e8 lo stesso di quello del metodo \nattributes\n. Tuttavia, consente di scegliere quali elementi di dati ( chiamati \ncampi\n), bisogna inserire nell'array risultante e come dovrebbero essere formattati.\n\n\nCampi\n\n\nUn campo \u00e8 semplicemente un elemento denominato nell'array ottenuto chiamando il metodo \nyii \\ base \\ Model :: toArray()\n di un modello.\n\n\nPer impostazione predefinita, i nomi dei campi sono equivalenti ai nomi degli attributi. Tuttavia, \u00e8 possibile modificare questo comportamento dichiarando i metodi \nfields()\n e / o \nextraFields()\n. Entrambi i metodi devono restituire un elenco delle definizione dei campi. I campi definiti da \nfields()\n sono campi predefiniti, il che significa che \ntoArray()\n restituir\u00e0 questi campi per impostazione predefinita. Il metodo \nextraFields()\n definisce campi aggiuntivi disponibili che possono anche essere restituiti dal metodo \ntoArray()\n affinch\u00e8 si specifichi tramite il parametro \n$expand\n. Ad esempio, il codice riportato di seguito restituir\u00e0 tutti i campi definiti \nfields()\n e i campi \nprettyName\n e \nfullAddress\n se sono definiti \nextraFields()\n.\n\n\n$array = $model-\ntoArray([], ['prettyName', 'fullAddress']);\n\n\n\nE' possibile ignorare \nfields()\n per aggiungere,rimuovere, rinominare o ridefinire i campi. Il valore restituito dal metodo \n`fields()\n dovr\u00e0 essere un array. I nomi dell'array sono i nomi dei campi e i valori dell'array sono le corrispondenti definizioni dei campi che possono essere nomi di propriet\u00e0/attributi o funzioni anonime che restituiscono i valori del campo corrispondente. Nel caso speciale quando un nome di un campo \u00e8 uguale al suo nome dell'attributo, \u00e8 possibile ignorare il nome dell'array. Per esempio:\n\n\n// explicitly list every field, best used when you want to make sure the changes\n// in your DB table or model attributes do not cause your field changes (to keep API backward compatibility).\npublic function fields(){\n\n    return [\n        // field name is the same as the attribute name\n        'id',\n\n        // field name is \"email\", the corresponding attribute name is \"email_address\"\n        'email' =\n 'email_address',\n\n        // field name is \"name\", its value is defined by a PHP callback\n        'name' =\n function () {\n            return $this-\nfirst_name . ' ' . $this-\nlast_name;\n        },\n    ];\n}\n\n// filter out some fields, best used when you want to inherit the parent implementation\n// and blacklist some sensitive fields.\npublic function fields(){\n\n    $fields = parent::fields();\n\n    // remove fields that contain sensitive information\n    unset($fields['auth_key'], $fields['password_hash'], $fields['password_reset_token']);\n\n    return $fields;\n}\n\n\n\n\n\nWarning\n\n\nPer impostazione predefinita tutti gli attributi di un modello saranno inclusi nell'array esportato, \u00e8 necessario esaminare i dati per assicurarsi di non contenere informazioni sensibili. Se ci sono tali informazioni, dovresti ignorare il metodo \nfields()\n per filtrarli. Nell'esempio sopra, abbiamo scelto di filtrare \nauth_key\n, \npassword_hash\n e \npassword_reset_token\n.",
            "title": "Modelli"
        },
        {
            "location": "/application-structure/sub-models/#modelli-models",
            "text": "I modelli sono parte dell'architettura MVC. Sono oggetti che rappresentano dati aziendali, regole e logica dell'applicazione.   E' possibile creare classi model estendendo   yii \\ base \\ Model   o le sue classi figlio. Questa classe supporta molte funzioni utili:   Attributi : rappresentano i dati aziendali ed \u00e8 possibile accedervi come propriet\u00e0 di oggetti normali;  Etichette di attributi : permette di specificare le etichette di visualizzazione per gli attributi;  Assegnazione massiva : supporta la popolazione di attributi multipli in un solo passsaggio;  Regole di convalida : assicura che i dati di input vadano bene in base alle regole di convalida dichiarate;  Esportazione dei dati : consente di esportare i dati del modello in termini di matrici con formati personalizzabili.   La classe  Model  \u00e8 anche la classe base per i modelli pi\u00f9 avanzati, ad esempio   Active Record  .",
            "title": "Modelli  (Models)"
        },
        {
            "location": "/application-structure/sub-models/#attributi",
            "text": "Ogni attributo \u00e8 come una propriet\u00e0 accessibile a livello pubblico di un modello. Il metodo   yii \\ base \\ Model :: attributes()   specifica quali attributi ha una classe modello.  E' possibile accedere a un attributo come l'accesso a una propriet\u00e0 di oggetto normale:   Esempio:  $model = new \\app\\models\\ContactForm;\n\n// \"name\" is an attribute of ContactForm\n$model- name = 'example';\necho $model- name;  E' inoltre possibile accedere agli attributi come l'accesso agli elementi dell'array, grazie al supporto per   ArrayAccess   e  Traversable ***.  $model = new \\app\\models\\ContactForm;\n\n// accessing attributes like array elements\n$model['name'] = 'example';\necho $model['name'];\n\n// Model is traversable using foreach.\nforeach ($model as $name =  $value) {\n    echo \"$name: $value\\n\";\n}",
            "title": "Attributi"
        },
        {
            "location": "/application-structure/sub-models/#definizione-degli-attributi",
            "text": "Per impostazione predefinita, se la classe del modello si estende direttamente da   yii \\ base \\ Model  , tutte le sue variabili non statiche di membro pubblico sono attributi. Ad esempio, la classe del modello  ContactForm  sotto ha quattro attributi:  name ,  email ,  subject  e  body . Il modello  ContactForm  viene utilizzato per rappresentare i dati di input ricevuti da un modulo HTML.  namespace app\\models;\n\nuse yii\\base\\Model;\n\nclass ContactForm extends Model{\n\n    public $name;\n    public $email;\n    public $subject;\n    public $body;\n}",
            "title": "Definizione degli attributi"
        },
        {
            "location": "/application-structure/sub-models/#etichette-di-attributi",
            "text": "Quando si visualizzano valori o otteniamo input per gli attributi, spesso \u00e8 necessario visualizzare alcune etichette associate agli attributi. Ad esempio, dato un attributo denominato,  firstName , e possibile visualizzare un'etichetta  First Name  che sia pi\u00f9 facile da usare quando viene visualizzata per mandare all'utente messaggi di errore oppure etichette di input.  E' possibile ottenere l'etichetta di un attributo chiamando   yii \\ base \\ Model :: getAttributeLabel()  . Per esempio:  $model = new \\app\\models\\ContactForm;\n\n// displays \"Name\"\necho $model- getAttributeLabel('name');  Per impostazione predefinita, le etichette degli attributi vengono generate automaticamente da nomi degli attributi. La generazione viene fatta con il metodo   yii \\ base \\ Model :: generateAttributeLabel()  . Alcuni esempi:  username  diventa  Username ,  firstName  diventa  First Name .  Se non si desidare utilizzare etichette generate automaticamente, \u00e8 possibile ignorare   yii \\ base \\ Model :: attributeLabels()   per dichiarare esplicitamente le etichette degli attributi.  Esempio:  namespace app\\models;\n\nuse yii\\base\\Model;\n\nclass ContactForm extends Model{\n\n    public $name;\n    public $email;\n    public $subject;\n    public $body;\n\n    public function attributeLabels(){\n\n        return [\n            'name' =  'Your name',\n            'email' =  'Your email address',\n            'subject' =  'Subject',\n            'body' =  'Content',\n        ];\n    }\n}  Per le applicazioni che supportano pi\u00f9 lingue, \u00e8 possibile tradurre le etichette degli attributi. Questo pu\u00f2 essere fatto anche all'interno del metodo  attributeLabels() , come nel seguente esempio:  public function attributeLabels(){\n\n    return [\n        'name' =  \\Yii::t('app', 'Your name'),\n        'email' =  \\Yii::t('app', 'Your email address'),\n        'subject' =  \\Yii::t('app', 'Subject'),\n        'body' =  \\Yii::t('app', 'Content'),\n    ];\n}  E' possibile definire anche etichette degli attributi. Ad esempio, in base allo scenario in cui \u00e8 stato utilizzato il modello, \u00e8 possibile restituire diverse etichette per lo stesso attributo   Note  Le etichette degli attributi fanno parte delle stesse view(viste). Ma la dichiarazione di etichette nei modelli \u00e8 spesso molto conveniente ed \u00e8 molto comodo per avere un codice pi\u00f9 pulito e riutilizzabile.",
            "title": "Etichette di attributi"
        },
        {
            "location": "/application-structure/sub-models/#scenari",
            "text": "Un modello pu\u00e0 essere utilizzato in diversi scenari. Ad esempio, un modello  User  pu\u00f2 essere utilizzato per raccogliere gli ingressi di login utente, ma pu\u00f2 essere utilizzato anche per la registrazione di utenti. In diversi scenari, un modello pu\u00f2 utilizzare regole e logiche differenti. Ad esempio, l'attributo  email  pu\u00f2 essere richiesto sia durante la registrazione degli utenti, ma non \u00e8 cos\u00ec durante la fase di login.  Un modello utilizza la propriet\u00e0   scenario yii \\ base \\ Model ::   per tenere traccia dello scenario in cui viene utilizzato. Per impostazione predefinita, un modello supporta solo un singolo scenario denominato  default . Il seguente codice mostra due modi per impostare lo scenario di un modello:  // scenario is set as a property\n$model = new User;\n$model- scenario = User::SCENARIO_LOGIN;\n\n// scenario is set through configuration\n$model = new User(['scenario' =  User::SCENARIO_LOGIN]);  Per impostazione predefinita, gli scenari supportati da un modello sono determinati dalle regole di convalida dichiarate nel modello. Tuttavia, \u00e8 possivile personalizzare questo comportamento prevenendo il meodo   yii \\ base \\ Model :: scenari()  , ad esempio:  namespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass User extends ActiveRecord{\n\n    const SCENARIO_LOGIN = 'login';\n    const SCENARIO_REGISTER = 'register';\n\n    public function scenarios(){\n\n        return [\n            self::SCENARIO_LOGIN =  ['username', 'password'],\n            self::SCENARIO_REGISTER =  ['username', 'email', 'password'],\n        ];\n    }\n}  Il metodo  scenarios()  restituisce un array le cui chiavi sono i nomi di scenari e valori relativi agli attributi attivi. Un attributo attivo pu\u00f2 essere assegnato massicciamente e soggetto alla convalida. Nell'esempio precedente, gli attributi  username  e  password  sono attivi nello scenario  login ; mentre nello scenario  register ,  email \u00e8 lo stesso attivo oltre a  username  e  password .  L'implementazione predefinita  scenarios() restituira tutti gli scenari trovati nel metodo di dichiarazione della regola valid   yii \\ base \\ Model :: rules()  . Quando si sceglie  scenarios() , se si desidare introdurre nuovi scenari in aggiunta a quelli predefiniti, \u00e8 possibile scrivere un codice come segue:  namespace app\\models;\n\nuse yii\\db\\ActiveRecord;\n\nclass User extends ActiveRecord{\n\n    const SCENARIO_LOGIN = 'login';\n    const SCENARIO_REGISTER = 'register';\n\n    public function scenarios(){\n\n        $scenarios = parent::scenarios();\n        $scenarios[self::SCENARIO_LOGIN] = ['username', 'password'];\n        $scenarios[self::SCENARIO_REGISTER] = ['username', 'email', 'password'];\n        return $scenarios;\n    }\n}",
            "title": "Scenari"
        },
        {
            "location": "/application-structure/sub-models/#regole-di-convalida",
            "text": "Quando i dati di un modello vengono ricevuti dagli utenti finali, deve essere convalidati per assicrarsi che soddisfino determinate regole ( chiamate   regole di convalida  ). Ad esempio, dato un modello  ContactForm , \u00e8 possibile assicurarsi che tutti gli attributi non siano vuoti e che l'attributo  email  contenga un indirizzo email valido. Se i valori di alcuni attributi non soddisfano le regole corrispondenti, \u00e8 necessario visualizzare i messaggi di errore appropriati per aiutare l'utente a correggere gli errori.  Puoi chiamare il metodo  yii \\ base \\ Model :: validate()  per convalidare i dati ricevuti. Il metodo utilizzer\u00e0 le regole di convalida dichiarate all'interno del nostro modello. Se non viene trovato alcun errore, esso restituir\u00e0  true . In caso contrario, manterr\u00e0 gli errori nella propriet\u00e0   yii \\ base \\ Model :: errors   e restituir\u00e0  false . Per esempio:  $model = new \\app\\models\\ContactForm;\n\n// populate model attributes with user inputs\n$model- attributes = \\Yii::$app- request- post('ContactForm');\n\nif ($model- validate()) {\n    // all inputs are valid\n} else {\n    // validation failed: $errors is an array containing error messages\n    $errors = $model- errors;\n}  Per dichiarare regole di convalida associate a un modello, dovete aggiungere il metodo   yii \\ base \\ Model :: rules()   restituendo le regole che gli attributi del modello devono soddisfare. L'esempio seguente mostra le regole di convalida dichiarate per il modello  ContactForm :  public function rules(){\n\n    return [\n        // the name, email, subject and body attributes are required\n        [['name', 'email', 'subject', 'body'], 'required'],\n\n        // the email attribute should be a valid email address\n        ['email', 'email'],\n    ];\n}  Una regola pu\u00f2 essere utilizzata per convalidare uno o pi\u00f9 attributi, e un attributo pu\u00f2 essere convalidato da una o pi\u00f9 regole.\nA volte, \u00e8 possibile che una regola venga applicata solo in alcuni scenari. A tal fine, \u00e8 possibile specificare la propriet\u00e0  on  ad una regola.  Esempio:  public function rules(){\n\n    return [\n        // username, email and password are all required in \"register\" scenario\n        [['username', 'email', 'password'], 'required', 'on' =  self::SCENARIO_REGISTER],\n\n        // username and password are required in \"login\" scenario\n        [['username', 'password'], 'required', 'on' =  self::SCENARIO_LOGIN],\n    ];\n}  Se non si specifica la propriet\u00e0  on , questa regola verr\u00e0 applicata in tutti gli scenari. Una regola, viene definita   attiva   se pu\u00f2 essere applicata nello scenario del modello corrente.  Un attributo verr\u00e0 convalidato se e solo se \u00e8 un attributo attivo dichiarato nel metodo  scenarios()  e associato a una o pi\u00f9 regole attive dichiarate nel metodo  rules() .",
            "title": "Regole di convalida"
        },
        {
            "location": "/application-structure/sub-models/#assegnazione-massiva",
            "text": "L'assegnazione massiva \u00e8 un modo conveniente per popolare un modello con gli ingressi utente utilizzando una sola riga di codice. Consente di popolare gli attributi di un modello  assegnando i dati di input direttamente alla propriet\u00e0 del nostro modulo. Le seguenti due righe di codice sono equivalenti, entrambi associano i dati del modulo inviati dagli utenti finali agli attributi del modello  ContactForm . Chiaramente, il primo, \u00e8 pi\u00f9 pulito e meno erroneo del secondo:  $model = new \\app\\models\\ContactForm;\n$model- attributes = \\Yii::$app- request- post('ContactForm');\n\n$model = new \\app\\models\\ContactForm;\n$data = \\Yii::$app- request- post('ContactForm', []);\n$model- name = isset($data['name']) ? $data['name'] : null;\n$model- email = isset($data['email']) ? $data['email'] : null;\n$model- subject = isset($data['subject']) ? $data['subject'] : null;\n$model- body = isset($data['body']) ? $data['body'] : null;",
            "title": "Assegnazione massiva"
        },
        {
            "location": "/application-structure/sub-models/#attributi-sicuri",
            "text": "L'assegnazione massiva si applica solo ai cosiddetti    attributi sicuri   che sono gli attributi elencati negli scenari del modello corrente. Ad esempio, se il modello  User  ha la seguente dichiarazione di scenari, allora quando lo scenario corrente \u00e8  login , solo l' username  e  password  pu\u00f2 essere assegnato massivamente. Qualsiasi altro attributo sar\u00e0 mantenuto intatto.  public function scenarios(){\n\n    return [\n        self::SCENARIO_LOGIN =  ['username', 'password'],\n        self::SCENARIO_REGISTER =  ['username', 'email', 'password'],\n    ];\n}   Note  Il motivo per cui l'assegnazione di massa si applica solo agli attributi sicuri, \u00e8 perch\u00e8 si desidera controllare quali attributi possono essere modificati dagli utenti finali. Ad esempio, se il modello  User  dispone di un attributo  permission  che determina l'autorizzazione assegnata all'utente, si desidera modificare tale attributo dagli amministratori solo tramite un'interfaccia backend.   Per rendere un attributo sicuro, viene fornito un alias chiamato  safe . E' un alias di validazione speciale in modo da poter dichiarare un attributo sicuro senza effettuare la convalida. Ad esempio, le seguenti regole dichiarano che sia  title  che  description  siano attributi sicuri.  public function rules(){\n\n    return [\n        [['title', 'description'], 'safe'],\n\n    ];\n}",
            "title": "Attributi sicuri"
        },
        {
            "location": "/application-structure/sub-models/#attributi-non-sicuri",
            "text": "Come detto in precedenza, il metodo  scenarios()  serve per due scopi: determinare quali attributi devono essere convalidati e determinare quali attributi sono sicuri. In alcuni casi rari, si potrebbe desiderare di convalidare un attributo, ma non si desidera contrassegnarlo. Puoi farlo configurando un punto esclamativo  !  al nome dell'attributo quando lo dichiari all'interno del metodo  scenarios() , come l'esempio dell'attributo  secret  nel seguente esempio:  public function scenarios(){\n\n    return [\n        self::SCENARIO_LOGIN =  ['username', 'password', '!secret'],\n\n    ];\n}  Quando il modello \u00e8 nello scenario  login , tutti e tre gli attributi verranno convalidati. Tuttavia, solo gli attributi  username  e  password  possono essere assegnati in modo massivo. Per assegnare un valore di input all'attributo  secret , dobbiamo farlo in modo esplicito  $model- secret = $secret;  La stessa cosa pu\u00f2 essere fatta nel metodo  rules() .  public function rules(){\n\n    return [\n        [['username', 'password', '!secret'], 'required', 'on' =  'login']\n    ];\n}  In questo caso gli attributi  username ,  password  e  secret  sono necessari, ma  secret  deve essere assegnato in modo esplicito.",
            "title": "Attributi non sicuri"
        },
        {
            "location": "/application-structure/sub-models/#esportazione-dei-dati",
            "text": "I modelli spesso devono essere esportati in diversi formati. Ad esempio, \u00e8 possibile convertire una raccolta di modeli in formato JSON o Excel. Il processo di esportazione pu\u00f2 essere suddiviso in due fasi indipendenti:\n- i modelli vengono convertiti in array;\n- gli array vengono convertiti in formati di destinazione.  Puoi concentrarti solo sul primo passo, perch\u00e8 il secondo pu\u00f2 essere raggiungo da formattatori di dati generici, come   yii \\ web \\ JsonResponseFormatter  .  Il modo pi\u00f9 semplice per convertire un modello in un array \u00e8 quello di utilizzare la propriet\u00e0   yii \\ base \\ Model :: $attributes  . Per esempio:  $post = \\app\\models\\Post::findOne(100);\n$array = $post- attributes;  Per impostazione predefinita, la propriet\u00e0  attributes  restituir\u00e0 i valori di tutti gli attributi dichiarati in   yii \\ base \\ Model :: ()  .  Un modo pi\u00f9 flessibile e potente per convertire un modello in un array \u00e8 quello di utilizzare il metodo  yii\\ base \\ Model :: to Array() . Il suo comportamento predefinito \u00e8 lo stesso di quello del metodo  attributes . Tuttavia, consente di scegliere quali elementi di dati ( chiamati  campi ), bisogna inserire nell'array risultante e come dovrebbero essere formattati.",
            "title": "Esportazione dei dati"
        },
        {
            "location": "/application-structure/sub-models/#campi",
            "text": "Un campo \u00e8 semplicemente un elemento denominato nell'array ottenuto chiamando il metodo  yii \\ base \\ Model :: toArray()  di un modello.  Per impostazione predefinita, i nomi dei campi sono equivalenti ai nomi degli attributi. Tuttavia, \u00e8 possibile modificare questo comportamento dichiarando i metodi  fields()  e / o  extraFields() . Entrambi i metodi devono restituire un elenco delle definizione dei campi. I campi definiti da  fields()  sono campi predefiniti, il che significa che  toArray()  restituir\u00e0 questi campi per impostazione predefinita. Il metodo  extraFields()  definisce campi aggiuntivi disponibili che possono anche essere restituiti dal metodo  toArray()  affinch\u00e8 si specifichi tramite il parametro  $expand . Ad esempio, il codice riportato di seguito restituir\u00e0 tutti i campi definiti  fields()  e i campi  prettyName  e  fullAddress  se sono definiti  extraFields() .  $array = $model- toArray([], ['prettyName', 'fullAddress']);  E' possibile ignorare  fields()  per aggiungere,rimuovere, rinominare o ridefinire i campi. Il valore restituito dal metodo  `fields()  dovr\u00e0 essere un array. I nomi dell'array sono i nomi dei campi e i valori dell'array sono le corrispondenti definizioni dei campi che possono essere nomi di propriet\u00e0/attributi o funzioni anonime che restituiscono i valori del campo corrispondente. Nel caso speciale quando un nome di un campo \u00e8 uguale al suo nome dell'attributo, \u00e8 possibile ignorare il nome dell'array. Per esempio:  // explicitly list every field, best used when you want to make sure the changes\n// in your DB table or model attributes do not cause your field changes (to keep API backward compatibility).\npublic function fields(){\n\n    return [\n        // field name is the same as the attribute name\n        'id',\n\n        // field name is \"email\", the corresponding attribute name is \"email_address\"\n        'email' =  'email_address',\n\n        // field name is \"name\", its value is defined by a PHP callback\n        'name' =  function () {\n            return $this- first_name . ' ' . $this- last_name;\n        },\n    ];\n}\n\n// filter out some fields, best used when you want to inherit the parent implementation\n// and blacklist some sensitive fields.\npublic function fields(){\n\n    $fields = parent::fields();\n\n    // remove fields that contain sensitive information\n    unset($fields['auth_key'], $fields['password_hash'], $fields['password_reset_token']);\n\n    return $fields;\n}   Warning  Per impostazione predefinita tutti gli attributi di un modello saranno inclusi nell'array esportato, \u00e8 necessario esaminare i dati per assicurarsi di non contenere informazioni sensibili. Se ci sono tali informazioni, dovresti ignorare il metodo  fields()  per filtrarli. Nell'esempio sopra, abbiamo scelto di filtrare  auth_key ,  password_hash  e  password_reset_token .",
            "title": "Campi"
        },
        {
            "location": "/application-structure/sub-views/",
            "text": "Viste (views)\n\n\nLe viste sono parte dell'architettura MVC. Essi sono responsabili del codice per la presentazione dei dati agli utenti finali. In un'applicazione Web, le visualizzazioni vengono generalmente create in termini di modelli di visualizzazione che sono file di script PHP contenenti principalmente codice HTML e codice PHP. Sono gestiti dalla \"view application component\u201c che fornisce metodi comunemente utilizzati per facilitare la composizione e la visualizzazione delle view.\n\n\nCreazione di viste\n\n\nCome gi\u00e0 detto, una vista \u00e8 semplicemente uno script PHP mescolato con codice HTML e PHP. Di seguito \u00e8 riportata una vista che presenta un modulo di accesso. Come potete vedere, il codice PHP viene visualizzato per generare contenuto dinamico, come il titolo della pagina e il modulo, mentre il codice HTML li organizza in una pagina HTML presentabile.\n\n\n?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\ActiveForm;\n\n/* @var $this yii\\web\\View */\n/* @var $form yii\\widgets\\ActiveForm */\n/* @var $model app\\models\\LoginForm */\n\n$this-\ntitle = 'Login';\n?\n\n\nh1\n?= Html::encode($this-\ntitle) ?\n/h1\n\n\n\np\nPlease fill out the following fields to login:\n/p\n\n\n\n?php $form = ActiveForm::begin(); ?\n\n    \n?= $form-\nfield($model, 'username') ?\n\n    \n?= $form-\nfield($model, 'password')-\npasswordInput() ?\n\n    \n?= Html::submitButton('Login') ?\n  \n\n?php ActiveForm::end(); ?\n\n\n\n\nAll'interno di una vista, \u00e8 possibile accedere a alla variabile \n$this\n, che si riferisce alla gestione della struttura di visualizzazione e al rendering di questo modello di visualizzazione.\n\n\nOltre a \nthis\n, ci possono essere altre variabili predefinite in una vista, come \n$model\n nell'esempio precedente. \n\n\n\n\nTip\n\n\nLe variabili predefinite sono elencate in un blocco di commento all'inizio di una vista in modo che possano essere riconosciute da IDE. E' anche un buon modo per documentare le tue opinioni.\n\n\n\n\nSicurezza\n\n\nQuando si creano viste che generano pagine HTML, \u00e8 importante che i dati provenienti dagli utenti finali siano controllati. Altrimenti la tua applicazione potrebbe essere soggetta agli attachi di \n scripting cross-site \n.\n\n\nPer visualizzare un testo semplice, abbiamo bisogno di codificarlo come prima cosa chiamando \n yii \\ helpers \\ Html :: encode() \n. Ad esempio, il seguente codice codifica il nome utente prima di visualizzarlo:\n\n\n?php\nuse yii\\helpers\\Html;\n?\n\n\n\ndiv class=\"username\"\n\n    \n?= Html::encode($user-\nname) ?\n\n\n/div\n\n\n\n\nPer visualizzare il contenuto HTML, utilizzare \n yii \\ helpers \\ HtmlPurifier \n per filtrare prima il contenuto. Ad esempio, il codice seguente filtra il contenuto postale prima di visualizzarlo:\n\n\n?php\nuse yii\\helpers\\HtmlPurifier;\n?\n\n\n\ndiv class=\"post\"\n\n    \n?= HtmlPurifier::process($post-\ntext) ?\n\n\n/div\n\n\n\n\n\n\nTip\n\n\nMentre HTML Purifier fa un ottimo lavoro per rendere l'output sicuro, non \u00e8 veloce. E' opportuno considerare la memorizzazione nella cache del risultato di filtraggio se la tua applicazione richiede elevate prestazioni.\n\n\n\n\nOrganizzazione delle viste\n\n\nCome controllers e models, ci sono convenzioni per organizzare le viste:\n\n\n\n\nPer le visualizzazioni rese da un controller, dovrebbero essere posizionate sotto la directory \n@app/views/ControllerID\n per impostazione predefinita, dove \nControllerID\n si riferisce all'ID del controller. Ad esempio, se la classe controller \u00e8 \nPostController\n, la directory sarebbe \n@app/views/post\n; se \u00e8 \nPostCommentController\n, la directory sarebbe \napp/views/post-comment\n. Nel caso in cui il controller appartiene a un modulo della directory si troverebbe \nviews/ControllerID\n sotto \n yii \\ base \\ Module :: basePath \n.\n\n\nPer le viste rese da un widget, dovrebbero essere posizionate sotto la \nWidgetPath/views\n directory per impostazione predefinita, dove si trova la directory \nWidgetPath\n contenente il file della classe widget.\n\n\nPer le visualizzazioni rese da altri oggetti, si consiglia di seguire la convenzione simile a quella relativa ai widget.\n\n\n\n\nE' possibile personalizzare queste directory di visualizzazione predefinite, usando il metodo \n yii \\ base \\ ViewContextInterface :: getViewPath() \n dei controller o dei widget.\n\n\nViste di rendering\n\n\nE' possibile restituire visualizzazioni in controller, widget o in qualsiasi altro luogo chiamando metodi di rendering delle visualizzazioni. Questi metodi condividono una firma simile mostrata come segue.\n\n\n/**\n* @param string $view view name or file path, depending on the actual rendering method\n* @param array $params the data to be passed to the view\n* @return string rendering result\n*/\nmethodName($view, $params = [])\n\n\n\nRendering nei controllori (controller)\n\n\nAll'interno dei controllori, \u00e8 possibile chiamare i seguenti metodi di controllo per restituire le view:\n\n\n\n\nrender()\n: restituisce una vista denominata e gli applica un layout al risultato di rendering.\n\n\nrenderPartial()\n: restituisce una vista denominata senza alcun layout.\n\n\nrenderAjax()\n: restituisce una vista denominata senza alcun layout e ci aggiunge tutti gli script e file JS / CSS registrati. Viene di solito usato come risposta alle richieste Web di AJAX.\n\n\nrenderFile()\n: restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.\n\n\nrenderContent()\n: restituisce una stringa statica incorporandola nel layout attualmente applicabile.\n\n\n\n\nPer esempio:\n\n\nnamespace app\\controllers;\n\nuse Yii;\nuse app\\models\\Post;\nuse yii\\web\\Controller;\nuse yii\\web\\NotFoundHttpException;\n\nclass PostController extends Controller{\n\n    public function actionView($id){\n\n        $model = Post::findOne($id);\n        if ($model === null) {\n            throw new NotFoundHttpException;\n        }\n\n        // renders a view named \"view\" and applies a layout to it\n        return $this-\nrender('view', [\n            'model' =\n $model,\n        ]);\n    }\n}\n\n\n\nRendering nei widget\n\n\nNei widget \u00e8 possibile chiamare i seguneti widget per restituire le view:\n\n\n\n\nrender()\n: restituisce una vista denominata.\n\n\nrenderFile()\n: restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.\n\n\n\n\nPer esempio:\n\n\nnamespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass ListWidget extends Widget{\n\n    public $items = [];\n\n    public function run(){\n\n        // renders a view named \"list\"\n        return $this-\nrender('list', [\n            'items' =\n $this-\nitems,\n        ]);\n    }\n}\n\n\n\nRendering nelle viste (view)\n\n\nE' possibile eseguire una visualizzazione in un'altra visione chiamando uno dei seguenti metodi forniti dal \"view component\":\n\n\n\n\nrender()\n: restituisce una vista denominata.\n\n\nrenderAjax()\n: restituisce una vista denominata e ci aggiunge tutti gli script e file JS / CSS registrati. Viene di solito usato come risposta alle richieste Web di AJAX.\n\n\nrenderFile()\n: restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.\n\n\n\n\nAd esempio, il codice riportato di seguito in una visualizzazione restituisce il file di visualizzazione \n_overview.php\n nella stessa directory della view attualmente resa. Ricorda che \n$this\n si riferisce al componente stesso di view:\n\n\n?= $this-\nrender('_overview') ?\n\n\n\n\nViste denominate\n\n\nUn nome di visualizzazione viene convertito nel percorso del file di viisualizzazzione corrispondente in base alle seguenti regole:\n\n\n\n\nUn nome di visualizzazione pu\u00f2 omettere il nome dell'estensione del file. In questo caso, \n.php\n verr\u00e0 utilizzato come estensione. Ad esempio, il nome della vista \nabout\n corrisponde al nome del file \nabout.php\n.\n\n\nSe il nome della visualizzazione inizia con \n//\n, il percorso del file corrispondente dovrebbe essere \n@app/views/ViewName\n. Cio\u00e8, la vista viene visualizzata sotto il metodo \nviewPath()\n. Ad esempio,\n//site/about\n verr\u00e0 convertito in \n@app/views/site/about.php\n.\n\n\nSe il nome della visualizzione inizia con \n/\n, il percorso del file viene formato prefigurando il nome della vista con il metodo \nviewPath()\n del modulo attualmente attivo. Se non esiste un modulo attivo, verr\u00e0 utilizzato \n@app/views/ViewName\n. Ad esempio, \n/user/create\n verr\u00e0 convertito in \n@aap/modules/views/user/create.php\n se attualmente il modulo attivo \u00e8 \nuser\n. Se non esiste un modulo attivo, il percorso del file di visualizzazione sar\u00e0 \n@app/views/user/create.php\n.\n\n\nSe la vista viene eseguita con un \"context\" e implementa \n yii \\ base \\ ViewContextInterface \n, il percorso del file di visualizzazione viene formato prefigurando il percorso di visualizzazione del context con il nome della vista. Questo principalmente si applica ai punti di vista resti all'interno di controller e widget. Ad esempio, \nabout\n verr\u00e0 convertito \n@app/views/site/about.php\n se il contesto \u00e8 il controller \nSiteController\n.\n\n\nSe una vista viene visualizzata in un'altra visualizzazione, la directory contenente l'altro file di visualizzazione sar\u00e0 il prefisso al nuovo nome di visualizzazione per formare il percorso effettivo. Ad esempio, \nitem\n verr\u00e0 convertito in \n@app/views/site/about.php\n se viene visualizzato nella vista \n@app/views/post/index.php\n.\n\n\n\n\nSecondo le regole precedenti, la chiamata \n$this-\nrender('view')\n in un controller \napp\\controllers\\PostController\n restituir\u00e0 effettivamente il file di visualizzazione \n@app/views/post/view.php\n, mentre quando richiamiamo \n$this-\nrender('_overview')\n di quella vista restituir\u00e0 il file di visualizzazione \n@app/views/post/_overview.php\n.\n\n\nAccesso ai dati nelle viste\n\n\nEsistono due approcci per accedere ai dati all'interno di una vista: push e pull.\n\n\nPassando i dati come secondo parametro ai metodi di views, significa che si sta utilizzando l'approccio push. I dati dovrebbero essere rappresentati come una matrice di coppie nome-valore. Quando viene eseguito il rendering della view, la funzione PHP \nextract()\n viene usata quando voglia che il nostro array venga estratto e associato a variabili distinte nella nostra vista. Ad esempio, il seguente codice di rendering della vista di un controller invier\u00e0 due varabili alla views \nreport\n: \n$foo = \\\n e \n$bar = 2\n.\n\n\necho $this-\nrender('report', [\n    'foo' =\n 1,\n    'bar' =\n 2,\n]);\n\n\n\nL'approccio pull permetter\u00e0 di recuperare attivamente i dati dalla componente di visualizzazione o da altri oggetti accessibili nelle viste ( ad esempio \nYii::$app\n). Utilizzando il seguente codice come esempio, all'interno della vista \u00e8 possibile ottenere l'oggetto controller dall'espressione \n$this-\ncontext\n. Di conseguenza, \u00e8 possibile accedere a qualsiasi propriet\u00e0 o metodo del controller nella views di \nreport\n, ad esempio l'ID del controller come mostrato di seguito:\n\n\nThe controller ID is: \n?= $this-\ncontext-\nid ?\n\n\n\n\nL'approccio push \u00e8 solitamente il modo preferito perch\u00e8 permette di accedere ai dati delle viste, poich\u00e8 rende le visualizzazioni meno dipendenti dagli oggetti di contesto. Il suo svantaggio \u00e8 che \u00e8 necessario costruire manualmente l'array di dati tutto il tempo, che potrebbe diventare noioso e soggetto a errori se una vista \u00e8 condivisa e resa in luoghi diversi.\n\n\nCondivisione dei dati tra le viste\n\n\nIl componente di visualizzazione fornisce la propriet\u00e0 \nparams\n che \u00e8 possibile utilizzare per condividere i dati tra le viste. \nAd esempio, in una view \nabout\n, \u00e8 possibile avere il seguente codice che specifica il segmento corrente dei breadcrumb.\n\n\n$this-\nparams['breadcrumbs'][] = 'About Us';\n\n\n\nQuando nel file di layout puoi visualizzare i breadcrumb usando i dati passati attraverso parametri:\n\n\n?= yii\\widgets\\Breadcrumbs::widget([\n    'links' =\n isset($this-\nparams['breadcrumbs']) ? $this-\nparams['breadcrumbs'] : [],\n]) ?\n\n\n\n\nLayout\n\n\nI layout sono un tipo speciale di viste che rappresentano le parti comune di pi\u00f9 viste. Ad esempio, le pagine per la maggior parte delle applicazioni Web condividono la stessa intestazione e il pi\u00e8 di pagina, Mentre \u00e8 possibile ripetere la stessa intestazione e il pi\u00e8 di pagina ad ogni vista, un modo migliore \u00e8 quello di farlo una volta in un layout e poi incorporarlo ad esso.\n\n\nCreazioen di un layout\n\n\nI layout sono anche viste, ed essendo delle viste possono essere create come in modo molto simile. Per impostazione predefinita, i layout sono memorizzati nella directory \n@app/views/layouts\n. Per i layout utilizzati all'interno di una modulo, devono essere memorizzati nella directory \nviews/layouts\n sotto \nyii \\ base \\ Module :: basePath\n. E' possibile personalizzare la directory di layout predefinita configurando la propriet\u00e0 \nyii \\ base \\ Module :: layoutPath\n dell'applicazione o dei moduli.\n\n\nL'esempio seguente mostra come appare un layout. Si noti che a scopo illustrativo, abbiamo notevolmente semplificato il codice nel layout. In pratica, potresti voler aggiungere pi\u00f9 contenuti ad esso, come \"head tag\", menu principale, ecc.\n\n\n?php\nuse yii\\helpers\\Html;\n\n/* @var $this yii\\web\\View */\n/* @var $content string */\n?\n\n\n?php $this-\nbeginPage() ?\n\n\n!DOCTYPE html\n\n\nhtml lang=\"en\"\n\n\nhead\n\n    \nmeta charset=\"UTF-8\"/\n\n    \n?= Html::csrfMetaTags() ?\n\n    \ntitle\n?= Html::encode($this-\ntitle) ?\n/title\n\n    \n?php $this-\nhead() ?\n\n\n/head\n\n\nbody\n\n\n?php $this-\nbeginBody() ?\n\n    \nheader\nMy Company\n/header\n\n    \n?= $content ?\n\n    \nfooter\ncopy; 2014 by My Company\n/footer\n\n\n?php $this-\nendBody() ?\n\n\n/body\n\n\n/html\n\n\n?php $this-\nendPage() ?\n\n\n\n\nCome puoi vedere, il layout genera i tag HTML comuni a tutte le pagine. All'interno della sezione \nbody\n, il layout richiama la variabile \n$content\n che rappresenta il risultato del rendering delle viste del contenuto e viene inserito nel layout quando viene chiamato \nyii \\ base \\ Controller :: render()\n.\n\n\nLa maggior parte dei layout dovrebbe chiamare i seguenti metodi come mostrato nel codice sopra. Questi metodi attivano principalmente eventi relativi al processo di rendering in modo che gli script e i tag registrati in altri luoghi possano essere iniettati correttamente nelle posizioni in cui vengono chiamati questi metodi.\n\n\n\n\nbeginPage()\n: questo metodo dovrebbe essere chiamato all'inizio del layout. Si innesca l'evento \nl'EVENT_BEGIN_PAGE\n  che indica l'inizio di una pagina.\n\n\nendPage()\n: questo metodo dovrebbe essere chiamato alla file del layout. Si innesca l'evento \nl'EVENT_END_PAGE\n che indica la fine di una partita.\n\n\nhead()\n: questo metodo dovrebbe essere chiamato all'interno del tag \nhead\n nella sezione di una pagina HTML. Genera un segnaposto che verr\u00e0 sostituito con il codice HTML head registrato ( ad es. Tag link, meta tag) quando una pagina termina in rendering.\n\n\nbeginBody()\n: questo metodo dovrebbe essere chiamato all'inizio della sezione \nbody\n. Si innesca l'evento \nl'EVENT_BEGIN_BODY\n e genera una segnaposto che sar\u00e0 sostituito dal codice HTML registrato ( ad es. Javascript()) destinato al corpo del nostro programma.\n\n\nendBody()\n: questo metodo dovrebbe essere chiamato alla fine della sezione \nbody\n. Si innesca l'evento \nl'EVENT_END_BODY\n e genera un segnaposto che sar\u00e0 sostituito dal codice HTML registrato  ( ad es. Javascript()) destinato alla posizione finale del corpo del programma.\n\n\n\n\nAccesso ai dati nei layout\n\n\nAll'interno di un layout, hai accesso a due variabili predefinite: \n$this\n e \n$content\n, Il primo si riferisce alla componente della vista, come nelle viste normali, mentre il secondo contiene il risultato del rendering di una vista del contenuto che viene renderizzata chiamando il metodo \nrender()\n nei controller.\n\n\nSe si desidera accedere ad altri dati nei layout, \u00e8 necessario utilizzare il metodo pull ( come descritto nella sottosezione \"Accesso ai dati nella vista ). Se si desidera trasferire dati da una vista di contenuto a un layout, \u00e8 possibile utilizzare il metodo descritto nella sottosezione \"Viste di condivisione dati\".\n\n\nUtilizzando i layout\n\n\nCome descritto nella sottosezione \"Rendering nei Controller, quando si esegue il rendering di una vista chiamando il metodo \nrender()\n in un controller, verr\u00e0 applicato un layout al risultato del rendering. Per impostazione predefinita, verr\u00e0 utilizzato il layout \n@app/views/layouts/main.php\n.\n\n\nE' possibile utilizzare un layout diverso configurando il layout \nyii \\ base \\ Application :: $\n o \nyii \\ base \\ Controller :: $\n. Il primo regola il layout utilizzato da tutti i controller, mentre il secondo sovrascrive il primo per i singoli controller. Ad esempio, il codice seguente rende il controller \npost\n da utilizzare come layout durante il rendering delle sue viste. ( url file: \n@app/views/layouts/post.php\n). Altri controller, supponendo che la loro propriet\u00e0 \nlayout\n non sia stata modificata, utilizzeranno comunque \n@app/views/layouts/main.php\n il layout di default.\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    public $layout = 'post';\n\n    // ...\n}\n\n\n\nPer i controllori appartenenti a un modulo, \u00e8 possibile configurare anche la propriet\u00e0 di layout del modulo per utilizzare un particolare layout per questi controller.\n\n\nPoich\u00e8 la propriet\u00e0 \nlayout\n pu\u00f2 essere configurata a diversi livelli ( controller,moduli,applicazione ), dietro la scena, Yii prende due passaggi per determinare qual \u00e8 il file di layout effettivo utilizzato per un particolare controller.\n\n\nNel primo passaggio, determina il valore di layout e il modulo di contesto:\n\n\n\n\nSe la propriet\u00e0 di layout del controller \n yii \\ base \\ Controller :: $ \n non \u00e8 \nnull\n, \u00e8 consigliabile usarlo come valore di layout e il modulo del controller come modulo del contesto.\n\n\nSe la propriet\u00e0 di layout del controller \n yii \\ base \\ Controller :: $ \n \u00e8 \nnull\n, conviene cercare tra tutti i moduli degli antenati ( inclusa l'applicazione stessa ) del controller e trovare il primo modulo la cui propriet\u00e0 layout non \u00e8 \nnull\n. Usa quel modulo e il suo valore di layout come modulo di contesto e valore scelto. Se tale modulo non pu\u00f2 essere trovato, significa che non verr\u00e0 applicato alcun layout.\n\n\n\n\nNella seconda fase, determina il file di layout effettivo di base al valore di layout e al modulo di contesto determinato nel primo passaggio. Il valore di layout pu\u00f2 essere:\n\n\n\n\nun percorso alias ( es. \n@app/views/layouts/main\n).\n\n\nun percorso assoluto ( es. \n/main\n): il valore del layout inizia con una barra. Il file di layout effettivo verr\u00e0 cercato sotto \n yii \\ base \\ Application :: layoutPath \n dell'applicazione che viene impostato automaticamente \n@app/views/layouts\n.\n\n\nun percorso relativo (es. \nmain\n): il file di layout effettivo verr\u00e0 cercato sotto \nyii \\ base \\ Module :: layoutPath\n del modulo di contesto, che per impostazione predefinita si trova nella directory \nviews/layouts\n sotto \n yii \\ base \\ Module :: basePath \n.\n\n\nil valore booleano \nfalse\n: non verr\u00e0 applicato alcun layout.\n\n\n\n\nSe il valore di layout non contiene un'estensione di file, utilizzer\u00e0 quella predefinita \n.php\n.\n\n\nLayout nidificati\n\n\nA volte potresti voler annidare un layout in un altro. Ad esempio, in diverse sezioni di un sito Web, se si desidera utilizzare layout diversi, mentre tutti questi layout condividono lo stesso layout di base che genera la struttura generale della pagina HTML5. E' possibile raggiungere questo obiettivo chiamando il metodo \nbeginContent()\n e \nendContent()\n nei layout figli come il seguente:\n\n\n?php $this-\nbeginContent('@app/views/layouts/base.php'); ?\n\n\n...child layout content here...\n\n\n?php $this-\nendContent(); ?\n\n\n\n\nCome mostrato sopra, il contenuto del layout figlio deve essere racchiuso tra \nbeginContent()\n e \nendContent()\n. Il parametro passato a \nbeginContent()\n specifica qual \u00e8 il layout principale. Pu\u00f2 essere un file di layout o un alias. \n\n\nUtilizzando l'approccio sopra, \u00e8 possibile nidificare i layout in pi\u00f9 livelli.\n\n\nUsare i blocchi\n\n\nI blocchi consentono di specificare il contenuto della vista in un punto mentre lo si visualizza in un altro. Sono spesso usati insieme ai layout. Ad esempio, \u00e8 possibile definire un blocco in una vista del contenuto e visualizzarlo nel layout.\n\n\nI metodi si chiamano \nbeginBlock()\n e \nendBlock()\n. E' possibile accedere al blocco tramite \n$view-\nblocks[$blockID]\n, dove a \n$blockID\n verr\u00e0 assegnato un ID univoco al momento della sua definizione.\n\n\nL'esempio seguente mostra come utilizzare i blocchi per personalizzare parti specifiche di un layout in una vista del contenuto.\n\n\nInnanzitutto, in una vista del contenuto, possiamo definire uno o pi\u00f9 blocchi ( come segue ):\n\n\n...\n\n\n?php $this-\nbeginBlock('block1'); ?\n\n\n...content of block1...\n\n\n?php $this-\nendBlock(); ?\n\n\n...\n\n\n?php $this-\nbeginBlock('block3'); ?\n\n\n...content of block3...\n\n\n?php $this-\nendBlock(); ?\n\n\n\n\nQuindi nella vista layout possiamo visualizzare i blocchi se sono disponibili o visualizzare i contenuti predefiniti se un blocco non \u00e8 definito.\n\n\n...\n\n?php if (isset($this-\nblocks['block1'])): ?\n\n    \n?= $this-\nblocks['block1'] ?\n\n\n?php else: ?\n\n    ... default content for block1 ...\n\n?php endif; ?\n\n\n...\n\n\n?php if (isset($this-\nblocks['block2'])): ?\n\n    \n?= $this-\nblocks['block2'] ?\n\n\n?php else: ?\n\n    ... default content for block2 ...\n\n?php endif; ?\n\n\n...\n\n\n?php if (isset($this-\nblocks['block3'])): ?\n\n    \n?= $this-\nblocks['block3'] ?\n\n\n?php else: ?\n\n    ... default content for block3 ...\n\n?php endif; ?\n\n...\n\n\n\nUtilizzo del \"View Components\"\n\n\nVisualizza componenti ( o View COmponents) offre molte funzionalit\u00e0 relative alla vista. Mentre \u00e8 possibile ottenere i componenti di visualizzazione creando singole istanze di \n yii \\ base \\ View \n o della relativa classe figlio, nella maggior parte dei casi si utilizzer\u00e0 principalmente il componente \nview\n dell'applicazione. E' possibile configurare questo componente nella configurazione dell'applicazione come la seguente:\n\n\n[\n    // ...\n    'components' =\n [\n        'view' =\n [\n            'class' =\n 'app\\components\\View',\n        ],\n        // ...\n    ],\n]\n\n\n\ni componenti View forniscono le seguenti utili funzionalit\u00e0 relative alla vista, ciascuna descritta in maggiori dettagli in una sezione separata:\n\n\n\n\ntematizzazione(theming)\n: consente di sviluppare e modificare il tema per il proprio sito Web.\n\n\ncatching dei frammenti\n: consente di memorizzare nella cache un frammento all'interno di una pagina Web.\n\n\ngestione degli script client\n: supporta la registrazione e il rendering di CSS e JavaScript.\n\n\ngestione dei pacchetti di asset\n: supporta la registrazione e il rendering di pacchetti e di risorse.\n\n\nmotori di template alternativi\n: consente di utilizzare altri motori di template, come \nTwig\n, \nSmarty\n.\n\n\n\n\nE' inoltre possibile utilizzare frequentamente le seguenti funzionalit\u00e0 secondarie ma utili durante lo sviluppo di pagine Web.\n\n\nImpostazione dei titoli delle pagine\n\n\nOgni pagina Web dovrebbe avere un titolo. Normalmente il tag del titolo viene visualizzato in un layout. Tuttavia, in pratica il titolo \u00e8 spesso determinato nelle visualizzazioni del contenuto piuttosto che nei layout. Per risolvere questo problema, \nyii \\ web \\ View\n fornisce la propriet\u00e0 \ntitle\n per consentire il passaggio delle informazioni sul titolo dalle viste del contenuto ai layout.\n\n\nPer utilizzare questa funzione, in ciascuna vista del contenuto, \u00e8 possibile impostare il titolo della pagina come segue:\n\n\n?php\n$this-\ntitle = 'My page title';\n?\n\n\n\n\nQuindi, nei layout, assicurati di avere il seguente codice nella sezione \nhead\n:\n\n\ntitle\n?= Html::encode($this-\ntitle) ?\n/title\n\n\n\n\nRegistrazione dei meta tag\n\n\nLe pagine Web di solito hanno bisogno di generare vari meta tag richiesti da parti diverse. Come i titoli di pagina, i meta tag compaiono nella sezione \nhead\n e di solito sono generati nei layout.\n\n\nSe si desidera specificare quali metatag generati nelle viste del contenuto, \u00e8 possibile chiamare \nyii \\ web \\ View :: registerMetaTag()\n in una vista del contenuto, come la seguente:\n\n\n?php\n$this-\nregisterMetaTag(['name' =\n 'keywords', 'content' =\n 'yii, framework, php']);\n?\n\n\n\n\nIl codice sopra riportato registrer\u00e0 un meta tag \"keywords\" con il componente di visualizzazione. Il meta tag registrato viene visualizzato dopo che il layout ha completato il rendering. Il seguente codice HTML verr\u00e0 generato e inserito nel punto in cui si chiama \n yii \\ web \\ View :: head() \n nei layout:\n\n\nmeta name=\"keywords\" content=\"yii, framework, php\"\n\n\n\n\nNota che se chiami pi\u00f9 volte \n yii \\ web \\ View :: registerMetaTag() \n, registrer\u00e0 pi\u00f9 meta tag, indipendentemente dal fatto che i meta tag siano uguali o meno.\nPer assicurarti che ci sia solo una singola istanza di un tipo di meta tag, puoi specificare una chiave come secondo parametro quando chiami il metodo. Ad esempio, il seguente codice registra due meta tag \"description\".\nTuttavia, verr\u00e0 reso solo il secondo.\n\n\n$this-\nregisterMetaTag(['name' =\n 'description', 'content' =\n 'This is my cool website made with Yii!'], 'description');\n$this-\nregisterMetaTag(['name' =\n 'description', 'content' =\n 'This website is about funny raccoons.'], 'description');\n\n\n\nRegistrazione dei tag nei collegamenti\n\n\nCome i meta tag, i tag di collegamento sono utili in molti casi, come personalizzare le favicon, puntare al feed RSS. Puoi lavorare con tag di collegamento in modo simile ai meta tag usando \n yii \\ web \\ View :: registerLinkTag() \n. Ad esempio, in una vista del contenuto, puoi registrare un tag link come segue:\n\n\n$this-\nregisterLinkTag([\n    'title' =\n 'Live News for Yii',\n    'rel' =\n 'alternate',\n    'type' =\n 'application/rss+xml',\n    'href' =\n 'http://www.yiiframework.com/rss.xml/',\n]);\n\n\n\nIl codice precedente comporter\u00e0\n\n\nlink title=\"Live News for Yii\" rel=\"alternate\" type=\"application/rss+xml\" href=\"http://www.yiiframework.com/rss.xml/\"\n\n\n\n\nSimile al metodo \nregisterMetaTag()\n, \u00e8 possibile specificare una chiave quando si chiama \nregisterLinkTag()\n per evitare di generare tag di collegamento ripetuti.\n\n\nVisualizzazione degli eventi\n\n\nI componenti di visualizzazione attivano numerosi eventi durante il processo di visualizzazione della vista. E' possibile rispondere a questi eventi per iniettare il contenuto di viste o elaborare i risultati del rendering prima che vengano inviati agli utenti finali.\n\n\n-\nEVENT_BEFORE_RENDER\n: attivato dall'inizio del rendering di un file in un controller. I gestori di questo evento possono impostare \nyii \\ base \\ ViewEvent :: $isValid\n ad essere \nfalse\n per annullare il processo di rendering. \n- \nEVENT_AFTER_RENDER\n: attivato dopo il rendering di un file tramite la chiamata del metodo \nyii \\ base \\ View :: afterRender()\n. I gestori di questo evento possono ottenere il risultato del rendering tramite l'output \nyii \\ base \\ ViewEvent :: $\n e possono modificare questa propriet\u00e0 per modificare il risultato del rendering.\n- \nEVENT_BEGIN_PAGE\n: attivato dalla chiamata del metodo \nyii \\ base \\ View :: beginPage()\n nei layout.\n- \nEVENT_END_PAGE\n: attivato dalla chiamata del metodo \nyii \\ base \\ View :: endPage()\n nei layout.\n- \nEVENT_BEGIN_BODY\n: attivato dalla chiamata del metodo \nyii \\ base \\ View :: beginBody()\n nei layout.\n- \nEVENT_END_BODY\n: attivato dalla chiamata del metodo \nyii \\ base \\ View :: endBody()\n nei layout. \n\n\nAd esempio, il codice seguente applica la data corrente alla fine del corpo della pagina:\n\n\n\\Yii::$app-\nview-\non(View::EVENT_END_BODY, function () {\n    echo date('Y-m-d');\n});\n\n\n\nRendering di pagine statiche\n\n\nLe pagine statiche si riferiscono a quelle pagine Web il cui contenuto principale \u00e8 per lo pi\u00f9 statico senza la necessit\u00e0 di accedere ai dati dinamici trasferiti dai controller.\n\n\nE' possibile generare pagine statiche inserendo il proprio codice nella vista e quindi utilizzando il codice come segue in un controller:\n\n\npublic function actionAbout(){\n\n    return $this-\nrender('about');\n\n}\n\n\n\nSe un sito Web contiene molte pagine statiche, sarebbe molto noioso ripetere il codice simile molte volte. Per risolvere questo problema, \u00e8 possibile introdurre un'azione autonoma denominata \n yii \\ base \\ ViewAction \n in un controller. Per esempio:\n\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public function actions(){\n\n        return [\n            'page' =\n [\n                'class' =\n 'yii\\web\\ViewAction',\n            ],\n        ];\n    }\n}\n\n\n\nOra se crei una vista \nabout\n sotto la directory \n@app/views/site/pages\n, sarai in grado di visualizzare questa vista con il seguente URL:\n\n\nhttp://localhost/index.php?r=site%2Fpage\nview=about\n\n\n\nIl parametro \nview\n passato in modo \nGET\n dice al metodo \nyii \\ web \\ ViewAction\n quale vista \u00e8 richiesta. L'azione cercher\u00e0 quindi questa vista sotto la directory \n@app/views/site/pages\n. E' possibile configurare \nyii \\ web \\ ViewAction :: $viewPrefix\n per modificare la directory per la ricerca di queste viste.",
            "title": "Viste"
        },
        {
            "location": "/application-structure/sub-views/#viste-views",
            "text": "Le viste sono parte dell'architettura MVC. Essi sono responsabili del codice per la presentazione dei dati agli utenti finali. In un'applicazione Web, le visualizzazioni vengono generalmente create in termini di modelli di visualizzazione che sono file di script PHP contenenti principalmente codice HTML e codice PHP. Sono gestiti dalla \"view application component\u201c che fornisce metodi comunemente utilizzati per facilitare la composizione e la visualizzazione delle view.",
            "title": "Viste (views)"
        },
        {
            "location": "/application-structure/sub-views/#creazione-di-viste",
            "text": "Come gi\u00e0 detto, una vista \u00e8 semplicemente uno script PHP mescolato con codice HTML e PHP. Di seguito \u00e8 riportata una vista che presenta un modulo di accesso. Come potete vedere, il codice PHP viene visualizzato per generare contenuto dinamico, come il titolo della pagina e il modulo, mentre il codice HTML li organizza in una pagina HTML presentabile.  ?php\nuse yii\\helpers\\Html;\nuse yii\\widgets\\ActiveForm;\n\n/* @var $this yii\\web\\View */\n/* @var $form yii\\widgets\\ActiveForm */\n/* @var $model app\\models\\LoginForm */\n\n$this- title = 'Login';\n?  h1 ?= Html::encode($this- title) ? /h1  p Please fill out the following fields to login: /p  ?php $form = ActiveForm::begin(); ? \n     ?= $form- field($model, 'username') ? \n     ?= $form- field($model, 'password')- passwordInput() ? \n     ?= Html::submitButton('Login') ?    ?php ActiveForm::end(); ?   All'interno di una vista, \u00e8 possibile accedere a alla variabile  $this , che si riferisce alla gestione della struttura di visualizzazione e al rendering di questo modello di visualizzazione.  Oltre a  this , ci possono essere altre variabili predefinite in una vista, come  $model  nell'esempio precedente.    Tip  Le variabili predefinite sono elencate in un blocco di commento all'inizio di una vista in modo che possano essere riconosciute da IDE. E' anche un buon modo per documentare le tue opinioni.",
            "title": "Creazione di viste"
        },
        {
            "location": "/application-structure/sub-views/#sicurezza",
            "text": "Quando si creano viste che generano pagine HTML, \u00e8 importante che i dati provenienti dagli utenti finali siano controllati. Altrimenti la tua applicazione potrebbe essere soggetta agli attachi di   scripting cross-site  .  Per visualizzare un testo semplice, abbiamo bisogno di codificarlo come prima cosa chiamando   yii \\ helpers \\ Html :: encode()  . Ad esempio, il seguente codice codifica il nome utente prima di visualizzarlo:  ?php\nuse yii\\helpers\\Html;\n?  div class=\"username\" \n     ?= Html::encode($user- name) ?  /div   Per visualizzare il contenuto HTML, utilizzare   yii \\ helpers \\ HtmlPurifier   per filtrare prima il contenuto. Ad esempio, il codice seguente filtra il contenuto postale prima di visualizzarlo:  ?php\nuse yii\\helpers\\HtmlPurifier;\n?  div class=\"post\" \n     ?= HtmlPurifier::process($post- text) ?  /div    Tip  Mentre HTML Purifier fa un ottimo lavoro per rendere l'output sicuro, non \u00e8 veloce. E' opportuno considerare la memorizzazione nella cache del risultato di filtraggio se la tua applicazione richiede elevate prestazioni.",
            "title": "Sicurezza"
        },
        {
            "location": "/application-structure/sub-views/#organizzazione-delle-viste",
            "text": "Come controllers e models, ci sono convenzioni per organizzare le viste:   Per le visualizzazioni rese da un controller, dovrebbero essere posizionate sotto la directory  @app/views/ControllerID  per impostazione predefinita, dove  ControllerID  si riferisce all'ID del controller. Ad esempio, se la classe controller \u00e8  PostController , la directory sarebbe  @app/views/post ; se \u00e8  PostCommentController , la directory sarebbe  app/views/post-comment . Nel caso in cui il controller appartiene a un modulo della directory si troverebbe  views/ControllerID  sotto   yii \\ base \\ Module :: basePath  .  Per le viste rese da un widget, dovrebbero essere posizionate sotto la  WidgetPath/views  directory per impostazione predefinita, dove si trova la directory  WidgetPath  contenente il file della classe widget.  Per le visualizzazioni rese da altri oggetti, si consiglia di seguire la convenzione simile a quella relativa ai widget.   E' possibile personalizzare queste directory di visualizzazione predefinite, usando il metodo   yii \\ base \\ ViewContextInterface :: getViewPath()   dei controller o dei widget.",
            "title": "Organizzazione delle viste"
        },
        {
            "location": "/application-structure/sub-views/#viste-di-rendering",
            "text": "E' possibile restituire visualizzazioni in controller, widget o in qualsiasi altro luogo chiamando metodi di rendering delle visualizzazioni. Questi metodi condividono una firma simile mostrata come segue.  /**\n* @param string $view view name or file path, depending on the actual rendering method\n* @param array $params the data to be passed to the view\n* @return string rendering result\n*/\nmethodName($view, $params = [])",
            "title": "Viste di rendering"
        },
        {
            "location": "/application-structure/sub-views/#rendering-nei-controllori-controller",
            "text": "All'interno dei controllori, \u00e8 possibile chiamare i seguenti metodi di controllo per restituire le view:   render() : restituisce una vista denominata e gli applica un layout al risultato di rendering.  renderPartial() : restituisce una vista denominata senza alcun layout.  renderAjax() : restituisce una vista denominata senza alcun layout e ci aggiunge tutti gli script e file JS / CSS registrati. Viene di solito usato come risposta alle richieste Web di AJAX.  renderFile() : restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.  renderContent() : restituisce una stringa statica incorporandola nel layout attualmente applicabile.   Per esempio:  namespace app\\controllers;\n\nuse Yii;\nuse app\\models\\Post;\nuse yii\\web\\Controller;\nuse yii\\web\\NotFoundHttpException;\n\nclass PostController extends Controller{\n\n    public function actionView($id){\n\n        $model = Post::findOne($id);\n        if ($model === null) {\n            throw new NotFoundHttpException;\n        }\n\n        // renders a view named \"view\" and applies a layout to it\n        return $this- render('view', [\n            'model' =  $model,\n        ]);\n    }\n}",
            "title": "Rendering nei controllori (controller)"
        },
        {
            "location": "/application-structure/sub-views/#rendering-nei-widget",
            "text": "Nei widget \u00e8 possibile chiamare i seguneti widget per restituire le view:   render() : restituisce una vista denominata.  renderFile() : restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.   Per esempio:  namespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass ListWidget extends Widget{\n\n    public $items = [];\n\n    public function run(){\n\n        // renders a view named \"list\"\n        return $this- render('list', [\n            'items' =  $this- items,\n        ]);\n    }\n}",
            "title": "Rendering nei widget"
        },
        {
            "location": "/application-structure/sub-views/#rendering-nelle-viste-view",
            "text": "E' possibile eseguire una visualizzazione in un'altra visione chiamando uno dei seguenti metodi forniti dal \"view component\":   render() : restituisce una vista denominata.  renderAjax() : restituisce una vista denominata e ci aggiunge tutti gli script e file JS / CSS registrati. Viene di solito usato come risposta alle richieste Web di AJAX.  renderFile() : restituisce una vista specificata in termini di percorso o alias del file di visualizzazione.   Ad esempio, il codice riportato di seguito in una visualizzazione restituisce il file di visualizzazione  _overview.php  nella stessa directory della view attualmente resa. Ricorda che  $this  si riferisce al componente stesso di view:  ?= $this- render('_overview') ?",
            "title": "Rendering nelle viste (view)"
        },
        {
            "location": "/application-structure/sub-views/#viste-denominate",
            "text": "Un nome di visualizzazione viene convertito nel percorso del file di viisualizzazzione corrispondente in base alle seguenti regole:   Un nome di visualizzazione pu\u00f2 omettere il nome dell'estensione del file. In questo caso,  .php  verr\u00e0 utilizzato come estensione. Ad esempio, il nome della vista  about  corrisponde al nome del file  about.php .  Se il nome della visualizzazione inizia con  // , il percorso del file corrispondente dovrebbe essere  @app/views/ViewName . Cio\u00e8, la vista viene visualizzata sotto il metodo  viewPath() . Ad esempio, //site/about  verr\u00e0 convertito in  @app/views/site/about.php .  Se il nome della visualizzione inizia con  / , il percorso del file viene formato prefigurando il nome della vista con il metodo  viewPath()  del modulo attualmente attivo. Se non esiste un modulo attivo, verr\u00e0 utilizzato  @app/views/ViewName . Ad esempio,  /user/create  verr\u00e0 convertito in  @aap/modules/views/user/create.php  se attualmente il modulo attivo \u00e8  user . Se non esiste un modulo attivo, il percorso del file di visualizzazione sar\u00e0  @app/views/user/create.php .  Se la vista viene eseguita con un \"context\" e implementa   yii \\ base \\ ViewContextInterface  , il percorso del file di visualizzazione viene formato prefigurando il percorso di visualizzazione del context con il nome della vista. Questo principalmente si applica ai punti di vista resti all'interno di controller e widget. Ad esempio,  about  verr\u00e0 convertito  @app/views/site/about.php  se il contesto \u00e8 il controller  SiteController .  Se una vista viene visualizzata in un'altra visualizzazione, la directory contenente l'altro file di visualizzazione sar\u00e0 il prefisso al nuovo nome di visualizzazione per formare il percorso effettivo. Ad esempio,  item  verr\u00e0 convertito in  @app/views/site/about.php  se viene visualizzato nella vista  @app/views/post/index.php .   Secondo le regole precedenti, la chiamata  $this- render('view')  in un controller  app\\controllers\\PostController  restituir\u00e0 effettivamente il file di visualizzazione  @app/views/post/view.php , mentre quando richiamiamo  $this- render('_overview')  di quella vista restituir\u00e0 il file di visualizzazione  @app/views/post/_overview.php .",
            "title": "Viste denominate"
        },
        {
            "location": "/application-structure/sub-views/#accesso-ai-dati-nelle-viste",
            "text": "Esistono due approcci per accedere ai dati all'interno di una vista: push e pull.  Passando i dati come secondo parametro ai metodi di views, significa che si sta utilizzando l'approccio push. I dati dovrebbero essere rappresentati come una matrice di coppie nome-valore. Quando viene eseguito il rendering della view, la funzione PHP  extract()  viene usata quando voglia che il nostro array venga estratto e associato a variabili distinte nella nostra vista. Ad esempio, il seguente codice di rendering della vista di un controller invier\u00e0 due varabili alla views  report :  $foo = \\  e  $bar = 2 .  echo $this- render('report', [\n    'foo' =  1,\n    'bar' =  2,\n]);  L'approccio pull permetter\u00e0 di recuperare attivamente i dati dalla componente di visualizzazione o da altri oggetti accessibili nelle viste ( ad esempio  Yii::$app ). Utilizzando il seguente codice come esempio, all'interno della vista \u00e8 possibile ottenere l'oggetto controller dall'espressione  $this- context . Di conseguenza, \u00e8 possibile accedere a qualsiasi propriet\u00e0 o metodo del controller nella views di  report , ad esempio l'ID del controller come mostrato di seguito:  The controller ID is:  ?= $this- context- id ?   L'approccio push \u00e8 solitamente il modo preferito perch\u00e8 permette di accedere ai dati delle viste, poich\u00e8 rende le visualizzazioni meno dipendenti dagli oggetti di contesto. Il suo svantaggio \u00e8 che \u00e8 necessario costruire manualmente l'array di dati tutto il tempo, che potrebbe diventare noioso e soggetto a errori se una vista \u00e8 condivisa e resa in luoghi diversi.",
            "title": "Accesso ai dati nelle viste"
        },
        {
            "location": "/application-structure/sub-views/#condivisione-dei-dati-tra-le-viste",
            "text": "Il componente di visualizzazione fornisce la propriet\u00e0  params  che \u00e8 possibile utilizzare per condividere i dati tra le viste. \nAd esempio, in una view  about , \u00e8 possibile avere il seguente codice che specifica il segmento corrente dei breadcrumb.  $this- params['breadcrumbs'][] = 'About Us';  Quando nel file di layout puoi visualizzare i breadcrumb usando i dati passati attraverso parametri:  ?= yii\\widgets\\Breadcrumbs::widget([\n    'links' =  isset($this- params['breadcrumbs']) ? $this- params['breadcrumbs'] : [],\n]) ?",
            "title": "Condivisione dei dati tra le viste"
        },
        {
            "location": "/application-structure/sub-views/#layout",
            "text": "I layout sono un tipo speciale di viste che rappresentano le parti comune di pi\u00f9 viste. Ad esempio, le pagine per la maggior parte delle applicazioni Web condividono la stessa intestazione e il pi\u00e8 di pagina, Mentre \u00e8 possibile ripetere la stessa intestazione e il pi\u00e8 di pagina ad ogni vista, un modo migliore \u00e8 quello di farlo una volta in un layout e poi incorporarlo ad esso.",
            "title": "Layout"
        },
        {
            "location": "/application-structure/sub-views/#creazioen-di-un-layout",
            "text": "I layout sono anche viste, ed essendo delle viste possono essere create come in modo molto simile. Per impostazione predefinita, i layout sono memorizzati nella directory  @app/views/layouts . Per i layout utilizzati all'interno di una modulo, devono essere memorizzati nella directory  views/layouts  sotto  yii \\ base \\ Module :: basePath . E' possibile personalizzare la directory di layout predefinita configurando la propriet\u00e0  yii \\ base \\ Module :: layoutPath  dell'applicazione o dei moduli.  L'esempio seguente mostra come appare un layout. Si noti che a scopo illustrativo, abbiamo notevolmente semplificato il codice nel layout. In pratica, potresti voler aggiungere pi\u00f9 contenuti ad esso, come \"head tag\", menu principale, ecc.  ?php\nuse yii\\helpers\\Html;\n\n/* @var $this yii\\web\\View */\n/* @var $content string */\n?  ?php $this- beginPage() ?  !DOCTYPE html  html lang=\"en\"  head \n     meta charset=\"UTF-8\"/ \n     ?= Html::csrfMetaTags() ? \n     title ?= Html::encode($this- title) ? /title \n     ?php $this- head() ?  /head  body  ?php $this- beginBody() ? \n     header My Company /header \n     ?= $content ? \n     footer copy; 2014 by My Company /footer  ?php $this- endBody() ?  /body  /html  ?php $this- endPage() ?   Come puoi vedere, il layout genera i tag HTML comuni a tutte le pagine. All'interno della sezione  body , il layout richiama la variabile  $content  che rappresenta il risultato del rendering delle viste del contenuto e viene inserito nel layout quando viene chiamato  yii \\ base \\ Controller :: render() .  La maggior parte dei layout dovrebbe chiamare i seguenti metodi come mostrato nel codice sopra. Questi metodi attivano principalmente eventi relativi al processo di rendering in modo che gli script e i tag registrati in altri luoghi possano essere iniettati correttamente nelle posizioni in cui vengono chiamati questi metodi.   beginPage() : questo metodo dovrebbe essere chiamato all'inizio del layout. Si innesca l'evento  l'EVENT_BEGIN_PAGE   che indica l'inizio di una pagina.  endPage() : questo metodo dovrebbe essere chiamato alla file del layout. Si innesca l'evento  l'EVENT_END_PAGE  che indica la fine di una partita.  head() : questo metodo dovrebbe essere chiamato all'interno del tag  head  nella sezione di una pagina HTML. Genera un segnaposto che verr\u00e0 sostituito con il codice HTML head registrato ( ad es. Tag link, meta tag) quando una pagina termina in rendering.  beginBody() : questo metodo dovrebbe essere chiamato all'inizio della sezione  body . Si innesca l'evento  l'EVENT_BEGIN_BODY  e genera una segnaposto che sar\u00e0 sostituito dal codice HTML registrato ( ad es. Javascript()) destinato al corpo del nostro programma.  endBody() : questo metodo dovrebbe essere chiamato alla fine della sezione  body . Si innesca l'evento  l'EVENT_END_BODY  e genera un segnaposto che sar\u00e0 sostituito dal codice HTML registrato  ( ad es. Javascript()) destinato alla posizione finale del corpo del programma.",
            "title": "Creazioen di un layout"
        },
        {
            "location": "/application-structure/sub-views/#accesso-ai-dati-nei-layout",
            "text": "All'interno di un layout, hai accesso a due variabili predefinite:  $this  e  $content , Il primo si riferisce alla componente della vista, come nelle viste normali, mentre il secondo contiene il risultato del rendering di una vista del contenuto che viene renderizzata chiamando il metodo  render()  nei controller.  Se si desidera accedere ad altri dati nei layout, \u00e8 necessario utilizzare il metodo pull ( come descritto nella sottosezione \"Accesso ai dati nella vista ). Se si desidera trasferire dati da una vista di contenuto a un layout, \u00e8 possibile utilizzare il metodo descritto nella sottosezione \"Viste di condivisione dati\".",
            "title": "Accesso ai dati nei layout"
        },
        {
            "location": "/application-structure/sub-views/#utilizzando-i-layout",
            "text": "Come descritto nella sottosezione \"Rendering nei Controller, quando si esegue il rendering di una vista chiamando il metodo  render()  in un controller, verr\u00e0 applicato un layout al risultato del rendering. Per impostazione predefinita, verr\u00e0 utilizzato il layout  @app/views/layouts/main.php .  E' possibile utilizzare un layout diverso configurando il layout  yii \\ base \\ Application :: $  o  yii \\ base \\ Controller :: $ . Il primo regola il layout utilizzato da tutti i controller, mentre il secondo sovrascrive il primo per i singoli controller. Ad esempio, il codice seguente rende il controller  post  da utilizzare come layout durante il rendering delle sue viste. ( url file:  @app/views/layouts/post.php ). Altri controller, supponendo che la loro propriet\u00e0  layout  non sia stata modificata, utilizzeranno comunque  @app/views/layouts/main.php  il layout di default.  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    public $layout = 'post';\n\n    // ...\n}  Per i controllori appartenenti a un modulo, \u00e8 possibile configurare anche la propriet\u00e0 di layout del modulo per utilizzare un particolare layout per questi controller.  Poich\u00e8 la propriet\u00e0  layout  pu\u00f2 essere configurata a diversi livelli ( controller,moduli,applicazione ), dietro la scena, Yii prende due passaggi per determinare qual \u00e8 il file di layout effettivo utilizzato per un particolare controller.  Nel primo passaggio, determina il valore di layout e il modulo di contesto:   Se la propriet\u00e0 di layout del controller   yii \\ base \\ Controller :: $   non \u00e8  null , \u00e8 consigliabile usarlo come valore di layout e il modulo del controller come modulo del contesto.  Se la propriet\u00e0 di layout del controller   yii \\ base \\ Controller :: $   \u00e8  null , conviene cercare tra tutti i moduli degli antenati ( inclusa l'applicazione stessa ) del controller e trovare il primo modulo la cui propriet\u00e0 layout non \u00e8  null . Usa quel modulo e il suo valore di layout come modulo di contesto e valore scelto. Se tale modulo non pu\u00f2 essere trovato, significa che non verr\u00e0 applicato alcun layout.   Nella seconda fase, determina il file di layout effettivo di base al valore di layout e al modulo di contesto determinato nel primo passaggio. Il valore di layout pu\u00f2 essere:   un percorso alias ( es.  @app/views/layouts/main ).  un percorso assoluto ( es.  /main ): il valore del layout inizia con una barra. Il file di layout effettivo verr\u00e0 cercato sotto   yii \\ base \\ Application :: layoutPath   dell'applicazione che viene impostato automaticamente  @app/views/layouts .  un percorso relativo (es.  main ): il file di layout effettivo verr\u00e0 cercato sotto  yii \\ base \\ Module :: layoutPath  del modulo di contesto, che per impostazione predefinita si trova nella directory  views/layouts  sotto   yii \\ base \\ Module :: basePath  .  il valore booleano  false : non verr\u00e0 applicato alcun layout.   Se il valore di layout non contiene un'estensione di file, utilizzer\u00e0 quella predefinita  .php .",
            "title": "Utilizzando i layout"
        },
        {
            "location": "/application-structure/sub-views/#layout-nidificati",
            "text": "A volte potresti voler annidare un layout in un altro. Ad esempio, in diverse sezioni di un sito Web, se si desidera utilizzare layout diversi, mentre tutti questi layout condividono lo stesso layout di base che genera la struttura generale della pagina HTML5. E' possibile raggiungere questo obiettivo chiamando il metodo  beginContent()  e  endContent()  nei layout figli come il seguente:  ?php $this- beginContent('@app/views/layouts/base.php'); ? \n\n...child layout content here... ?php $this- endContent(); ?   Come mostrato sopra, il contenuto del layout figlio deve essere racchiuso tra  beginContent()  e  endContent() . Il parametro passato a  beginContent()  specifica qual \u00e8 il layout principale. Pu\u00f2 essere un file di layout o un alias.   Utilizzando l'approccio sopra, \u00e8 possibile nidificare i layout in pi\u00f9 livelli.",
            "title": "Layout nidificati"
        },
        {
            "location": "/application-structure/sub-views/#usare-i-blocchi",
            "text": "I blocchi consentono di specificare il contenuto della vista in un punto mentre lo si visualizza in un altro. Sono spesso usati insieme ai layout. Ad esempio, \u00e8 possibile definire un blocco in una vista del contenuto e visualizzarlo nel layout.  I metodi si chiamano  beginBlock()  e  endBlock() . E' possibile accedere al blocco tramite  $view- blocks[$blockID] , dove a  $blockID  verr\u00e0 assegnato un ID univoco al momento della sua definizione.  L'esempio seguente mostra come utilizzare i blocchi per personalizzare parti specifiche di un layout in una vista del contenuto.  Innanzitutto, in una vista del contenuto, possiamo definire uno o pi\u00f9 blocchi ( come segue ):  ... ?php $this- beginBlock('block1'); ? \n\n...content of block1... ?php $this- endBlock(); ? \n\n... ?php $this- beginBlock('block3'); ? \n\n...content of block3... ?php $this- endBlock(); ?   Quindi nella vista layout possiamo visualizzare i blocchi se sono disponibili o visualizzare i contenuti predefiniti se un blocco non \u00e8 definito.  ... ?php if (isset($this- blocks['block1'])): ? \n     ?= $this- blocks['block1'] ?  ?php else: ? \n    ... default content for block1 ... ?php endif; ? \n\n... ?php if (isset($this- blocks['block2'])): ? \n     ?= $this- blocks['block2'] ?  ?php else: ? \n    ... default content for block2 ... ?php endif; ? \n\n... ?php if (isset($this- blocks['block3'])): ? \n     ?= $this- blocks['block3'] ?  ?php else: ? \n    ... default content for block3 ... ?php endif; ? \n...",
            "title": "Usare i blocchi"
        },
        {
            "location": "/application-structure/sub-views/#utilizzo-del-view-components",
            "text": "Visualizza componenti ( o View COmponents) offre molte funzionalit\u00e0 relative alla vista. Mentre \u00e8 possibile ottenere i componenti di visualizzazione creando singole istanze di   yii \\ base \\ View   o della relativa classe figlio, nella maggior parte dei casi si utilizzer\u00e0 principalmente il componente  view  dell'applicazione. E' possibile configurare questo componente nella configurazione dell'applicazione come la seguente:  [\n    // ...\n    'components' =  [\n        'view' =  [\n            'class' =  'app\\components\\View',\n        ],\n        // ...\n    ],\n]  i componenti View forniscono le seguenti utili funzionalit\u00e0 relative alla vista, ciascuna descritta in maggiori dettagli in una sezione separata:   tematizzazione(theming) : consente di sviluppare e modificare il tema per il proprio sito Web.  catching dei frammenti : consente di memorizzare nella cache un frammento all'interno di una pagina Web.  gestione degli script client : supporta la registrazione e il rendering di CSS e JavaScript.  gestione dei pacchetti di asset : supporta la registrazione e il rendering di pacchetti e di risorse.  motori di template alternativi : consente di utilizzare altri motori di template, come  Twig ,  Smarty .   E' inoltre possibile utilizzare frequentamente le seguenti funzionalit\u00e0 secondarie ma utili durante lo sviluppo di pagine Web.",
            "title": "Utilizzo del \"View Components\""
        },
        {
            "location": "/application-structure/sub-views/#impostazione-dei-titoli-delle-pagine",
            "text": "Ogni pagina Web dovrebbe avere un titolo. Normalmente il tag del titolo viene visualizzato in un layout. Tuttavia, in pratica il titolo \u00e8 spesso determinato nelle visualizzazioni del contenuto piuttosto che nei layout. Per risolvere questo problema,  yii \\ web \\ View  fornisce la propriet\u00e0  title  per consentire il passaggio delle informazioni sul titolo dalle viste del contenuto ai layout.  Per utilizzare questa funzione, in ciascuna vista del contenuto, \u00e8 possibile impostare il titolo della pagina come segue:  ?php\n$this- title = 'My page title';\n?   Quindi, nei layout, assicurati di avere il seguente codice nella sezione  head :  title ?= Html::encode($this- title) ? /title",
            "title": "Impostazione dei titoli delle pagine"
        },
        {
            "location": "/application-structure/sub-views/#registrazione-dei-meta-tag",
            "text": "Le pagine Web di solito hanno bisogno di generare vari meta tag richiesti da parti diverse. Come i titoli di pagina, i meta tag compaiono nella sezione  head  e di solito sono generati nei layout.  Se si desidera specificare quali metatag generati nelle viste del contenuto, \u00e8 possibile chiamare  yii \\ web \\ View :: registerMetaTag()  in una vista del contenuto, come la seguente:  ?php\n$this- registerMetaTag(['name' =  'keywords', 'content' =  'yii, framework, php']);\n?   Il codice sopra riportato registrer\u00e0 un meta tag \"keywords\" con il componente di visualizzazione. Il meta tag registrato viene visualizzato dopo che il layout ha completato il rendering. Il seguente codice HTML verr\u00e0 generato e inserito nel punto in cui si chiama   yii \\ web \\ View :: head()   nei layout:  meta name=\"keywords\" content=\"yii, framework, php\"   Nota che se chiami pi\u00f9 volte   yii \\ web \\ View :: registerMetaTag()  , registrer\u00e0 pi\u00f9 meta tag, indipendentemente dal fatto che i meta tag siano uguali o meno.\nPer assicurarti che ci sia solo una singola istanza di un tipo di meta tag, puoi specificare una chiave come secondo parametro quando chiami il metodo. Ad esempio, il seguente codice registra due meta tag \"description\".\nTuttavia, verr\u00e0 reso solo il secondo.  $this- registerMetaTag(['name' =  'description', 'content' =  'This is my cool website made with Yii!'], 'description');\n$this- registerMetaTag(['name' =  'description', 'content' =  'This website is about funny raccoons.'], 'description');",
            "title": "Registrazione dei meta tag"
        },
        {
            "location": "/application-structure/sub-views/#registrazione-dei-tag-nei-collegamenti",
            "text": "Come i meta tag, i tag di collegamento sono utili in molti casi, come personalizzare le favicon, puntare al feed RSS. Puoi lavorare con tag di collegamento in modo simile ai meta tag usando   yii \\ web \\ View :: registerLinkTag()  . Ad esempio, in una vista del contenuto, puoi registrare un tag link come segue:  $this- registerLinkTag([\n    'title' =  'Live News for Yii',\n    'rel' =  'alternate',\n    'type' =  'application/rss+xml',\n    'href' =  'http://www.yiiframework.com/rss.xml/',\n]);  Il codice precedente comporter\u00e0  link title=\"Live News for Yii\" rel=\"alternate\" type=\"application/rss+xml\" href=\"http://www.yiiframework.com/rss.xml/\"   Simile al metodo  registerMetaTag() , \u00e8 possibile specificare una chiave quando si chiama  registerLinkTag()  per evitare di generare tag di collegamento ripetuti.",
            "title": "Registrazione dei tag nei collegamenti"
        },
        {
            "location": "/application-structure/sub-views/#visualizzazione-degli-eventi",
            "text": "I componenti di visualizzazione attivano numerosi eventi durante il processo di visualizzazione della vista. E' possibile rispondere a questi eventi per iniettare il contenuto di viste o elaborare i risultati del rendering prima che vengano inviati agli utenti finali.  - EVENT_BEFORE_RENDER : attivato dall'inizio del rendering di un file in un controller. I gestori di questo evento possono impostare  yii \\ base \\ ViewEvent :: $isValid  ad essere  false  per annullare il processo di rendering. \n-  EVENT_AFTER_RENDER : attivato dopo il rendering di un file tramite la chiamata del metodo  yii \\ base \\ View :: afterRender() . I gestori di questo evento possono ottenere il risultato del rendering tramite l'output  yii \\ base \\ ViewEvent :: $  e possono modificare questa propriet\u00e0 per modificare il risultato del rendering.\n-  EVENT_BEGIN_PAGE : attivato dalla chiamata del metodo  yii \\ base \\ View :: beginPage()  nei layout.\n-  EVENT_END_PAGE : attivato dalla chiamata del metodo  yii \\ base \\ View :: endPage()  nei layout.\n-  EVENT_BEGIN_BODY : attivato dalla chiamata del metodo  yii \\ base \\ View :: beginBody()  nei layout.\n-  EVENT_END_BODY : attivato dalla chiamata del metodo  yii \\ base \\ View :: endBody()  nei layout.   Ad esempio, il codice seguente applica la data corrente alla fine del corpo della pagina:  \\Yii::$app- view- on(View::EVENT_END_BODY, function () {\n    echo date('Y-m-d');\n});",
            "title": "Visualizzazione degli eventi"
        },
        {
            "location": "/application-structure/sub-views/#rendering-di-pagine-statiche",
            "text": "Le pagine statiche si riferiscono a quelle pagine Web il cui contenuto principale \u00e8 per lo pi\u00f9 statico senza la necessit\u00e0 di accedere ai dati dinamici trasferiti dai controller.  E' possibile generare pagine statiche inserendo il proprio codice nella vista e quindi utilizzando il codice come segue in un controller:  public function actionAbout(){\n\n    return $this- render('about');\n\n}  Se un sito Web contiene molte pagine statiche, sarebbe molto noioso ripetere il codice simile molte volte. Per risolvere questo problema, \u00e8 possibile introdurre un'azione autonoma denominata   yii \\ base \\ ViewAction   in un controller. Per esempio:  namespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass SiteController extends Controller{\n\n    public function actions(){\n\n        return [\n            'page' =  [\n                'class' =  'yii\\web\\ViewAction',\n            ],\n        ];\n    }\n}  Ora se crei una vista  about  sotto la directory  @app/views/site/pages , sarai in grado di visualizzare questa vista con il seguente URL:  http://localhost/index.php?r=site%2Fpage view=about  Il parametro  view  passato in modo  GET  dice al metodo  yii \\ web \\ ViewAction  quale vista \u00e8 richiesta. L'azione cercher\u00e0 quindi questa vista sotto la directory  @app/views/site/pages . E' possibile configurare  yii \\ web \\ ViewAction :: $viewPrefix  per modificare la directory per la ricerca di queste viste.",
            "title": "Rendering di pagine statiche"
        },
        {
            "location": "/application-structure/sub-modules/",
            "text": "Moduli  (Modules)\n\n\nI moduli sono unit\u00e0 software autonome costituite da modelli, viste, controller e altri componenti di supporto. Gli utenti finali possono accedere ai controller di un modulo quando \u00e8 installato nell'applicazione. Per questi motivi, i moduli sono spesso visti come mini-applicazioni. I moduli differiscono dalle applicazioni in quanto i moduli non possono essere distribuiti da soli e devono risiedere all'interno dell'applicazioni.\n\n\nCreazione di moduli\n\n\nUn modulo \u00e8 organizzato come una directory chiamata \nyii \\ base \\ Module :: base Path\n del modulo. All'interno della directory, ci sono sub-directory, ad esempio \ncontrollers\n,\nmodels\n,\nviews\n, che detengono i controller, i modelli, le viste e altro codice, proprio come in un'applicazione. L'esempio seguente mostra il contenuto all'interno di un modulo:\n\n\nforum/\n    Module.php                   the module class file\n    controllers/                 containing controller class files\n        DefaultController.php    the default controller class file\n    models/                      containing model class files\n    views/                       containing controller view and layout files\n        layouts/                 containing layout view files\n        default/                 containing view files for DefaultController\n            index.php            the index view file\n\n\n\nClassi del modulo\n\n\nOgni modulo dovrebbe avere una classe di modulo univoca che si estende dai \nyii \\ base \\ Module\n. La classe dovrebbe trovarsi direttamente sotto il modulo \nyii \\ base \\ Module :: basePath\n e dovrebbe essere caricabile automaticamente. Quando si accede a un modulo, verr\u00e0 creata una singola istanza della classe modulo corrispondente. Come le istanze dell'applicazione, le istanze del modulo vengono utilizzate per condividere dati e componenti per il codice all'interno dei moduli.\n\n\nQuello che segue \u00e8 un esempio di come pu\u00f2 essere una classe di modulo:\n\n\nnamespace app\\modules\\forum;\n\nclass Module extends \\yii\\base\\Module{\n\n    public function init(){\n\n        parent::init();\n\n        $this-\nparams['foo'] = 'bar';\n        // ...  other initialization code ...\n    }\n}\n\n\n\nSe il metodo \ninit()\n contiene molto codice che inizializza la propriet\u00e0 del modulo, \u00e8 possibile salvarle anche in termini di configurazione e caricarlo con il seguente codice in \ninit()\n:\n\n\npublic function init(){\n\n    parent::init();\n    // initialize the module with the configuration loaded from config.php\n    \\Yii::configure($this, require __DIR__ . '/config.php');\n}\n\n\n\ndove il file di configurazione \nconfig.php\n pu\u00f2 contenere il seguente contenuto, simile a quello in una configurazione dell'applicazione.\n\n\n?php\nreturn [\n    'components' =\n [\n        // list of component configurations\n    ],\n    'params' =\n [\n        // list of parameters\n    ],\n];\n\n\n\nController nei moduli\n\n\nQuando si creano i controller in un modulo, una convenzione consiste nel mettere le classi controller sotto il namespace \ncontrollers\n. Ci\u00f2 significa anche che i file di classe del controller devono essere inseriti nella directory \ncontroller\n all'interno del modulo \nyii \\ base \\ Module :: basePath\n. Ad esempio, per creare un controller \npost\n nel modulo \nforum\n mostrato nell'ultima sottosezione, \u00e8 necessario dichiarare la classe controller come segue:\n\n\nnamespace app\\modules\\forum\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    // ...\n\n}\n\n\n\nE' possibile personalizzare i namespace delle classi controller configurando la propriet\u00e0 \nyii \\ base \\ Module :: $controllerNamespace\n. Nel caso in cui alcuni controller si trovino al di fuori di questi namespaces, \u00e8 possibile renderli accessibili configurando la propriet\u00e0 \nyii \\ base \\ Module :: $controllerMap\n, in modo simile a ci\u00f2 che si fa in un'applicazione.\n\n\nViste nei moduli\n\n\nLe viste in un modulo dovrebbero essere inserite nella directory \nviews\n all'interno del modulo \nyii \\ base \\ Module :: basePath\n. Per le viste visualizzate da un controller nel modulo, devono essere inserite nella directory \nviews/ControllerID\n, dove \nControllerID\n fa riferimento all'ID del controller. Ad esempio, se la classe controller \u00e8 \nPostController\n, la directory dpvrebbe trovarsi in \nviews/post\n all'interno del modulo \nyii \\ base \\ Module :: basePath\n.\n\n\nUn modulo pu\u00f2 specificare un layout che viene applicato alle viste visualizzate dai controller del modulo. Il layout deve essere inserito nella directory \nviews/layouts\n per impostazione predefinita e \u00e8 necessario configurare la propriet\u00e0 \nyii \\ base \\ Module :: $layout\n in modo che punti al nome del layout. Se non si configura la propriet\u00e0 \nlayout\n, verr\u00e0 utilizzato il layout dell'applicazione.\n\n\nComandi della console nei moduli\n\n\nIl tuo modulo potrebbe anche dichiarare comandi, che saranno disponibili attraverso la modalit\u00e0 Console. Affinch\u00e8 l'utilit\u00e0 della riga di comando visualizzi i comandi, sar\u00e0 necessario modificare la propriet\u00e0 \nyii \\ base \\ Module :: $controllerNamespace\n, quando Yii viene eseguito in modalit\u00e0 console e puntarlo verso i namespace dei comandi.\n\n\nUn modo per ottenerlo \u00e8 testare il tipo di istanza dell'applicazione Yii nel metodo \ninit()\n del modulo:\n\n\npublic function init(){\n\n    parent::init();\n    if (Yii::$app instanceof \\yii\\console\\Application) {\n        $this-\ncontrollerNamespace = 'app\\modules\\forum\\commands';\n    }\n}\n\n\n\nI tuoi comandi saranno quindi disponibili dalla riga di comando utilizzando il seguente percorso:\n\n\nyii \nmodule_id\n/\ncommand\n/\nsub_command\n\n\n\n\nUtilizzo dei moduli\n\n\nPer utilizzare un modulo in un'applicazione, \u00e8 sufficiente configurare l'applicazione elencando il modulo nella propriet\u00e0 \nyii \\ base \\ Application :: modules\n dell'applicazione. Il seguente codice nella configurazione dell'applicazione utilizza il modulo \nforum\n:\n\n\n[\n    'modules' =\n [\n        'forum' =\n [\n            'class' =\n 'app\\modules\\forum\\Module',\n            // ... other configurations for the module ...\n        ],\n    ],\n]\n\n\n\nLa propriet\u00e0 \nyii \\ base \\ Application :: modules\n accetta una serie di configurazioni dei moduli. Ogni chiave dell'array rappresenta un ID modulo che identifica in modo univoco il modulo tra tutti i moduli dell'applicazione e il valore dell'array corrispondente \u00e8 una configurazione per la creazione del modulo.\n\n\nItinerari\n\n\nCome riusciamo ad accedere ai controller in un'applicazione, allora stesso modo, i percorsi vengono utilizzati per indirizzare i controller in un modulo. Una rotta per un controller all'interno di un modulo deve ininziare con l'ID modulo seguito dall'ID controller e dall'ID azione. Ad esempio, se un'applicazione utilizza un modulo denominato \nforum\n, la rotta \nforum/post/index\n rappresenterebbe l'azione \nindex\n del \npost\n controller nel modulo. Se la route contiene solo l'ID del modulo, la propriet\u00e0 \nyii \\ base \\ Module :: $defaultRoute\n, che per impostazione predefinit\u00e0 sar\u00e0 \ndefault\n, determiner\u00e0 quale controller/azione deve essere utilizzato. Ci\u00f2 significa che un percorso \nforum\n rappresenterebbe il \ndefault\ncontroller nel modulo \nforum\n.\n\n\nAccesso ai moduli\n\n\nAll'interno di un modulo, potrebbe essere spesso necessario ottenere l'istanza della classe del modulo in modo che sia possibile accedere all'ID del modulo, ai parametri del modulo, ai componenti del modulo, ecc. E' possibile farlo utilizzando la seguente dichiarazione:\n\n\n$module = MyModuleClass::getInstance();\n\n\n\ndove \nMyModuleClass\n si riferisce al nome della classe del modulo a cui sei interessato. Il metodo \ngetIstance()\n restituir\u00e0 l'istanza attualmente richiesta della classe del modulo. Se il modulo non viene richiesto, il metodo restituir\u00e0 \nnull\n. Si noti che non si desidera creare manualmente una nuova istanza della classe modulo perch\u00e8 sar\u00e0 diversa da quella creata da Yii in risposta a una richiesta.\n\n\n\n\nNote\n\n\nQuando si sviluppa un modulo, non si deve presumente che il modulo utilizzer\u00e0 un ID fisso. Questo perch\u00e8 un modulo pu\u00f2 essere associato a un ID arbitrario quando viene utilizzato in un'applicazione o in un altro modulo. Per ottenere l'ID del modulo, \u00e8 necessario utilizzare l'approccio descritto in precedenza per ottenere prima l'istanza del modulo, e quindi ottenere l'ID tramite \n$module-\nid\n.\n\n\n\n\nPuoi anche accedere all'istanza di un modulo usando i seguenti approcci:\n\n\n// get the child module whose ID is \"forum\"\n$module = \\Yii::$app-\ngetModule('forum');\n\n// get the module to which the currently requested controller belongs\n$module = \\Yii::$app-\ncontroller-\nmodule;\n\n\n\nIl primo approccio \u00e8 utile solo quando si conosce l'ID del modulo, mentre il secondo approccio \u00e8 pi\u00f9 utile quando si conoscono i controller richiesti.\n\n\nUna volta ottenuta l'istanza del modulo, \u00e8 possibile accedere ai parametri e ai componenti registrati con il modulo.\nPer esempio:\n\n\n$maxPostCount = $module-\nparams['maxPostCount'];\n\n\n\nModuli di bootstrap\n\n\nAlcuni moduli potrebbero essere eseguiti per ogni richiesta. Il modulo di debug \u00e8 un esempio. Per fare ci\u00f2, dobbiamo elencare gli ID di tali moduli nella propriet\u00e0 \nbootstrap\n dell'applicazione.\n\n\nAd esempio, la seguente configurazione dell'applicazione assicura che il modulo \ndebug\n sia sempre caricato:\n\n\n[\n    'bootstrap' =\n [\n        'debug',\n    ],\n\n    'modules' =\n [\n        'debug' =\n 'yii\\debug\\Module',\n    ],\n]\n\n\n\nModuli annidati\n\n\nI moduli possono essere annidati a livelli illimitati. Cio\u00e8, un modulo pu\u00f2 contenere un altro modulo che pu\u00f2 contenere a sua volta un altro modulo. Chiamiamo il precedente \"modulo padre\" mentre il secondo \"modulo figlio\". I moduli figli devono essere dichiarati nella propriet\u00e0 \nyii \\ base \\ Module :: modules\n dei rispettivi moduli genitori. \n\n\nPer esempio:\n\n\nnamespace app\\modules\\forum;\n\nclass Module extends \\yii\\base\\Module{\n\n    public function init(){\n\n        parent::init();\n\n        $this-\nmodules = [\n            'admin' =\n [\n                // you should consider using a shorter namespace here!\n                'class' =\n 'app\\modules\\forum\\modules\\admin\\Module',\n            ],\n        ];\n    }\n}\n\n\n\nPer un controller al'interno di un modulo nidificato, la sua route dovrebbe includere gli ID di tutti i suoi moduli antenati. Ad esempio, la rotta \nforum/admin/dashboard/index\n rappresenta l'azione \nindex\n del controller \ndashboard\n nel modulo \nadmin\n che \u00e8 un modulo figlio del modulo \nforum\n.\n\n\n\n\nNote\n\n\nil metodo \ngetModule()\n restituisce solo il modulo figlio che appartiene direttamente al suo genitore. La propriet\u00e0 \nyii \\ base \\ Application :: $loadedModules\n mantiene un elenco di moduli caricati, compresi i bambini diretti e quelli nidificati, indicizzati dai loro nomi di classe.\n\n\n\n\nAccessi ai componenti all'interno dei moduli\n\n\nLa versione 2.0.13 supporta l'attraversamento dell'albero. Ci\u00f2 consente agli sviluppatori di fare riferimento a componenti (applicazioni) tramite il localizzatore di servizio che \u00e8 il loro modulo. Ci\u00f2 significa che \u00e8 preferibile utilizzare \n$module-\nget('db')\n oltre \nYii::$app-\nget('db')\n. L'utente di un modulo \u00e8 in grado di specificare un componente specifico da utilizzare per il modulo nel caso sia necessario un componente diverso (configurazione).\n\n\nAd esempio, considera questa configurazione dell'applicazione:\n\n\n'components' =\n [\n    'db' =\n [\n        'tablePrefix' =\n 'main_',\n    ],\n],\n'modules' =\n [\n    'mymodule' =\n [\n        'components' =\n [\n            'db' =\n [\n                'tablePrefix' =\n 'module_',\n            ],\n        ],\n    ],\n],\n\n\n\nLe tabelle del database dell'applicazione saranno precedute da prefisso con \nmain_\n tutte le tabelle dei moduli \nmodule_\n.",
            "title": "Moduli"
        },
        {
            "location": "/application-structure/sub-modules/#moduli-modules",
            "text": "I moduli sono unit\u00e0 software autonome costituite da modelli, viste, controller e altri componenti di supporto. Gli utenti finali possono accedere ai controller di un modulo quando \u00e8 installato nell'applicazione. Per questi motivi, i moduli sono spesso visti come mini-applicazioni. I moduli differiscono dalle applicazioni in quanto i moduli non possono essere distribuiti da soli e devono risiedere all'interno dell'applicazioni.",
            "title": "Moduli  (Modules)"
        },
        {
            "location": "/application-structure/sub-modules/#creazione-di-moduli",
            "text": "Un modulo \u00e8 organizzato come una directory chiamata  yii \\ base \\ Module :: base Path  del modulo. All'interno della directory, ci sono sub-directory, ad esempio  controllers , models , views , che detengono i controller, i modelli, le viste e altro codice, proprio come in un'applicazione. L'esempio seguente mostra il contenuto all'interno di un modulo:  forum/\n    Module.php                   the module class file\n    controllers/                 containing controller class files\n        DefaultController.php    the default controller class file\n    models/                      containing model class files\n    views/                       containing controller view and layout files\n        layouts/                 containing layout view files\n        default/                 containing view files for DefaultController\n            index.php            the index view file",
            "title": "Creazione di moduli"
        },
        {
            "location": "/application-structure/sub-modules/#classi-del-modulo",
            "text": "Ogni modulo dovrebbe avere una classe di modulo univoca che si estende dai  yii \\ base \\ Module . La classe dovrebbe trovarsi direttamente sotto il modulo  yii \\ base \\ Module :: basePath  e dovrebbe essere caricabile automaticamente. Quando si accede a un modulo, verr\u00e0 creata una singola istanza della classe modulo corrispondente. Come le istanze dell'applicazione, le istanze del modulo vengono utilizzate per condividere dati e componenti per il codice all'interno dei moduli.  Quello che segue \u00e8 un esempio di come pu\u00f2 essere una classe di modulo:  namespace app\\modules\\forum;\n\nclass Module extends \\yii\\base\\Module{\n\n    public function init(){\n\n        parent::init();\n\n        $this- params['foo'] = 'bar';\n        // ...  other initialization code ...\n    }\n}  Se il metodo  init()  contiene molto codice che inizializza la propriet\u00e0 del modulo, \u00e8 possibile salvarle anche in termini di configurazione e caricarlo con il seguente codice in  init() :  public function init(){\n\n    parent::init();\n    // initialize the module with the configuration loaded from config.php\n    \\Yii::configure($this, require __DIR__ . '/config.php');\n}  dove il file di configurazione  config.php  pu\u00f2 contenere il seguente contenuto, simile a quello in una configurazione dell'applicazione.  ?php\nreturn [\n    'components' =  [\n        // list of component configurations\n    ],\n    'params' =  [\n        // list of parameters\n    ],\n];",
            "title": "Classi del modulo"
        },
        {
            "location": "/application-structure/sub-modules/#controller-nei-moduli",
            "text": "Quando si creano i controller in un modulo, una convenzione consiste nel mettere le classi controller sotto il namespace  controllers . Ci\u00f2 significa anche che i file di classe del controller devono essere inseriti nella directory  controller  all'interno del modulo  yii \\ base \\ Module :: basePath . Ad esempio, per creare un controller  post  nel modulo  forum  mostrato nell'ultima sottosezione, \u00e8 necessario dichiarare la classe controller come segue:  namespace app\\modules\\forum\\controllers;\n\nuse yii\\web\\Controller;\n\nclass PostController extends Controller{\n\n    // ...\n\n}  E' possibile personalizzare i namespace delle classi controller configurando la propriet\u00e0  yii \\ base \\ Module :: $controllerNamespace . Nel caso in cui alcuni controller si trovino al di fuori di questi namespaces, \u00e8 possibile renderli accessibili configurando la propriet\u00e0  yii \\ base \\ Module :: $controllerMap , in modo simile a ci\u00f2 che si fa in un'applicazione.",
            "title": "Controller nei moduli"
        },
        {
            "location": "/application-structure/sub-modules/#viste-nei-moduli",
            "text": "Le viste in un modulo dovrebbero essere inserite nella directory  views  all'interno del modulo  yii \\ base \\ Module :: basePath . Per le viste visualizzate da un controller nel modulo, devono essere inserite nella directory  views/ControllerID , dove  ControllerID  fa riferimento all'ID del controller. Ad esempio, se la classe controller \u00e8  PostController , la directory dpvrebbe trovarsi in  views/post  all'interno del modulo  yii \\ base \\ Module :: basePath .  Un modulo pu\u00f2 specificare un layout che viene applicato alle viste visualizzate dai controller del modulo. Il layout deve essere inserito nella directory  views/layouts  per impostazione predefinita e \u00e8 necessario configurare la propriet\u00e0  yii \\ base \\ Module :: $layout  in modo che punti al nome del layout. Se non si configura la propriet\u00e0  layout , verr\u00e0 utilizzato il layout dell'applicazione.",
            "title": "Viste nei moduli"
        },
        {
            "location": "/application-structure/sub-modules/#comandi-della-console-nei-moduli",
            "text": "Il tuo modulo potrebbe anche dichiarare comandi, che saranno disponibili attraverso la modalit\u00e0 Console. Affinch\u00e8 l'utilit\u00e0 della riga di comando visualizzi i comandi, sar\u00e0 necessario modificare la propriet\u00e0  yii \\ base \\ Module :: $controllerNamespace , quando Yii viene eseguito in modalit\u00e0 console e puntarlo verso i namespace dei comandi.  Un modo per ottenerlo \u00e8 testare il tipo di istanza dell'applicazione Yii nel metodo  init()  del modulo:  public function init(){\n\n    parent::init();\n    if (Yii::$app instanceof \\yii\\console\\Application) {\n        $this- controllerNamespace = 'app\\modules\\forum\\commands';\n    }\n}  I tuoi comandi saranno quindi disponibili dalla riga di comando utilizzando il seguente percorso:  yii  module_id / command / sub_command",
            "title": "Comandi della console nei moduli"
        },
        {
            "location": "/application-structure/sub-modules/#utilizzo-dei-moduli",
            "text": "Per utilizzare un modulo in un'applicazione, \u00e8 sufficiente configurare l'applicazione elencando il modulo nella propriet\u00e0  yii \\ base \\ Application :: modules  dell'applicazione. Il seguente codice nella configurazione dell'applicazione utilizza il modulo  forum :  [\n    'modules' =  [\n        'forum' =  [\n            'class' =  'app\\modules\\forum\\Module',\n            // ... other configurations for the module ...\n        ],\n    ],\n]  La propriet\u00e0  yii \\ base \\ Application :: modules  accetta una serie di configurazioni dei moduli. Ogni chiave dell'array rappresenta un ID modulo che identifica in modo univoco il modulo tra tutti i moduli dell'applicazione e il valore dell'array corrispondente \u00e8 una configurazione per la creazione del modulo.",
            "title": "Utilizzo dei moduli"
        },
        {
            "location": "/application-structure/sub-modules/#itinerari",
            "text": "Come riusciamo ad accedere ai controller in un'applicazione, allora stesso modo, i percorsi vengono utilizzati per indirizzare i controller in un modulo. Una rotta per un controller all'interno di un modulo deve ininziare con l'ID modulo seguito dall'ID controller e dall'ID azione. Ad esempio, se un'applicazione utilizza un modulo denominato  forum , la rotta  forum/post/index  rappresenterebbe l'azione  index  del  post  controller nel modulo. Se la route contiene solo l'ID del modulo, la propriet\u00e0  yii \\ base \\ Module :: $defaultRoute , che per impostazione predefinit\u00e0 sar\u00e0  default , determiner\u00e0 quale controller/azione deve essere utilizzato. Ci\u00f2 significa che un percorso  forum  rappresenterebbe il  default controller nel modulo  forum .",
            "title": "Itinerari"
        },
        {
            "location": "/application-structure/sub-modules/#accesso-ai-moduli",
            "text": "All'interno di un modulo, potrebbe essere spesso necessario ottenere l'istanza della classe del modulo in modo che sia possibile accedere all'ID del modulo, ai parametri del modulo, ai componenti del modulo, ecc. E' possibile farlo utilizzando la seguente dichiarazione:  $module = MyModuleClass::getInstance();  dove  MyModuleClass  si riferisce al nome della classe del modulo a cui sei interessato. Il metodo  getIstance()  restituir\u00e0 l'istanza attualmente richiesta della classe del modulo. Se il modulo non viene richiesto, il metodo restituir\u00e0  null . Si noti che non si desidera creare manualmente una nuova istanza della classe modulo perch\u00e8 sar\u00e0 diversa da quella creata da Yii in risposta a una richiesta.   Note  Quando si sviluppa un modulo, non si deve presumente che il modulo utilizzer\u00e0 un ID fisso. Questo perch\u00e8 un modulo pu\u00f2 essere associato a un ID arbitrario quando viene utilizzato in un'applicazione o in un altro modulo. Per ottenere l'ID del modulo, \u00e8 necessario utilizzare l'approccio descritto in precedenza per ottenere prima l'istanza del modulo, e quindi ottenere l'ID tramite  $module- id .   Puoi anche accedere all'istanza di un modulo usando i seguenti approcci:  // get the child module whose ID is \"forum\"\n$module = \\Yii::$app- getModule('forum');\n\n// get the module to which the currently requested controller belongs\n$module = \\Yii::$app- controller- module;  Il primo approccio \u00e8 utile solo quando si conosce l'ID del modulo, mentre il secondo approccio \u00e8 pi\u00f9 utile quando si conoscono i controller richiesti.  Una volta ottenuta l'istanza del modulo, \u00e8 possibile accedere ai parametri e ai componenti registrati con il modulo.\nPer esempio:  $maxPostCount = $module- params['maxPostCount'];",
            "title": "Accesso ai moduli"
        },
        {
            "location": "/application-structure/sub-modules/#moduli-di-bootstrap",
            "text": "Alcuni moduli potrebbero essere eseguiti per ogni richiesta. Il modulo di debug \u00e8 un esempio. Per fare ci\u00f2, dobbiamo elencare gli ID di tali moduli nella propriet\u00e0  bootstrap  dell'applicazione.  Ad esempio, la seguente configurazione dell'applicazione assicura che il modulo  debug  sia sempre caricato:  [\n    'bootstrap' =  [\n        'debug',\n    ],\n\n    'modules' =  [\n        'debug' =  'yii\\debug\\Module',\n    ],\n]",
            "title": "Moduli di bootstrap"
        },
        {
            "location": "/application-structure/sub-modules/#moduli-annidati",
            "text": "I moduli possono essere annidati a livelli illimitati. Cio\u00e8, un modulo pu\u00f2 contenere un altro modulo che pu\u00f2 contenere a sua volta un altro modulo. Chiamiamo il precedente \"modulo padre\" mentre il secondo \"modulo figlio\". I moduli figli devono essere dichiarati nella propriet\u00e0  yii \\ base \\ Module :: modules  dei rispettivi moduli genitori.   Per esempio:  namespace app\\modules\\forum;\n\nclass Module extends \\yii\\base\\Module{\n\n    public function init(){\n\n        parent::init();\n\n        $this- modules = [\n            'admin' =  [\n                // you should consider using a shorter namespace here!\n                'class' =  'app\\modules\\forum\\modules\\admin\\Module',\n            ],\n        ];\n    }\n}  Per un controller al'interno di un modulo nidificato, la sua route dovrebbe includere gli ID di tutti i suoi moduli antenati. Ad esempio, la rotta  forum/admin/dashboard/index  rappresenta l'azione  index  del controller  dashboard  nel modulo  admin  che \u00e8 un modulo figlio del modulo  forum .   Note  il metodo  getModule()  restituisce solo il modulo figlio che appartiene direttamente al suo genitore. La propriet\u00e0  yii \\ base \\ Application :: $loadedModules  mantiene un elenco di moduli caricati, compresi i bambini diretti e quelli nidificati, indicizzati dai loro nomi di classe.",
            "title": "Moduli annidati"
        },
        {
            "location": "/application-structure/sub-modules/#accessi-ai-componenti-allinterno-dei-moduli",
            "text": "La versione 2.0.13 supporta l'attraversamento dell'albero. Ci\u00f2 consente agli sviluppatori di fare riferimento a componenti (applicazioni) tramite il localizzatore di servizio che \u00e8 il loro modulo. Ci\u00f2 significa che \u00e8 preferibile utilizzare  $module- get('db')  oltre  Yii::$app- get('db') . L'utente di un modulo \u00e8 in grado di specificare un componente specifico da utilizzare per il modulo nel caso sia necessario un componente diverso (configurazione).  Ad esempio, considera questa configurazione dell'applicazione:  'components' =  [\n    'db' =  [\n        'tablePrefix' =  'main_',\n    ],\n],\n'modules' =  [\n    'mymodule' =  [\n        'components' =  [\n            'db' =  [\n                'tablePrefix' =  'module_',\n            ],\n        ],\n    ],\n],  Le tabelle del database dell'applicazione saranno precedute da prefisso con  main_  tutte le tabelle dei moduli  module_ .",
            "title": "Accessi ai componenti all'interno dei moduli"
        },
        {
            "location": "/application-structure/sub-filters/",
            "text": "Filtri (filters)\n\n\nI filtri sono oggetti che vengono eseguiti prima e / o dopo le azioni del controllore. Ad esempio, un filtro di controllo dell'accesso pu\u00f2 essere eseguito dalle azioni per garantire che sia loro consentito l'accesso da parte di determinati utenti finali; un filtro di compressione del contenuto pu\u00f2 essere eseguito dopo le azioni per comptrimere il contenuto della risposta prima di inviarlo agli utenti finali.\n\n\nUn filtro pu\u00f2 consistere in un pre-filtro (logica di filtraggio applicata prima delle azioni) e / o un post-filtro (logica applicata dopo le azioni).\n\n\nUtilizzando i filtri\n\n\nI filtri ahnno un comportamente abbastanza particolare. Pertanto, l'uso dei filtri \u00e8 uguale all'utilizzo dei \"behaviors\".E' possibile dichiarare i filtri di una classe controller sovrascrivendo il suo metodo \nbehaviors()\n come il seguente:\n\n\npublic function behaviors(){\n\n    return [\n        [\n            'class' =\n 'yii\\filters\\HttpCache',\n            'only' =\n ['index', 'view'],\n            'lastModified' =\n function ($action, $params) {\n                $q = new \\yii\\db\\Query();\n                return $q-\nfrom('user')-\nmax('updated_at');\n            },\n        ],\n    ];\n}\n\n\n\nPer impostazione predefinita, i filtri dichiarati in una classe controller verranno applicati a tutte le azioni in quel controller. Tuttavia, \u00e8 possibile specificare esplicitamente a quali azioni applicare il filtro configurando la propriet\u00e0 \nonly\n. Nell'esempio soprastante, il filtro \nHttpCache\n si applica solo alle azioni \nindex\n e \nview\n. E' anche possibile configurare la propriet\u00e0 \nexcept\n per mettere in blacklist alcune azioni dell'essere filtrate.\n\n\noltre ai controller, puoi anche dichiarare i filtri in un modulo o in un'applicazione. Quando lo fa, i filtri verranno applicate tutte le azioni di controllo che appartengono a tale modulo o applicazione, a meno che non si configurano i filtri \"only\" e \"except\" come descritto sopra.\n\n\n\n\nWarning\n\n\nQuando si dichiara filtri in moduli o applicazioni, \u00e8 necessario utilizzare percorsi invece di ID di azione nelle propriet\u00e0 \nonly\n e \nexcept\n. Questo perch\u00e8 gli ID d'azione da solo non possono specificare completamente le azioni nell'ambito di un modulo o di un'applicazione.\n\n\n\n\nQuando pi\u00f9 filtri sono configurati per una singola azione, vengnono applicati in base alle regole descritte di seguito:\n\n\n\n\nPre-filtraggio\n\n\nApplicare i filtri dichiarati nell'applicazione nell'ordine in cui sono elencati \nbehaviors()\n.\n\n\nApplicare i filtri dichiarati nel modulo nell'ordine in cui sono elencati \nbehaviors()\n.\n\n\nApplicare i filtri dichiarati nel controller nell'ordine in cui sono elencati \nbehaviors()\n.\n\n\nSe uno qualsiasi dei filtri annulla l'esecuzione dell'azione, i filtri (prefiltri e post-filtri) non verranno applicati.\n\n\n\n\n\n\nEsecuzione dell'azione de passa per il pre-filtro.\n\n\nPost-filtraggio\n\n\nApplicare i filtri dichiarati nel controller nell'ordine inverso in cui sono elencati \nbehaviors()\n.\n\n\nApplicare i filtri dichiarati nel modulo nell'ordine inverso in cui sono elencati \nbehaviors()\n.\n\n\nApplicare i filtri dichiarati nell'applicazione nell'ordine inverso in cui sono elencati \nbehaviors()\n.\n\n\n\n\n\n\n\n\nCreazione di filtri\n\n\nPer creare un nuovo filtro azione, dobbiamo estenderlo da \nyii \\ base \\ ActionFilter\n e sovrascrivi i metodi \nbeforeAction()\n e / o \nafterAction()\n. Il primo verr\u00e0 eseguito prima dell'esecuzione di un'azione mentre il secondo dopo l'esecuzione di un'azione. Il valore di ritorno di \nbeforeAction()\n determina se un'azione deve essere eseguita o meno. Se il valore \u00e8 \nfalse\n, i filtri dopo questo verranno saltati e l'azione non verr\u00e0 eseguita.\n\n\nL'esempio seguente mostra un filtro che registra il tempo di esecuzione dell'azione:\n\n\nnamespace app\\components;\n\nuse Yii;\nuse yii\\base\\ActionFilter;\n\nclass ActionTimeFilter extends ActionFilter{\n\n    private $_startTime;\n\n    public function beforeAction($action){\n\n        $this-\n_startTime = microtime(true);\n        return parent::beforeAction($action);\n    }\n\n    public function afterAction($action, $result){\n\n        $time = microtime(true) - $this-\n_startTime;\n        Yii::trace(\"Action '{$action-\nuniqueId}' spent $time second.\");\n        return parent::afterAction($action, $result);\n    }\n}\n\n\n\nFiltri principali\n\n\nYii fornisce un set di filtri comunemente usati, trovati principalmente sotto il namespace \nyii\\filters\n. Di seguit, introdurremo brevemente questi filtri.\n\n\nControllo all'accesso\n\n\nAccessControl\n fornisce un semplice controllo degli accessi basato su un insieme di regole. In particolare, prima che un'azione venga eseguita, AccessControl esaminer\u00e0 le regole elencate e trover\u00e0 il primo che corrisponde alle variabili di contesto correnti (come l'indirizzo IP dell'utente, lo stato di accesso dell'utente, ecc..). La regola di corrispondenza determiner\u00e0 se consentire o negare l'esecuzione dell'azione richiesta. Se nessuna regola corrisponde, l'accesso verr\u00e0 negato.\n\n\nL'esempio seguente mostra come consentire agli utenti autenticati di accedere alle azione \ncreate\n e \nupdate\n, mentre negando tutti gli altri utenti di accedere a queste due azioni.\n\n\nuse yii\\filters\\AccessControl;\n\npublic function behaviors(){\n\n    return [\n        'access' =\n [\n            'class' =\n AccessControl::className(),\n            'only' =\n ['create', 'update'],\n            'rules' =\n [\n                // allow authenticated users\n                [\n                    'allow' =\n true,\n                    'roles' =\n ['@'],\n                ],\n                // everything else is denied by default\n            ],\n        ],\n    ];\n}\n\n\n\nFiltri del metodo di autenticazione\n\n\nI filtri del metodo di autenticazione vengono utilizzati per autenticare un utente utilizzando vari metodi, come \nHTTP Basic Auth\n, \nOAuth 2\n. Queste classi di filtri sono tutte sotto il namespace \nyii\\filters\\auth\n.\n\n\nL'esempio seguente mostra come utilizzare \nyii \\ filters \\ auth \\ HttpBasicAuth\n per autenticare un utente utilizzando un token di accesso basato sul metodo di autenticazione HTTP di base. Si noti che affinch\u00e8 funzioni, la classe di identit\u00e0 dell'utente deve implementare il metodo \nfindIdentityByAccessToken()\n.\n\n\nuse yii\\filters\\auth\\HttpBasicAuth;\n\npublic function behaviors(){\n\n    return [\n        'basicAuth' =\n [\n            'class' =\n HttpBasicAuth::className(),\n        ],\n    ];\n}\n\n\n\nI filtri del metodo di autenticazione sono comunemente usati nell'implementazione delle API Restful.\n\n\nContentNegotiator\n\n\nContentNegotiator\n supporta la negoziazione del formato di risposta e la negoziazione della lingua dell'applicazione. Prover\u00e0 a determinare il formato di risposta e / o la lingua esaminando i parametri \nGET\n e l'intestazione HTTP \nAccept\n.\n\n\nNell'esempio seguente, ContentNegotiator \u00e8 configurato per supportare i formati di risposta JSON e XML e le lingue inglese (Stati Uniti) e tedesca.\n\n\nuse yii\\filters\\ContentNegotiator;\nuse yii\\web\\Response;\n\n\npublic function behaviors(){\n\n    return [\n        [\n            'class' =\n ContentNegotiator::className(),\n            'formats' =\n [\n                'application/json' =\n Response::FORMAT_JSON,\n                'application/xml' =\n Response::FORMAT_XML,\n            ],\n            'languages' =\n [\n                'en-US',\n                'de',\n            ],\n        ],\n    ];\n}\n\n\n\nSpesso i formati e le lingue di risposta devono essere determinati molto prima durante il ciclo di vita dell'applicazione. Per questo motivo, ContentNegotiator \u00e8 progettato in modo tale da poter essere utilizzato anche come componente di bootstrap oltre a essere utilizzato come filtro. Ad esempio, puoi configurarlo nella configurazione dell'applicazione come segue:\n\n\nuse yii\\filters\\ContentNegotiator;\nuse yii\\web\\Response;\n\n[\n    'bootstrap' =\n [\n        [\n            'class' =\n ContentNegotiator::className(),\n            'formats' =\n [\n                'application/json' =\n Response::FORMAT_JSON,\n                'application/xml' =\n Response::FORMAT_XML,\n            ],\n            'languages' =\n [\n                'en-US',\n                'de',\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nNote\n\n\nNel caso in cui il tipo di contenuto e la lingua preferiti non possano essere determinati da una richiesta, verranno utilizzati il primo formato e la lingua elencati nei campi \nformats\n e \nlanguages\n.\n\n\n\n\nHttpCache\n\n\nHttpCache\n implementa il caching sul lato client utilizzando le intestazioni HTTP \nLast-Modified\n e \nEtag\n.\nPer esempio:\n\n\nuse yii\\filters\\HttpCache;\n\npublic function behaviors(){\n\n    return [\n        [\n            'class' =\n HttpCache::className(),\n            'only' =\n ['index'],\n            'lastModified' =\n function ($action, $params) {\n                $q = new \\yii\\db\\Query();\n                return $q-\nfrom('user')-\nmax('updated_at');\n            },\n        ],\n    ];\n}\n\n\n\nPageCache\n\n\nPageCache\n implementa il catching lato server di pagine intere. Nell'esempio seguente, PageCache viene applicato all'azione \nindex\n per memorizzare nella cache l'intera pagina per un massimo di 60 secondi o finch\u00e8 il conteggio delle voci nella tabella \npost\n non cambia. Memorizza anche diverse versioni della pagina a seconda della lingua dell'applicazione scelta.\n\n\nuse yii\\filters\\PageCache;\nuse yii\\caching\\DbDependency;\n\npublic function behaviors(){\n\n    return [\n        'pageCache' =\n [\n            'class' =\n PageCache::className(),\n            'only' =\n ['index'],\n            'duration' =\n 60,\n            'dependency' =\n [\n                'class' =\n DbDependency::className(),\n                'sql' =\n 'SELECT COUNT(*) FROM post',\n            ],\n            'variations' =\n [\n                \\Yii::$app-\nlanguage,\n            ]\n        ],\n    ];\n}\n\n\n\nRateLimiter\n\n\nRateLimiter\n implementa un algoritmo di limitazione della velocit\u00e0 basato sull'algoritmo \nleaky bucket\n. Viene principalmente utilizzato nell'implementazione di ApiRESTful.\n\n\nVerbFilter\n\n\nVerbFilter\n controlla se i metodi di richiesta HTTP sono consentiti dalle azioni richieste. Se non \u00e8 consentito, generer\u00e0 un'eccezione HTTP 405. Nell'esempio seguente, VerbFIlter viene dichiarato per specificare un set tipico di metodi di richiesta consentiti per le azioni CRUD.\n\n\nuse yii\\filters\\VerbFilter;\n\npublic function behaviors(){\n\n    return [\n        'verbs' =\n [\n            'class' =\n VerbFilter::className(),\n            'actions' =\n [\n                'index'  =\n ['get'],\n                'view'   =\n ['get'],\n                'create' =\n ['get', 'post'],\n                'update' =\n ['get', 'put', 'post'],\n                'delete' =\n ['post', 'delete'],\n            ],\n        ],\n    ];\n}\n\n\n\nCors\n\n\nCondivisione delle risorse tra origini \nCORS\n \u00e8 un meccanismo che consente a molte risorse (ad es. Caratters, JavaScript, ecc..). Su una pagina Web di essere richieste da un altro dominio al di fuori del dominio da cui proviene la risorsa. In particolare, le chiamate AJAX di JavaScript possono utilizzare il meccanismo XMLHttpRequest. Tali richieste \"interdominio\" sarebbero altrimenti vietate dai browser Web, secondo la stessa politica di sicurezza dell'origine. CORS definisce un modo in cui il browser e il server possono interagire per determinare se consentire o meno la richiesta di origine incrociata.\n\n\nIl \nfiltro Cors\n deve essere definito prima dei filtri di autenticazione / autorizzazione per assicurarsi che le intestazioni CORS vengano sempre inviate.\n\n\nuse yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n\n    return ArrayHelper::merge([\n        [\n            'class' =\n Cors::className(),\n        ],\n    ], parent::behaviors());\n}\n\n\n\nControllare anche la sezione sui controller REST se si desidera aggiungere il filtro CORS a una classe \nyii \\ rest \\ ActiveController\n nella propria API.\n\n\nIl filtraggio Cors pu\u00f2 essere ottimizzato usando la propriet\u00e0 \n$Cors\n.\n\n\n\n\ncors['Origin']\n: array utilizzato per definire le origini consentite. Pu\u00f2 essere \n['*']\n(tutti) o \n['http://www.myserver.net', 'http://www.myotherserver.com']\n. Predefinito a \n['*']\n.\n\n\ncors['Access-Control-Request-Method']\n: rappresenta un array di verbi che sono consentiti da Yii come \n['GET', 'OPTIONS', 'HEAD']\n. L'array predefinito \u00e8 \n['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS']\n.\n\n\ncors['Access-Control-Request-Headers']\n: matrice di intestazioni consentite da Yii. Possono essere \n['*']\n tutte le intestazioni o specifiche \n['X-Request-With']\n. Predefinito a \n['*']\n.\n\n\ncors['Access-Control-Allow-Credentials']\n: questa regola controlla se la richiesta corrente pu\u00f2 essere fatta usando le credenziali. Pu\u00f2 essere \ntrue\n, \nfalse\n o \nnull\n(non impostato). Predefinito a \nnull\n.\n\n\ncors['Access-Control-Max-Age']\n: definisce la durata della richiesta pre-flight. Il valore predefinito \u00e8 \n86400\n.\n\n\n\n\nAd esempio, consentendo CORS come URL di origine (\nhttp://www.myserver.net\n) con il metodo \nGET\n, \nHEAD\n e \nOPTIONS\n:\n\n\nuse yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n    return ArrayHelper::merge([\n        [\n            'class' =\n Cors::className(),\n            'cors' =\n [\n                'Origin' =\n ['http://www.myserver.net'],\n                'Access-Control-Request-Method' =\n ['GET', 'HEAD', 'OPTIONS'],\n            ],\n        ],\n    ], parent::behaviors());\n}\n\n\n\nE' possibile ottimizzare le intestazioni CORS sostituendo i parametri predefiniti in base all'azione. Ad esempio aggiungendo \nAccess-Control-Allow-Credentials\n per l'azione di \nlogin\n potrebbe essere fatto in questo modo:\n\n\nuse yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n\n    return ArrayHelper::merge([\n        [\n            'class' =\n Cors::className(),\n            'cors' =\n [\n                'Origin' =\n ['http://www.myserver.net'],\n                'Access-Control-Request-Method' =\n ['GET', 'HEAD', 'OPTIONS'],\n            ],\n            'actions' =\n [\n                'login' =\n [\n                    'Access-Control-Allow-Credentials' =\n true,\n                ]\n            ]\n        ],\n    ], parent::behaviors());\n}",
            "title": "Filtri"
        },
        {
            "location": "/application-structure/sub-filters/#filtri-filters",
            "text": "I filtri sono oggetti che vengono eseguiti prima e / o dopo le azioni del controllore. Ad esempio, un filtro di controllo dell'accesso pu\u00f2 essere eseguito dalle azioni per garantire che sia loro consentito l'accesso da parte di determinati utenti finali; un filtro di compressione del contenuto pu\u00f2 essere eseguito dopo le azioni per comptrimere il contenuto della risposta prima di inviarlo agli utenti finali.  Un filtro pu\u00f2 consistere in un pre-filtro (logica di filtraggio applicata prima delle azioni) e / o un post-filtro (logica applicata dopo le azioni).",
            "title": "Filtri (filters)"
        },
        {
            "location": "/application-structure/sub-filters/#utilizzando-i-filtri",
            "text": "I filtri ahnno un comportamente abbastanza particolare. Pertanto, l'uso dei filtri \u00e8 uguale all'utilizzo dei \"behaviors\".E' possibile dichiarare i filtri di una classe controller sovrascrivendo il suo metodo  behaviors()  come il seguente:  public function behaviors(){\n\n    return [\n        [\n            'class' =  'yii\\filters\\HttpCache',\n            'only' =  ['index', 'view'],\n            'lastModified' =  function ($action, $params) {\n                $q = new \\yii\\db\\Query();\n                return $q- from('user')- max('updated_at');\n            },\n        ],\n    ];\n}  Per impostazione predefinita, i filtri dichiarati in una classe controller verranno applicati a tutte le azioni in quel controller. Tuttavia, \u00e8 possibile specificare esplicitamente a quali azioni applicare il filtro configurando la propriet\u00e0  only . Nell'esempio soprastante, il filtro  HttpCache  si applica solo alle azioni  index  e  view . E' anche possibile configurare la propriet\u00e0  except  per mettere in blacklist alcune azioni dell'essere filtrate.  oltre ai controller, puoi anche dichiarare i filtri in un modulo o in un'applicazione. Quando lo fa, i filtri verranno applicate tutte le azioni di controllo che appartengono a tale modulo o applicazione, a meno che non si configurano i filtri \"only\" e \"except\" come descritto sopra.   Warning  Quando si dichiara filtri in moduli o applicazioni, \u00e8 necessario utilizzare percorsi invece di ID di azione nelle propriet\u00e0  only  e  except . Questo perch\u00e8 gli ID d'azione da solo non possono specificare completamente le azioni nell'ambito di un modulo o di un'applicazione.   Quando pi\u00f9 filtri sono configurati per una singola azione, vengnono applicati in base alle regole descritte di seguito:   Pre-filtraggio  Applicare i filtri dichiarati nell'applicazione nell'ordine in cui sono elencati  behaviors() .  Applicare i filtri dichiarati nel modulo nell'ordine in cui sono elencati  behaviors() .  Applicare i filtri dichiarati nel controller nell'ordine in cui sono elencati  behaviors() .  Se uno qualsiasi dei filtri annulla l'esecuzione dell'azione, i filtri (prefiltri e post-filtri) non verranno applicati.    Esecuzione dell'azione de passa per il pre-filtro.  Post-filtraggio  Applicare i filtri dichiarati nel controller nell'ordine inverso in cui sono elencati  behaviors() .  Applicare i filtri dichiarati nel modulo nell'ordine inverso in cui sono elencati  behaviors() .  Applicare i filtri dichiarati nell'applicazione nell'ordine inverso in cui sono elencati  behaviors() .",
            "title": "Utilizzando i filtri"
        },
        {
            "location": "/application-structure/sub-filters/#creazione-di-filtri",
            "text": "Per creare un nuovo filtro azione, dobbiamo estenderlo da  yii \\ base \\ ActionFilter  e sovrascrivi i metodi  beforeAction()  e / o  afterAction() . Il primo verr\u00e0 eseguito prima dell'esecuzione di un'azione mentre il secondo dopo l'esecuzione di un'azione. Il valore di ritorno di  beforeAction()  determina se un'azione deve essere eseguita o meno. Se il valore \u00e8  false , i filtri dopo questo verranno saltati e l'azione non verr\u00e0 eseguita.  L'esempio seguente mostra un filtro che registra il tempo di esecuzione dell'azione:  namespace app\\components;\n\nuse Yii;\nuse yii\\base\\ActionFilter;\n\nclass ActionTimeFilter extends ActionFilter{\n\n    private $_startTime;\n\n    public function beforeAction($action){\n\n        $this- _startTime = microtime(true);\n        return parent::beforeAction($action);\n    }\n\n    public function afterAction($action, $result){\n\n        $time = microtime(true) - $this- _startTime;\n        Yii::trace(\"Action '{$action- uniqueId}' spent $time second.\");\n        return parent::afterAction($action, $result);\n    }\n}",
            "title": "Creazione di filtri"
        },
        {
            "location": "/application-structure/sub-filters/#filtri-principali",
            "text": "Yii fornisce un set di filtri comunemente usati, trovati principalmente sotto il namespace  yii\\filters . Di seguit, introdurremo brevemente questi filtri.",
            "title": "Filtri principali"
        },
        {
            "location": "/application-structure/sub-filters/#controllo-allaccesso",
            "text": "AccessControl  fornisce un semplice controllo degli accessi basato su un insieme di regole. In particolare, prima che un'azione venga eseguita, AccessControl esaminer\u00e0 le regole elencate e trover\u00e0 il primo che corrisponde alle variabili di contesto correnti (come l'indirizzo IP dell'utente, lo stato di accesso dell'utente, ecc..). La regola di corrispondenza determiner\u00e0 se consentire o negare l'esecuzione dell'azione richiesta. Se nessuna regola corrisponde, l'accesso verr\u00e0 negato.  L'esempio seguente mostra come consentire agli utenti autenticati di accedere alle azione  create  e  update , mentre negando tutti gli altri utenti di accedere a queste due azioni.  use yii\\filters\\AccessControl;\n\npublic function behaviors(){\n\n    return [\n        'access' =  [\n            'class' =  AccessControl::className(),\n            'only' =  ['create', 'update'],\n            'rules' =  [\n                // allow authenticated users\n                [\n                    'allow' =  true,\n                    'roles' =  ['@'],\n                ],\n                // everything else is denied by default\n            ],\n        ],\n    ];\n}",
            "title": "Controllo all'accesso"
        },
        {
            "location": "/application-structure/sub-filters/#filtri-del-metodo-di-autenticazione",
            "text": "I filtri del metodo di autenticazione vengono utilizzati per autenticare un utente utilizzando vari metodi, come  HTTP Basic Auth ,  OAuth 2 . Queste classi di filtri sono tutte sotto il namespace  yii\\filters\\auth .  L'esempio seguente mostra come utilizzare  yii \\ filters \\ auth \\ HttpBasicAuth  per autenticare un utente utilizzando un token di accesso basato sul metodo di autenticazione HTTP di base. Si noti che affinch\u00e8 funzioni, la classe di identit\u00e0 dell'utente deve implementare il metodo  findIdentityByAccessToken() .  use yii\\filters\\auth\\HttpBasicAuth;\n\npublic function behaviors(){\n\n    return [\n        'basicAuth' =  [\n            'class' =  HttpBasicAuth::className(),\n        ],\n    ];\n}  I filtri del metodo di autenticazione sono comunemente usati nell'implementazione delle API Restful.",
            "title": "Filtri del metodo di autenticazione"
        },
        {
            "location": "/application-structure/sub-filters/#contentnegotiator",
            "text": "ContentNegotiator  supporta la negoziazione del formato di risposta e la negoziazione della lingua dell'applicazione. Prover\u00e0 a determinare il formato di risposta e / o la lingua esaminando i parametri  GET  e l'intestazione HTTP  Accept .  Nell'esempio seguente, ContentNegotiator \u00e8 configurato per supportare i formati di risposta JSON e XML e le lingue inglese (Stati Uniti) e tedesca.  use yii\\filters\\ContentNegotiator;\nuse yii\\web\\Response;  public function behaviors(){\n\n    return [\n        [\n            'class' =  ContentNegotiator::className(),\n            'formats' =  [\n                'application/json' =  Response::FORMAT_JSON,\n                'application/xml' =  Response::FORMAT_XML,\n            ],\n            'languages' =  [\n                'en-US',\n                'de',\n            ],\n        ],\n    ];\n}  Spesso i formati e le lingue di risposta devono essere determinati molto prima durante il ciclo di vita dell'applicazione. Per questo motivo, ContentNegotiator \u00e8 progettato in modo tale da poter essere utilizzato anche come componente di bootstrap oltre a essere utilizzato come filtro. Ad esempio, puoi configurarlo nella configurazione dell'applicazione come segue:  use yii\\filters\\ContentNegotiator;\nuse yii\\web\\Response;\n\n[\n    'bootstrap' =  [\n        [\n            'class' =  ContentNegotiator::className(),\n            'formats' =  [\n                'application/json' =  Response::FORMAT_JSON,\n                'application/xml' =  Response::FORMAT_XML,\n            ],\n            'languages' =  [\n                'en-US',\n                'de',\n            ],\n        ],\n    ],\n];   Note  Nel caso in cui il tipo di contenuto e la lingua preferiti non possano essere determinati da una richiesta, verranno utilizzati il primo formato e la lingua elencati nei campi  formats  e  languages .",
            "title": "ContentNegotiator"
        },
        {
            "location": "/application-structure/sub-filters/#httpcache",
            "text": "HttpCache  implementa il caching sul lato client utilizzando le intestazioni HTTP  Last-Modified  e  Etag .\nPer esempio:  use yii\\filters\\HttpCache;\n\npublic function behaviors(){\n\n    return [\n        [\n            'class' =  HttpCache::className(),\n            'only' =  ['index'],\n            'lastModified' =  function ($action, $params) {\n                $q = new \\yii\\db\\Query();\n                return $q- from('user')- max('updated_at');\n            },\n        ],\n    ];\n}",
            "title": "HttpCache"
        },
        {
            "location": "/application-structure/sub-filters/#pagecache",
            "text": "PageCache  implementa il catching lato server di pagine intere. Nell'esempio seguente, PageCache viene applicato all'azione  index  per memorizzare nella cache l'intera pagina per un massimo di 60 secondi o finch\u00e8 il conteggio delle voci nella tabella  post  non cambia. Memorizza anche diverse versioni della pagina a seconda della lingua dell'applicazione scelta.  use yii\\filters\\PageCache;\nuse yii\\caching\\DbDependency;\n\npublic function behaviors(){\n\n    return [\n        'pageCache' =  [\n            'class' =  PageCache::className(),\n            'only' =  ['index'],\n            'duration' =  60,\n            'dependency' =  [\n                'class' =  DbDependency::className(),\n                'sql' =  'SELECT COUNT(*) FROM post',\n            ],\n            'variations' =  [\n                \\Yii::$app- language,\n            ]\n        ],\n    ];\n}",
            "title": "PageCache"
        },
        {
            "location": "/application-structure/sub-filters/#ratelimiter",
            "text": "RateLimiter  implementa un algoritmo di limitazione della velocit\u00e0 basato sull'algoritmo  leaky bucket . Viene principalmente utilizzato nell'implementazione di ApiRESTful.",
            "title": "RateLimiter"
        },
        {
            "location": "/application-structure/sub-filters/#verbfilter",
            "text": "VerbFilter  controlla se i metodi di richiesta HTTP sono consentiti dalle azioni richieste. Se non \u00e8 consentito, generer\u00e0 un'eccezione HTTP 405. Nell'esempio seguente, VerbFIlter viene dichiarato per specificare un set tipico di metodi di richiesta consentiti per le azioni CRUD.  use yii\\filters\\VerbFilter;\n\npublic function behaviors(){\n\n    return [\n        'verbs' =  [\n            'class' =  VerbFilter::className(),\n            'actions' =  [\n                'index'  =  ['get'],\n                'view'   =  ['get'],\n                'create' =  ['get', 'post'],\n                'update' =  ['get', 'put', 'post'],\n                'delete' =  ['post', 'delete'],\n            ],\n        ],\n    ];\n}",
            "title": "VerbFilter"
        },
        {
            "location": "/application-structure/sub-filters/#cors",
            "text": "Condivisione delle risorse tra origini  CORS  \u00e8 un meccanismo che consente a molte risorse (ad es. Caratters, JavaScript, ecc..). Su una pagina Web di essere richieste da un altro dominio al di fuori del dominio da cui proviene la risorsa. In particolare, le chiamate AJAX di JavaScript possono utilizzare il meccanismo XMLHttpRequest. Tali richieste \"interdominio\" sarebbero altrimenti vietate dai browser Web, secondo la stessa politica di sicurezza dell'origine. CORS definisce un modo in cui il browser e il server possono interagire per determinare se consentire o meno la richiesta di origine incrociata.  Il  filtro Cors  deve essere definito prima dei filtri di autenticazione / autorizzazione per assicurarsi che le intestazioni CORS vengano sempre inviate.  use yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n\n    return ArrayHelper::merge([\n        [\n            'class' =  Cors::className(),\n        ],\n    ], parent::behaviors());\n}  Controllare anche la sezione sui controller REST se si desidera aggiungere il filtro CORS a una classe  yii \\ rest \\ ActiveController  nella propria API.  Il filtraggio Cors pu\u00f2 essere ottimizzato usando la propriet\u00e0  $Cors .   cors['Origin'] : array utilizzato per definire le origini consentite. Pu\u00f2 essere  ['*'] (tutti) o  ['http://www.myserver.net', 'http://www.myotherserver.com'] . Predefinito a  ['*'] .  cors['Access-Control-Request-Method'] : rappresenta un array di verbi che sono consentiti da Yii come  ['GET', 'OPTIONS', 'HEAD'] . L'array predefinito \u00e8  ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'] .  cors['Access-Control-Request-Headers'] : matrice di intestazioni consentite da Yii. Possono essere  ['*']  tutte le intestazioni o specifiche  ['X-Request-With'] . Predefinito a  ['*'] .  cors['Access-Control-Allow-Credentials'] : questa regola controlla se la richiesta corrente pu\u00f2 essere fatta usando le credenziali. Pu\u00f2 essere  true ,  false  o  null (non impostato). Predefinito a  null .  cors['Access-Control-Max-Age'] : definisce la durata della richiesta pre-flight. Il valore predefinito \u00e8  86400 .   Ad esempio, consentendo CORS come URL di origine ( http://www.myserver.net ) con il metodo  GET ,  HEAD  e  OPTIONS :  use yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n    return ArrayHelper::merge([\n        [\n            'class' =  Cors::className(),\n            'cors' =  [\n                'Origin' =  ['http://www.myserver.net'],\n                'Access-Control-Request-Method' =  ['GET', 'HEAD', 'OPTIONS'],\n            ],\n        ],\n    ], parent::behaviors());\n}  E' possibile ottimizzare le intestazioni CORS sostituendo i parametri predefiniti in base all'azione. Ad esempio aggiungendo  Access-Control-Allow-Credentials  per l'azione di  login  potrebbe essere fatto in questo modo:  use yii\\filters\\Cors;\nuse yii\\helpers\\ArrayHelper;\n\npublic function behaviors(){\n\n    return ArrayHelper::merge([\n        [\n            'class' =  Cors::className(),\n            'cors' =  [\n                'Origin' =  ['http://www.myserver.net'],\n                'Access-Control-Request-Method' =  ['GET', 'HEAD', 'OPTIONS'],\n            ],\n            'actions' =  [\n                'login' =  [\n                    'Access-Control-Allow-Credentials' =  true,\n                ]\n            ]\n        ],\n    ], parent::behaviors());\n}",
            "title": "Cors"
        },
        {
            "location": "/application-structure/sub-widget/",
            "text": "Widget\n\n\nI widget sono blocchi predefiniti riutilizzabili utilizzati nelle viste per creare elementi dell'interfaccia utente complessi e configurabili in modo orientato agli oggetti. Ad esempio, un widget di selezione della data pu\u00f2 generare una selezione data fantasia, che permette agli utenti di selezionare una data come input. Tutto quello che devi fare \u00e8 quello di inserire il codice seguente in una vista:\n\n\n?php\nuse yii\\jui\\DatePicker;\n?\n\n\n?= DatePicker::widget(['name' =\n 'date']) ?\n\n\n\n\nCi sono un buon numero di widget in bundle con Yii, come active form, JQuery UI, Twitter Bootrstrap Widget, ecc.. \nDi seguito, introdurremo le conoscenze di base sui widget. Si prega di far riferimento alla documentazione della classe API se si desidera conoscere l'utilizzo di un particolare widget.\n\n\nUtilizzo dei widget\n\n\nI widget vengono principalmente utilizzati nelle visualizzazioni. E' possibile chiamare il metodo \nyii \\ base \\Widget :: widget()\n per utilizzare un widget in una vista. Il metodo accetta un array di configurazione per inizializzare il widget e restituisce il risultato del rendering del widget. Ad esempio, il codice seguente inserisce un widget di selezione della data configurato per utilizzare la lingua russa e mantenere l'input \nfrom_date\n nell'attributo \n$model\n.\n\n\n?php\nuse yii\\jui\\DatePicker;\n?\n\n\n?= DatePicker::widget([\n    'model' =\n $model,\n    'attribute' =\n 'from_date',\n    'language' =\n 'ru',\n    'dateFormat' =\n 'php:Y-m-d',\n]) ?\n\n\n\n\nAlcuni widget possono prendere un blocco riguardante un contenuto, e lo racchiude tra l'invocazione di \nyii \\ base \\ Widget :: begin()\n e \nyii \\ base \\ Widget :: end()\n. Ad esempio, il seguente codice utilizza il widget \nyii \\ widgets \\ ActiveForm\n per generare un modulo di accesso. Il widget generer\u00e0 l'apertura e chiusura del tag \nform\n dove viene chiamato il metodo \nbegin()\n e il metodo \nend()\n. Qualunque cosa nel mezzo sar\u00e0 lasciata cos\u00ec com'\u00e8.\n\n\n?php\nuse yii\\widgets\\ActiveForm;\nuse yii\\helpers\\Html;\n?\n\n\n\n?php $form = ActiveForm::begin(['id' =\n 'login-form']); ?\n\n\n    \n?= $form-\nfield($model, 'username') ?\n\n\n    \n?= $form-\nfield($model, 'password')-\npasswordInput() ?\n\n\n    \ndiv class=\"form-group\"\n\n        \n?= Html::submitButton('Login') ?\n\n    \n/div\n\n\n\n?php ActiveForm::end(); ?\n\n\n\n\nSi noti che a differenza di \nyii \\ base \\ Widget :: widget()\n che restituisce il risultato di rendering di un widget, il metodo \nyii \\ base \\ Widget :: begin()\n restituisce un'istanza del widget che \u00e8 possibile utilizzare per creare il contenuto del widget stesso.\n\n\n\n\nWarning\n\n\nAlcuni widget utilizzeranno il buffering dell'output per regolare il contenuto incluso quando viene chiamato \nyii \\ base \\ Widget :: end()\n. Per questo motivo \u00e8 previsto che la chiamata di \nyii \\ base \\ Widget :: begin()\n e \nyii \\ base \\ Widget :: end()\n avvenga nello stesso file di visualizzazione. La mancata osservanza di questa regola pu\u00f2 comportare un risultato inaspettato.\n\n\n\n\nCreazione di widget\n\n\nPer creare un widget,dobbiamo estendere \nyii \\ base \\ Widget\n e dobbiamo sovrascrivere i metodi \nyii \\ base \\ Widget :: init()\n e / o \nyii \\ base \\ Widget :: run()\n. In genere, il metodo \ninit()\n deve contenere il codice che normalizza le propriet\u00e0 widget, mentre il metodo \nrun()\n deve contenere il codice che genera il risultato di rendering del widget. Il risultato del rendering pu\u00f2 essere restituito direttamente o restituito come stringa dal metodo \nrun()\n.\n\n\nNell'esempio seguente, il codice HTML all'interno della classe \nHelloWidget\n visualizza il contenuto assegnato alla sua propriet\u00e0 \nmessage\n. Se la propriet\u00e0 non \u00e8 impostata, visualizzer\u00e0 \"Hello World\" per impostazione predefinita.\n\n\nnamespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass HelloWidget extends Widget{\n\n    public $message;\n\n    public function init(){\n\n        parent::init();\n        if ($this-\nmessage === null) {\n            $this-\nmessage = 'Hello World';\n        }\n    }\n\n    public function run(){\n\n        return Html::encode($this-\nmessage);\n    }\n}\n\n\n\nPer utilizzare questo widget, \u00e8 sufficiente inserire il seguente codice in una vista:\n\n\n?php\nuse app\\components\\HelloWidget;\n?\n\n\n?= HelloWidget::widget(['message' =\n 'Good morning']) ?\n\n\n\n\nDi seguito vi mostro una variante della classe \nHelloWidget\n che prende il contenuto racchiuso tra le chiamate del metodo \nbegin()\n e \nend()\n, con HTML-encode() per visualizzarlo.\n\n\nnamespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass HelloWidget extends Widget{\n\n    public function init(){\n\n        parent::init();\n        ob_start();\n    }\n\n    public function run(){\n\n        $content = ob_get_clean();\n        return Html::encode($content);\n    }\n}\n\n\n\nCome puoi vedere, il buffer di output di PHP viene avviato all'interno del metodo \ninit()\n in modo che qualsiasi output tra le chiamate dei metodi \ninit()\n e \nrun()\n possa essere catturato, elaborato e restituito da \nrun()\n.\n\n\n\n\nNote\n\n\nQuando chiamate il metodo \nyii \\ base \\ Widget :: begin()\n, verr\u00e0 creata una nuova istanza del widget e il metodo \ninit()\n verr\u00e0 chiamato alla fine del costruttore del widget. Quando chiamate \nyii \\ base \\ Widget :: end()\n,\nrun()\n verr\u00e0 chiamato dal metodo di cui verr\u00e0 restituito il risultato del return().\n\n\n\n\nIl seguente codice mostra come utilizzare questa nuova variante della classe \nHelloWidget\n:\n\n\n?php\nuse app\\components\\HelloWidget;\n?\n\n\n?php HelloWidget::begin(); ?\n\n\n    content that may contain \ntag\n's\n\n\n?php HelloWidget::end(); ?\n\n\n\n\nA volte, un widget potrebbe dover restituire una grande quantit\u00e0 di contenuti. Mentre puoi incorporare il contenuto del metodo \nrun()\n, un approccio migliore \u00e8 quello di metterlo in una vista e chiamare \nyii \\ base \\ Widget :: render()\n per restituirlo. Per esempio:\n\n\npublic function run(){\n\n    return $this-\nrender('hello');\n\n}\n\n\n\nPer impostazione predefinita, le viste per un widget devono essere memorizzate in file nella directory \nWidgetPath(views\n, dove \nWidgetPath\n trova la directory contenente il file della classe relatio al widget. Pertanto, l'esempio soprastante, renderizza il file di visualizzazione \n@app/components/views/hello.php\n, assumendo che la classe del widget si trovi sotto \n@app/components\n. E' possibile sovrascrivere il metodo \nyii \\ base \\ Widget :: getViewPath()\n per personalizzare la directory contenente il file di visualizzazione del widget.",
            "title": "Widget"
        },
        {
            "location": "/application-structure/sub-widget/#widget",
            "text": "I widget sono blocchi predefiniti riutilizzabili utilizzati nelle viste per creare elementi dell'interfaccia utente complessi e configurabili in modo orientato agli oggetti. Ad esempio, un widget di selezione della data pu\u00f2 generare una selezione data fantasia, che permette agli utenti di selezionare una data come input. Tutto quello che devi fare \u00e8 quello di inserire il codice seguente in una vista:  ?php\nuse yii\\jui\\DatePicker;\n?  ?= DatePicker::widget(['name' =  'date']) ?   Ci sono un buon numero di widget in bundle con Yii, come active form, JQuery UI, Twitter Bootrstrap Widget, ecc.. \nDi seguito, introdurremo le conoscenze di base sui widget. Si prega di far riferimento alla documentazione della classe API se si desidera conoscere l'utilizzo di un particolare widget.",
            "title": "Widget"
        },
        {
            "location": "/application-structure/sub-widget/#utilizzo-dei-widget",
            "text": "I widget vengono principalmente utilizzati nelle visualizzazioni. E' possibile chiamare il metodo  yii \\ base \\Widget :: widget()  per utilizzare un widget in una vista. Il metodo accetta un array di configurazione per inizializzare il widget e restituisce il risultato del rendering del widget. Ad esempio, il codice seguente inserisce un widget di selezione della data configurato per utilizzare la lingua russa e mantenere l'input  from_date  nell'attributo  $model .  ?php\nuse yii\\jui\\DatePicker;\n?  ?= DatePicker::widget([\n    'model' =  $model,\n    'attribute' =  'from_date',\n    'language' =  'ru',\n    'dateFormat' =  'php:Y-m-d',\n]) ?   Alcuni widget possono prendere un blocco riguardante un contenuto, e lo racchiude tra l'invocazione di  yii \\ base \\ Widget :: begin()  e  yii \\ base \\ Widget :: end() . Ad esempio, il seguente codice utilizza il widget  yii \\ widgets \\ ActiveForm  per generare un modulo di accesso. Il widget generer\u00e0 l'apertura e chiusura del tag  form  dove viene chiamato il metodo  begin()  e il metodo  end() . Qualunque cosa nel mezzo sar\u00e0 lasciata cos\u00ec com'\u00e8.  ?php\nuse yii\\widgets\\ActiveForm;\nuse yii\\helpers\\Html;\n?  ?php $form = ActiveForm::begin(['id' =  'login-form']); ? \n\n     ?= $form- field($model, 'username') ? \n\n     ?= $form- field($model, 'password')- passwordInput() ? \n\n     div class=\"form-group\" \n         ?= Html::submitButton('Login') ? \n     /div  ?php ActiveForm::end(); ?   Si noti che a differenza di  yii \\ base \\ Widget :: widget()  che restituisce il risultato di rendering di un widget, il metodo  yii \\ base \\ Widget :: begin()  restituisce un'istanza del widget che \u00e8 possibile utilizzare per creare il contenuto del widget stesso.   Warning  Alcuni widget utilizzeranno il buffering dell'output per regolare il contenuto incluso quando viene chiamato  yii \\ base \\ Widget :: end() . Per questo motivo \u00e8 previsto che la chiamata di  yii \\ base \\ Widget :: begin()  e  yii \\ base \\ Widget :: end()  avvenga nello stesso file di visualizzazione. La mancata osservanza di questa regola pu\u00f2 comportare un risultato inaspettato.",
            "title": "Utilizzo dei widget"
        },
        {
            "location": "/application-structure/sub-widget/#creazione-di-widget",
            "text": "Per creare un widget,dobbiamo estendere  yii \\ base \\ Widget  e dobbiamo sovrascrivere i metodi  yii \\ base \\ Widget :: init()  e / o  yii \\ base \\ Widget :: run() . In genere, il metodo  init()  deve contenere il codice che normalizza le propriet\u00e0 widget, mentre il metodo  run()  deve contenere il codice che genera il risultato di rendering del widget. Il risultato del rendering pu\u00f2 essere restituito direttamente o restituito come stringa dal metodo  run() .  Nell'esempio seguente, il codice HTML all'interno della classe  HelloWidget  visualizza il contenuto assegnato alla sua propriet\u00e0  message . Se la propriet\u00e0 non \u00e8 impostata, visualizzer\u00e0 \"Hello World\" per impostazione predefinita.  namespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass HelloWidget extends Widget{\n\n    public $message;\n\n    public function init(){\n\n        parent::init();\n        if ($this- message === null) {\n            $this- message = 'Hello World';\n        }\n    }\n\n    public function run(){\n\n        return Html::encode($this- message);\n    }\n}  Per utilizzare questo widget, \u00e8 sufficiente inserire il seguente codice in una vista:  ?php\nuse app\\components\\HelloWidget;\n?  ?= HelloWidget::widget(['message' =  'Good morning']) ?   Di seguito vi mostro una variante della classe  HelloWidget  che prende il contenuto racchiuso tra le chiamate del metodo  begin()  e  end() , con HTML-encode() per visualizzarlo.  namespace app\\components;\n\nuse yii\\base\\Widget;\nuse yii\\helpers\\Html;\n\nclass HelloWidget extends Widget{\n\n    public function init(){\n\n        parent::init();\n        ob_start();\n    }\n\n    public function run(){\n\n        $content = ob_get_clean();\n        return Html::encode($content);\n    }\n}  Come puoi vedere, il buffer di output di PHP viene avviato all'interno del metodo  init()  in modo che qualsiasi output tra le chiamate dei metodi  init()  e  run()  possa essere catturato, elaborato e restituito da  run() .   Note  Quando chiamate il metodo  yii \\ base \\ Widget :: begin() , verr\u00e0 creata una nuova istanza del widget e il metodo  init()  verr\u00e0 chiamato alla fine del costruttore del widget. Quando chiamate  yii \\ base \\ Widget :: end() , run()  verr\u00e0 chiamato dal metodo di cui verr\u00e0 restituito il risultato del return().   Il seguente codice mostra come utilizzare questa nuova variante della classe  HelloWidget :  ?php\nuse app\\components\\HelloWidget;\n?  ?php HelloWidget::begin(); ? \n\n    content that may contain  tag 's ?php HelloWidget::end(); ?   A volte, un widget potrebbe dover restituire una grande quantit\u00e0 di contenuti. Mentre puoi incorporare il contenuto del metodo  run() , un approccio migliore \u00e8 quello di metterlo in una vista e chiamare  yii \\ base \\ Widget :: render()  per restituirlo. Per esempio:  public function run(){\n\n    return $this- render('hello');\n\n}  Per impostazione predefinita, le viste per un widget devono essere memorizzate in file nella directory  WidgetPath(views , dove  WidgetPath  trova la directory contenente il file della classe relatio al widget. Pertanto, l'esempio soprastante, renderizza il file di visualizzazione  @app/components/views/hello.php , assumendo che la classe del widget si trovi sotto  @app/components . E' possibile sovrascrivere il metodo  yii \\ base \\ Widget :: getViewPath()  per personalizzare la directory contenente il file di visualizzazione del widget.",
            "title": "Creazione di widget"
        },
        {
            "location": "/application-structure/sub-assets/",
            "text": "Risorse (Assets)\n\n\nUna risorsa in Yii \u00e8 un file a cui \u00e8 possibile fare riferimento in una pagina Web. Pu\u00f2 essere un file CSS, un file JavaScript, un'immagine o un file video, ecc.. Le risorse si trovano in directory accessibili dal Web e sono servite direttamente dai server Web.\n\n\nSpesso \u00e8 preferibile gestire le risorse a livello di programmazione. Ad esempio, quando si utilizza il widget \nyii \\ jui \\ DatePicker\n in una pagina, verranno automaticamente inclusi i file CSS e JavaScript richiesti, invece di chiedere di trovare manualmente questi file e includerli. E quando si aggiorna il widget a una nuova versione, verr\u00e0 automaticamente utilizzata la nuova versione dei file di asset. In questo tutorial, descriveremo la potente capacit\u00e0 di gestione degli asset fornita da Yii.\n\n\nDefinizione dei pacchetti di asset\n\n\nI pacchetti di asset sono specificati come classi PHP che si estendono da \nyii \\ web \\ AssetBundle\n. Il nome di un bundle \u00e8 semplicemente il suo nome relativo alla classe PHP. una classe di asset bundle dovrebbe essere autoloadable. Solitamente specifica dove si trovano le risorse, quali file CSS e JavaScript, e ci dice anche quale pacchetto dipende da altri bundle.\n\n\nIl seguente codice definisce il pacchetto di asset principale utilizzato dal progetto del modello base:\n\n\n?php\n\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\n\nclass AppAsset extends AssetBundle{\n\n    public $basePath = '@webroot';\n    public $baseUrl = '@web';\n    public $css = [\n        'css/site.css',\n        ['css/print.css', 'media' =\n 'print'],\n    ];\n    public $js = [\n    ];\n    public $depends = [\n        'yii\\web\\YiiAsset',\n        'yii\\bootstrap\\BootstrapAsset',\n    ];\n}\n\n\n\nLa classe \nAppAsset\n specifica che il file di asset si trovano nella directory \n@webroot\n che corrisponde all'URL \n@web\n; il pacchetto contiene un singolo file CSS \ncss/site.css\n. e nessun file JavaScript. Il pacchetto dipende da altri due bundle: \nyii \\ base \\ YiiAsset\n e \nyii \\ bootstrap \\ BootstrapAsset\n. Una spiegazione pi\u00f9 dettagliata della propriet\u00e0 \nyii \\ web \\ AssetBundle\n pu\u00f2 essere trovata nel modo seguente:\n\n\n\n\nsourcePath\n: specifica la directory root che contiene i file di asset in questo pacchetto. Questa propriet\u00e0 deve essere impostata se la directory principale non \u00e8 accessibile dal Web. In caso contrario, \u00e8 necessario impostare la propriet\u00e0 \nbasePath\n e  la propriet\u00e0 \nbaseurl\n. Gli alias di percorso possono essere utilizzati.\n\n\nbasePath\n: specifica una directory accessibile dal Web che contiene i file di asset in questo pacchetto. Quando si specifica la propriet\u00e0 \nsourcePath\n, il gestore risorse pubblica le risorse di questo pacchetto in una directory accessibile dal Web, e sovrascrive di conseguenza questa propriet\u00e0. \u00c8 necessario impostarla se i file delle risorse sono gi\u00e0 in una directory accessibile dal Web e non \u00e8 necessario pubblicare gli asset. Gli alias di percorso possono essere utilizzati.\n\n\nbaseUrl\n: specifica l'URL corrispondente alla directory basePath. Come basePath , se si specifica la propriet\u00e0 sourcePath , il gestore risorse pubblicher\u00e0 le risorse e sovrascriver\u00e0 di conseguenza questa propriet\u00e0. Gli alias di percorso possono essere utilizzati.\n\n\ncss\n: specifica un array che elenca i file CSS contenuti in questo pacchetto. Si noti che solo la barra \"/\" deve essere utilizzata come separatore di directory. Ogni file pu\u00f2 essere specificato da solo come stringa o in un array insieme ai tag di attributo e ai relativi valori.\n\n\n\n\njs\n: specifica un array che elenca i file JavaScript contenuti in questo pacchetto. Il formato di questo array \u00e8 lo stesso di quello del css . Ogni file JavaScript pu\u00f2 essere specificato in uno dei seguenti due formati:\n\n\n\n\nun percorso relativo che rappresenta un file JavaScript locale (es js/main.js.). Il percorso effettivo del file pu\u00f2 essere determinato anteponendo \nyii \\ web \\ AssetManager :: $ basePath\n al percorso relativo e l'URL effettivo del file pu\u00f2 essere determinato anteponendo \nyii \\ web \\ AssetManager :: $ baseUrl\n al percorso relativo.\n\n\nun URL assoluto che rappresenta un file JavaScript esterno. Ad esempio \nhttp://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\n o \n//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js.\n.\n\n\n\n\n\n\n\n\ndepends\n: specifica un array che elenca i nomi dei bundle di asset da cui dipende questo bundle (sar\u00e0 spiegato nei prossimi paragrafi).\n\n\n\n\njsOptions\n: specifica le opzioni che verranno passate al metodo \nyii \\ web \\ View :: registerJsFile ()\n quando viene chiamato per registrare ogni file JavaScript in questo pacchetto.\n\n\ncssOptions\n: specifica le opzioni che verranno passate al metodo \nyii \\ web \\ View :: registerCssFile ()\n quando viene chiamato per registrare ogni file CSS in questo pacchetto.\n\n\npublishOptions\n: specifica le opzioni che verranno passate al metodo \nyii \\ web \\ AssetManager :: publish ()\n quando viene chiamato per pubblicare i file di risorse dall'origine in una directory Web. Viene utilizzato solo se si specifica la propriet\u00e0 \nsourcePath\n.\n\n\n\n\nPosizioni delle risorse\n\n\nLe risorse, in base alla loro posizione, possono essere classificate come:\n\n\n\n\nsource assets\n: i file delle risorse si trovano insieme al codice sorgente PHP che non pu\u00f2 essere direttamente accessibile via Web. Per utilizzare le source assets in una pagina, devono essere copiati in una directory Web e trasformati nelle cosiddette risorse pubbliche. Questo processo \u00e8 chiamato \nasset publishing\n che verr\u00e0 descritto nei paragrafi successivi.\n\n\nrisorse pubblicate\n: i file delle risorse si trovano in una directory Web e possono quindi essere accessibili direttamente via Web.\n\n\nrisorse esterne\n: i file delle risorse si trovano su un server Web diverso da quello che ospita la tua applicazione Web.\n\n\n\n\nQuando si definisce una classe bundle di asset, se si specifica la propriet\u00e0 \nsourcePath\n, significa che tutte le risorse elencate, stanno utilizzando percorsi relativi e saranno considerate come source assets. Se non si specifica questa propriet\u00e0, significa che tali risorse sono risorse pubblicate (public assets) (\u00e8 necessario specificare \nbasePath\n e \nbaseUrl\n per consentire a Yii di sapere dove si trovano).\n\n\nSi consiglia di posizionare le risorse appartenenti a un'applicazione in una directory Web, per evitare il processo di pubblicazione di asset non necessario e non voluto. Questo \u00e8 il motivo per cui \n`AppAssetper\n,nell'esempio precedente, gli viene specificato il \nbasePath\n, anzich\u00e9 il \nsourcePath\n.\n\n\nPer le estensioni, poich\u00e9 le loro risorse si trovano insieme al loro codice sorgente nelle directory che non sono accessibili dal Web, \u00e8 necessario specificare la propriet\u00e0 \nsourcePath\n quando si definiscono le classi di pacchetti di asset relativi ad essi.\n\n\n\n\nWarning\n\n\nNon utilizzare il percorso di origine \n@webroot/assetscome\n. Questa directory viene utilizzata come impostazione predefinita dal gestore risorse, per salvare i file di asset pubblicati dalla loro posizione di origine. Qualsiasi contenuto in questa directory, \u00e8 considerato temporaneamente e potrebbe essere soggetto a rimozione.\n\n\n\n\nDipendenze delle risorse\n\n\nQuando includi pi\u00f9 file CSS o JavaScript in una pagina Web, devono seguire un certo ordine per evitare problemi di sovrascrittura. Ad esempio, se si utilizza un widget dell'interfaccia utente jQuery in una pagina Web, \u00e8 necessario assicurarsi che il file jQuery JavaScript sia incluso prima del file JavaScript dell'interfaccia jQuery. Chiamiamo questi controlli \"dipendenze tra le risorse\".\n\n\nLe dipendenze delle risorse vengono principalmente specificate tramite la propriet\u00e0 \nyii \\ web \\ AssetBundle :: $ depends\n. Nell'esempio \nAppAsset\n, il fascio di asset dipende da altri due fasci di attivit\u00e0:\nYii \\ web \\ YiiAsset\n e \nYii \\ bootstrap \\ BootstrapAsset\n, il che significa che i file CSS e JavaScript in \nAppAsset\n saranno incluse dopo quei file nei due pacchetti dipendenti.\n\n\nLe dipendenze delle risorse sono transitive. Ci\u00f2 significa che se il pacchetto A dipende da B, che dipende da C, A dipender\u00e0 anche da C.\n\n\nOpzioni degli asset\n\n\n\u00c8 possibile specificare le propriet\u00e0 \ncssOptions\n e \njsOptions\n per personalizzare il modo in cui i file CSS e JavaScript sono inclusi in una pagina. I valori di queste propriet\u00e0 verranno passati ai metodi \nyii \\ web \\ View :: registerCssFile ()\n e \nyii \\ web \\ View :: registerJsFile ()\n, quando verranno chiamati dalla view per includere file CSS e JavaScript.\n\n\n\n\nNote\n\n\nLe opzioni impostate in una classe di bundle di asset, si applicano a ogni file CSS / JavaScript nel pacchetto. Se si desidera utilizzare diverse opzioni per file diversi, \u00e8 necessario utilizzare il formato indicato sopra o creare pacchetti di risorse separati e utilizzare un set di opzioni in ciascun pacchetto.\n\n\n\n\nAd esempio, per includere in modo condizionale un file CSS per i browser con IE9 (Internet Explorer 9) o inferiore, \u00e8 possibile utilizzare la seguente opzione:\n\n\npublic $cssOptions = ['condition' =\n 'lte IE9'];\n\n\n\nCi\u00f2 causer\u00e0 l'inclusione di un file CSS nel pacchetto utilizzando i seguenti tag HTML:\n\n\n!--[if lte IE9]\n\n\nlink rel=\"stylesheet\" href=\"path/to/foo.css\"\n\n\n![endif]--\n\n\n\n\nPer racchiudere i tag di collegamento CSS generati all'interno di \nnoscript\n, puoi configurare \ncssOptions\n come segue:\n\n\npublic $cssOptions = ['noscript' =\n true];\n\n\n\nPer includere un file JavaScript nella sezione head di una pagina, puoi utilizzare la seguente opzione:\n\n\npublic $jsOptions = ['position' =\n \\yii\\web\\View::POS_HEAD];\n\n\n\nPer impostazione predefinita, quando un pacchetto di risorse viene pubblicato, tutti i contenuti nella directory specificata da \nyii \\ web \\ AssetBundle :: $ sourcePath\n verranno pubblicati. \u00c8 possibile personalizzare questo comportamento configurando la propriet\u00e0 \npublishOptions\n. Ad esempio, per pubblicare solo una o alcune sottodirectory di \nyii \\ web \\ AssetBundle :: $ sourcePath\n, \u00e8 possibile effettuare quanto segue nella classe bundle degli asset:\n\n\n?php\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\n\nclass FontAwesomeAsset extends AssetBundle {\n\n    public $sourcePath = '@bower/font-awesome'; \n    public $css = [ \n        'css/font-awesome.min.css', \n    ];\n    public $publishOptions = [\n        'only' =\n [\n            'fonts/',\n            'css/',\n        ]\n    ];\n}\n\n\n\nL'esempio precedente definisce un pacchetto di risorse per il pacchetto \"fontawesome\" . Specificando l'opzione di pubblicazione \nonly\n, verranno pubblicate solo le sottodirectory \nfonts\ne \ncss\n.\n\n\nUtilizzo dei pacchetti di asset\n\n\nPer utilizzare un pacchetto di risorse, dobbiamo registrarlo con una vista chiamando il metodo \nyii \\ web \\ AssetBundle :: register ()\n. Ad esempio, in un modello di vista \u00e8 possibile registrare un pacchetto di asset come il seguente:  \n\n\nuse app\\assets\\AppAsset;\nAppAsset::register($this);  // $this represents the view object\n\n\n\n\n\nTip\n\n\nIl metodo \nyii \\ web \\ AssetBundle :: register()\n restituisce un oggetto bundle di asset contenente le informazioni sulle risorse pubblicate, come  \nbasePath\n e \nbaseUrl\n.\n\n\n\n\nSe si sta registrando un pacchetto di risorse in altri luoghi, \u00e8 necessario fornire l'oggetto di visualizzazione necessario. Ad esempio, per registrare un pacchetto di risorse in una classe widget , \u00e8 possibile ottenere l'oggetto vista per \n$this-\nview\n.\n\n\nQuando un bundle di asset \u00e8 registrato con una view, Yii registrer\u00e0 tutti i suoi bundle di asset dipendenti. Se un pacchetto di risorse si trova in una directory inaccessibile attraverso il Web, verr\u00e0 pubblicato in una directory Web. Successivamente, quando la vista esegue il rendering di una pagina, generer\u00e0 tag \nlink\ne  \nscript\n per i file CSS e JavaScript elencati nei pacchetti registrati. L'ordine di questi tag \u00e8 determinato dalle dipendenze tra i bundle registrati e dall'ordine delle risorse elencate nelle propriet\u00e0 \nyii \\ web \\ AssetBundle :: $ css\n e \nyii \\ web \\ AssetBundle :: $ js\n.\n\n\nBundle di asset dinamici\n\n\nEssendo un normale pacchetto di risorse di classe PHP, \u00e8 possibile avere alcune logiche aggiuntive ad esso correlate e pu\u00f2 modificare dinamicamente i parametri interni. Ad esempio: \u00e8 possibile utilizzare una sofisticata libreria JavaScript, che fornisce internazionalizzazione in file di origine separati: ciascuno per ciascuna lingua supportata. Quindi dovrai aggiungere un particolare file \".js\" alla tua pagina per far funzionare la traduzione della libreria. Questo pu\u00f2 essere ottenuto sovrascrivendo il metodo yii \\ web \\ AssetBundle :: init () :\n\n\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\nuse Yii;\n\nclass SophisticatedAssetBundle extends AssetBundle{\n\n    public $sourcePath = '/path/to/sophisticated/src';\n    public $js = [\n        'sophisticated.js' // file, which is always used\n    ];\n\n    public function init(){\n\n        parent::init();\n        $this-\njs[] = 'i18n/' . Yii::$app-\nlanguage . '.js'; // dynamic file added\n    }\n}\n\n\n\nL'asset bunlde pu\u00f2 anche essere regolato tramite la sua istanza restituita da \nyii \\ web \\ AssetBundle :: register()\n. Per esempio:\n\n\nuse app\\assets\\SophisticatedAssetBundle;\nuse Yii;\n\n$bundle = SophisticatedAssetBundle::register(Yii::$app-\nview);\n$bundle-\njs[] = 'i18n/' . Yii::$app-\nlanguage . '.js'; // dynamic file added\n\n\n\n\n\nWarning\n\n\nSebbene sia supportata la regolazione dinamica dei pacchetti di asset, non \u00e8 una buona pratica, perch\u00e8 pu\u00f2 portare a effetti collaterali imprevisti e, se possibile, dovrebbe essere evitata.\n\n\n\n\nPersonalizzazione dei pacchetti di risorse\n\n\nYii gestisce i bundle delle risorse tramite un componente dell'applicazione denominato \nassetManager\n che \u00e8 implementato da \nyii \\ web \\ AssetManager\n. Configurando la propriet\u00e0 \nyii \\ web \\ AssetManager :: $ bundles\n, \u00e8 possibile personalizzare il comportamento di un pacchetto di risorse. Ad esempio, il pacchetto asset predefinito \nyii \\ web \\ JqueryAsset\n utilizza il file \njquery.js\n dal pacchetto jquery Bower installato. Per migliorare la disponibilit\u00e0 e le prestazioni, potresti voler utilizzare una versione ospitata da Google. Questo lo possiamo ottenere configurando \nassetManager\n nella configurazione dell'applicazione come mostrato di seguito:\n\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'bundles' =\n [\n                'yii\\web\\JqueryAsset' =\n [\n                    'sourcePath' =\n null,   // do not publish the bundle\n                    'js' =\n [\n                        '//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js',\n                    ]\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\u00c8 possibile configurare pi\u00f9 bundle di asset in modo simile tramite \nyii \\ web \\ AssetManager :: $ bundles\n. Le chiavi dell'array dovrebbero essere i nomi delle classi  dei bundle di asset (senza la barra rovesciata iniziale) e i valori dell'array dovrebbero corrispondere agli array di configurazione corrispondenti.\n\n\n\n\nTip\n\n\nE' possibile scegliere condizionalmente quali risorse utilizzare in un pacchetto di risorse. L'esempio seguente mostra come utilizzare \njquery.js\n nell'ambiente di sviluppo e anche \njquery.min.js\n in altro modo:\n    'yii\\web\\JqueryAsset' =\n [\n        'js' =\n [\n        YII_ENV_DEV ? 'jquery.js' : 'jquery.min.js'\n        ]\n    ],\n\n\n\n\n\u00c8 possibile disabilitare uno o pi\u00f9 gruppi di risorse associandogli il valore \nfalse\n ai nomi dei pacchetti di asset che si desidera disabilitare. Quando si registra un pacchetto di asset disabilitato ad una vista, nessuno dei suoi bundle dipendenti verr\u00e0 registrato e la vista non includer\u00e0 alcuna delle risorse nel pacchetto nella pagina che esegue il rendering. Ad esempio, per disabilitare \nyii \\ web \\ JqueryAsset\n, \u00e8 possibile utilizzare la seguente configurazione:\n\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'bundles' =\n [\n                'yii\\web\\JqueryAsset' =\n false,\n            ],\n        ],\n    ],\n];\n\n\n\nPuoi anche disabilitare tutti i pacchetti delle risorse impostante \nyii \\ web \\ AssetManager :: $bundles\n a \nfalse\n.\n\n\nTieni presente che la personalizzazione effettuata tramite \nyii \\ web \\ AssetManager :: $ bundle\n viene applicata alla creazione del bundle di risorse, ad esempio durante la fase di costruzione di oggetti. Pertanto, qualsiasi aggiustamento apportato all'oggetto \nbundle\n,sostituir\u00e0 l'impostazione della mappatura al livello di \nyii \\ web \\ AssetManager :: $ bundles\n. In particolare: le regolazioni effettuate all'interno del metodo \nyii \\ web \\ AssetBundle :: init ()\n o sull'oggetto bundle registrato, avranno la precedenza sulla configurazione dell'\nAssetManager\n. Ecco alcuni esempi, in cui la mappatura impostata tramite \nyii \\ web \\ AssetManager :: $ bundles\n non ha alcun effetto:\n\n\n// Program source code:\n\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\nuse Yii;\n\nclass LanguageAssetBundle extends AssetBundle{\n\n    // ...\n\n    public function init(){\n\n        parent::init();\n        $this-\nbaseUrl = '@web/i18n/' . Yii::$app-\nlanguage; // can NOT be handled by `AssetManager`!\n    }\n}\n// ...\n\n$bundle = \\app\\assets\\LargeFileAssetBundle::register(Yii::$app-\nview);\n$bundle-\nbaseUrl = YII_DEBUG ? '@web/large-files': '@web/large-files/minified'; // can NOT be handled by `AssetManager`!\n\n\n// Application config :\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'bundles' =\n [\n                'app\\assets\\LanguageAssetBundle' =\n [\n                    'baseUrl' =\n 'http://some.cdn.com/files/i18n/en' // makes NO effect!\n                ],\n                'app\\assets\\LargeFileAssetBundle' =\n [\n                    'baseUrl' =\n 'http://some.cdn.com/files/large-files' // makes NO effect!\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nMappgin degli asset\n\n\nA volte potresti voler \"correggere\" i percorsi dei file di asset errati / incompatibili usati in pi\u00f9 bundle. Ad esempio, il pacchetto A utilizza la versione 1.11.1 del file \njquery.min.js\n e il pacchetto B utilizza la versione 2.1.1 del file \njquery.js\n. Mentre \u00e8 possibile risolvere il problema personalizzando ogni fascio, un modo pi\u00f9 semplice \u00e8 quello di utilizzare funzione per mappare le attivit\u00e0 non corrette a agli oggetti desiderati. Per fare ci\u00f2, dobbiamo configurare la propriet\u00e0 \nyii \\ web \\ AssetManager :: $ assetMap\n come segue: \n\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'assetMap' =\n [\n                'jquery.js' =\n '//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js',\n            ],\n        ],\n    ],\n];\n\n\n\nLe chiavi di \nassetMap\n sono i nomi delle risorse che si desidera correggere e i valori sono i percorsi degli asset desiderati. Quando registri un pacchetto di asset con una vista, ogni file di asset relativo nei suoi array css e js sar\u00e0 esaminato rispetto a questa mappa. Se si trova che una delle chiavi \u00e8 l'ultima parte di un file di asset (che \u00e8 preceduta dal metodo\nyii \\ web \\ AssetBundle :: $ sourcePath\n, se disponibile), il valore corrispondente sostituir\u00e0 l'asset, e sar\u00e0 registrato nella vista. Ad esempio, il file di asset \nmy/path/to/jquery.js\ncorrisponde alla chiave \njquery.js\n.\n\n\n\n\nWarning\n\n\nSolo le risorse specificate utilizzando i percorsi relativi sono soggette alla mappatura delle risorse. I percorsi delle risorse devono essere URL assoluti o percorsi relativi a \nyii \\ web \\ AssetManager :: $basePath\n.\n\n\n\n\nPublishing degli asset\n\n\nCome sopra indicato, se un pacchetto di risorse si trova in una directory che non \u00e8 accessibile dal Web, le sue risorse verranno copiate in una directory Web quando il bundle viene registrato con una vista. Questo processo \u00e8 chiamato \nasset publishing\n e viene eseguito automaticamente dal gestore degli asset .\n\n\nPer impostazione predefinita, le risorse vengono pubblicate nella directory \n@webroot/assets\n che corrisponde all'URL \n@web/assets\n. \u00c8 possibile personalizzare questa posizione configurando le propriet\u00e0 \nbasePath\n e \nbaseUrl\n.\n\n\nInvece di pubblicare le risorse tramite la copia di file, \u00e8 possibile considerare l'utilizzo di collegamenti simbolici, sempre che sia il sistema operativo che il server lo permettano.Questa funzione pu\u00f2 essere abilitata impostando il valore di \nlinkAssets\n a \ntrue\n.\n\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'linkAssets' =\n true,\n        ],\n    ],\n];\n\n\n\nCon la configurazione sopra indicata, il gestore degli asset creer\u00e0 un collegamento simbolico al percorso di origine di un pacchetto di asset quando esso verr\u00e0 pubblicato. \u00c8 pi\u00f9 veloce della copia di file e pu\u00f2 anche garantire che le risorse pubblicate siano sempre aggiornate.\n\n\nCache busting\n\n\nPer l'applicazione Web eseguita in modalit\u00e0 di produzione, \u00e8 prassi abilitare la memorizzazione nella cache HTTP per le risorse. Uno svantaggio di questa pratica \u00e8 che ogni volta che si modifica una risorsa e la si distribuisce in produzione, un client utente pu\u00f2 ancora utilizzare la versione precedente a causa della memorizzazione nella cache HTTP. Per ovviare a questo inconveniente, \u00e8 possibile utilizzare la funzionalit\u00e0 \ncache busting\n, introdotta nella versione 2.0.3, configurando \nyii \\ web \\ AssetManager\n come segue:\n\n\nreturn [\n    // ...\n    'components' =\n [\n        'assetManager' =\n [\n            'appendTimestamp' =\n true,\n        ],\n    ],\n];\n\n\n\nIn questo modo, l'URL di ogni risorsa pubblicata verr\u00e0 aggiunto con il timestamp dell'ultima modifica. Ad esempio, l'URL \nyii.js\n potrebbe essere cos\u00ec fatto  \n/assets/5515a87c/yii.js?v=1423448645\"\n, in cui il parametro \nv\n rappresenta l'ultima data di modifica del file \nyii.js\n. Ora se modifichi una risorsa, anche il suo URL verr\u00e0 modificato, il che fa s\u00ec che il client recuperi la versione pi\u00f9 recente della risorsa.\n\n\nPacchetti di beni comunemente usati\n\n\nIl codice principale di Yii definisce molti pacchetti di risorse. Tra questi, i seguenti pacchetti sono comunemente usati e possono essere referenziati nell'applicazione o nel codice di estensione.\n\n\n\n\nyii \\ web \\ YiiAsset\n: include principalmente il file \nyii.js\n  che implementa un meccanismo di organizzazione del codice JavaScript nei moduli. Fornisce inoltre supporto speciale per gli attributi \ndata-method\n e \ndata-confirm\n e altre funzionalit\u00e0 utili.\n\n\nyii \\ web \\ JqueryAsset\n: include il file \njquery.js\n dal pacchetto \njQuery Bower\n.\n\n\nyii \\ bootstrap \\ BootstrapAsset\n: include il file CSS dal framework Bootstrap di Twitter.\n\n\n*yii \\ bootstrap \\ BootstrapPluginAsset\n: include il file JavaScript dal framework Bootstrap di Twitter per supportare i plug-in JavaScript di Bootstrap.\n\n\nyii \\ jui \\ JuiAsset\n: include i file CSS e JavaScript dalla libreria dell'interfaccia utente jQuery.\n\n\n\n\nSe il tuo codice dipende da jQuery, jQuery UI o Bootstrap, dovresti utilizzare questi bundle di asset predefiniti piuttosto che creare le tue versioni.\n\n\nConversione delle risorse\n\n\nInvece di scrivere direttamente codice CSS e / o JavaScript, gli sviluppatori spesso li scrivono in una sintassi estesa e usano strumenti speciali per convertirli in CSS / JavaScript. Ad esempio,per il codice CSS \u00e8 possibile utilizzare \nLESS\n o \nSCSS\n; e per JavaScript puoi usare \nTypeScript\n.\n\n\n\u00c8 possibile elencare i file di asset in sintassi estesa nelle propriet\u00e0 \ncss\n e \njs\n di un pacchetto di risorse. Per esempio,\n\n\nclass AppAsset extends AssetBundle{\n\n    public $basePath = '@webroot';\n    public $baseUrl = '@web';\n    public $css = [\n        'css/site.less',\n    ];\n    public $js = [\n        'js/site.ts',\n    ];\n    public $depends = [\n        'yii\\web\\YiiAsset',\n        'yii\\bootstrap\\BootstrapAsset',\n    ];\n}\n\n\n\nQuando si registra un pacchetto di asset con una vista, il gestore risorse eseguir\u00e0 automaticamente gli strumenti di pre-processore per convertire le risorse nella sintassi estesa riconosciuta in CSS / JavaScript. Quando alla fine, la vista esegue il rendering di una pagina, includer\u00e0 i file CSS / JavaScript nella pagina, anzich\u00e9 le risorse originali nella sintassi estesa.\n\n\nYii usa le estensioni dei nomi dei file per identificare la sintassi estesa in cui \u00e8 presente una risorsa. Per impostazione predefinita riconosce le seguenti estensioni di sintassi e nome file:\n\n\n\n\nLESS\n: \n.less\n\n\nSCSS\n: \n.scss\n\n\nStilo\n: \n.styl\n\n\nCoffeeScript\n: \n.coffee\n\n\nTypeScript\n: \n.ts\n\n\n\n\nYii fa affidamento sugli strumenti pre-processore installati per convertire le risorse. Ad esempio, per utilizzare \nLESS\n \u00e8 necessario installare il comando \nlessc\n pre-processore.\n\n\nE' possibile personalizzare i comandi del pre-processore e la sintassi estesa supportata, configurando il convertitore \nyii \\ web \\ AssetManager ::\n come il seguente:\n\n\nreturn [\n    'components' =\n [\n        'assetManager' =\n [\n            'converter' =\n [\n                'class' =\n 'yii\\web\\AssetConverter',\n                'commands' =\n [\n                    'less' =\n ['css', 'lessc {from} {to} --no-color'],\n                    'ts' =\n ['js', 'tsc --out {to} {from}'],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nCome riportato sopra, specifichiamo la sintassi estesa supportata tramite la propriet\u00e0 \nyii \\ web \\ AssetConverter :: $ commands\n. Le chiavi dell'array sono i nomi delle estensioni dei file (senza punto iniziale) e i valori dell'array sono i nomi delle estensioni dei file delle risorse risultanti e i comandi per eseguire la conversione degli asset. I token \n{from}\n e \n{to}\n verranno sostituiti con i percorsi dei file di asset di origine e i percorsi dei file di asset di destinazione.\n\n\n\n\nInfo\n\n\nEsistono altri modi di lavorare con le risorse nella sintassi estesa, oltre a quella descritta sopra. Ad esempio, \u00e8 possibile utilizzare strumenti di compilazione come \ngrunt\n per monitorare e convertire automaticamente le risorse in sintassi estesa. In questo caso, \u00e8 necessario elencare i file CSS / JavaScript risultanti in bundle di asset anzich\u00e9 nei file originali.\n\n\n\n\nCombinazione e compressione delle risorse\n\n\nUna pagina Web pu\u00f2 includere molti file CSS e / o JavaScript. Per ridurre il numero di richieste HTTP e la dimensione complessiva di download di questi file, \u00e8 prassi comune combinare e comprimere pi\u00f9 file CSS / JavaScript in uno o pochissimi file e quindi includere questi file compressi invece di quelli originali nel Web pagine.\n\n\n\n\nInfo\n\n\nLa combinazione e la compressione delle risorse sono in genere necessarie quando un'applicazione \u00e8 in modalit\u00e0 di produzione. Nella modalit\u00e0 di sviluppo, l'utilizzo dei file CSS / JavaScript originali \u00e8 spesso pi\u00f9 conveniente ai fini del debug.\n\n\n\n\nDi seguito, introduciamo un approccio per unire e comprimere i file delle risorse senza la necessit\u00e0 di modificare il codice dell'applicazione esistente.\n\n\n\n\nTrovare tutti i pacchetti delle risorse nella nostra applicazione che vogliamo unire e comprimere.\n\n\nDividi questi pacchetti in uno o pochi gruppi. Si noti che ogni pacchetto pu\u00f2 appartenere solo a un singolo gruppo.\n\n\nUnire / comprimere i file CSS in ogni gruppo in un singolo file. Fai lo stesso per i file JavaScript.\n\n\nDefinire un nuovo pacchetto di risorse per ogni gruppo:\n\n\nImpostare la propriet\u00e0 \ncss\n e \njs\n come file uniti rispettivamente di file CSS e file di JavaScript.\n\n\n\n\n\n\n\n\nUtilizzando questo approccio, quando si registra un pacchetto di asset in una vista, viene eseguita la registrazione automatica del nuovo bundle di asset per il gruppo a cui appartiene il bundle originale. Di conseguenza, i file di asset uniti / compressi sono inclusi nella pagina, anzich\u00e9 quelli originali.\n\n\nUn esempio\n\n\nFacciamo un esempio per spiegare ulteriormente l'approccio sopra.\n\n\nSupponiamo che la tua applicazione abbia due pagine, X e Y. Pagina X utilizza i bundle di asset A, B e C, mentre Page Y utilizza i bundle di asset B, C e D.\n\n\nHai due modi per dividere questi pacchetti di risorse. Uno consiste nell'utilizzare un singolo gruppo per includere tutti i pacchetti di risorse, l'altro \u00e8 mettere A nel Gruppo X, D nel Gruppo Y e (B, C) nel Gruppo S. Qual \u00e8 il migliore? Dipende. Il primo modo ha il vantaggio che entrambe le pagine condividono gli stessi file combinati ( CSS e JavaScript), il che rende pi\u00f9 efficace il caching HTTP. D'altra parte, poich\u00e9 il gruppo singolo contiene tutti i bundle, la dimensione dei file combinati CSS e JavaScript sar\u00e0 maggiore e quindi aumenter\u00e0 il tempo di trasmissione del file iniziale. Per semplicit\u00e0, in questo esempio, useremo il primo modo, utilizzare un singolo gruppo per contenere tutti i bundle.\n\n\n\n\nInfo\n\n\nDividere i raggruppamenti delle risorse in gruppi non \u00e8 un compito banale. Di solito richiede analisi sui dati di traffico del mondo reale di varie risorse su pagine diverse. All'inizio, puoi iniziare con un singolo gruppo per semplicit\u00e0.\n\n\n\n\nUtilizza gli strumenti esistenti (ad esempio Closure Compiler , YUI Compressor ) per unire e comprimere i file CSS e JavaScript in tutti i bundle. Si noti che i file devono essere combinati nell'ordine che soddisfa le dipendenze tra i pacchetti. Ad esempio, se Bundle A dipende da B che dipende da C e D, allora dovresti elencare i file di asset a partire da C e D, seguiti da B e infine A.\n\n\nDopo l'unione e la compressione, otteniamo un file CSS e un file JavaScript. Si supponga di nomiare i file \nall-xyz.css\n e \nall-xyz.js\n, dove \nxyz\nsta per un timestamp o un hash che viene utilizzato per rendere il nome del file univoco per evitare problemi di caching HTTP.\n\n\nSiamo all'ultimo passo ora. Configurare il gestore degli asset come segue nella configurazione dell'applicazione:\n\n\nreturn [\n    'components' =\n [\n        'assetManager' =\n [\n            'bundles' =\n [\n                'all' =\n [\n                    'class' =\n 'yii\\web\\AssetBundle',\n                    'basePath' =\n '@webroot/assets',\n                    'baseUrl' =\n '@web/assets',\n                    'css' =\n ['all-xyz.css'],\n                    'js' =\n ['all-xyz.js'],\n                ],\n                'A' =\n ['css' =\n [], 'js' =\n [], 'depends' =\n ['all']],\n                'B' =\n ['css' =\n [], 'js' =\n [], 'depends' =\n ['all']],\n                'C' =\n ['css' =\n [], 'js' =\n [], 'depends' =\n ['all']],\n                'D' =\n ['css' =\n [], 'js' =\n [], 'depends' =\n ['all']],\n            ],\n        ],\n    ],\n];\n\n\n\nLa suddetta configurazione modifica il comportamento predefinito di ciascun pacchetto. In particolare, i pacchetti A, B, C e D non hanno pi\u00f9 file di risorse. Ora dipendono tutti dal pacchetto \nall\n che contiene i file combinati \nall-xyz.css\n e \nall-xyz.js\n. Di conseguenza, per la Pagina X, invece di includere i file originali dal Bundle A, B e C, saranno inclusi solo questi due file combinati; la stessa cosa succede a Page Y.\n\n\nC'\u00e8 un trucco finale per rendere l'approccio spiegato in precedena pi\u00f9 agevole. Invece di modificare direttamente il file di configurazione dell'applicazione, \u00e8 possibile inserire l'array di personalizzazione del bundle in un file separato e includere condizionatamente questo file nella configurazione dell'applicazione. Per esempio,\n\n\nreturn [\n    'components' =\n [\n        'assetManager' =\n [\n            'bundles' =\n require __DIR__ . '/' . (YII_ENV_PROD ? 'assets-prod.php' : 'assets-dev.php'),  \n        ],\n    ],\n];\n\n\n\nIn altre parole, l'array di configurazione del bundle di asset viene salvato \nassets-prod.php\n per la modalit\u00e0 di produzione e \nassets-dev.php\nper la modalit\u00e0 non di produzione.\n\n\n\n\nWarning\n\n\nQuesto meccanismo di combinazione delle risorse si basa sulla capacit\u00e0 di poter sovrascrivere le propriet\u00e0 dei bundle di asse registrati tramite \nyii \\ web \\ AssetManager :: $ bundle\n. Tuttavia, come gi\u00e0 detto sopra, questa abilit\u00e0 non copre gli aggiustamenti del bundle degli asset, che vengono eseguiti nel metodo \nyii \\ web \\ AssetBundle :: init ()\n o dopo che il bundle \u00e8 stato registrato. Dovresti evitare l'uso di tali pacchetti dinamici durante la combinazione delle risorse.\n\n\n\n\nComando \nasset\n\n\nYii fornisce un comando console chiamato \nasset\n per automatizzare l'approccio che abbiamo appena descritto.\n\n\nPer utilizzare questo comando, \u00e8 necessario innanzitutto creare un file di configurazione per descrivere quali gruppi di risorse devono essere combinati e come devono essere raggruppati. \u00c8 possibile utilizzare il sottocomando \nasset/template\n per generare un modello e quindi modificarlo per adattarlo alle proprie esigenze.\n\n\nyii asset/template assets.php\n\n\n\nIl comando genera un file nominato \nassets.php\n nella directory corrente. Il contenuto di questo file \u00e8 simile al seguente:\n\n\n?php\n/**\n* Configuration file for the \"yii asset\" console command.\n* Note that in the console environment, some path aliases like '@webroot' and '@web' may not exist.\n* Please define these missing path aliases.\n*/\nreturn [\n    // Adjust command/callback for JavaScript files compressing:\n    'jsCompressor' =\n 'java -jar compiler.jar --js {from} --js_output_file {to}',\n    // Adjust command/callback for CSS files compressing:\n    'cssCompressor' =\n 'java -jar yuicompressor.jar --type css {from} -o {to}',\n    // Whether to delete asset source after compression:\n    'deleteSource' =\n false,\n    // The list of asset bundles to compress:\n    'bundles' =\n [\n        // 'yii\\web\\YiiAsset',\n        // 'yii\\web\\JqueryAsset',\n    ],\n    // Asset bundle for compression output:\n    'targets' =\n [\n        'all' =\n [\n            'class' =\n 'yii\\web\\AssetBundle',\n            'basePath' =\n '@webroot/assets',\n            'baseUrl' =\n '@web/assets',\n            'js' =\n 'js/all-{hash}.js',\n            'css' =\n 'css/all-{hash}.css',\n        ],\n    ],\n    // Asset manager configuration:\n    'assetManager' =\n [\n    ],\n];\n\n\n\n\u00c8 necessario modificare questo file e specificare i pacchetti che si intende combinare nell'opzione \nbundles\n. Nell'opzione \ntargets\n \u00e8 necessario specificare come i fasci debbano essere divisi in gruppi. \u00c8 possibile specificare uno o pi\u00f9 gruppi, come sopra menzionato.\n\n\n\n\nWarning\n\n\nPoich\u00e8 gli alia \n@webroot\n e \n@web\n non sono disponibili nella console, \u00e8 necessario definire in modo esplicito nella configurazione.\n\n\n\n\nI file JavaScript vengono uniti, compressi e scritti \njs/all-{hash}.js\n dove {hash} viene sostituito con l'hash del file risultante.\n\n\nLe opzioni \njsCompressor\n e \ncssCompressor\n specificano i comandi della console o i callback PHP per l'esecuzione di JavaScript e CSS. Per impostazione predefinita, Yii utilizza \nClosure Compiler\n per combinare i file JavaScript e YUI Compressor per combinare i file CSS. Dovresti installare questi strumenti manualmente o modificare queste opzioni per utilizzare i tuoi strumenti preferiti.\n\n\nCon il file di configurazione, \u00e8 possibile eseguire il comando \nasset\n per combinare e comprimere i file di asset e quindi generare un nuovo file di configurazione del bundle di asset \nassets-prod.php\n:\n\n\nyii asset assets.php config/assets-prod.php\n\n\n\nIl file di configurazione generato pu\u00f2 essere incluso nella configurazione dell'applicazione, come descritto nell'ultima sottosezione.\n\n\n\n\nWarning\n\n\nSe si personalizzano i bundle delle risorse per la propria applicazione tramite \nyii \\ web \\ AssetManager :: $ bundles\n o \nyii \\ web \\ AssetManager :: $ assetMap\n e si desidera applicare questa personalizzazione per i file di origine della compressione, \u00e8 necessario includere queste opzioni per la sezione \nassetManager\n all'interno del file di configurazione del comando asset.\n\n\n\n\n\n\nWarning\n\n\nMentre si specifica la sorgente di compressione, si dovrebbe evitare l'uso di bundle di asset i cui parametri possono essere regolati dinamicamente (ad esempio al metodo \ninit()\n o dopo la registrazione), poich\u00e9 potrebbero funzionare in modo non corretto dopo la compressione.\n\n\n\n\nRaggruppamento di pacchetti di asset\n\n\nNell'ultima sottosezione, abbiamo spiegato come combinare tutti i pacchetti di risorse in uno solo per minimizzare le richieste HTTP per i file di risorsa a cui si fa riferimento in un'applicazione. Questo non \u00e8 sempre auspicabile nella pratica. Ad esempio, immagina che la tua applicazione abbia un \"front-end\" e un \"back-end\", ognuno dei quali utilizza un set diverso di file JavaScript e CSS. In questo caso, la combinazione di tutti i bundle di asset non ha senso, perch\u00e9 i bundle di asset per il \"front-end\" non vengono utilizzati dal \"back-end\" e sarebbe uno spreco di larghezza di banda della rete da inviare le risorse \"back-end\" quando viene richiesta una pagina \"front-end\".\n\n\nPer risolvere il problema precedente, \u00e8 possibile dividere gruppi di risorse in gruppi e combinare raggruppamenti di risorse per ciascun gruppo. La seguente configurazione mostra come raggruppare i pacchetti di asset:\n\n\nreturn [\n    ...\n    // Specify output bundles with groups:\n    'targets' =\n [\n        'allShared' =\n [\n            'js' =\n 'js/all-shared-{hash}.js',\n            'css' =\n 'css/all-shared-{hash}.css',\n            'depends' =\n [\n                // Include all assets shared between 'backend' and 'frontend'\n                'yii\\web\\YiiAsset',\n                'app\\assets\\SharedAsset',\n            ],\n        ],\n        'allBackEnd' =\n [\n            'js' =\n 'js/all-{hash}.js',\n            'css' =\n 'css/all-{hash}.css',\n            'depends' =\n [\n                // Include only 'backend' assets:\n                'app\\assets\\AdminAsset'\n            ],\n        ],\n        'allFrontEnd' =\n [\n            'js' =\n 'js/all-{hash}.js',\n            'css' =\n 'css/all-{hash}.css',\n            'depends' =\n [], // Include all remaining assets\n        ],\n    ],\n    ...\n];\n\n\n\nCome si pu\u00f2 vedere, i fasci di attivit\u00e0 si dividono in tre gruppi: \nallShared\n, \nallBackEnd\n e \nallFrontEnd\n. Ognuno di essi dipende da un insieme appropriato di pacchetti di risorse. Ad esempio, \nallBackEnd\n dipende da \napp\\assets\\AdminAsset\n. Quando si esegue il comando \nasset\n con questa configurazione, unir\u00e0 i bundle di asset in base alle specifiche precedenti.\n\n\n\n\nInfo\n\n\nPuoi lasciare la configurazione \ndepends\n vuota per uno dei pacchetti di destinazione. In questo modo, quel particolare bundle di asset dipender\u00e0 da tutti i bundle di asset rimanenti su cui altri bundle target non dipendono.",
            "title": "Assets"
        },
        {
            "location": "/application-structure/sub-assets/#risorse-assets",
            "text": "Una risorsa in Yii \u00e8 un file a cui \u00e8 possibile fare riferimento in una pagina Web. Pu\u00f2 essere un file CSS, un file JavaScript, un'immagine o un file video, ecc.. Le risorse si trovano in directory accessibili dal Web e sono servite direttamente dai server Web.  Spesso \u00e8 preferibile gestire le risorse a livello di programmazione. Ad esempio, quando si utilizza il widget  yii \\ jui \\ DatePicker  in una pagina, verranno automaticamente inclusi i file CSS e JavaScript richiesti, invece di chiedere di trovare manualmente questi file e includerli. E quando si aggiorna il widget a una nuova versione, verr\u00e0 automaticamente utilizzata la nuova versione dei file di asset. In questo tutorial, descriveremo la potente capacit\u00e0 di gestione degli asset fornita da Yii.",
            "title": "Risorse (Assets)"
        },
        {
            "location": "/application-structure/sub-assets/#definizione-dei-pacchetti-di-asset",
            "text": "I pacchetti di asset sono specificati come classi PHP che si estendono da  yii \\ web \\ AssetBundle . Il nome di un bundle \u00e8 semplicemente il suo nome relativo alla classe PHP. una classe di asset bundle dovrebbe essere autoloadable. Solitamente specifica dove si trovano le risorse, quali file CSS e JavaScript, e ci dice anche quale pacchetto dipende da altri bundle.  Il seguente codice definisce il pacchetto di asset principale utilizzato dal progetto del modello base:  ?php\n\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\n\nclass AppAsset extends AssetBundle{\n\n    public $basePath = '@webroot';\n    public $baseUrl = '@web';\n    public $css = [\n        'css/site.css',\n        ['css/print.css', 'media' =  'print'],\n    ];\n    public $js = [\n    ];\n    public $depends = [\n        'yii\\web\\YiiAsset',\n        'yii\\bootstrap\\BootstrapAsset',\n    ];\n}  La classe  AppAsset  specifica che il file di asset si trovano nella directory  @webroot  che corrisponde all'URL  @web ; il pacchetto contiene un singolo file CSS  css/site.css . e nessun file JavaScript. Il pacchetto dipende da altri due bundle:  yii \\ base \\ YiiAsset  e  yii \\ bootstrap \\ BootstrapAsset . Una spiegazione pi\u00f9 dettagliata della propriet\u00e0  yii \\ web \\ AssetBundle  pu\u00f2 essere trovata nel modo seguente:   sourcePath : specifica la directory root che contiene i file di asset in questo pacchetto. Questa propriet\u00e0 deve essere impostata se la directory principale non \u00e8 accessibile dal Web. In caso contrario, \u00e8 necessario impostare la propriet\u00e0  basePath  e  la propriet\u00e0  baseurl . Gli alias di percorso possono essere utilizzati.  basePath : specifica una directory accessibile dal Web che contiene i file di asset in questo pacchetto. Quando si specifica la propriet\u00e0  sourcePath , il gestore risorse pubblica le risorse di questo pacchetto in una directory accessibile dal Web, e sovrascrive di conseguenza questa propriet\u00e0. \u00c8 necessario impostarla se i file delle risorse sono gi\u00e0 in una directory accessibile dal Web e non \u00e8 necessario pubblicare gli asset. Gli alias di percorso possono essere utilizzati.  baseUrl : specifica l'URL corrispondente alla directory basePath. Come basePath , se si specifica la propriet\u00e0 sourcePath , il gestore risorse pubblicher\u00e0 le risorse e sovrascriver\u00e0 di conseguenza questa propriet\u00e0. Gli alias di percorso possono essere utilizzati.  css : specifica un array che elenca i file CSS contenuti in questo pacchetto. Si noti che solo la barra \"/\" deve essere utilizzata come separatore di directory. Ogni file pu\u00f2 essere specificato da solo come stringa o in un array insieme ai tag di attributo e ai relativi valori.   js : specifica un array che elenca i file JavaScript contenuti in questo pacchetto. Il formato di questo array \u00e8 lo stesso di quello del css . Ogni file JavaScript pu\u00f2 essere specificato in uno dei seguenti due formati:   un percorso relativo che rappresenta un file JavaScript locale (es js/main.js.). Il percorso effettivo del file pu\u00f2 essere determinato anteponendo  yii \\ web \\ AssetManager :: $ basePath  al percorso relativo e l'URL effettivo del file pu\u00f2 essere determinato anteponendo  yii \\ web \\ AssetManager :: $ baseUrl  al percorso relativo.  un URL assoluto che rappresenta un file JavaScript esterno. Ad esempio  http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js  o  //ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js. .     depends : specifica un array che elenca i nomi dei bundle di asset da cui dipende questo bundle (sar\u00e0 spiegato nei prossimi paragrafi).   jsOptions : specifica le opzioni che verranno passate al metodo  yii \\ web \\ View :: registerJsFile ()  quando viene chiamato per registrare ogni file JavaScript in questo pacchetto.  cssOptions : specifica le opzioni che verranno passate al metodo  yii \\ web \\ View :: registerCssFile ()  quando viene chiamato per registrare ogni file CSS in questo pacchetto.  publishOptions : specifica le opzioni che verranno passate al metodo  yii \\ web \\ AssetManager :: publish ()  quando viene chiamato per pubblicare i file di risorse dall'origine in una directory Web. Viene utilizzato solo se si specifica la propriet\u00e0  sourcePath .",
            "title": "Definizione dei pacchetti di asset"
        },
        {
            "location": "/application-structure/sub-assets/#posizioni-delle-risorse",
            "text": "Le risorse, in base alla loro posizione, possono essere classificate come:   source assets : i file delle risorse si trovano insieme al codice sorgente PHP che non pu\u00f2 essere direttamente accessibile via Web. Per utilizzare le source assets in una pagina, devono essere copiati in una directory Web e trasformati nelle cosiddette risorse pubbliche. Questo processo \u00e8 chiamato  asset publishing  che verr\u00e0 descritto nei paragrafi successivi.  risorse pubblicate : i file delle risorse si trovano in una directory Web e possono quindi essere accessibili direttamente via Web.  risorse esterne : i file delle risorse si trovano su un server Web diverso da quello che ospita la tua applicazione Web.   Quando si definisce una classe bundle di asset, se si specifica la propriet\u00e0  sourcePath , significa che tutte le risorse elencate, stanno utilizzando percorsi relativi e saranno considerate come source assets. Se non si specifica questa propriet\u00e0, significa che tali risorse sono risorse pubblicate (public assets) (\u00e8 necessario specificare  basePath  e  baseUrl  per consentire a Yii di sapere dove si trovano).  Si consiglia di posizionare le risorse appartenenti a un'applicazione in una directory Web, per evitare il processo di pubblicazione di asset non necessario e non voluto. Questo \u00e8 il motivo per cui  `AppAssetper ,nell'esempio precedente, gli viene specificato il  basePath , anzich\u00e9 il  sourcePath .  Per le estensioni, poich\u00e9 le loro risorse si trovano insieme al loro codice sorgente nelle directory che non sono accessibili dal Web, \u00e8 necessario specificare la propriet\u00e0  sourcePath  quando si definiscono le classi di pacchetti di asset relativi ad essi.   Warning  Non utilizzare il percorso di origine  @webroot/assetscome . Questa directory viene utilizzata come impostazione predefinita dal gestore risorse, per salvare i file di asset pubblicati dalla loro posizione di origine. Qualsiasi contenuto in questa directory, \u00e8 considerato temporaneamente e potrebbe essere soggetto a rimozione.",
            "title": "Posizioni delle risorse"
        },
        {
            "location": "/application-structure/sub-assets/#dipendenze-delle-risorse",
            "text": "Quando includi pi\u00f9 file CSS o JavaScript in una pagina Web, devono seguire un certo ordine per evitare problemi di sovrascrittura. Ad esempio, se si utilizza un widget dell'interfaccia utente jQuery in una pagina Web, \u00e8 necessario assicurarsi che il file jQuery JavaScript sia incluso prima del file JavaScript dell'interfaccia jQuery. Chiamiamo questi controlli \"dipendenze tra le risorse\".  Le dipendenze delle risorse vengono principalmente specificate tramite la propriet\u00e0  yii \\ web \\ AssetBundle :: $ depends . Nell'esempio  AppAsset , il fascio di asset dipende da altri due fasci di attivit\u00e0: Yii \\ web \\ YiiAsset  e  Yii \\ bootstrap \\ BootstrapAsset , il che significa che i file CSS e JavaScript in  AppAsset  saranno incluse dopo quei file nei due pacchetti dipendenti.  Le dipendenze delle risorse sono transitive. Ci\u00f2 significa che se il pacchetto A dipende da B, che dipende da C, A dipender\u00e0 anche da C.",
            "title": "Dipendenze delle risorse"
        },
        {
            "location": "/application-structure/sub-assets/#opzioni-degli-asset",
            "text": "\u00c8 possibile specificare le propriet\u00e0  cssOptions  e  jsOptions  per personalizzare il modo in cui i file CSS e JavaScript sono inclusi in una pagina. I valori di queste propriet\u00e0 verranno passati ai metodi  yii \\ web \\ View :: registerCssFile ()  e  yii \\ web \\ View :: registerJsFile () , quando verranno chiamati dalla view per includere file CSS e JavaScript.   Note  Le opzioni impostate in una classe di bundle di asset, si applicano a ogni file CSS / JavaScript nel pacchetto. Se si desidera utilizzare diverse opzioni per file diversi, \u00e8 necessario utilizzare il formato indicato sopra o creare pacchetti di risorse separati e utilizzare un set di opzioni in ciascun pacchetto.   Ad esempio, per includere in modo condizionale un file CSS per i browser con IE9 (Internet Explorer 9) o inferiore, \u00e8 possibile utilizzare la seguente opzione:  public $cssOptions = ['condition' =  'lte IE9'];  Ci\u00f2 causer\u00e0 l'inclusione di un file CSS nel pacchetto utilizzando i seguenti tag HTML:  !--[if lte IE9]  link rel=\"stylesheet\" href=\"path/to/foo.css\"  ![endif]--   Per racchiudere i tag di collegamento CSS generati all'interno di  noscript , puoi configurare  cssOptions  come segue:  public $cssOptions = ['noscript' =  true];  Per includere un file JavaScript nella sezione head di una pagina, puoi utilizzare la seguente opzione:  public $jsOptions = ['position' =  \\yii\\web\\View::POS_HEAD];  Per impostazione predefinita, quando un pacchetto di risorse viene pubblicato, tutti i contenuti nella directory specificata da  yii \\ web \\ AssetBundle :: $ sourcePath  verranno pubblicati. \u00c8 possibile personalizzare questo comportamento configurando la propriet\u00e0  publishOptions . Ad esempio, per pubblicare solo una o alcune sottodirectory di  yii \\ web \\ AssetBundle :: $ sourcePath , \u00e8 possibile effettuare quanto segue nella classe bundle degli asset:  ?php\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\n\nclass FontAwesomeAsset extends AssetBundle {\n\n    public $sourcePath = '@bower/font-awesome'; \n    public $css = [ \n        'css/font-awesome.min.css', \n    ];\n    public $publishOptions = [\n        'only' =  [\n            'fonts/',\n            'css/',\n        ]\n    ];\n}  L'esempio precedente definisce un pacchetto di risorse per il pacchetto \"fontawesome\" . Specificando l'opzione di pubblicazione  only , verranno pubblicate solo le sottodirectory  fonts e  css .",
            "title": "Opzioni degli asset"
        },
        {
            "location": "/application-structure/sub-assets/#utilizzo-dei-pacchetti-di-asset",
            "text": "Per utilizzare un pacchetto di risorse, dobbiamo registrarlo con una vista chiamando il metodo  yii \\ web \\ AssetBundle :: register () . Ad esempio, in un modello di vista \u00e8 possibile registrare un pacchetto di asset come il seguente:    use app\\assets\\AppAsset;\nAppAsset::register($this);  // $this represents the view object   Tip  Il metodo  yii \\ web \\ AssetBundle :: register()  restituisce un oggetto bundle di asset contenente le informazioni sulle risorse pubblicate, come   basePath  e  baseUrl .   Se si sta registrando un pacchetto di risorse in altri luoghi, \u00e8 necessario fornire l'oggetto di visualizzazione necessario. Ad esempio, per registrare un pacchetto di risorse in una classe widget , \u00e8 possibile ottenere l'oggetto vista per  $this- view .  Quando un bundle di asset \u00e8 registrato con una view, Yii registrer\u00e0 tutti i suoi bundle di asset dipendenti. Se un pacchetto di risorse si trova in una directory inaccessibile attraverso il Web, verr\u00e0 pubblicato in una directory Web. Successivamente, quando la vista esegue il rendering di una pagina, generer\u00e0 tag  link e   script  per i file CSS e JavaScript elencati nei pacchetti registrati. L'ordine di questi tag \u00e8 determinato dalle dipendenze tra i bundle registrati e dall'ordine delle risorse elencate nelle propriet\u00e0  yii \\ web \\ AssetBundle :: $ css  e  yii \\ web \\ AssetBundle :: $ js .",
            "title": "Utilizzo dei pacchetti di asset"
        },
        {
            "location": "/application-structure/sub-assets/#bundle-di-asset-dinamici",
            "text": "Essendo un normale pacchetto di risorse di classe PHP, \u00e8 possibile avere alcune logiche aggiuntive ad esso correlate e pu\u00f2 modificare dinamicamente i parametri interni. Ad esempio: \u00e8 possibile utilizzare una sofisticata libreria JavaScript, che fornisce internazionalizzazione in file di origine separati: ciascuno per ciascuna lingua supportata. Quindi dovrai aggiungere un particolare file \".js\" alla tua pagina per far funzionare la traduzione della libreria. Questo pu\u00f2 essere ottenuto sovrascrivendo il metodo yii \\ web \\ AssetBundle :: init () :  namespace app\\assets;\n\nuse yii\\web\\AssetBundle;\nuse Yii;\n\nclass SophisticatedAssetBundle extends AssetBundle{\n\n    public $sourcePath = '/path/to/sophisticated/src';\n    public $js = [\n        'sophisticated.js' // file, which is always used\n    ];\n\n    public function init(){\n\n        parent::init();\n        $this- js[] = 'i18n/' . Yii::$app- language . '.js'; // dynamic file added\n    }\n}  L'asset bunlde pu\u00f2 anche essere regolato tramite la sua istanza restituita da  yii \\ web \\ AssetBundle :: register() . Per esempio:  use app\\assets\\SophisticatedAssetBundle;\nuse Yii;\n\n$bundle = SophisticatedAssetBundle::register(Yii::$app- view);\n$bundle- js[] = 'i18n/' . Yii::$app- language . '.js'; // dynamic file added   Warning  Sebbene sia supportata la regolazione dinamica dei pacchetti di asset, non \u00e8 una buona pratica, perch\u00e8 pu\u00f2 portare a effetti collaterali imprevisti e, se possibile, dovrebbe essere evitata.",
            "title": "Bundle di asset dinamici"
        },
        {
            "location": "/application-structure/sub-assets/#personalizzazione-dei-pacchetti-di-risorse",
            "text": "Yii gestisce i bundle delle risorse tramite un componente dell'applicazione denominato  assetManager  che \u00e8 implementato da  yii \\ web \\ AssetManager . Configurando la propriet\u00e0  yii \\ web \\ AssetManager :: $ bundles , \u00e8 possibile personalizzare il comportamento di un pacchetto di risorse. Ad esempio, il pacchetto asset predefinito  yii \\ web \\ JqueryAsset  utilizza il file  jquery.js  dal pacchetto jquery Bower installato. Per migliorare la disponibilit\u00e0 e le prestazioni, potresti voler utilizzare una versione ospitata da Google. Questo lo possiamo ottenere configurando  assetManager  nella configurazione dell'applicazione come mostrato di seguito:  return [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'bundles' =  [\n                'yii\\web\\JqueryAsset' =  [\n                    'sourcePath' =  null,   // do not publish the bundle\n                    'js' =  [\n                        '//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js',\n                    ]\n                ],\n            ],\n        ],\n    ],\n];  \u00c8 possibile configurare pi\u00f9 bundle di asset in modo simile tramite  yii \\ web \\ AssetManager :: $ bundles . Le chiavi dell'array dovrebbero essere i nomi delle classi  dei bundle di asset (senza la barra rovesciata iniziale) e i valori dell'array dovrebbero corrispondere agli array di configurazione corrispondenti.   Tip  E' possibile scegliere condizionalmente quali risorse utilizzare in un pacchetto di risorse. L'esempio seguente mostra come utilizzare  jquery.js  nell'ambiente di sviluppo e anche  jquery.min.js  in altro modo:\n    'yii\\web\\JqueryAsset' =  [\n        'js' =  [\n        YII_ENV_DEV ? 'jquery.js' : 'jquery.min.js'\n        ]\n    ],   \u00c8 possibile disabilitare uno o pi\u00f9 gruppi di risorse associandogli il valore  false  ai nomi dei pacchetti di asset che si desidera disabilitare. Quando si registra un pacchetto di asset disabilitato ad una vista, nessuno dei suoi bundle dipendenti verr\u00e0 registrato e la vista non includer\u00e0 alcuna delle risorse nel pacchetto nella pagina che esegue il rendering. Ad esempio, per disabilitare  yii \\ web \\ JqueryAsset , \u00e8 possibile utilizzare la seguente configurazione:  return [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'bundles' =  [\n                'yii\\web\\JqueryAsset' =  false,\n            ],\n        ],\n    ],\n];  Puoi anche disabilitare tutti i pacchetti delle risorse impostante  yii \\ web \\ AssetManager :: $bundles  a  false .  Tieni presente che la personalizzazione effettuata tramite  yii \\ web \\ AssetManager :: $ bundle  viene applicata alla creazione del bundle di risorse, ad esempio durante la fase di costruzione di oggetti. Pertanto, qualsiasi aggiustamento apportato all'oggetto  bundle ,sostituir\u00e0 l'impostazione della mappatura al livello di  yii \\ web \\ AssetManager :: $ bundles . In particolare: le regolazioni effettuate all'interno del metodo  yii \\ web \\ AssetBundle :: init ()  o sull'oggetto bundle registrato, avranno la precedenza sulla configurazione dell' AssetManager . Ecco alcuni esempi, in cui la mappatura impostata tramite  yii \\ web \\ AssetManager :: $ bundles  non ha alcun effetto:  // Program source code:\n\nnamespace app\\assets;\n\nuse yii\\web\\AssetBundle;\nuse Yii;\n\nclass LanguageAssetBundle extends AssetBundle{\n\n    // ...\n\n    public function init(){\n\n        parent::init();\n        $this- baseUrl = '@web/i18n/' . Yii::$app- language; // can NOT be handled by `AssetManager`!\n    }\n}\n// ...\n\n$bundle = \\app\\assets\\LargeFileAssetBundle::register(Yii::$app- view);\n$bundle- baseUrl = YII_DEBUG ? '@web/large-files': '@web/large-files/minified'; // can NOT be handled by `AssetManager`!\n\n\n// Application config :\n\nreturn [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'bundles' =  [\n                'app\\assets\\LanguageAssetBundle' =  [\n                    'baseUrl' =  'http://some.cdn.com/files/i18n/en' // makes NO effect!\n                ],\n                'app\\assets\\LargeFileAssetBundle' =  [\n                    'baseUrl' =  'http://some.cdn.com/files/large-files' // makes NO effect!\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Personalizzazione dei pacchetti di risorse"
        },
        {
            "location": "/application-structure/sub-assets/#mappgin-degli-asset",
            "text": "A volte potresti voler \"correggere\" i percorsi dei file di asset errati / incompatibili usati in pi\u00f9 bundle. Ad esempio, il pacchetto A utilizza la versione 1.11.1 del file  jquery.min.js  e il pacchetto B utilizza la versione 2.1.1 del file  jquery.js . Mentre \u00e8 possibile risolvere il problema personalizzando ogni fascio, un modo pi\u00f9 semplice \u00e8 quello di utilizzare funzione per mappare le attivit\u00e0 non corrette a agli oggetti desiderati. Per fare ci\u00f2, dobbiamo configurare la propriet\u00e0  yii \\ web \\ AssetManager :: $ assetMap  come segue:   return [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'assetMap' =  [\n                'jquery.js' =  '//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js',\n            ],\n        ],\n    ],\n];  Le chiavi di  assetMap  sono i nomi delle risorse che si desidera correggere e i valori sono i percorsi degli asset desiderati. Quando registri un pacchetto di asset con una vista, ogni file di asset relativo nei suoi array css e js sar\u00e0 esaminato rispetto a questa mappa. Se si trova che una delle chiavi \u00e8 l'ultima parte di un file di asset (che \u00e8 preceduta dal metodo yii \\ web \\ AssetBundle :: $ sourcePath , se disponibile), il valore corrispondente sostituir\u00e0 l'asset, e sar\u00e0 registrato nella vista. Ad esempio, il file di asset  my/path/to/jquery.js corrisponde alla chiave  jquery.js .   Warning  Solo le risorse specificate utilizzando i percorsi relativi sono soggette alla mappatura delle risorse. I percorsi delle risorse devono essere URL assoluti o percorsi relativi a  yii \\ web \\ AssetManager :: $basePath .",
            "title": "Mappgin degli asset"
        },
        {
            "location": "/application-structure/sub-assets/#publishing-degli-asset",
            "text": "Come sopra indicato, se un pacchetto di risorse si trova in una directory che non \u00e8 accessibile dal Web, le sue risorse verranno copiate in una directory Web quando il bundle viene registrato con una vista. Questo processo \u00e8 chiamato  asset publishing  e viene eseguito automaticamente dal gestore degli asset .  Per impostazione predefinita, le risorse vengono pubblicate nella directory  @webroot/assets  che corrisponde all'URL  @web/assets . \u00c8 possibile personalizzare questa posizione configurando le propriet\u00e0  basePath  e  baseUrl .  Invece di pubblicare le risorse tramite la copia di file, \u00e8 possibile considerare l'utilizzo di collegamenti simbolici, sempre che sia il sistema operativo che il server lo permettano.Questa funzione pu\u00f2 essere abilitata impostando il valore di  linkAssets  a  true .  return [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'linkAssets' =  true,\n        ],\n    ],\n];  Con la configurazione sopra indicata, il gestore degli asset creer\u00e0 un collegamento simbolico al percorso di origine di un pacchetto di asset quando esso verr\u00e0 pubblicato. \u00c8 pi\u00f9 veloce della copia di file e pu\u00f2 anche garantire che le risorse pubblicate siano sempre aggiornate.",
            "title": "Publishing degli asset"
        },
        {
            "location": "/application-structure/sub-assets/#cache-busting",
            "text": "Per l'applicazione Web eseguita in modalit\u00e0 di produzione, \u00e8 prassi abilitare la memorizzazione nella cache HTTP per le risorse. Uno svantaggio di questa pratica \u00e8 che ogni volta che si modifica una risorsa e la si distribuisce in produzione, un client utente pu\u00f2 ancora utilizzare la versione precedente a causa della memorizzazione nella cache HTTP. Per ovviare a questo inconveniente, \u00e8 possibile utilizzare la funzionalit\u00e0  cache busting , introdotta nella versione 2.0.3, configurando  yii \\ web \\ AssetManager  come segue:  return [\n    // ...\n    'components' =  [\n        'assetManager' =  [\n            'appendTimestamp' =  true,\n        ],\n    ],\n];  In questo modo, l'URL di ogni risorsa pubblicata verr\u00e0 aggiunto con il timestamp dell'ultima modifica. Ad esempio, l'URL  yii.js  potrebbe essere cos\u00ec fatto   /assets/5515a87c/yii.js?v=1423448645\" , in cui il parametro  v  rappresenta l'ultima data di modifica del file  yii.js . Ora se modifichi una risorsa, anche il suo URL verr\u00e0 modificato, il che fa s\u00ec che il client recuperi la versione pi\u00f9 recente della risorsa.",
            "title": "Cache busting"
        },
        {
            "location": "/application-structure/sub-assets/#pacchetti-di-beni-comunemente-usati",
            "text": "Il codice principale di Yii definisce molti pacchetti di risorse. Tra questi, i seguenti pacchetti sono comunemente usati e possono essere referenziati nell'applicazione o nel codice di estensione.   yii \\ web \\ YiiAsset : include principalmente il file  yii.js   che implementa un meccanismo di organizzazione del codice JavaScript nei moduli. Fornisce inoltre supporto speciale per gli attributi  data-method  e  data-confirm  e altre funzionalit\u00e0 utili.  yii \\ web \\ JqueryAsset : include il file  jquery.js  dal pacchetto  jQuery Bower .  yii \\ bootstrap \\ BootstrapAsset : include il file CSS dal framework Bootstrap di Twitter.  *yii \\ bootstrap \\ BootstrapPluginAsset : include il file JavaScript dal framework Bootstrap di Twitter per supportare i plug-in JavaScript di Bootstrap.  yii \\ jui \\ JuiAsset : include i file CSS e JavaScript dalla libreria dell'interfaccia utente jQuery.   Se il tuo codice dipende da jQuery, jQuery UI o Bootstrap, dovresti utilizzare questi bundle di asset predefiniti piuttosto che creare le tue versioni.",
            "title": "Pacchetti di beni comunemente usati"
        },
        {
            "location": "/application-structure/sub-assets/#conversione-delle-risorse",
            "text": "Invece di scrivere direttamente codice CSS e / o JavaScript, gli sviluppatori spesso li scrivono in una sintassi estesa e usano strumenti speciali per convertirli in CSS / JavaScript. Ad esempio,per il codice CSS \u00e8 possibile utilizzare  LESS  o  SCSS ; e per JavaScript puoi usare  TypeScript .  \u00c8 possibile elencare i file di asset in sintassi estesa nelle propriet\u00e0  css  e  js  di un pacchetto di risorse. Per esempio,  class AppAsset extends AssetBundle{\n\n    public $basePath = '@webroot';\n    public $baseUrl = '@web';\n    public $css = [\n        'css/site.less',\n    ];\n    public $js = [\n        'js/site.ts',\n    ];\n    public $depends = [\n        'yii\\web\\YiiAsset',\n        'yii\\bootstrap\\BootstrapAsset',\n    ];\n}  Quando si registra un pacchetto di asset con una vista, il gestore risorse eseguir\u00e0 automaticamente gli strumenti di pre-processore per convertire le risorse nella sintassi estesa riconosciuta in CSS / JavaScript. Quando alla fine, la vista esegue il rendering di una pagina, includer\u00e0 i file CSS / JavaScript nella pagina, anzich\u00e9 le risorse originali nella sintassi estesa.  Yii usa le estensioni dei nomi dei file per identificare la sintassi estesa in cui \u00e8 presente una risorsa. Per impostazione predefinita riconosce le seguenti estensioni di sintassi e nome file:   LESS :  .less  SCSS :  .scss  Stilo :  .styl  CoffeeScript :  .coffee  TypeScript :  .ts   Yii fa affidamento sugli strumenti pre-processore installati per convertire le risorse. Ad esempio, per utilizzare  LESS  \u00e8 necessario installare il comando  lessc  pre-processore.  E' possibile personalizzare i comandi del pre-processore e la sintassi estesa supportata, configurando il convertitore  yii \\ web \\ AssetManager ::  come il seguente:  return [\n    'components' =  [\n        'assetManager' =  [\n            'converter' =  [\n                'class' =  'yii\\web\\AssetConverter',\n                'commands' =  [\n                    'less' =  ['css', 'lessc {from} {to} --no-color'],\n                    'ts' =  ['js', 'tsc --out {to} {from}'],\n                ],\n            ],\n        ],\n    ],\n];  Come riportato sopra, specifichiamo la sintassi estesa supportata tramite la propriet\u00e0  yii \\ web \\ AssetConverter :: $ commands . Le chiavi dell'array sono i nomi delle estensioni dei file (senza punto iniziale) e i valori dell'array sono i nomi delle estensioni dei file delle risorse risultanti e i comandi per eseguire la conversione degli asset. I token  {from}  e  {to}  verranno sostituiti con i percorsi dei file di asset di origine e i percorsi dei file di asset di destinazione.   Info  Esistono altri modi di lavorare con le risorse nella sintassi estesa, oltre a quella descritta sopra. Ad esempio, \u00e8 possibile utilizzare strumenti di compilazione come  grunt  per monitorare e convertire automaticamente le risorse in sintassi estesa. In questo caso, \u00e8 necessario elencare i file CSS / JavaScript risultanti in bundle di asset anzich\u00e9 nei file originali.",
            "title": "Conversione delle risorse"
        },
        {
            "location": "/application-structure/sub-assets/#combinazione-e-compressione-delle-risorse",
            "text": "Una pagina Web pu\u00f2 includere molti file CSS e / o JavaScript. Per ridurre il numero di richieste HTTP e la dimensione complessiva di download di questi file, \u00e8 prassi comune combinare e comprimere pi\u00f9 file CSS / JavaScript in uno o pochissimi file e quindi includere questi file compressi invece di quelli originali nel Web pagine.   Info  La combinazione e la compressione delle risorse sono in genere necessarie quando un'applicazione \u00e8 in modalit\u00e0 di produzione. Nella modalit\u00e0 di sviluppo, l'utilizzo dei file CSS / JavaScript originali \u00e8 spesso pi\u00f9 conveniente ai fini del debug.   Di seguito, introduciamo un approccio per unire e comprimere i file delle risorse senza la necessit\u00e0 di modificare il codice dell'applicazione esistente.   Trovare tutti i pacchetti delle risorse nella nostra applicazione che vogliamo unire e comprimere.  Dividi questi pacchetti in uno o pochi gruppi. Si noti che ogni pacchetto pu\u00f2 appartenere solo a un singolo gruppo.  Unire / comprimere i file CSS in ogni gruppo in un singolo file. Fai lo stesso per i file JavaScript.  Definire un nuovo pacchetto di risorse per ogni gruppo:  Impostare la propriet\u00e0  css  e  js  come file uniti rispettivamente di file CSS e file di JavaScript.     Utilizzando questo approccio, quando si registra un pacchetto di asset in una vista, viene eseguita la registrazione automatica del nuovo bundle di asset per il gruppo a cui appartiene il bundle originale. Di conseguenza, i file di asset uniti / compressi sono inclusi nella pagina, anzich\u00e9 quelli originali.",
            "title": "Combinazione e compressione delle risorse"
        },
        {
            "location": "/application-structure/sub-assets/#un-esempio",
            "text": "Facciamo un esempio per spiegare ulteriormente l'approccio sopra.  Supponiamo che la tua applicazione abbia due pagine, X e Y. Pagina X utilizza i bundle di asset A, B e C, mentre Page Y utilizza i bundle di asset B, C e D.  Hai due modi per dividere questi pacchetti di risorse. Uno consiste nell'utilizzare un singolo gruppo per includere tutti i pacchetti di risorse, l'altro \u00e8 mettere A nel Gruppo X, D nel Gruppo Y e (B, C) nel Gruppo S. Qual \u00e8 il migliore? Dipende. Il primo modo ha il vantaggio che entrambe le pagine condividono gli stessi file combinati ( CSS e JavaScript), il che rende pi\u00f9 efficace il caching HTTP. D'altra parte, poich\u00e9 il gruppo singolo contiene tutti i bundle, la dimensione dei file combinati CSS e JavaScript sar\u00e0 maggiore e quindi aumenter\u00e0 il tempo di trasmissione del file iniziale. Per semplicit\u00e0, in questo esempio, useremo il primo modo, utilizzare un singolo gruppo per contenere tutti i bundle.   Info  Dividere i raggruppamenti delle risorse in gruppi non \u00e8 un compito banale. Di solito richiede analisi sui dati di traffico del mondo reale di varie risorse su pagine diverse. All'inizio, puoi iniziare con un singolo gruppo per semplicit\u00e0.   Utilizza gli strumenti esistenti (ad esempio Closure Compiler , YUI Compressor ) per unire e comprimere i file CSS e JavaScript in tutti i bundle. Si noti che i file devono essere combinati nell'ordine che soddisfa le dipendenze tra i pacchetti. Ad esempio, se Bundle A dipende da B che dipende da C e D, allora dovresti elencare i file di asset a partire da C e D, seguiti da B e infine A.  Dopo l'unione e la compressione, otteniamo un file CSS e un file JavaScript. Si supponga di nomiare i file  all-xyz.css  e  all-xyz.js , dove  xyz sta per un timestamp o un hash che viene utilizzato per rendere il nome del file univoco per evitare problemi di caching HTTP.  Siamo all'ultimo passo ora. Configurare il gestore degli asset come segue nella configurazione dell'applicazione:  return [\n    'components' =  [\n        'assetManager' =  [\n            'bundles' =  [\n                'all' =  [\n                    'class' =  'yii\\web\\AssetBundle',\n                    'basePath' =  '@webroot/assets',\n                    'baseUrl' =  '@web/assets',\n                    'css' =  ['all-xyz.css'],\n                    'js' =  ['all-xyz.js'],\n                ],\n                'A' =  ['css' =  [], 'js' =  [], 'depends' =  ['all']],\n                'B' =  ['css' =  [], 'js' =  [], 'depends' =  ['all']],\n                'C' =  ['css' =  [], 'js' =  [], 'depends' =  ['all']],\n                'D' =  ['css' =  [], 'js' =  [], 'depends' =  ['all']],\n            ],\n        ],\n    ],\n];  La suddetta configurazione modifica il comportamento predefinito di ciascun pacchetto. In particolare, i pacchetti A, B, C e D non hanno pi\u00f9 file di risorse. Ora dipendono tutti dal pacchetto  all  che contiene i file combinati  all-xyz.css  e  all-xyz.js . Di conseguenza, per la Pagina X, invece di includere i file originali dal Bundle A, B e C, saranno inclusi solo questi due file combinati; la stessa cosa succede a Page Y.  C'\u00e8 un trucco finale per rendere l'approccio spiegato in precedena pi\u00f9 agevole. Invece di modificare direttamente il file di configurazione dell'applicazione, \u00e8 possibile inserire l'array di personalizzazione del bundle in un file separato e includere condizionatamente questo file nella configurazione dell'applicazione. Per esempio,  return [\n    'components' =  [\n        'assetManager' =  [\n            'bundles' =  require __DIR__ . '/' . (YII_ENV_PROD ? 'assets-prod.php' : 'assets-dev.php'),  \n        ],\n    ],\n];  In altre parole, l'array di configurazione del bundle di asset viene salvato  assets-prod.php  per la modalit\u00e0 di produzione e  assets-dev.php per la modalit\u00e0 non di produzione.   Warning  Questo meccanismo di combinazione delle risorse si basa sulla capacit\u00e0 di poter sovrascrivere le propriet\u00e0 dei bundle di asse registrati tramite  yii \\ web \\ AssetManager :: $ bundle . Tuttavia, come gi\u00e0 detto sopra, questa abilit\u00e0 non copre gli aggiustamenti del bundle degli asset, che vengono eseguiti nel metodo  yii \\ web \\ AssetBundle :: init ()  o dopo che il bundle \u00e8 stato registrato. Dovresti evitare l'uso di tali pacchetti dinamici durante la combinazione delle risorse.",
            "title": "Un esempio"
        },
        {
            "location": "/application-structure/sub-assets/#comando-asset",
            "text": "Yii fornisce un comando console chiamato  asset  per automatizzare l'approccio che abbiamo appena descritto.  Per utilizzare questo comando, \u00e8 necessario innanzitutto creare un file di configurazione per descrivere quali gruppi di risorse devono essere combinati e come devono essere raggruppati. \u00c8 possibile utilizzare il sottocomando  asset/template  per generare un modello e quindi modificarlo per adattarlo alle proprie esigenze.  yii asset/template assets.php  Il comando genera un file nominato  assets.php  nella directory corrente. Il contenuto di questo file \u00e8 simile al seguente:  ?php\n/**\n* Configuration file for the \"yii asset\" console command.\n* Note that in the console environment, some path aliases like '@webroot' and '@web' may not exist.\n* Please define these missing path aliases.\n*/\nreturn [\n    // Adjust command/callback for JavaScript files compressing:\n    'jsCompressor' =  'java -jar compiler.jar --js {from} --js_output_file {to}',\n    // Adjust command/callback for CSS files compressing:\n    'cssCompressor' =  'java -jar yuicompressor.jar --type css {from} -o {to}',\n    // Whether to delete asset source after compression:\n    'deleteSource' =  false,\n    // The list of asset bundles to compress:\n    'bundles' =  [\n        // 'yii\\web\\YiiAsset',\n        // 'yii\\web\\JqueryAsset',\n    ],\n    // Asset bundle for compression output:\n    'targets' =  [\n        'all' =  [\n            'class' =  'yii\\web\\AssetBundle',\n            'basePath' =  '@webroot/assets',\n            'baseUrl' =  '@web/assets',\n            'js' =  'js/all-{hash}.js',\n            'css' =  'css/all-{hash}.css',\n        ],\n    ],\n    // Asset manager configuration:\n    'assetManager' =  [\n    ],\n];  \u00c8 necessario modificare questo file e specificare i pacchetti che si intende combinare nell'opzione  bundles . Nell'opzione  targets  \u00e8 necessario specificare come i fasci debbano essere divisi in gruppi. \u00c8 possibile specificare uno o pi\u00f9 gruppi, come sopra menzionato.   Warning  Poich\u00e8 gli alia  @webroot  e  @web  non sono disponibili nella console, \u00e8 necessario definire in modo esplicito nella configurazione.   I file JavaScript vengono uniti, compressi e scritti  js/all-{hash}.js  dove {hash} viene sostituito con l'hash del file risultante.  Le opzioni  jsCompressor  e  cssCompressor  specificano i comandi della console o i callback PHP per l'esecuzione di JavaScript e CSS. Per impostazione predefinita, Yii utilizza  Closure Compiler  per combinare i file JavaScript e YUI Compressor per combinare i file CSS. Dovresti installare questi strumenti manualmente o modificare queste opzioni per utilizzare i tuoi strumenti preferiti.  Con il file di configurazione, \u00e8 possibile eseguire il comando  asset  per combinare e comprimere i file di asset e quindi generare un nuovo file di configurazione del bundle di asset  assets-prod.php :  yii asset assets.php config/assets-prod.php  Il file di configurazione generato pu\u00f2 essere incluso nella configurazione dell'applicazione, come descritto nell'ultima sottosezione.   Warning  Se si personalizzano i bundle delle risorse per la propria applicazione tramite  yii \\ web \\ AssetManager :: $ bundles  o  yii \\ web \\ AssetManager :: $ assetMap  e si desidera applicare questa personalizzazione per i file di origine della compressione, \u00e8 necessario includere queste opzioni per la sezione  assetManager  all'interno del file di configurazione del comando asset.    Warning  Mentre si specifica la sorgente di compressione, si dovrebbe evitare l'uso di bundle di asset i cui parametri possono essere regolati dinamicamente (ad esempio al metodo  init()  o dopo la registrazione), poich\u00e9 potrebbero funzionare in modo non corretto dopo la compressione.",
            "title": "Comando asset"
        },
        {
            "location": "/application-structure/sub-assets/#raggruppamento-di-pacchetti-di-asset",
            "text": "Nell'ultima sottosezione, abbiamo spiegato come combinare tutti i pacchetti di risorse in uno solo per minimizzare le richieste HTTP per i file di risorsa a cui si fa riferimento in un'applicazione. Questo non \u00e8 sempre auspicabile nella pratica. Ad esempio, immagina che la tua applicazione abbia un \"front-end\" e un \"back-end\", ognuno dei quali utilizza un set diverso di file JavaScript e CSS. In questo caso, la combinazione di tutti i bundle di asset non ha senso, perch\u00e9 i bundle di asset per il \"front-end\" non vengono utilizzati dal \"back-end\" e sarebbe uno spreco di larghezza di banda della rete da inviare le risorse \"back-end\" quando viene richiesta una pagina \"front-end\".  Per risolvere il problema precedente, \u00e8 possibile dividere gruppi di risorse in gruppi e combinare raggruppamenti di risorse per ciascun gruppo. La seguente configurazione mostra come raggruppare i pacchetti di asset:  return [\n    ...\n    // Specify output bundles with groups:\n    'targets' =  [\n        'allShared' =  [\n            'js' =  'js/all-shared-{hash}.js',\n            'css' =  'css/all-shared-{hash}.css',\n            'depends' =  [\n                // Include all assets shared between 'backend' and 'frontend'\n                'yii\\web\\YiiAsset',\n                'app\\assets\\SharedAsset',\n            ],\n        ],\n        'allBackEnd' =  [\n            'js' =  'js/all-{hash}.js',\n            'css' =  'css/all-{hash}.css',\n            'depends' =  [\n                // Include only 'backend' assets:\n                'app\\assets\\AdminAsset'\n            ],\n        ],\n        'allFrontEnd' =  [\n            'js' =  'js/all-{hash}.js',\n            'css' =  'css/all-{hash}.css',\n            'depends' =  [], // Include all remaining assets\n        ],\n    ],\n    ...\n];  Come si pu\u00f2 vedere, i fasci di attivit\u00e0 si dividono in tre gruppi:  allShared ,  allBackEnd  e  allFrontEnd . Ognuno di essi dipende da un insieme appropriato di pacchetti di risorse. Ad esempio,  allBackEnd  dipende da  app\\assets\\AdminAsset . Quando si esegue il comando  asset  con questa configurazione, unir\u00e0 i bundle di asset in base alle specifiche precedenti.   Info  Puoi lasciare la configurazione  depends  vuota per uno dei pacchetti di destinazione. In questo modo, quel particolare bundle di asset dipender\u00e0 da tutti i bundle di asset rimanenti su cui altri bundle target non dipendono.",
            "title": "Raggruppamento di pacchetti di asset"
        },
        {
            "location": "/application-structure/sub-extensions/",
            "text": "Estensioni\n\n\nLe estensioni sono pacchetti software ridistribuibili progettati specificamente per essere utilizzati nella applicazioni Yii e offrono funzionalit\u00e0 pronte all'uso. Ad esempio, l'estensione \nyiisoft / yii2-debug\n aggiunge una comoda barra di debug nella parte inferiore di ogni pagina dell'applicazione per aiutarti a comprendere pi\u00f9 facilmente come vengono generate le pagine. Puoi usare le estensioni per accellerare il tuo processo di sviluppo. Puoi anche impacchettare il tuo codice come estensione per condividere con altre persone il tuo grande lavoro.\n\n\n\n\nNote\n\n\nUtiliziamo il termine \"estensione\" per fare riferimento ai pacchetti software specifici di Yii. Per pacchetti software generici che possono essere utilizzati senza Yii, faremo riferimento a loro usando il termine di \"pacchetto\" o \"libreria\".\n\n\n\n\nUtilizzando le estensioni\n\n\nPer utilizzare un'estensione, \u00e8 necessario prima installarla. La maggior parte delle estensioni sono distribuite come pacchetti di \nComposer\n che possono essere installati seguendo due semplici passaggi:\n1. modificare il file \ncomposer.json\n dell'applicazione e specificare quali estensioni (pacchetti di Composer) si desidera installare.\n2. eseguire \ncomposer install\n per installare le estensioni specificate.\n\n\nSi noti che potrebbe essere necessario installare il Composer se non lo si possiede.\n\n\nPer impostazione predefinita, il Composer installa i pacchetti registrati su \nPackagist\n, il pi\u00f9 grande repository per i pacchetti Composer open source. Puoi cercare estensioni su Packagist. Puoi anche creare il tuo repository e configurare il Composer per usarlo. Questo \u00e8 utile se stai sviluppando estensioni private che vuoi condividere solo nei tuoi progetti.\n\n\nLe estensioni installate da Composer sono memorizzate nella directory \nBasePath/vendor\n, dove \nBasePath\n fa riferimento al percorso base dell'applicazione.\nPoich\u00e8 il Composer \u00e8 un gestore delle dipendenze, quando installa un pacchetto, installa anche tutti i suoi pacchetti dipendenti.\n\n\nAd esempio, per installare l'estensione \nyiisoft/yii2-imagine\n, dobbiamo modificare il nostro \ncomposer.json\n, simile al seguente:\n\n\n{\n    // ...\n\n    \"require\": {\n        // ... other dependencies\n\n        \"yiisoft/yii2-imagine\": \"*\"\n    }\n}\n\n\n\nDopo l'installazione, dovresti vedere la directory \nyiisoft/yii2-imagine\n sotto \nBasePath/vendor\n. Dovresti anche vedere un'altra directory \nimagine/imagine\n che contiene il pacchetto dipendente installato.\n\n\n\n\nTip\n\n\nIl \nyiisoft/yii2-imagine\n \u00e8 un'estensione nucleo sviluppato e mantenuto dal team di sviluppo di Yii. Tutte le estensioni base sono ospitate su \nPackagist\n e sono denominate come \nyiisoft/yii2-xyz\n, dove \nxyz\n stanno per le diverse versioni.\n\n\n\n\nOra puoi usare le estensioni installate che faranno parte della tua applicazione. L'esempio seguente mostra come utilizzare la classe \nyii\\imagine\\Image\n fornita dall'estensione \nyiisoft/yii2-imagine\n:\n\n\nuse Yii;\nuse yii\\imagine\\Image;\n\n// generate a thumbnail image\nImage::thumbnail('@webroot/img/test-image.jpg', 120, 120)\n    -\nsave(Yii::getAlias('@runtime/thumb-test-image.jpg'), ['quality' =\n 50]);\n\n\n\n\n\nTip\n\n\nLe classi delle estensioni vengono caricate automaticamente dal caricatore automatico della classe Yii.\n\n\n\n\nInstallare manualmente le estensioni\n\n\nIn alcune rare occasioni, potresti voler installare alcune o tutte le estensioni manualmente, piuttosto che affidarti al Composer. Per fare ci\u00f2, dovresti:\n\n\n\n\nscaricare i file dell'archivio dell'estensione e decomprimerli nella directory \nvendor\n.\n\n\ninstallare i caricatori automatici della classe forniti dalle estensioni, se presenti.\n\n\nscaricare e installare le estensioni dipendenti come da istruzioni.\n\n\n\n\nSe un'estensione non ha un autoloader di classe ma segue lo standard \nPSR-4\n, \u00e8 possibile utilizzare il caricatore automatico di classe fornito da Yii per caricare automaticamente le classe di estensione. Tutto quello che devi fare \u00e8 solo dichiarare un alias di root per la directory dell'estensione. Ad esempio, supponendo di aver installato un'estensione nella directory \nvendor/mycompany/myext\n e le classi di estensione si trovano nel namespace \nmyext\n, \u00e8 possibile includere il seguente codice nella configurazione dell'applicazione:\n\n\n[\n    'aliases' =\n [\n        '@myext' =\n '@vendor/mycompany/myext',\n    ],\n]\n\n\n\nCreazione di un'estensione\n\n\nPotresti considerare di creare un'estensione quando senti la necessit\u00e0 di condividere con altre persone il tuo codice. Un'estensione pu\u00f2 contenere qualsiasi codice che preferisci, come una classe helper, un widget, un modulo, ecc..\n\n\nSi consiglia di creare un'estensione in termini di un pacchetto Composer in modo che possa essere installato in modo pi\u00f9 semplice e che possa essere anche utilizzato da altri utenti.\n\n\nDi seguito sono riportati i passaggi di base che \u00e8 possibile seguire per creare un'estensione come pacchetto di Composer.\n\n\n\n\nCrea un progetto per la tua estensione e ospitalo si una repository VCS, come per esempio \ngithub.com\n. Il lavoro di sviluppo e manutensione per l'estensione dovrebbe essere fatto su questa directory.\n\n\nSotto la directory root del progetto, crea un file chiamato \ncomposer.json\n come richiesto dal Composer.\n\n\nRegistra la tua estensione come una repository Composer, come Packagist, in modo che altri utenti possano trovare e installare la tua estensione usando il Composer.\n\n\n\n\nComposer.json\n\n\nOgni pacchetto di Composer deve avere un file \ncomposer.json\n nella sua directory principale. Il file contiene i metadati relativi al pacchetto. L'esempio seguente mostra il file \ncomposer.json\n per l'estensione \nyiisoft/yii2-imagine\n:\n\n\n{\n    // package name\n    \"name\": \"yiisoft/yii2-imagine\",\n\n    // package type\n    \"type\": \"yii2-extension\",\n\n    \"description\": \"The Imagine integration for the Yii framework\",\n    \"keywords\": [\"yii2\", \"imagine\", \"image\", \"helper\"],\n    \"license\": \"BSD-3-Clause\",\n    \"support\": {\n        \"issues\": \"https://github.com/yiisoft/yii2/issues?labels=ext%3Aimagine\",\n        \"forum\": \"http://www.yiiframework.com/forum/\",\n        \"wiki\": \"http://www.yiiframework.com/wiki/\",\n        \"irc\": \"irc://irc.freenode.net/yii\",\n        \"source\": \"https://github.com/yiisoft/yii2\"\n    },\n    \"authors\": [\n        {\n            \"name\": \"Lorenzo Milicia\",\n            \"email\": \"lorenzo.milicia4@gmail.com\"\n        }\n    ],\n\n    // package dependencies\n    \"require\": {\n        \"yiisoft/yii2\": \"~2.0.0\",\n        \"imagine/imagine\": \"v0.5.0\"\n    },\n\n    // class autoloading specs\n    \"autoload\": {\n        \"psr-4\": {\n            \"yii\\\\imagine\\\\\": \"\"\n        }\n    }\n}\n\n\n\nEstensioni principali\n\n\nYii fornisce le seguenti estensioni principali sviluppate e gestite dal team di sviluppatori di Yii. Sono tutti registrati su Packagist. Ecco un elenco delle principali estensioni:\n\n\n\n\nyiisoft / yii2-apidoc\n: fornisce un generatore di documentazione API estensibile e ad alte prestazioni. Viene anche utilizzato per generare la documentazione dell'API del framework principale.\n\n\nyiisoft / yii2-authclient\n: fornisce un insieme di client di autenticazione comunemente utilizzati, come il client OAuth2 di Facebook, il client GitHub OAuth2.\n\n\nyiisoft / yii2-bootstrap\n: fornisce un set di widget che incapsulano i componenti e i plugin Bootstrap .\n\n\nyiisoft / yii2-codeception\n: fornisce supporto di test basato su Codeception .\n\n\nyiisoft / yii2-debug\n: fornisce il supporto per il debug per le applicazioni Yii. Quando viene utilizzata questa estensione, nella parte inferiore di ogni pagina viene visualizzata una barra degli strumenti del debugger. L'estensione fornisce anche una serie di pagine autonome per visualizzare informazioni di debug pi\u00f9 dettagliate.\n\n\nyiisoft / yii2-elasticsearch\n: fornisce il supporto per l'utilizzo di Elasticsearch . Comprende il supporto di query / ricerca di base e implementa anche il pattern Active Record che consente di archiviare i record attivi in \u200b\u200bElasticsearch.\n\n\nyiisoft / yii2-faker\n: fornisce il supporto per l'utilizzo di Faker per generare dati falsi per te.\n\n\nyiisoft / yii2-gii\n: fornisce un generatore di codice basato sul Web che \u00e8 altamente estensibile e pu\u00f2 essere utilizzato per generare rapidamente modelli, moduli, moduli, CRUD, ecc.\n\n\nyiisoft / yii2-httpclient\n: fornisce un client HTTP.\n\n\nyiisoft / yii2-imagine\n: fornisce funzioni di manipolazione delle immagini di uso comune basate su Imagine .\n\n\nyiisoft / yii2-jui\n: fornisce un insieme di widget che incapsulano le interazioni e i widget dell'interfaccia utente JQuery .\n\n\nyiisoft / yii2-mongodb\n: fornisce il supporto per l'utilizzo di MongoDB . Include funzionalit\u00e0 come query di base, record attivi, migrazioni, memorizzazione nella cache, generazione di codice, ecc.\n\n\nyiisoft / yii2-redis\n: fornisce il supporto per l'utilizzo di redis . Include funzionalit\u00e0 come query di base, record attivi, memorizzazione nella cache, ecc.\n\n\nyiisoft / yii2-smarty\n: fornisce un motore di template basato su Smarty .\n\n\nyiisoft / yii2-sfinge\n: fornisce il supporto per l'uso di Sfinge . Include funzionalit\u00e0 come query di base, Active Record, generazione di codice, ecc.\n\n\nyiisoft / yii2-swiftmailer\n: fornisce funzioni di invio e-mail basate su swiftmailer .\n\n\nyiisoft / yii2-twig\n: fornisce un motore di template basato su Twig .",
            "title": "Estensioni"
        },
        {
            "location": "/application-structure/sub-extensions/#estensioni",
            "text": "Le estensioni sono pacchetti software ridistribuibili progettati specificamente per essere utilizzati nella applicazioni Yii e offrono funzionalit\u00e0 pronte all'uso. Ad esempio, l'estensione  yiisoft / yii2-debug  aggiunge una comoda barra di debug nella parte inferiore di ogni pagina dell'applicazione per aiutarti a comprendere pi\u00f9 facilmente come vengono generate le pagine. Puoi usare le estensioni per accellerare il tuo processo di sviluppo. Puoi anche impacchettare il tuo codice come estensione per condividere con altre persone il tuo grande lavoro.   Note  Utiliziamo il termine \"estensione\" per fare riferimento ai pacchetti software specifici di Yii. Per pacchetti software generici che possono essere utilizzati senza Yii, faremo riferimento a loro usando il termine di \"pacchetto\" o \"libreria\".",
            "title": "Estensioni"
        },
        {
            "location": "/application-structure/sub-extensions/#utilizzando-le-estensioni",
            "text": "Per utilizzare un'estensione, \u00e8 necessario prima installarla. La maggior parte delle estensioni sono distribuite come pacchetti di  Composer  che possono essere installati seguendo due semplici passaggi:\n1. modificare il file  composer.json  dell'applicazione e specificare quali estensioni (pacchetti di Composer) si desidera installare.\n2. eseguire  composer install  per installare le estensioni specificate.  Si noti che potrebbe essere necessario installare il Composer se non lo si possiede.  Per impostazione predefinita, il Composer installa i pacchetti registrati su  Packagist , il pi\u00f9 grande repository per i pacchetti Composer open source. Puoi cercare estensioni su Packagist. Puoi anche creare il tuo repository e configurare il Composer per usarlo. Questo \u00e8 utile se stai sviluppando estensioni private che vuoi condividere solo nei tuoi progetti.  Le estensioni installate da Composer sono memorizzate nella directory  BasePath/vendor , dove  BasePath  fa riferimento al percorso base dell'applicazione.\nPoich\u00e8 il Composer \u00e8 un gestore delle dipendenze, quando installa un pacchetto, installa anche tutti i suoi pacchetti dipendenti.  Ad esempio, per installare l'estensione  yiisoft/yii2-imagine , dobbiamo modificare il nostro  composer.json , simile al seguente:  {\n    // ...\n\n    \"require\": {\n        // ... other dependencies\n\n        \"yiisoft/yii2-imagine\": \"*\"\n    }\n}  Dopo l'installazione, dovresti vedere la directory  yiisoft/yii2-imagine  sotto  BasePath/vendor . Dovresti anche vedere un'altra directory  imagine/imagine  che contiene il pacchetto dipendente installato.   Tip  Il  yiisoft/yii2-imagine  \u00e8 un'estensione nucleo sviluppato e mantenuto dal team di sviluppo di Yii. Tutte le estensioni base sono ospitate su  Packagist  e sono denominate come  yiisoft/yii2-xyz , dove  xyz  stanno per le diverse versioni.   Ora puoi usare le estensioni installate che faranno parte della tua applicazione. L'esempio seguente mostra come utilizzare la classe  yii\\imagine\\Image  fornita dall'estensione  yiisoft/yii2-imagine :  use Yii;\nuse yii\\imagine\\Image;\n\n// generate a thumbnail image\nImage::thumbnail('@webroot/img/test-image.jpg', 120, 120)\n    - save(Yii::getAlias('@runtime/thumb-test-image.jpg'), ['quality' =  50]);   Tip  Le classi delle estensioni vengono caricate automaticamente dal caricatore automatico della classe Yii.",
            "title": "Utilizzando le estensioni"
        },
        {
            "location": "/application-structure/sub-extensions/#installare-manualmente-le-estensioni",
            "text": "In alcune rare occasioni, potresti voler installare alcune o tutte le estensioni manualmente, piuttosto che affidarti al Composer. Per fare ci\u00f2, dovresti:   scaricare i file dell'archivio dell'estensione e decomprimerli nella directory  vendor .  installare i caricatori automatici della classe forniti dalle estensioni, se presenti.  scaricare e installare le estensioni dipendenti come da istruzioni.   Se un'estensione non ha un autoloader di classe ma segue lo standard  PSR-4 , \u00e8 possibile utilizzare il caricatore automatico di classe fornito da Yii per caricare automaticamente le classe di estensione. Tutto quello che devi fare \u00e8 solo dichiarare un alias di root per la directory dell'estensione. Ad esempio, supponendo di aver installato un'estensione nella directory  vendor/mycompany/myext  e le classi di estensione si trovano nel namespace  myext , \u00e8 possibile includere il seguente codice nella configurazione dell'applicazione:  [\n    'aliases' =  [\n        '@myext' =  '@vendor/mycompany/myext',\n    ],\n]",
            "title": "Installare manualmente le estensioni"
        },
        {
            "location": "/application-structure/sub-extensions/#creazione-di-unestensione",
            "text": "Potresti considerare di creare un'estensione quando senti la necessit\u00e0 di condividere con altre persone il tuo codice. Un'estensione pu\u00f2 contenere qualsiasi codice che preferisci, come una classe helper, un widget, un modulo, ecc..  Si consiglia di creare un'estensione in termini di un pacchetto Composer in modo che possa essere installato in modo pi\u00f9 semplice e che possa essere anche utilizzato da altri utenti.  Di seguito sono riportati i passaggi di base che \u00e8 possibile seguire per creare un'estensione come pacchetto di Composer.   Crea un progetto per la tua estensione e ospitalo si una repository VCS, come per esempio  github.com . Il lavoro di sviluppo e manutensione per l'estensione dovrebbe essere fatto su questa directory.  Sotto la directory root del progetto, crea un file chiamato  composer.json  come richiesto dal Composer.  Registra la tua estensione come una repository Composer, come Packagist, in modo che altri utenti possano trovare e installare la tua estensione usando il Composer.",
            "title": "Creazione di un'estensione"
        },
        {
            "location": "/application-structure/sub-extensions/#composerjson",
            "text": "Ogni pacchetto di Composer deve avere un file  composer.json  nella sua directory principale. Il file contiene i metadati relativi al pacchetto. L'esempio seguente mostra il file  composer.json  per l'estensione  yiisoft/yii2-imagine :  {\n    // package name\n    \"name\": \"yiisoft/yii2-imagine\",\n\n    // package type\n    \"type\": \"yii2-extension\",\n\n    \"description\": \"The Imagine integration for the Yii framework\",\n    \"keywords\": [\"yii2\", \"imagine\", \"image\", \"helper\"],\n    \"license\": \"BSD-3-Clause\",\n    \"support\": {\n        \"issues\": \"https://github.com/yiisoft/yii2/issues?labels=ext%3Aimagine\",\n        \"forum\": \"http://www.yiiframework.com/forum/\",\n        \"wiki\": \"http://www.yiiframework.com/wiki/\",\n        \"irc\": \"irc://irc.freenode.net/yii\",\n        \"source\": \"https://github.com/yiisoft/yii2\"\n    },\n    \"authors\": [\n        {\n            \"name\": \"Lorenzo Milicia\",\n            \"email\": \"lorenzo.milicia4@gmail.com\"\n        }\n    ],\n\n    // package dependencies\n    \"require\": {\n        \"yiisoft/yii2\": \"~2.0.0\",\n        \"imagine/imagine\": \"v0.5.0\"\n    },\n\n    // class autoloading specs\n    \"autoload\": {\n        \"psr-4\": {\n            \"yii\\\\imagine\\\\\": \"\"\n        }\n    }\n}",
            "title": "Composer.json"
        },
        {
            "location": "/application-structure/sub-extensions/#estensioni-principali",
            "text": "Yii fornisce le seguenti estensioni principali sviluppate e gestite dal team di sviluppatori di Yii. Sono tutti registrati su Packagist. Ecco un elenco delle principali estensioni:   yiisoft / yii2-apidoc : fornisce un generatore di documentazione API estensibile e ad alte prestazioni. Viene anche utilizzato per generare la documentazione dell'API del framework principale.  yiisoft / yii2-authclient : fornisce un insieme di client di autenticazione comunemente utilizzati, come il client OAuth2 di Facebook, il client GitHub OAuth2.  yiisoft / yii2-bootstrap : fornisce un set di widget che incapsulano i componenti e i plugin Bootstrap .  yiisoft / yii2-codeception : fornisce supporto di test basato su Codeception .  yiisoft / yii2-debug : fornisce il supporto per il debug per le applicazioni Yii. Quando viene utilizzata questa estensione, nella parte inferiore di ogni pagina viene visualizzata una barra degli strumenti del debugger. L'estensione fornisce anche una serie di pagine autonome per visualizzare informazioni di debug pi\u00f9 dettagliate.  yiisoft / yii2-elasticsearch : fornisce il supporto per l'utilizzo di Elasticsearch . Comprende il supporto di query / ricerca di base e implementa anche il pattern Active Record che consente di archiviare i record attivi in \u200b\u200bElasticsearch.  yiisoft / yii2-faker : fornisce il supporto per l'utilizzo di Faker per generare dati falsi per te.  yiisoft / yii2-gii : fornisce un generatore di codice basato sul Web che \u00e8 altamente estensibile e pu\u00f2 essere utilizzato per generare rapidamente modelli, moduli, moduli, CRUD, ecc.  yiisoft / yii2-httpclient : fornisce un client HTTP.  yiisoft / yii2-imagine : fornisce funzioni di manipolazione delle immagini di uso comune basate su Imagine .  yiisoft / yii2-jui : fornisce un insieme di widget che incapsulano le interazioni e i widget dell'interfaccia utente JQuery .  yiisoft / yii2-mongodb : fornisce il supporto per l'utilizzo di MongoDB . Include funzionalit\u00e0 come query di base, record attivi, migrazioni, memorizzazione nella cache, generazione di codice, ecc.  yiisoft / yii2-redis : fornisce il supporto per l'utilizzo di redis . Include funzionalit\u00e0 come query di base, record attivi, memorizzazione nella cache, ecc.  yiisoft / yii2-smarty : fornisce un motore di template basato su Smarty .  yiisoft / yii2-sfinge : fornisce il supporto per l'uso di Sfinge . Include funzionalit\u00e0 come query di base, Active Record, generazione di codice, ecc.  yiisoft / yii2-swiftmailer : fornisce funzioni di invio e-mail basate su swiftmailer .  yiisoft / yii2-twig : fornisce un motore di template basato su Twig .",
            "title": "Estensioni principali"
        },
        {
            "location": "/handling-requests/sub-request-overview/",
            "text": "Panoramica\n\n\nOgni volta che un'applicazione Yii gestisce una richiesta, subisce un flusso di richieste come segue:\n\n\n\n\nUn utente fa una richiesta allo script di entrata \nweb/index.php\n.\n\n\nLo script di entrata carica la configurazione dell'applicazione e crea un'istanza dell'applicazione per gestire la richiesta.\n\n\nL'applicazione converte il percorso richiesto con l'aiuto del componente dell'applicazione richiesta.\n\n\nL'applicazione crea un'istanza del controller per gestire la richiesta.\n\n\nIl controller crea un'istanza di azione ed esegue i filtri per l'azione.\n\n\nSe un filtro fallisce, l'azione viene annullata.\n\n\nSe tutti i filtri passano, l'azione viene eseguita.\n\n\nL'azione carica un modello di dati , possibilmente da un database.\n\n\nL'azione rende una vista , fornendola con il modello di dati.\n\n\nIl risultato del rendering viene restituito al componente dell'applicazione di risposta .\n\n\nIl componente di risposta invia il risultato visualizzato al browser dell'utente.\n\n\n\n\nIl seguente diagramma mostra come un'applicazione gestisce una richiesta.\n\n\n\n\nIn questa sezione, descriveremo in dettaglio come funzionano alcuni di questi passaggi.",
            "title": "Panoramica sulla gestione delle richieste"
        },
        {
            "location": "/handling-requests/sub-request-overview/#panoramica",
            "text": "Ogni volta che un'applicazione Yii gestisce una richiesta, subisce un flusso di richieste come segue:   Un utente fa una richiesta allo script di entrata  web/index.php .  Lo script di entrata carica la configurazione dell'applicazione e crea un'istanza dell'applicazione per gestire la richiesta.  L'applicazione converte il percorso richiesto con l'aiuto del componente dell'applicazione richiesta.  L'applicazione crea un'istanza del controller per gestire la richiesta.  Il controller crea un'istanza di azione ed esegue i filtri per l'azione.  Se un filtro fallisce, l'azione viene annullata.  Se tutti i filtri passano, l'azione viene eseguita.  L'azione carica un modello di dati , possibilmente da un database.  L'azione rende una vista , fornendola con il modello di dati.  Il risultato del rendering viene restituito al componente dell'applicazione di risposta .  Il componente di risposta invia il risultato visualizzato al browser dell'utente.   Il seguente diagramma mostra come un'applicazione gestisce una richiesta.   In questa sezione, descriveremo in dettaglio come funzionano alcuni di questi passaggi.",
            "title": "Panoramica"
        },
        {
            "location": "/handling-requests/sub-bootstrapping/",
            "text": "Bootstrapping\n\n\nIl bootstrap fa riferimento al processo di preparazione dell'ambiente prima che un'applicazione inizi a risolvere e ad elaborare una richiesta in entrata. Il bootstrap viene eseguito in due punti: lo script di immissione (entry scrpit) e nell' applicazione.\n\n\nNell'entry script, vengono registrati i caricatori automatici di classi per diverse librerie. Ci\u00f2 include il caricatore automatico \nComposer\n tramite il relativo file \nautoload.php\n e il caricatore automatico Yii, attraverso il relativo file della classe \nYii\n. L'entry script carica quindi la configurazione dell'applicazione e crea un'istanza dell'applicazione.\n\n\nNel costruttore dell'applicazione, viene eseguito il seguente lavoro di bootstrap:\n\n\n\n\nviene chiamato il metodo \npreInit()\n, che configura alcune propriet\u00e0 dell'applicazione ad alta priorit\u00e0, come \nyii \\ base \\ Application :: basePath\n.\n\n\nRegistrare \nyii \\ base \\ Application :: errorHandler\n.\n\n\nInizializza le propriet\u00e0 dell'applicazione utilizzando la configurazione dell'applicazione specificata.\n\n\nViene chiamato il metodo \ninit()\n che a sua volta chiama il metodo \nbootstrap()\n per eseguire componenti bootstrap.\n\n\nIncludi il file manifest dell'estensione \nvendor/yiisoft/extensions.php\n.\n\n\nCrea ed esegui i componenti bootstrap dichiarati dalle estensioni.\n\n\nDobbiamo creare ed eseguire componenti e / o moduli dell'applicazione dichiarati nella propriet\u00e0 bootstrap dell'applicazione .\n\n\n\n\n\n\n\n\nPoich\u00e9 bootstrap deve essere eseguito prima di gestire ogni richiesta, \u00e8 molto importante mantenere questo processo leggero e ottimizzarlo il pi\u00f9 possibile.\n\n\nAdesso dobbiamo cercare di non registrare troppi componenti bootstrap. Un componente bootstrap \u00e8 necessario solo se vuole partecipare all'intero ciclo di vita della gestione richiesta. Ad esempio,se un modulo deve registrare regole di analisi URL aggiuntive, dovrebbe essere elencato nella propriet\u00e0 bootstrap in modo che le nuove regole URL possano avere effetto prima che vengano utilizzate per risolvere le richieste.\n\n\nIn modalit\u00e0 di produzione dell'applicazione, possiamo abilitare una cache bytecode, come \nOPcache\n o \nAPC\n, per ridurre al minimo il tempo necessario per includere e analizzare i file PHP.\n\n\nAlcune applicazioni di grandi dimensioni hanno configurazioni molto complesse e suddivise in molti file di configurazione pi\u00f9 piccoli. In tal caso, ci conviene prendere in considerazione la memorizzazione nella cache di un intero array di configurazione.",
            "title": "Bootstrapping"
        },
        {
            "location": "/handling-requests/sub-bootstrapping/#bootstrapping",
            "text": "Il bootstrap fa riferimento al processo di preparazione dell'ambiente prima che un'applicazione inizi a risolvere e ad elaborare una richiesta in entrata. Il bootstrap viene eseguito in due punti: lo script di immissione (entry scrpit) e nell' applicazione.  Nell'entry script, vengono registrati i caricatori automatici di classi per diverse librerie. Ci\u00f2 include il caricatore automatico  Composer  tramite il relativo file  autoload.php  e il caricatore automatico Yii, attraverso il relativo file della classe  Yii . L'entry script carica quindi la configurazione dell'applicazione e crea un'istanza dell'applicazione.  Nel costruttore dell'applicazione, viene eseguito il seguente lavoro di bootstrap:   viene chiamato il metodo  preInit() , che configura alcune propriet\u00e0 dell'applicazione ad alta priorit\u00e0, come  yii \\ base \\ Application :: basePath .  Registrare  yii \\ base \\ Application :: errorHandler .  Inizializza le propriet\u00e0 dell'applicazione utilizzando la configurazione dell'applicazione specificata.  Viene chiamato il metodo  init()  che a sua volta chiama il metodo  bootstrap()  per eseguire componenti bootstrap.  Includi il file manifest dell'estensione  vendor/yiisoft/extensions.php .  Crea ed esegui i componenti bootstrap dichiarati dalle estensioni.  Dobbiamo creare ed eseguire componenti e / o moduli dell'applicazione dichiarati nella propriet\u00e0 bootstrap dell'applicazione .     Poich\u00e9 bootstrap deve essere eseguito prima di gestire ogni richiesta, \u00e8 molto importante mantenere questo processo leggero e ottimizzarlo il pi\u00f9 possibile.  Adesso dobbiamo cercare di non registrare troppi componenti bootstrap. Un componente bootstrap \u00e8 necessario solo se vuole partecipare all'intero ciclo di vita della gestione richiesta. Ad esempio,se un modulo deve registrare regole di analisi URL aggiuntive, dovrebbe essere elencato nella propriet\u00e0 bootstrap in modo che le nuove regole URL possano avere effetto prima che vengano utilizzate per risolvere le richieste.  In modalit\u00e0 di produzione dell'applicazione, possiamo abilitare una cache bytecode, come  OPcache  o  APC , per ridurre al minimo il tempo necessario per includere e analizzare i file PHP.  Alcune applicazioni di grandi dimensioni hanno configurazioni molto complesse e suddivise in molti file di configurazione pi\u00f9 piccoli. In tal caso, ci conviene prendere in considerazione la memorizzazione nella cache di un intero array di configurazione.",
            "title": "Bootstrapping"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/",
            "text": "Routing e creazione degli URL\n\n\nQuando un'applicazione Yii avvia l'elaborazione di una richiesta di URL, il primo passo necessario \u00e8 analizzare l'URL in una \nroute\n. Il percorso viene quindi utilizzato per istanziare l' azione del controller corrispondente per gestire la richiesta. L'intero processo \u00e8 chiamato \nrouting\n.\n\n\nIl processo inverso di routing si chiama creazione di URL , che crea un URL da una determinata route e i parametri di query associati. Successivamente, quando viene richiesto l'URL creato, il processo di routing pu\u00f2 risolverlo nel percorso originale e nei parametri della query associata.\n\n\nIl pezzo centrale responsabile per il routing e la creazione di URL \u00e8 il gestore degli URL , che \u00e8 registrato come componente dell'applicazione \nurlManager\n. Il gestore URL fornisce il metodo \nparseRequest()\n per analizzare una richiesta in entrata in una route e i parametri di query associati ad esso, e fornisce anche il metodo \ncreateUrl()\n per creare un URL da una determinata route e i relativi parametri di query associati.\n\n\nConfigurando il componente \nurlManager\n nella configurazione dell'applicazione, \u00e8 possibile consentire all'applicazione di riconoscere i formati di URL arbitrari senza modificare il codice dell'applicazione esistente. Ad esempio, \u00e8 possibile utilizzare il seguente codice per creare un URL per l'azione \npost/view\n:\n\n\nuse yii\\helpers\\Url;\n\n// Url::to() calls UrlManager::createUrl() to create a URL\n$url = Url::to(['post/view', 'id' =\n 100]);\n\n\n\nA seconda della configurazione dell'\nurlManager\n, l'URL creato pu\u00f2 apparire come uno degli esempi sottostanti. E se l'URL creato viene richiesto in seguito, verr\u00e0 comunque analizzato nella route originale e nel valore del parametro di query.\n\n\n/index.php?r=post%2Fview\nid=100\n/index.php/post/100\n/posts/100\n\n\n\nFormati degli URL\n\n\nIl gestore degli URL supporta due formati:\n\n\n\n\nIl formato URL predefinito.\n\n\nIl formato URL pi\u00f9 \"grazioso\".\n\n\n\n\nIl formato URL predefinito utilizza un parametro di query denominato \nr\n per rappresentare la route e i normali parametri di query. Ad esempio, l'URL \n/index.php?r=post/view\nid=100\n rappresenta il percorso \npost/view\n e il parametro \nid\n ha un valore di \n100\n. Il formato URL predefinito non richiede alcuna configurazione del gestore URL e funziona in qualsiasi configurazione del server Web.\n\n\nIl formato URL \u201cgrazioso\u201c utilizza il percorso aggiuntivo che segue il nome dello script della voce per rappresentare la route e i parametri di query associati. Ad esempio, il percorso aggiuntivo nell'URL \n/index.php/post/100\n \u00e8 \n/post/100\n che pu\u00f2 rappresentare il percorso \npost/view\ne il parametro \nid\n che ha come valore della query \n100\ncon una regola URL appropriata . Per utilizzare il formato URL pi\u00f9 grazioso, \u00e8 necessario progettare un set di regole URL in base ai requisiti effettivi su come dovrebbe apparire l'URL.\n\n\n\u00c8 possibile passare tra i due formati di URL attivando la propriet\u00e0 \nenablePrettyUrl\n del gestore URL senza modificare nessun codice nell'applicazione.\n\n\nRouting\n\n\nIl routing prevede due passaggi:\n\n\n\n\nla richiesta in entrata viene analizzata in una route e i parametri di query associati;\n\n\nviene creata un'azione di controllo corrispondente al percorso analizzato per gestire la richiesta.\n\n\n\n\nQuando si utilizza il formato URL predefinito, l'analisi di una richiesta in una route \u00e8 semplice come ottenere il valore di un parametro GET di una query denominata \nr\n.\n\n\nQuando si utilizza il formato URL \"grazioso\", il gestore URL esaminer\u00e0 le regole URL registrate per trovare quella corrispondente che possa risolvere la richiesta in una route. Se tale regola non pu\u00f2 essere trovata, verr\u00e0 generata un'eccezione \nyii \\ web \\ NotFoundHttpException\n.\n\n\nUna volta che la richiesta viene analizzata in una route, \u00e8 il momento di creare l'azione del controller identificata dalla route stessa. Il percorso \u00e8 suddiviso in pi\u00f9 parti con le barre in esso contenute. Ad esempio, \nsite/index\n sar\u00e0 suddiviso in \nsite\ne \nindex\n. Ogni parte \u00e8 un ID che pu\u00f2 riferirsi a un modulo, a un controllore o a un'azione. A partire dalla prima parte del percorso, l'applicazione effettua le seguenti operazioni per creare i moduli (se presenti), il controller e l'azione:",
            "title": "Routing e creazione degli URL"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#routing-e-creazione-degli-url",
            "text": "Quando un'applicazione Yii avvia l'elaborazione di una richiesta di URL, il primo passo necessario \u00e8 analizzare l'URL in una  route . Il percorso viene quindi utilizzato per istanziare l' azione del controller corrispondente per gestire la richiesta. L'intero processo \u00e8 chiamato  routing .  Il processo inverso di routing si chiama creazione di URL , che crea un URL da una determinata route e i parametri di query associati. Successivamente, quando viene richiesto l'URL creato, il processo di routing pu\u00f2 risolverlo nel percorso originale e nei parametri della query associata.  Il pezzo centrale responsabile per il routing e la creazione di URL \u00e8 il gestore degli URL , che \u00e8 registrato come componente dell'applicazione  urlManager . Il gestore URL fornisce il metodo  parseRequest()  per analizzare una richiesta in entrata in una route e i parametri di query associati ad esso, e fornisce anche il metodo  createUrl()  per creare un URL da una determinata route e i relativi parametri di query associati.  Configurando il componente  urlManager  nella configurazione dell'applicazione, \u00e8 possibile consentire all'applicazione di riconoscere i formati di URL arbitrari senza modificare il codice dell'applicazione esistente. Ad esempio, \u00e8 possibile utilizzare il seguente codice per creare un URL per l'azione  post/view :  use yii\\helpers\\Url;\n\n// Url::to() calls UrlManager::createUrl() to create a URL\n$url = Url::to(['post/view', 'id' =  100]);  A seconda della configurazione dell' urlManager , l'URL creato pu\u00f2 apparire come uno degli esempi sottostanti. E se l'URL creato viene richiesto in seguito, verr\u00e0 comunque analizzato nella route originale e nel valore del parametro di query.  /index.php?r=post%2Fview id=100\n/index.php/post/100\n/posts/100",
            "title": "Routing e creazione degli URL"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#formati-degli-url",
            "text": "Il gestore degli URL supporta due formati:   Il formato URL predefinito.  Il formato URL pi\u00f9 \"grazioso\".   Il formato URL predefinito utilizza un parametro di query denominato  r  per rappresentare la route e i normali parametri di query. Ad esempio, l'URL  /index.php?r=post/view id=100  rappresenta il percorso  post/view  e il parametro  id  ha un valore di  100 . Il formato URL predefinito non richiede alcuna configurazione del gestore URL e funziona in qualsiasi configurazione del server Web.  Il formato URL \u201cgrazioso\u201c utilizza il percorso aggiuntivo che segue il nome dello script della voce per rappresentare la route e i parametri di query associati. Ad esempio, il percorso aggiuntivo nell'URL  /index.php/post/100  \u00e8  /post/100  che pu\u00f2 rappresentare il percorso  post/view e il parametro  id  che ha come valore della query  100 con una regola URL appropriata . Per utilizzare il formato URL pi\u00f9 grazioso, \u00e8 necessario progettare un set di regole URL in base ai requisiti effettivi su come dovrebbe apparire l'URL.  \u00c8 possibile passare tra i due formati di URL attivando la propriet\u00e0  enablePrettyUrl  del gestore URL senza modificare nessun codice nell'applicazione.",
            "title": "Formati degli URL"
        },
        {
            "location": "/handling-requests/sub-routing-url-creation/#routing",
            "text": "Il routing prevede due passaggi:   la richiesta in entrata viene analizzata in una route e i parametri di query associati;  viene creata un'azione di controllo corrispondente al percorso analizzato per gestire la richiesta.   Quando si utilizza il formato URL predefinito, l'analisi di una richiesta in una route \u00e8 semplice come ottenere il valore di un parametro GET di una query denominata  r .  Quando si utilizza il formato URL \"grazioso\", il gestore URL esaminer\u00e0 le regole URL registrate per trovare quella corrispondente che possa risolvere la richiesta in una route. Se tale regola non pu\u00f2 essere trovata, verr\u00e0 generata un'eccezione  yii \\ web \\ NotFoundHttpException .  Una volta che la richiesta viene analizzata in una route, \u00e8 il momento di creare l'azione del controller identificata dalla route stessa. Il percorso \u00e8 suddiviso in pi\u00f9 parti con le barre in esso contenute. Ad esempio,  site/index  sar\u00e0 suddiviso in  site e  index . Ogni parte \u00e8 un ID che pu\u00f2 riferirsi a un modulo, a un controllore o a un'azione. A partire dalla prima parte del percorso, l'applicazione effettua le seguenti operazioni per creare i moduli (se presenti), il controller e l'azione:",
            "title": "Routing"
        },
        {
            "location": "/handling-requests/sub-requests/",
            "text": "",
            "title": "Requests"
        },
        {
            "location": "/handling-requests/sub-responses/",
            "text": "",
            "title": "Responses"
        },
        {
            "location": "/handling-requests/sub-session-cookies/",
            "text": "",
            "title": "Session & Cookies"
        },
        {
            "location": "/handling-requests/sub-handling-error/",
            "text": "",
            "title": "Gestione degli errori"
        },
        {
            "location": "/handling-requests/sub-logging/",
            "text": "",
            "title": "Registrazione"
        }
    ]
}